/* by abeto - https://abeto.co */
(function(){"use strict";let a=null;const I=["Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array"],T=new TextDecoder;function _(e,r){switch(r){case Float32Array:return e.DT_FLOAT32;case Int8Array:return e.DT_INT8;case Int16Array:return e.DT_INT16;case Int32Array:return e.DT_INT32;case Uint8Array:return e.DT_UINT8;case Uint16Array:return e.DT_UINT16;case Uint32Array:return e.DT_UINT32}}let D=null;const g=e=>D||(D=new Promise(async r=>{let n=e;for(;!n.endsWith("/assets/geometries");){const t=n.lastIndexOf("/");if(t===-1)throw new Error("Draco: Could not find the assets folder.");n=n.substring(0,t)}const s="/assets/libs/",c=await Promise.all([await import(`${s}draco/draco_wasm_wrapper.js`),fetch(`${s}draco/draco_decoder.wasm`,{credentials:"same-origin"}).then(t=>t.arrayBuffer())]);c[0].default({wasmBinary:c[1]}).then(t=>{a=t,r()})}).catch(r=>{console.error("Error loading draco:",r)}),D);function h(e,r){let n=null,s=null;const t=T.decode(new Uint8Array(r.slice(0,5)))==="DRACO";if(t)n=new Int8Array(r);else{const i=new Uint32Array(r.slice(0,4))[0];s=JSON.parse(T.decode(r.slice(4,4+i))),n=new Int8Array(r.slice(4+i))}let o=null,l=null;const u=e.GetEncodedGeometryType(n);if(u===a.TRIANGULAR_MESH)o=new a.Mesh,l=e.DecodeArrayToMesh(n,n.byteLength,o);else if(u===a.POINT_CLOUD)o=new a.PointCloud,l=e.DecodeArrayToPointCloud(n,n.byteLength,o);else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");if(!l.ok()||o.ptr===0)throw new Error(`THREE.DRACOLoader: Decoding failed: ${l.error_msg()}`);if(t){const i=new a.MetadataQuerier,A=e.GetMetadata(o);i.HasEntry(A,"info")&&(s=JSON.parse(i.GetStringEntry(A,"info"))),a.destroy(i)}const f={},y={};s.attributes.forEach((i,A)=>{const m=i[0];f[m]=A,y[m]=I[i[1]]});const d={index:null,attributes:[],userData:{}};s.userData&&(d.userData=s.userData);for(const i in f){const A=self[y[i]];let m=null,w=null;w=f[i],m=e.GetAttributeByUniqueId(o,w);const b=E(e,o,i,A,m);d.attributes.push(b)}return u===a.TRIANGULAR_MESH&&(d.index=p(e,o)),a.destroy(o),d}function p(e,r){const s=r.num_faces()*3,c=s*4,t=a._malloc(c);e.GetTrianglesUInt32Array(r,c,t);const o=new Uint32Array(a.HEAPF32.buffer,t,s).slice();return a._free(t),{array:o,itemSize:1}}function E(e,r,n,s,c){const t=c.num_components(),l=r.num_points()*t,u=l*s.BYTES_PER_ELEMENT,f=_(a,s),y=a._malloc(u);e.GetAttributeDataArrayForAllPoints(r,c,f,u,y);const d=new s(a.HEAPF32.buffer,y,l).slice();return a._free(y),{name:n,array:d,itemSize:t}}onmessage=async e=>{const{url:r,buffer:n,id:s}=e.data;await g(r);const c=new a.Decoder;try{const t=h(c,n),o=t.attributes.map(l=>l.array.buffer);t.index&&o.push(t.index.array.buffer),self.postMessage({id:s,geometry:t},o)}catch(t){console.error(t),self.postMessage({id:s,error:!0})}finally{a.destroy(c)}}})();
