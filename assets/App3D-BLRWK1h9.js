/* by abeto - https://abeto.co */
var xo = Object.defineProperty; var Na = r => { throw TypeError(r) }; var yo = (r, e, i) => e in r ? xo(r, e, { enumerable: !0, configurable: !0, writable: !0, value: i }) : r[e] = i; var Ke = (r, e, i) => yo(r, typeof e != "symbol" ? e + "" : e, i), ea = (r, e, i) => e.has(r) || Na("Cannot " + i); var L = (r, e, i) => (ea(r, e, "read from private field"), i ? i.call(r) : e.get(r)), pe = (r, e, i) => e.has(r) ? Na("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(r) : e.set(r, i), Xe = (r, e, i, s) => (ea(r, e, "write to private field"), s ? s.call(r, i) : e.set(r, i), i), Pe = (r, e, i) => (ea(r, e, "access private method"), i); var pr = (r, e, i, s) => ({ set _(a) { Xe(r, e, a, i) }, get _() { return L(r, e, s) } }); import { r as run_all, m as is_firefox, h as create_text, T as TEMPLATE_USE_IMPORT_NODE, b as active_effect, n as get_first_child, o as TEMPLATE_FRAGMENT, q as block, E as EFFECT_TRANSPARENT, j as branch, t as current_batch, U as UNINITIALIZED, u as should_defer_append, v as resume_effect, w as pause_effect, x as effect, y as render_effect, z as untrack, S as STATE_SYMBOL, P as PROPS_IS_UPDATED, A as get, B as derived, C as set, D as is_destroying_effect, F as DESTROYED, G as legacy_mode_flag, H as PROPS_IS_RUNES, I as state, J as user_effect, K as first_child, l as pop, p as push, L as child, M as enable_legacy_mode_flag, N as sibling } from "./runtime-C2kxzoFi.js"; let micro_tasks = []; function run_micro_tasks() { var r = micro_tasks; micro_tasks = [], run_all(r) } function queue_micro_task(r) { micro_tasks.length === 0 && queueMicrotask(run_micro_tasks), micro_tasks.push(r) } function create_fragment_from_html(r) { var e = document.createElement("template"); return e.innerHTML = r.replaceAll("<!>", "<!---->"), e.content } function assign_nodes(r, e) { var i = active_effect; i.nodes_start === null && (i.nodes_start = r, i.nodes_end = e) } function from_html(r, e) { var i = (e & TEMPLATE_FRAGMENT) !== 0, s = (e & TEMPLATE_USE_IMPORT_NODE) !== 0, a, o = !r.startsWith("<!>"); return () => { a === void 0 && (a = create_fragment_from_html(o ? r : "<!>" + r), i || (a = get_first_child(a))); var l = s || is_firefox ? document.importNode(a, !0) : a.cloneNode(!0); if (i) { var c = get_first_child(l), h = l.lastChild; assign_nodes(c, h) } else assign_nodes(l, l); return l } } function comment() { var r = document.createDocumentFragment(), e = document.createComment(""), i = create_text(); return r.append(e, i), assign_nodes(e, i), r } function append(r, e) { r !== null && r.before(e) } function if_block(r, e, i = !1) { var s = r, a = null, o = null, l = UNINITIALIZED, c = i ? EFFECT_TRANSPARENT : 0, h = !1; const d = (x, b = !0) => { h = !0, _(b, x) }; var p = null; function f() { p !== null && (p.lastChild.remove(), s.before(p), p = null); var x = l ? a : o, b = l ? o : a; x && resume_effect(x), b && pause_effect(b, () => { l ? o = null : a = null }) } const _ = (x, b) => { if (l !== (l = x)) { var T = should_defer_append(), M = s; if (T && (p = document.createDocumentFragment(), p.append(M = create_text())), l ? a ?? (a = b && branch(() => b(M))) : o ?? (o = b && branch(() => b(M))), T) { var w = current_batch, D = l ? a : o, R = l ? o : a; D && w.skipped_effects.delete(D), R && w.skipped_effects.add(R), w.add_callback(f) } else f() } }; block(() => { h = !1, e(d), h || _(null, null) }, c) } function is_bound_this(r, e) { return r === e || (r == null ? void 0 : r[STATE_SYMBOL]) === e } function bind_this(r = {}, e, i, s) { return effect(() => { var a, o; return render_effect(() => { a = o, o = [], untrack(() => { r !== i(...o) && (e(r, ...o), a && is_bound_this(i(...a), r) && e(null, ...a)) }) }), () => { queue_micro_task(() => { o && is_bound_this(i(...o), r) && e(null, ...o) }) } }), r } function prop(r, e, i, s) { var a = !legacy_mode_flag || (i & PROPS_IS_RUNES) !== 0, o = s, l = !0, c = () => (l && (l = !1, o = s), o), h; h = r[e], h === void 0 && s !== void 0 && (h = c()); var d; if (a ? d = () => { var x = r[e]; return x === void 0 ? c() : (l = !0, x) } : d = () => { var x = r[e]; return x !== void 0 && (o = void 0), x === void 0 ? o : x }, a && (i & PROPS_IS_UPDATED) === 0) return d; var p = !1, f = derived(() => (p = !1, d())), _ = active_effect; return function (x, b) { if (arguments.length > 0) { const T = b ? get(f) : x; return set(f, T), p = !0, o !== void 0 && (o = T), x } return is_destroying_effect && p || (_.f & DESTROYED) !== 0 ? f.v : get(f) } } const PUBLIC_VERSION = "5"; var Oa; typeof window < "u" && ((Oa = window.__svelte ?? (window.__svelte = {})).v ?? (Oa.v = new Set)).add(PUBLIC_VERSION);/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const REVISION = "180", CullFaceNone = 0, CullFaceBack = 1, CullFaceFront = 2, PCFShadowMap = 1, PCFSoftShadowMap = 2, VSMShadowMap = 3, FrontSide = 0, BackSide = 1, DoubleSide = 2, NoBlending = 0, NormalBlending = 1, AdditiveBlending = 2, SubtractiveBlending = 3, MultiplyBlending = 4, CustomBlending = 5, AddEquation = 100, SubtractEquation = 101, ReverseSubtractEquation = 102, MinEquation = 103, MaxEquation = 104, ZeroFactor = 200, OneFactor = 201, SrcColorFactor = 202, OneMinusSrcColorFactor = 203, SrcAlphaFactor = 204, OneMinusSrcAlphaFactor = 205, DstAlphaFactor = 206, OneMinusDstAlphaFactor = 207, DstColorFactor = 208, OneMinusDstColorFactor = 209, SrcAlphaSaturateFactor = 210, ConstantColorFactor = 211, OneMinusConstantColorFactor = 212, ConstantAlphaFactor = 213, OneMinusConstantAlphaFactor = 214, NeverDepth = 0, AlwaysDepth = 1, LessDepth = 2, LessEqualDepth = 3, EqualDepth = 4, GreaterEqualDepth = 5, GreaterDepth = 6, NotEqualDepth = 7, MultiplyOperation = 0, MixOperation = 1, AddOperation = 2, NoToneMapping = 0, LinearToneMapping = 1, ReinhardToneMapping = 2, CineonToneMapping = 3, ACESFilmicToneMapping = 4, CustomToneMapping = 5, AgXToneMapping = 6, NeutralToneMapping = 7, AttachedBindMode = "attached", DetachedBindMode = "detached", UVMapping = 300, CubeReflectionMapping = 301, CubeRefractionMapping = 302, EquirectangularReflectionMapping = 303, EquirectangularRefractionMapping = 304, CubeUVReflectionMapping = 306, RepeatWrapping = 1e3, ClampToEdgeWrapping = 1001, MirroredRepeatWrapping = 1002, NearestFilter = 1003, NearestMipmapNearestFilter = 1004, NearestMipmapLinearFilter = 1005, LinearFilter = 1006, LinearMipmapNearestFilter = 1007, LinearMipmapLinearFilter = 1008, UnsignedByteType = 1009, ByteType = 1010, ShortType = 1011, UnsignedShortType = 1012, IntType = 1013, UnsignedIntType = 1014, FloatType = 1015, HalfFloatType = 1016, UnsignedShort4444Type = 1017, UnsignedShort5551Type = 1018, UnsignedInt248Type = 1020, UnsignedInt5999Type = 35902, UnsignedInt101111Type = 35899, AlphaFormat = 1021, RGBFormat = 1022, RGBAFormat = 1023, DepthFormat = 1026, DepthStencilFormat = 1027, RedFormat = 1028, RedIntegerFormat = 1029, RGFormat = 1030, RGIntegerFormat = 1031, RGBAIntegerFormat = 1033, RGB_S3TC_DXT1_Format = 33776, RGBA_S3TC_DXT1_Format = 33777, RGBA_S3TC_DXT3_Format = 33778, RGBA_S3TC_DXT5_Format = 33779, RGB_PVRTC_4BPPV1_Format = 35840, RGB_PVRTC_2BPPV1_Format = 35841, RGBA_PVRTC_4BPPV1_Format = 35842, RGBA_PVRTC_2BPPV1_Format = 35843, RGB_ETC1_Format = 36196, RGB_ETC2_Format = 37492, RGBA_ETC2_EAC_Format = 37496, RGBA_ASTC_4x4_Format = 37808, RGBA_ASTC_5x4_Format = 37809, RGBA_ASTC_5x5_Format = 37810, RGBA_ASTC_6x5_Format = 37811, RGBA_ASTC_6x6_Format = 37812, RGBA_ASTC_8x5_Format = 37813, RGBA_ASTC_8x6_Format = 37814, RGBA_ASTC_8x8_Format = 37815, RGBA_ASTC_10x5_Format = 37816, RGBA_ASTC_10x6_Format = 37817, RGBA_ASTC_10x8_Format = 37818, RGBA_ASTC_10x10_Format = 37819, RGBA_ASTC_12x10_Format = 37820, RGBA_ASTC_12x12_Format = 37821, RGBA_BPTC_Format = 36492, RGB_BPTC_SIGNED_Format = 36494, RGB_BPTC_UNSIGNED_Format = 36495, RED_RGTC1_Format = 36283, SIGNED_RED_RGTC1_Format = 36284, RED_GREEN_RGTC2_Format = 36285, SIGNED_RED_GREEN_RGTC2_Format = 36286, LoopOnce = 2200, LoopRepeat = 2201, LoopPingPong = 2202, InterpolateDiscrete = 2300, InterpolateLinear = 2301, InterpolateSmooth = 2302, ZeroCurvatureEnding = 2400, ZeroSlopeEnding = 2401, WrapAroundEnding = 2402, NormalAnimationBlendMode = 2500, AdditiveAnimationBlendMode = 2501, TrianglesDrawMode = 0, TriangleStripDrawMode = 1, TriangleFanDrawMode = 2, BasicDepthPacking = 3200, RGBADepthPacking = 3201, TangentSpaceNormalMap = 0, ObjectSpaceNormalMap = 1, NoColorSpace = "", SRGBColorSpace = "srgb", LinearSRGBColorSpace = "srgb-linear", LinearTransfer = "linear", SRGBTransfer = "srgb", KeepStencilOp = 7680, AlwaysStencilFunc = 519, NeverCompare = 512, LessCompare = 513, EqualCompare = 514, LessEqualCompare = 515, GreaterCompare = 516, NotEqualCompare = 517, GreaterEqualCompare = 518, AlwaysCompare = 519, StaticDrawUsage = 35044, DynamicDrawUsage = 35048, GLSL3 = "300 es", WebGLCoordinateSystem = 2e3, WebGPUCoordinateSystem = 2001; class EventDispatcher { addEventListener(e, i) { this._listeners === void 0 && (this._listeners = {}); const s = this._listeners; s[e] === void 0 && (s[e] = []), s[e].indexOf(i) === -1 && s[e].push(i) } hasEventListener(e, i) { const s = this._listeners; return s === void 0 ? !1 : s[e] !== void 0 && s[e].indexOf(i) !== -1 } removeEventListener(e, i) { const s = this._listeners; if (s === void 0) return; const a = s[e]; if (a !== void 0) { const o = a.indexOf(i); o !== -1 && a.splice(o, 1) } } dispatchEvent(e) { const i = this._listeners; if (i === void 0) return; const s = i[e.type]; if (s !== void 0) { e.target = this; const a = s.slice(0); for (let o = 0, l = a.length; o < l; o++)a[o].call(this, e); e.target = null } } } const _lut = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"]; let _seed = 1234567; const DEG2RAD = Math.PI / 180, RAD2DEG = 180 / Math.PI; function generateUUID() { const r = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0, s = Math.random() * 4294967295 | 0; return (_lut[r & 255] + _lut[r >> 8 & 255] + _lut[r >> 16 & 255] + _lut[r >> 24 & 255] + "-" + _lut[e & 255] + _lut[e >> 8 & 255] + "-" + _lut[e >> 16 & 15 | 64] + _lut[e >> 24 & 255] + "-" + _lut[i & 63 | 128] + _lut[i >> 8 & 255] + "-" + _lut[i >> 16 & 255] + _lut[i >> 24 & 255] + _lut[s & 255] + _lut[s >> 8 & 255] + _lut[s >> 16 & 255] + _lut[s >> 24 & 255]).toLowerCase() } function clamp(r, e, i) { return Math.max(e, Math.min(i, r)) } function euclideanModulo(r, e) { return (r % e + e) % e } function mapLinear(r, e, i, s, a) { return s + (r - e) * (a - s) / (i - e) } function inverseLerp(r, e, i) { return r !== e ? (i - r) / (e - r) : 0 } function lerp(r, e, i) { return (1 - i) * r + i * e } function damp(r, e, i, s) { return lerp(r, e, 1 - Math.exp(-i * s)) } function pingpong(r, e = 1) { return e - Math.abs(euclideanModulo(r, e * 2) - e) } function smoothstep(r, e, i) { return r <= e ? 0 : r >= i ? 1 : (r = (r - e) / (i - e), r * r * (3 - 2 * r)) } function smootherstep(r, e, i) { return r <= e ? 0 : r >= i ? 1 : (r = (r - e) / (i - e), r * r * r * (r * (r * 6 - 15) + 10)) } function randInt(r, e) { return r + Math.floor(Math.random() * (e - r + 1)) } function randFloat(r, e) { return r + Math.random() * (e - r) } function randFloatSpread(r) { return r * (.5 - Math.random()) } function seededRandom(r) { r !== void 0 && (_seed = r); let e = _seed += 1831565813; return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296 } function degToRad(r) { return r * DEG2RAD } function radToDeg(r) { return r * RAD2DEG } function isPowerOfTwo(r) { return (r & r - 1) === 0 && r !== 0 } function ceilPowerOfTwo(r) { return Math.pow(2, Math.ceil(Math.log(r) / Math.LN2)) } function floorPowerOfTwo(r) { return Math.pow(2, Math.floor(Math.log(r) / Math.LN2)) } function setQuaternionFromProperEuler(r, e, i, s, a) { const o = Math.cos, l = Math.sin, c = o(i / 2), h = l(i / 2), d = o((e + s) / 2), p = l((e + s) / 2), f = o((e - s) / 2), _ = l((e - s) / 2), x = o((s - e) / 2), b = l((s - e) / 2); switch (a) { case "XYX": r.set(c * p, h * f, h * _, c * d); break; case "YZY": r.set(h * _, c * p, h * f, c * d); break; case "ZXZ": r.set(h * f, h * _, c * p, c * d); break; case "XZX": r.set(c * p, h * b, h * x, c * d); break; case "YXY": r.set(h * x, c * p, h * b, c * d); break; case "ZYZ": r.set(h * b, h * x, c * p, c * d); break; default: console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + a) } } function denormalize(r, e) { switch (e.constructor) { case Float32Array: return r; case Uint32Array: return r / 4294967295; case Uint16Array: return r / 65535; case Uint8Array: return r / 255; case Int32Array: return Math.max(r / 2147483647, -1); case Int16Array: return Math.max(r / 32767, -1); case Int8Array: return Math.max(r / 127, -1); default: throw new Error("Invalid component type.") } } function normalize(r, e) { switch (e.constructor) { case Float32Array: return r; case Uint32Array: return Math.round(r * 4294967295); case Uint16Array: return Math.round(r * 65535); case Uint8Array: return Math.round(r * 255); case Int32Array: return Math.round(r * 2147483647); case Int16Array: return Math.round(r * 32767); case Int8Array: return Math.round(r * 127); default: throw new Error("Invalid component type.") } } const MathUtils = { DEG2RAD, RAD2DEG, generateUUID, clamp, euclideanModulo, mapLinear, inverseLerp, lerp, damp, pingpong, smoothstep, smootherstep, randInt, randFloat, randFloatSpread, seededRandom, degToRad, radToDeg, isPowerOfTwo, ceilPowerOfTwo, floorPowerOfTwo, setQuaternionFromProperEuler, normalize, denormalize }; class Vector2 { constructor(e = 0, i = 0) { Vector2.prototype.isVector2 = !0, this.x = e, this.y = i } get width() { return this.x } set width(e) { this.x = e } get height() { return this.y } set height(e) { this.y = e } set(e, i) { return this.x = e, this.y = i, this } setScalar(e) { return this.x = e, this.y = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setComponent(e, i) { switch (e) { case 0: this.x = i; break; case 1: this.y = i; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y) } copy(e) { return this.x = e.x, this.y = e.y, this } add(e) { return this.x += e.x, this.y += e.y, this } addScalar(e) { return this.x += e, this.y += e, this } addVectors(e, i) { return this.x = e.x + i.x, this.y = e.y + i.y, this } addScaledVector(e, i) { return this.x += e.x * i, this.y += e.y * i, this } sub(e) { return this.x -= e.x, this.y -= e.y, this } subScalar(e) { return this.x -= e, this.y -= e, this } subVectors(e, i) { return this.x = e.x - i.x, this.y = e.y - i.y, this } multiply(e) { return this.x *= e.x, this.y *= e.y, this } multiplyScalar(e) { return this.x *= e, this.y *= e, this } divide(e) { return this.x /= e.x, this.y /= e.y, this } divideScalar(e) { return this.multiplyScalar(1 / e) } applyMatrix3(e) { const i = this.x, s = this.y, a = e.elements; return this.x = a[0] * i + a[3] * s + a[6], this.y = a[1] * i + a[4] * s + a[7], this } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this } clamp(e, i) { return this.x = clamp(this.x, e.x, i.x), this.y = clamp(this.y, e.y, i.y), this } clampScalar(e, i) { return this.x = clamp(this.x, e, i), this.y = clamp(this.y, e, i), this } clampLength(e, i) { const s = this.length(); return this.divideScalar(s || 1).multiplyScalar(clamp(s, e, i)) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this } roundToZero() { return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this } negate() { return this.x = -this.x, this.y = -this.y, this } dot(e) { return this.x * e.x + this.y * e.y } cross(e) { return this.x * e.y - this.y * e.x } lengthSq() { return this.x * this.x + this.y * this.y } length() { return Math.sqrt(this.x * this.x + this.y * this.y) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) } normalize() { return this.divideScalar(this.length() || 1) } angle() { return Math.atan2(-this.y, -this.x) + Math.PI } angleTo(e) { const i = Math.sqrt(this.lengthSq() * e.lengthSq()); if (i === 0) return Math.PI / 2; const s = this.dot(e) / i; return Math.acos(clamp(s, -1, 1)) } distanceTo(e) { return Math.sqrt(this.distanceToSquared(e)) } distanceToSquared(e) { const i = this.x - e.x, s = this.y - e.y; return i * i + s * s } manhattanDistanceTo(e) { return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, i) { return this.x += (e.x - this.x) * i, this.y += (e.y - this.y) * i, this } lerpVectors(e, i, s) { return this.x = e.x + (i.x - e.x) * s, this.y = e.y + (i.y - e.y) * s, this } equals(e) { return e.x === this.x && e.y === this.y } fromArray(e, i = 0) { return this.x = e[i], this.y = e[i + 1], this } toArray(e = [], i = 0) { return e[i] = this.x, e[i + 1] = this.y, e } fromBufferAttribute(e, i) { return this.x = e.getX(i), this.y = e.getY(i), this } rotateAround(e, i) { const s = Math.cos(i), a = Math.sin(i), o = this.x - e.x, l = this.y - e.y; return this.x = o * s - l * a + e.x, this.y = o * a + l * s + e.y, this } random() { return this.x = Math.random(), this.y = Math.random(), this } *[Symbol.iterator]() { yield this.x, yield this.y } } class Quaternion { constructor(e = 0, i = 0, s = 0, a = 1) { this.isQuaternion = !0, this._x = e, this._y = i, this._z = s, this._w = a } static slerpFlat(e, i, s, a, o, l, c) { let h = s[a + 0], d = s[a + 1], p = s[a + 2], f = s[a + 3]; const _ = o[l + 0], x = o[l + 1], b = o[l + 2], T = o[l + 3]; if (c === 0) { e[i + 0] = h, e[i + 1] = d, e[i + 2] = p, e[i + 3] = f; return } if (c === 1) { e[i + 0] = _, e[i + 1] = x, e[i + 2] = b, e[i + 3] = T; return } if (f !== T || h !== _ || d !== x || p !== b) { let M = 1 - c; const w = h * _ + d * x + p * b + f * T, D = w >= 0 ? 1 : -1, R = 1 - w * w; if (R > Number.EPSILON) { const U = Math.sqrt(R), O = Math.atan2(U, w * D); M = Math.sin(M * O) / U, c = Math.sin(c * O) / U } const P = c * D; if (h = h * M + _ * P, d = d * M + x * P, p = p * M + b * P, f = f * M + T * P, M === 1 - c) { const U = 1 / Math.sqrt(h * h + d * d + p * p + f * f); h *= U, d *= U, p *= U, f *= U } } e[i] = h, e[i + 1] = d, e[i + 2] = p, e[i + 3] = f } static multiplyQuaternionsFlat(e, i, s, a, o, l) { const c = s[a], h = s[a + 1], d = s[a + 2], p = s[a + 3], f = o[l], _ = o[l + 1], x = o[l + 2], b = o[l + 3]; return e[i] = c * b + p * f + h * x - d * _, e[i + 1] = h * b + p * _ + d * f - c * x, e[i + 2] = d * b + p * x + c * _ - h * f, e[i + 3] = p * b - c * f - h * _ - d * x, e } get x() { return this._x } set x(e) { this._x = e, this._onChangeCallback() } get y() { return this._y } set y(e) { this._y = e, this._onChangeCallback() } get z() { return this._z } set z(e) { this._z = e, this._onChangeCallback() } get w() { return this._w } set w(e) { this._w = e, this._onChangeCallback() } set(e, i, s, a) { return this._x = e, this._y = i, this._z = s, this._w = a, this._onChangeCallback(), this } clone() { return new this.constructor(this._x, this._y, this._z, this._w) } copy(e) { return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this } setFromEuler(e, i = !0) { const s = e._x, a = e._y, o = e._z, l = e._order, c = Math.cos, h = Math.sin, d = c(s / 2), p = c(a / 2), f = c(o / 2), _ = h(s / 2), x = h(a / 2), b = h(o / 2); switch (l) { case "XYZ": this._x = _ * p * f + d * x * b, this._y = d * x * f - _ * p * b, this._z = d * p * b + _ * x * f, this._w = d * p * f - _ * x * b; break; case "YXZ": this._x = _ * p * f + d * x * b, this._y = d * x * f - _ * p * b, this._z = d * p * b - _ * x * f, this._w = d * p * f + _ * x * b; break; case "ZXY": this._x = _ * p * f - d * x * b, this._y = d * x * f + _ * p * b, this._z = d * p * b + _ * x * f, this._w = d * p * f - _ * x * b; break; case "ZYX": this._x = _ * p * f - d * x * b, this._y = d * x * f + _ * p * b, this._z = d * p * b - _ * x * f, this._w = d * p * f + _ * x * b; break; case "YZX": this._x = _ * p * f + d * x * b, this._y = d * x * f + _ * p * b, this._z = d * p * b - _ * x * f, this._w = d * p * f - _ * x * b; break; case "XZY": this._x = _ * p * f - d * x * b, this._y = d * x * f - _ * p * b, this._z = d * p * b + _ * x * f, this._w = d * p * f + _ * x * b; break; default: console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + l) }return i === !0 && this._onChangeCallback(), this } setFromAxisAngle(e, i) { const s = i / 2, a = Math.sin(s); return this._x = e.x * a, this._y = e.y * a, this._z = e.z * a, this._w = Math.cos(s), this._onChangeCallback(), this } setFromRotationMatrix(e) { const i = e.elements, s = i[0], a = i[4], o = i[8], l = i[1], c = i[5], h = i[9], d = i[2], p = i[6], f = i[10], _ = s + c + f; if (_ > 0) { const x = .5 / Math.sqrt(_ + 1); this._w = .25 / x, this._x = (p - h) * x, this._y = (o - d) * x, this._z = (l - a) * x } else if (s > c && s > f) { const x = 2 * Math.sqrt(1 + s - c - f); this._w = (p - h) / x, this._x = .25 * x, this._y = (a + l) / x, this._z = (o + d) / x } else if (c > f) { const x = 2 * Math.sqrt(1 + c - s - f); this._w = (o - d) / x, this._x = (a + l) / x, this._y = .25 * x, this._z = (h + p) / x } else { const x = 2 * Math.sqrt(1 + f - s - c); this._w = (l - a) / x, this._x = (o + d) / x, this._y = (h + p) / x, this._z = .25 * x } return this._onChangeCallback(), this } setFromUnitVectors(e, i) { let s = e.dot(i) + 1; return s < 1e-8 ? (s = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = s) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = s)) : (this._x = e.y * i.z - e.z * i.y, this._y = e.z * i.x - e.x * i.z, this._z = e.x * i.y - e.y * i.x, this._w = s), this.normalize() } angleTo(e) { return 2 * Math.acos(Math.abs(clamp(this.dot(e), -1, 1))) } rotateTowards(e, i) { const s = this.angleTo(e); if (s === 0) return this; const a = Math.min(1, i / s); return this.slerp(e, a), this } identity() { return this.set(0, 0, 0, 1) } invert() { return this.conjugate() } conjugate() { return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this } dot(e) { return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w } lengthSq() { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w } length() { return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w) } normalize() { let e = this.length(); return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this } multiply(e) { return this.multiplyQuaternions(this, e) } premultiply(e) { return this.multiplyQuaternions(e, this) } multiplyQuaternions(e, i) { const s = e._x, a = e._y, o = e._z, l = e._w, c = i._x, h = i._y, d = i._z, p = i._w; return this._x = s * p + l * c + a * d - o * h, this._y = a * p + l * h + o * c - s * d, this._z = o * p + l * d + s * h - a * c, this._w = l * p - s * c - a * h - o * d, this._onChangeCallback(), this } slerp(e, i) { if (i === 0) return this; if (i === 1) return this.copy(e); const s = this._x, a = this._y, o = this._z, l = this._w; let c = l * e._w + s * e._x + a * e._y + o * e._z; if (c < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, c = -c) : this.copy(e), c >= 1) return this._w = l, this._x = s, this._y = a, this._z = o, this; const h = 1 - c * c; if (h <= Number.EPSILON) { const x = 1 - i; return this._w = x * l + i * this._w, this._x = x * s + i * this._x, this._y = x * a + i * this._y, this._z = x * o + i * this._z, this.normalize(), this } const d = Math.sqrt(h), p = Math.atan2(d, c), f = Math.sin((1 - i) * p) / d, _ = Math.sin(i * p) / d; return this._w = l * f + this._w * _, this._x = s * f + this._x * _, this._y = a * f + this._y * _, this._z = o * f + this._z * _, this._onChangeCallback(), this } slerpQuaternions(e, i, s) { return this.copy(e).slerp(i, s) } random() { const e = 2 * Math.PI * Math.random(), i = 2 * Math.PI * Math.random(), s = Math.random(), a = Math.sqrt(1 - s), o = Math.sqrt(s); return this.set(a * Math.sin(e), a * Math.cos(e), o * Math.sin(i), o * Math.cos(i)) } equals(e) { return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w } fromArray(e, i = 0) { return this._x = e[i], this._y = e[i + 1], this._z = e[i + 2], this._w = e[i + 3], this._onChangeCallback(), this } toArray(e = [], i = 0) { return e[i] = this._x, e[i + 1] = this._y, e[i + 2] = this._z, e[i + 3] = this._w, e } fromBufferAttribute(e, i) { return this._x = e.getX(i), this._y = e.getY(i), this._z = e.getZ(i), this._w = e.getW(i), this._onChangeCallback(), this } toJSON() { return this.toArray() } _onChange(e) { return this._onChangeCallback = e, this } _onChangeCallback() { } *[Symbol.iterator]() { yield this._x, yield this._y, yield this._z, yield this._w } } class Vector3 { constructor(e = 0, i = 0, s = 0) { Vector3.prototype.isVector3 = !0, this.x = e, this.y = i, this.z = s } set(e, i, s) { return s === void 0 && (s = this.z), this.x = e, this.y = i, this.z = s, this } setScalar(e) { return this.x = e, this.y = e, this.z = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setZ(e) { return this.z = e, this } setComponent(e, i) { switch (e) { case 0: this.x = i; break; case 1: this.y = i; break; case 2: this.z = i; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; case 2: return this.z; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y, this.z) } copy(e) { return this.x = e.x, this.y = e.y, this.z = e.z, this } add(e) { return this.x += e.x, this.y += e.y, this.z += e.z, this } addScalar(e) { return this.x += e, this.y += e, this.z += e, this } addVectors(e, i) { return this.x = e.x + i.x, this.y = e.y + i.y, this.z = e.z + i.z, this } addScaledVector(e, i) { return this.x += e.x * i, this.y += e.y * i, this.z += e.z * i, this } sub(e) { return this.x -= e.x, this.y -= e.y, this.z -= e.z, this } subScalar(e) { return this.x -= e, this.y -= e, this.z -= e, this } subVectors(e, i) { return this.x = e.x - i.x, this.y = e.y - i.y, this.z = e.z - i.z, this } multiply(e) { return this.x *= e.x, this.y *= e.y, this.z *= e.z, this } multiplyScalar(e) { return this.x *= e, this.y *= e, this.z *= e, this } multiplyVectors(e, i) { return this.x = e.x * i.x, this.y = e.y * i.y, this.z = e.z * i.z, this } applyEuler(e) { return this.applyQuaternion(_quaternion$4.setFromEuler(e)) } applyAxisAngle(e, i) { return this.applyQuaternion(_quaternion$4.setFromAxisAngle(e, i)) } applyMatrix3(e) { const i = this.x, s = this.y, a = this.z, o = e.elements; return this.x = o[0] * i + o[3] * s + o[6] * a, this.y = o[1] * i + o[4] * s + o[7] * a, this.z = o[2] * i + o[5] * s + o[8] * a, this } applyNormalMatrix(e) { return this.applyMatrix3(e).normalize() } applyMatrix4(e) { const i = this.x, s = this.y, a = this.z, o = e.elements, l = 1 / (o[3] * i + o[7] * s + o[11] * a + o[15]); return this.x = (o[0] * i + o[4] * s + o[8] * a + o[12]) * l, this.y = (o[1] * i + o[5] * s + o[9] * a + o[13]) * l, this.z = (o[2] * i + o[6] * s + o[10] * a + o[14]) * l, this } applyQuaternion(e) { const i = this.x, s = this.y, a = this.z, o = e.x, l = e.y, c = e.z, h = e.w, d = 2 * (l * a - c * s), p = 2 * (c * i - o * a), f = 2 * (o * s - l * i); return this.x = i + h * d + l * f - c * p, this.y = s + h * p + c * d - o * f, this.z = a + h * f + o * p - l * d, this } project(e) { return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix) } unproject(e) { return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld) } transformDirection(e) { const i = this.x, s = this.y, a = this.z, o = e.elements; return this.x = o[0] * i + o[4] * s + o[8] * a, this.y = o[1] * i + o[5] * s + o[9] * a, this.z = o[2] * i + o[6] * s + o[10] * a, this.normalize() } divide(e) { return this.x /= e.x, this.y /= e.y, this.z /= e.z, this } divideScalar(e) { return this.multiplyScalar(1 / e) } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this } clamp(e, i) { return this.x = clamp(this.x, e.x, i.x), this.y = clamp(this.y, e.y, i.y), this.z = clamp(this.z, e.z, i.z), this } clampScalar(e, i) { return this.x = clamp(this.x, e, i), this.y = clamp(this.y, e, i), this.z = clamp(this.z, e, i), this } clampLength(e, i) { const s = this.length(); return this.divideScalar(s || 1).multiplyScalar(clamp(s, e, i)) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this } roundToZero() { return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this } negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this } dot(e) { return this.x * e.x + this.y * e.y + this.z * e.z } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) } normalize() { return this.divideScalar(this.length() || 1) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, i) { return this.x += (e.x - this.x) * i, this.y += (e.y - this.y) * i, this.z += (e.z - this.z) * i, this } lerpVectors(e, i, s) { return this.x = e.x + (i.x - e.x) * s, this.y = e.y + (i.y - e.y) * s, this.z = e.z + (i.z - e.z) * s, this } cross(e) { return this.crossVectors(this, e) } crossVectors(e, i) { const s = e.x, a = e.y, o = e.z, l = i.x, c = i.y, h = i.z; return this.x = a * h - o * c, this.y = o * l - s * h, this.z = s * c - a * l, this } projectOnVector(e) { const i = e.lengthSq(); if (i === 0) return this.set(0, 0, 0); const s = e.dot(this) / i; return this.copy(e).multiplyScalar(s) } projectOnPlane(e) { return _vector$c.copy(this).projectOnVector(e), this.sub(_vector$c) } reflect(e) { return this.sub(_vector$c.copy(e).multiplyScalar(2 * this.dot(e))) } angleTo(e) { const i = Math.sqrt(this.lengthSq() * e.lengthSq()); if (i === 0) return Math.PI / 2; const s = this.dot(e) / i; return Math.acos(clamp(s, -1, 1)) } distanceTo(e) { return Math.sqrt(this.distanceToSquared(e)) } distanceToSquared(e) { const i = this.x - e.x, s = this.y - e.y, a = this.z - e.z; return i * i + s * s + a * a } manhattanDistanceTo(e) { return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z) } setFromSpherical(e) { return this.setFromSphericalCoords(e.radius, e.phi, e.theta) } setFromSphericalCoords(e, i, s) { const a = Math.sin(i) * e; return this.x = a * Math.sin(s), this.y = Math.cos(i) * e, this.z = a * Math.cos(s), this } setFromCylindrical(e) { return this.setFromCylindricalCoords(e.radius, e.theta, e.y) } setFromCylindricalCoords(e, i, s) { return this.x = e * Math.sin(i), this.y = s, this.z = e * Math.cos(i), this } setFromMatrixPosition(e) { const i = e.elements; return this.x = i[12], this.y = i[13], this.z = i[14], this } setFromMatrixScale(e) { const i = this.setFromMatrixColumn(e, 0).length(), s = this.setFromMatrixColumn(e, 1).length(), a = this.setFromMatrixColumn(e, 2).length(); return this.x = i, this.y = s, this.z = a, this } setFromMatrixColumn(e, i) { return this.fromArray(e.elements, i * 4) } setFromMatrix3Column(e, i) { return this.fromArray(e.elements, i * 3) } setFromEuler(e) { return this.x = e._x, this.y = e._y, this.z = e._z, this } setFromColor(e) { return this.x = e.r, this.y = e.g, this.z = e.b, this } equals(e) { return e.x === this.x && e.y === this.y && e.z === this.z } fromArray(e, i = 0) { return this.x = e[i], this.y = e[i + 1], this.z = e[i + 2], this } toArray(e = [], i = 0) { return e[i] = this.x, e[i + 1] = this.y, e[i + 2] = this.z, e } fromBufferAttribute(e, i) { return this.x = e.getX(i), this.y = e.getY(i), this.z = e.getZ(i), this } random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this } randomDirection() { const e = Math.random() * Math.PI * 2, i = Math.random() * 2 - 1, s = Math.sqrt(1 - i * i); return this.x = s * Math.cos(e), this.y = i, this.z = s * Math.sin(e), this } *[Symbol.iterator]() { yield this.x, yield this.y, yield this.z } } const _vector$c = new Vector3, _quaternion$4 = new Quaternion; class Matrix3 { constructor(e, i, s, a, o, l, c, h, d) { Matrix3.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], e !== void 0 && this.set(e, i, s, a, o, l, c, h, d) } set(e, i, s, a, o, l, c, h, d) { const p = this.elements; return p[0] = e, p[1] = a, p[2] = c, p[3] = i, p[4] = o, p[5] = h, p[6] = s, p[7] = l, p[8] = d, this } identity() { return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this } copy(e) { const i = this.elements, s = e.elements; return i[0] = s[0], i[1] = s[1], i[2] = s[2], i[3] = s[3], i[4] = s[4], i[5] = s[5], i[6] = s[6], i[7] = s[7], i[8] = s[8], this } extractBasis(e, i, s) { return e.setFromMatrix3Column(this, 0), i.setFromMatrix3Column(this, 1), s.setFromMatrix3Column(this, 2), this } setFromMatrix4(e) { const i = e.elements; return this.set(i[0], i[4], i[8], i[1], i[5], i[9], i[2], i[6], i[10]), this } multiply(e) { return this.multiplyMatrices(this, e) } premultiply(e) { return this.multiplyMatrices(e, this) } multiplyMatrices(e, i) { const s = e.elements, a = i.elements, o = this.elements, l = s[0], c = s[3], h = s[6], d = s[1], p = s[4], f = s[7], _ = s[2], x = s[5], b = s[8], T = a[0], M = a[3], w = a[6], D = a[1], R = a[4], P = a[7], U = a[2], O = a[5], N = a[8]; return o[0] = l * T + c * D + h * U, o[3] = l * M + c * R + h * O, o[6] = l * w + c * P + h * N, o[1] = d * T + p * D + f * U, o[4] = d * M + p * R + f * O, o[7] = d * w + p * P + f * N, o[2] = _ * T + x * D + b * U, o[5] = _ * M + x * R + b * O, o[8] = _ * w + x * P + b * N, this } multiplyScalar(e) { const i = this.elements; return i[0] *= e, i[3] *= e, i[6] *= e, i[1] *= e, i[4] *= e, i[7] *= e, i[2] *= e, i[5] *= e, i[8] *= e, this } determinant() { const e = this.elements, i = e[0], s = e[1], a = e[2], o = e[3], l = e[4], c = e[5], h = e[6], d = e[7], p = e[8]; return i * l * p - i * c * d - s * o * p + s * c * h + a * o * d - a * l * h } invert() { const e = this.elements, i = e[0], s = e[1], a = e[2], o = e[3], l = e[4], c = e[5], h = e[6], d = e[7], p = e[8], f = p * l - c * d, _ = c * h - p * o, x = d * o - l * h, b = i * f + s * _ + a * x; if (b === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0); const T = 1 / b; return e[0] = f * T, e[1] = (a * d - p * s) * T, e[2] = (c * s - a * l) * T, e[3] = _ * T, e[4] = (p * i - a * h) * T, e[5] = (a * o - c * i) * T, e[6] = x * T, e[7] = (s * h - d * i) * T, e[8] = (l * i - s * o) * T, this } transpose() { let e; const i = this.elements; return e = i[1], i[1] = i[3], i[3] = e, e = i[2], i[2] = i[6], i[6] = e, e = i[5], i[5] = i[7], i[7] = e, this } getNormalMatrix(e) { return this.setFromMatrix4(e).invert().transpose() } transposeIntoArray(e) { const i = this.elements; return e[0] = i[0], e[1] = i[3], e[2] = i[6], e[3] = i[1], e[4] = i[4], e[5] = i[7], e[6] = i[2], e[7] = i[5], e[8] = i[8], this } setUvTransform(e, i, s, a, o, l, c) { const h = Math.cos(o), d = Math.sin(o); return this.set(s * h, s * d, -s * (h * l + d * c) + l + e, -a * d, a * h, -a * (-d * l + h * c) + c + i, 0, 0, 1), this } scale(e, i) { return this.premultiply(_m3.makeScale(e, i)), this } rotate(e) { return this.premultiply(_m3.makeRotation(-e)), this } translate(e, i) { return this.premultiply(_m3.makeTranslation(e, i)), this } makeTranslation(e, i) { return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, i, 0, 0, 1), this } makeRotation(e) { const i = Math.cos(e), s = Math.sin(e); return this.set(i, -s, 0, s, i, 0, 0, 0, 1), this } makeScale(e, i) { return this.set(e, 0, 0, 0, i, 0, 0, 0, 1), this } equals(e) { const i = this.elements, s = e.elements; for (let a = 0; a < 9; a++)if (i[a] !== s[a]) return !1; return !0 } fromArray(e, i = 0) { for (let s = 0; s < 9; s++)this.elements[s] = e[s + i]; return this } toArray(e = [], i = 0) { const s = this.elements; return e[i] = s[0], e[i + 1] = s[1], e[i + 2] = s[2], e[i + 3] = s[3], e[i + 4] = s[4], e[i + 5] = s[5], e[i + 6] = s[6], e[i + 7] = s[7], e[i + 8] = s[8], e } clone() { return new this.constructor().fromArray(this.elements) } } const _m3 = new Matrix3; function arrayNeedsUint32(r) { for (let e = r.length - 1; e >= 0; --e)if (r[e] >= 65535) return !0; return !1 } const TYPED_ARRAYS = { Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array }; function getTypedArray(r, e) { return new TYPED_ARRAYS[r](e) } function createElementNS(r) { return document.createElementNS("http://www.w3.org/1999/xhtml", r) } function createCanvasElement() { const r = createElementNS("canvas"); return r.style.display = "block", r } const _cache = {}; function warnOnce(r) { r in _cache || (_cache[r] = !0, console.warn(r)) } function probeAsync(r, e, i) { return new Promise(function (s, a) { function o() { switch (r.clientWaitSync(e, r.SYNC_FLUSH_COMMANDS_BIT, 0)) { case r.WAIT_FAILED: a(); break; case r.TIMEOUT_EXPIRED: setTimeout(o, i); break; default: s() } } setTimeout(o, i) }) } const LINEAR_REC709_TO_XYZ = new Matrix3().set(.4123908, .3575843, .1804808, .212639, .7151687, .0721923, .0193308, .1191948, .9505322), XYZ_TO_LINEAR_REC709 = new Matrix3().set(3.2409699, -1.5373832, -.4986108, -.9692436, 1.8759675, .0415551, .0556301, -.203977, 1.0569715); function createColorManagement() { const r = { enabled: !0, workingColorSpace: LinearSRGBColorSpace, spaces: {}, convert: function (a, o, l) { return this.enabled === !1 || o === l || !o || !l || (this.spaces[o].transfer === SRGBTransfer && (a.r = SRGBToLinear(a.r), a.g = SRGBToLinear(a.g), a.b = SRGBToLinear(a.b)), this.spaces[o].primaries !== this.spaces[l].primaries && (a.applyMatrix3(this.spaces[o].toXYZ), a.applyMatrix3(this.spaces[l].fromXYZ)), this.spaces[l].transfer === SRGBTransfer && (a.r = LinearToSRGB(a.r), a.g = LinearToSRGB(a.g), a.b = LinearToSRGB(a.b))), a }, workingToColorSpace: function (a, o) { return this.convert(a, this.workingColorSpace, o) }, colorSpaceToWorking: function (a, o) { return this.convert(a, o, this.workingColorSpace) }, getPrimaries: function (a) { return this.spaces[a].primaries }, getTransfer: function (a) { return a === NoColorSpace ? LinearTransfer : this.spaces[a].transfer }, getToneMappingMode: function (a) { return this.spaces[a].outputColorSpaceConfig.toneMappingMode || "standard" }, getLuminanceCoefficients: function (a, o = this.workingColorSpace) { return a.fromArray(this.spaces[o].luminanceCoefficients) }, define: function (a) { Object.assign(this.spaces, a) }, _getMatrix: function (a, o, l) { return a.copy(this.spaces[o].toXYZ).multiply(this.spaces[l].fromXYZ) }, _getDrawingBufferColorSpace: function (a) { return this.spaces[a].outputColorSpaceConfig.drawingBufferColorSpace }, _getUnpackColorSpace: function (a = this.workingColorSpace) { return this.spaces[a].workingColorSpaceConfig.unpackColorSpace }, fromWorkingColorSpace: function (a, o) { return warnOnce("THREE.ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace()."), r.workingToColorSpace(a, o) }, toWorkingColorSpace: function (a, o) { return warnOnce("THREE.ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking()."), r.colorSpaceToWorking(a, o) } }, e = [.64, .33, .3, .6, .15, .06], i = [.2126, .7152, .0722], s = [.3127, .329]; return r.define({ [LinearSRGBColorSpace]: { primaries: e, whitePoint: s, transfer: LinearTransfer, toXYZ: LINEAR_REC709_TO_XYZ, fromXYZ: XYZ_TO_LINEAR_REC709, luminanceCoefficients: i, workingColorSpaceConfig: { unpackColorSpace: SRGBColorSpace }, outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace } }, [SRGBColorSpace]: { primaries: e, whitePoint: s, transfer: SRGBTransfer, toXYZ: LINEAR_REC709_TO_XYZ, fromXYZ: XYZ_TO_LINEAR_REC709, luminanceCoefficients: i, outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace } } }), r } const ColorManagement = createColorManagement(); function SRGBToLinear(r) { return r < .04045 ? r * .0773993808 : Math.pow(r * .9478672986 + .0521327014, 2.4) } function LinearToSRGB(r) { return r < .0031308 ? r * 12.92 : 1.055 * Math.pow(r, .41666) - .055 } let _canvas; class ImageUtils { static getDataURL(e, i = "image/png") { if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src; let s; if (e instanceof HTMLCanvasElement) s = e; else { _canvas === void 0 && (_canvas = createElementNS("canvas")), _canvas.width = e.width, _canvas.height = e.height; const a = _canvas.getContext("2d"); e instanceof ImageData ? a.putImageData(e, 0, 0) : a.drawImage(e, 0, 0, e.width, e.height), s = _canvas } return s.toDataURL(i) } static sRGBToLinear(e) { if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) { const i = createElementNS("canvas"); i.width = e.width, i.height = e.height; const s = i.getContext("2d"); s.drawImage(e, 0, 0, e.width, e.height); const a = s.getImageData(0, 0, e.width, e.height), o = a.data; for (let l = 0; l < o.length; l++)o[l] = SRGBToLinear(o[l] / 255) * 255; return s.putImageData(a, 0, 0), i } else if (e.data) { const i = e.data.slice(0); for (let s = 0; s < i.length; s++)i instanceof Uint8Array || i instanceof Uint8ClampedArray ? i[s] = Math.floor(SRGBToLinear(i[s] / 255) * 255) : i[s] = SRGBToLinear(i[s]); return { data: i, width: e.width, height: e.height } } else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e } } let _sourceId = 0; class Source { constructor(e = null) { this.isSource = !0, Object.defineProperty(this, "id", { value: _sourceId++ }), this.uuid = generateUUID(), this.data = e, this.dataReady = !0, this.version = 0 } getSize(e) { const i = this.data; return typeof HTMLVideoElement < "u" && i instanceof HTMLVideoElement ? e.set(i.videoWidth, i.videoHeight, 0) : i instanceof VideoFrame ? e.set(i.displayHeight, i.displayWidth, 0) : i !== null ? e.set(i.width, i.height, i.depth || 0) : e.set(0, 0, 0), e } set needsUpdate(e) { e === !0 && this.version++ } toJSON(e) { const i = e === void 0 || typeof e == "string"; if (!i && e.images[this.uuid] !== void 0) return e.images[this.uuid]; const s = { uuid: this.uuid, url: "" }, a = this.data; if (a !== null) { let o; if (Array.isArray(a)) { o = []; for (let l = 0, c = a.length; l < c; l++)a[l].isDataTexture ? o.push(serializeImage(a[l].image)) : o.push(serializeImage(a[l])) } else o = serializeImage(a); s.url = o } return i || (e.images[this.uuid] = s), s } } function serializeImage(r) { return typeof HTMLImageElement < "u" && r instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && r instanceof ImageBitmap ? ImageUtils.getDataURL(r) : r.data ? { data: Array.from(r.data), width: r.width, height: r.height, type: r.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {}) } let _textureId = 0; const _tempVec3 = new Vector3; class Texture extends EventDispatcher { constructor(e = Texture.DEFAULT_IMAGE, i = Texture.DEFAULT_MAPPING, s = ClampToEdgeWrapping, a = ClampToEdgeWrapping, o = LinearFilter, l = LinearMipmapLinearFilter, c = RGBAFormat, h = UnsignedByteType, d = Texture.DEFAULT_ANISOTROPY, p = NoColorSpace) { super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: _textureId++ }), this.uuid = generateUUID(), this.name = "", this.source = new Source(e), this.mipmaps = [], this.mapping = i, this.channel = 0, this.wrapS = s, this.wrapT = a, this.magFilter = o, this.minFilter = l, this.anisotropy = d, this.format = c, this.internalFormat = null, this.type = h, this.offset = new Vector2(0, 0), this.repeat = new Vector2(1, 1), this.center = new Vector2(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Matrix3, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = p, this.userData = {}, this.updateRanges = [], this.version = 0, this.onUpdate = null, this.renderTarget = null, this.isRenderTargetTexture = !1, this.isArrayTexture = !!(e && e.depth && e.depth > 1), this.pmremVersion = 0 } get width() { return this.source.getSize(_tempVec3).x } get height() { return this.source.getSize(_tempVec3).y } get depth() { return this.source.getSize(_tempVec3).z } get image() { return this.source.data } set image(e = null) { this.source.data = e } updateMatrix() { this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y) } addUpdateRange(e, i) { this.updateRanges.push({ start: e, count: i }) } clearUpdateRanges() { this.updateRanges.length = 0 } clone() { return new this.constructor().copy(this) } copy(e) { return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.renderTarget = e.renderTarget, this.isRenderTargetTexture = e.isRenderTargetTexture, this.isArrayTexture = e.isArrayTexture, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this } setValues(e) { for (const i in e) { const s = e[i]; if (s === void 0) { console.warn(`THREE.Texture.setValues(): parameter '${i}' has value of undefined.`); continue } const a = this[i]; if (a === void 0) { console.warn(`THREE.Texture.setValues(): property '${i}' does not exist.`); continue } a && s && a.isVector2 && s.isVector2 || a && s && a.isVector3 && s.isVector3 || a && s && a.isMatrix3 && s.isMatrix3 ? a.copy(s) : this[i] = s } } toJSON(e) { const i = e === void 0 || typeof e == "string"; if (!i && e.textures[this.uuid] !== void 0) return e.textures[this.uuid]; const s = { metadata: { version: 4.7, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, image: this.source.toJSON(e).uuid, mapping: this.mapping, channel: this.channel, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, internalFormat: this.internalFormat, type: this.type, colorSpace: this.colorSpace, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, generateMipmaps: this.generateMipmaps, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment }; return Object.keys(this.userData).length > 0 && (s.userData = this.userData), i || (e.textures[this.uuid] = s), s } dispose() { this.dispatchEvent({ type: "dispose" }) } transformUv(e) { if (this.mapping !== UVMapping) return e; if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) { case RepeatWrapping: e.x = e.x - Math.floor(e.x); break; case ClampToEdgeWrapping: e.x = e.x < 0 ? 0 : 1; break; case MirroredRepeatWrapping: Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x); break }if (e.y < 0 || e.y > 1) switch (this.wrapT) { case RepeatWrapping: e.y = e.y - Math.floor(e.y); break; case ClampToEdgeWrapping: e.y = e.y < 0 ? 0 : 1; break; case MirroredRepeatWrapping: Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y); break }return this.flipY && (e.y = 1 - e.y), e } set needsUpdate(e) { e === !0 && (this.version++, this.source.needsUpdate = !0) } set needsPMREMUpdate(e) { e === !0 && this.pmremVersion++ } } Texture.DEFAULT_IMAGE = null; Texture.DEFAULT_MAPPING = UVMapping; Texture.DEFAULT_ANISOTROPY = 1; class Vector4 { constructor(e = 0, i = 0, s = 0, a = 1) { Vector4.prototype.isVector4 = !0, this.x = e, this.y = i, this.z = s, this.w = a } get width() { return this.z } set width(e) { this.z = e } get height() { return this.w } set height(e) { this.w = e } set(e, i, s, a) { return this.x = e, this.y = i, this.z = s, this.w = a, this } setScalar(e) { return this.x = e, this.y = e, this.z = e, this.w = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setZ(e) { return this.z = e, this } setW(e) { return this.w = e, this } setComponent(e, i) { switch (e) { case 0: this.x = i; break; case 1: this.y = i; break; case 2: this.z = i; break; case 3: this.w = i; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; case 2: return this.z; case 3: return this.w; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y, this.z, this.w) } copy(e) { return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this } add(e) { return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this } addScalar(e) { return this.x += e, this.y += e, this.z += e, this.w += e, this } addVectors(e, i) { return this.x = e.x + i.x, this.y = e.y + i.y, this.z = e.z + i.z, this.w = e.w + i.w, this } addScaledVector(e, i) { return this.x += e.x * i, this.y += e.y * i, this.z += e.z * i, this.w += e.w * i, this } sub(e) { return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this } subScalar(e) { return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this } subVectors(e, i) { return this.x = e.x - i.x, this.y = e.y - i.y, this.z = e.z - i.z, this.w = e.w - i.w, this } multiply(e) { return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this } multiplyScalar(e) { return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this } applyMatrix4(e) { const i = this.x, s = this.y, a = this.z, o = this.w, l = e.elements; return this.x = l[0] * i + l[4] * s + l[8] * a + l[12] * o, this.y = l[1] * i + l[5] * s + l[9] * a + l[13] * o, this.z = l[2] * i + l[6] * s + l[10] * a + l[14] * o, this.w = l[3] * i + l[7] * s + l[11] * a + l[15] * o, this } divide(e) { return this.x /= e.x, this.y /= e.y, this.z /= e.z, this.w /= e.w, this } divideScalar(e) { return this.multiplyScalar(1 / e) } setAxisAngleFromQuaternion(e) { this.w = 2 * Math.acos(e.w); const i = Math.sqrt(1 - e.w * e.w); return i < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / i, this.y = e.y / i, this.z = e.z / i), this } setAxisAngleFromRotationMatrix(e) { let i, s, a, o; const h = e.elements, d = h[0], p = h[4], f = h[8], _ = h[1], x = h[5], b = h[9], T = h[2], M = h[6], w = h[10]; if (Math.abs(p - _) < .01 && Math.abs(f - T) < .01 && Math.abs(b - M) < .01) { if (Math.abs(p + _) < .1 && Math.abs(f + T) < .1 && Math.abs(b + M) < .1 && Math.abs(d + x + w - 3) < .1) return this.set(1, 0, 0, 0), this; i = Math.PI; const R = (d + 1) / 2, P = (x + 1) / 2, U = (w + 1) / 2, O = (p + _) / 4, N = (f + T) / 4, H = (b + M) / 4; return R > P && R > U ? R < .01 ? (s = 0, a = .707106781, o = .707106781) : (s = Math.sqrt(R), a = O / s, o = N / s) : P > U ? P < .01 ? (s = .707106781, a = 0, o = .707106781) : (a = Math.sqrt(P), s = O / a, o = H / a) : U < .01 ? (s = .707106781, a = .707106781, o = 0) : (o = Math.sqrt(U), s = N / o, a = H / o), this.set(s, a, o, i), this } let D = Math.sqrt((M - b) * (M - b) + (f - T) * (f - T) + (_ - p) * (_ - p)); return Math.abs(D) < .001 && (D = 1), this.x = (M - b) / D, this.y = (f - T) / D, this.z = (_ - p) / D, this.w = Math.acos((d + x + w - 1) / 2), this } setFromMatrixPosition(e) { const i = e.elements; return this.x = i[12], this.y = i[13], this.z = i[14], this.w = i[15], this } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this } clamp(e, i) { return this.x = clamp(this.x, e.x, i.x), this.y = clamp(this.y, e.y, i.y), this.z = clamp(this.z, e.z, i.z), this.w = clamp(this.w, e.w, i.w), this } clampScalar(e, i) { return this.x = clamp(this.x, e, i), this.y = clamp(this.y, e, i), this.z = clamp(this.z, e, i), this.w = clamp(this.w, e, i), this } clampLength(e, i) { const s = this.length(); return this.divideScalar(s || 1).multiplyScalar(clamp(s, e, i)) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this } roundToZero() { return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this } negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this } dot(e) { return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w) } normalize() { return this.divideScalar(this.length() || 1) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, i) { return this.x += (e.x - this.x) * i, this.y += (e.y - this.y) * i, this.z += (e.z - this.z) * i, this.w += (e.w - this.w) * i, this } lerpVectors(e, i, s) { return this.x = e.x + (i.x - e.x) * s, this.y = e.y + (i.y - e.y) * s, this.z = e.z + (i.z - e.z) * s, this.w = e.w + (i.w - e.w) * s, this } equals(e) { return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w } fromArray(e, i = 0) { return this.x = e[i], this.y = e[i + 1], this.z = e[i + 2], this.w = e[i + 3], this } toArray(e = [], i = 0) { return e[i] = this.x, e[i + 1] = this.y, e[i + 2] = this.z, e[i + 3] = this.w, e } fromBufferAttribute(e, i) { return this.x = e.getX(i), this.y = e.getY(i), this.z = e.getZ(i), this.w = e.getW(i), this } random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this } *[Symbol.iterator]() { yield this.x, yield this.y, yield this.z, yield this.w } } class RenderTarget extends EventDispatcher { constructor(e = 1, i = 1, s = {}) { super(), s = Object.assign({ generateMipmaps: !1, internalFormat: null, minFilter: LinearFilter, depthBuffer: !0, stencilBuffer: !1, resolveDepthBuffer: !0, resolveStencilBuffer: !0, depthTexture: null, samples: 0, count: 1, depth: 1, multiview: !1 }, s), this.isRenderTarget = !0, this.width = e, this.height = i, this.depth = s.depth, this.scissor = new Vector4(0, 0, e, i), this.scissorTest = !1, this.viewport = new Vector4(0, 0, e, i); const a = { width: e, height: i, depth: s.depth }, o = new Texture(a); this.textures = []; const l = s.count; for (let c = 0; c < l; c++)this.textures[c] = o.clone(), this.textures[c].isRenderTargetTexture = !0, this.textures[c].renderTarget = this; this._setTextureOptions(s), this.depthBuffer = s.depthBuffer, this.stencilBuffer = s.stencilBuffer, this.resolveDepthBuffer = s.resolveDepthBuffer, this.resolveStencilBuffer = s.resolveStencilBuffer, this._depthTexture = null, this.depthTexture = s.depthTexture, this.samples = s.samples, this.multiview = s.multiview } _setTextureOptions(e = {}) { const i = { minFilter: LinearFilter, generateMipmaps: !1, flipY: !1, internalFormat: null }; e.mapping !== void 0 && (i.mapping = e.mapping), e.wrapS !== void 0 && (i.wrapS = e.wrapS), e.wrapT !== void 0 && (i.wrapT = e.wrapT), e.wrapR !== void 0 && (i.wrapR = e.wrapR), e.magFilter !== void 0 && (i.magFilter = e.magFilter), e.minFilter !== void 0 && (i.minFilter = e.minFilter), e.format !== void 0 && (i.format = e.format), e.type !== void 0 && (i.type = e.type), e.anisotropy !== void 0 && (i.anisotropy = e.anisotropy), e.colorSpace !== void 0 && (i.colorSpace = e.colorSpace), e.flipY !== void 0 && (i.flipY = e.flipY), e.generateMipmaps !== void 0 && (i.generateMipmaps = e.generateMipmaps), e.internalFormat !== void 0 && (i.internalFormat = e.internalFormat); for (let s = 0; s < this.textures.length; s++)this.textures[s].setValues(i) } get texture() { return this.textures[0] } set texture(e) { this.textures[0] = e } set depthTexture(e) { this._depthTexture !== null && (this._depthTexture.renderTarget = null), e !== null && (e.renderTarget = this), this._depthTexture = e } get depthTexture() { return this._depthTexture } setSize(e, i, s = 1) { if (this.width !== e || this.height !== i || this.depth !== s) { this.width = e, this.height = i, this.depth = s; for (let a = 0, o = this.textures.length; a < o; a++)this.textures[a].image.width = e, this.textures[a].image.height = i, this.textures[a].image.depth = s, this.textures[a].isArrayTexture = this.textures[a].image.depth > 1; this.dispose() } this.viewport.set(0, 0, e, i), this.scissor.set(0, 0, e, i) } clone() { return new this.constructor().copy(this) } copy(e) { this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0; for (let i = 0, s = e.textures.length; i < s; i++) { this.textures[i] = e.textures[i].clone(), this.textures[i].isRenderTargetTexture = !0, this.textures[i].renderTarget = this; const a = Object.assign({}, e.textures[i].image); this.textures[i].source = new Source(a) } return this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.resolveDepthBuffer = e.resolveDepthBuffer, this.resolveStencilBuffer = e.resolveStencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this } dispose() { this.dispatchEvent({ type: "dispose" }) } } class WebGLRenderTarget extends RenderTarget { constructor(e = 1, i = 1, s = {}) { super(e, i, s), this.isWebGLRenderTarget = !0 } } class DataArrayTexture extends Texture { constructor(e = null, i = 1, s = 1, a = 1) { super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: i, height: s, depth: a }, this.magFilter = NearestFilter, this.minFilter = NearestFilter, this.wrapR = ClampToEdgeWrapping, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.layerUpdates = new Set } addLayerUpdate(e) { this.layerUpdates.add(e) } clearLayerUpdates() { this.layerUpdates.clear() } } class Data3DTexture extends Texture { constructor(e = null, i = 1, s = 1, a = 1) { super(null), this.isData3DTexture = !0, this.image = { data: e, width: i, height: s, depth: a }, this.magFilter = NearestFilter, this.minFilter = NearestFilter, this.wrapR = ClampToEdgeWrapping, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 } } class Box3 { constructor(e = new Vector3(1 / 0, 1 / 0, 1 / 0), i = new Vector3(-1 / 0, -1 / 0, -1 / 0)) { this.isBox3 = !0, this.min = e, this.max = i } set(e, i) { return this.min.copy(e), this.max.copy(i), this } setFromArray(e) { this.makeEmpty(); for (let i = 0, s = e.length; i < s; i += 3)this.expandByPoint(_vector$b.fromArray(e, i)); return this } setFromBufferAttribute(e) { this.makeEmpty(); for (let i = 0, s = e.count; i < s; i++)this.expandByPoint(_vector$b.fromBufferAttribute(e, i)); return this } setFromPoints(e) { this.makeEmpty(); for (let i = 0, s = e.length; i < s; i++)this.expandByPoint(e[i]); return this } setFromCenterAndSize(e, i) { const s = _vector$b.copy(i).multiplyScalar(.5); return this.min.copy(e).sub(s), this.max.copy(e).add(s), this } setFromObject(e, i = !1) { return this.makeEmpty(), this.expandByObject(e, i) } clone() { return new this.constructor().copy(this) } copy(e) { return this.min.copy(e.min), this.max.copy(e.max), this } makeEmpty() { return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this } isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z } getCenter(e) { return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5) } getSize(e) { return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min) } expandByPoint(e) { return this.min.min(e), this.max.max(e), this } expandByVector(e) { return this.min.sub(e), this.max.add(e), this } expandByScalar(e) { return this.min.addScalar(-e), this.max.addScalar(e), this } expandByObject(e, i = !1) { e.updateWorldMatrix(!1, !1); const s = e.geometry; if (s !== void 0) { const o = s.getAttribute("position"); if (i === !0 && o !== void 0 && e.isInstancedMesh !== !0) for (let l = 0, c = o.count; l < c; l++)e.isMesh === !0 ? e.getVertexPosition(l, _vector$b) : _vector$b.fromBufferAttribute(o, l), _vector$b.applyMatrix4(e.matrixWorld), this.expandByPoint(_vector$b); else e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), _box$4.copy(e.boundingBox)) : (s.boundingBox === null && s.computeBoundingBox(), _box$4.copy(s.boundingBox)), _box$4.applyMatrix4(e.matrixWorld), this.union(_box$4) } const a = e.children; for (let o = 0, l = a.length; o < l; o++)this.expandByObject(a[o], i); return this } containsPoint(e) { return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z } containsBox(e) { return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z } getParameter(e, i) { return i.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z)) } intersectsBox(e) { return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z } intersectsSphere(e) { return this.clampPoint(e.center, _vector$b), _vector$b.distanceToSquared(e.center) <= e.radius * e.radius } intersectsPlane(e) { let i, s; return e.normal.x > 0 ? (i = e.normal.x * this.min.x, s = e.normal.x * this.max.x) : (i = e.normal.x * this.max.x, s = e.normal.x * this.min.x), e.normal.y > 0 ? (i += e.normal.y * this.min.y, s += e.normal.y * this.max.y) : (i += e.normal.y * this.max.y, s += e.normal.y * this.min.y), e.normal.z > 0 ? (i += e.normal.z * this.min.z, s += e.normal.z * this.max.z) : (i += e.normal.z * this.max.z, s += e.normal.z * this.min.z), i <= -e.constant && s >= -e.constant } intersectsTriangle(e) { if (this.isEmpty()) return !1; this.getCenter(_center), _extents.subVectors(this.max, _center), _v0$2$1.subVectors(e.a, _center), _v1$7$1.subVectors(e.b, _center), _v2$4$1.subVectors(e.c, _center), _f0.subVectors(_v1$7$1, _v0$2$1), _f1.subVectors(_v2$4$1, _v1$7$1), _f2.subVectors(_v0$2$1, _v2$4$1); let i = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0]; return !satForAxes(i, _v0$2$1, _v1$7$1, _v2$4$1, _extents) || (i = [1, 0, 0, 0, 1, 0, 0, 0, 1], !satForAxes(i, _v0$2$1, _v1$7$1, _v2$4$1, _extents)) ? !1 : (_triangleNormal.crossVectors(_f0, _f1), i = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z], satForAxes(i, _v0$2$1, _v1$7$1, _v2$4$1, _extents)) } clampPoint(e, i) { return i.copy(e).clamp(this.min, this.max) } distanceToPoint(e) { return this.clampPoint(e, _vector$b).distanceTo(e) } getBoundingSphere(e) { return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(_vector$b).length() * .5), e } intersect(e) { return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this } union(e) { return this.min.min(e.min), this.max.max(e.max), this } applyMatrix4(e) { return this.isEmpty() ? this : (_points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(_points), this) } translate(e) { return this.min.add(e), this.max.add(e), this } equals(e) { return e.min.equals(this.min) && e.max.equals(this.max) } toJSON() { return { min: this.min.toArray(), max: this.max.toArray() } } fromJSON(e) { return this.min.fromArray(e.min), this.max.fromArray(e.max), this } } const _points = [new Vector3, new Vector3, new Vector3, new Vector3, new Vector3, new Vector3, new Vector3, new Vector3], _vector$b = new Vector3, _box$4 = new Box3, _v0$2$1 = new Vector3, _v1$7$1 = new Vector3, _v2$4$1 = new Vector3, _f0 = new Vector3, _f1 = new Vector3, _f2 = new Vector3, _center = new Vector3, _extents = new Vector3, _triangleNormal = new Vector3, _testAxis = new Vector3; function satForAxes(r, e, i, s, a) { for (let o = 0, l = r.length - 3; o <= l; o += 3) { _testAxis.fromArray(r, o); const c = a.x * Math.abs(_testAxis.x) + a.y * Math.abs(_testAxis.y) + a.z * Math.abs(_testAxis.z), h = e.dot(_testAxis), d = i.dot(_testAxis), p = s.dot(_testAxis); if (Math.max(-Math.max(h, d, p), Math.min(h, d, p)) > c) return !1 } return !0 } const _box$3 = new Box3, _v1$6$1 = new Vector3, _v2$3$1 = new Vector3; class Sphere { constructor(e = new Vector3, i = -1) { this.isSphere = !0, this.center = e, this.radius = i } set(e, i) { return this.center.copy(e), this.radius = i, this } setFromPoints(e, i) { const s = this.center; i !== void 0 ? s.copy(i) : _box$3.setFromPoints(e).getCenter(s); let a = 0; for (let o = 0, l = e.length; o < l; o++)a = Math.max(a, s.distanceToSquared(e[o])); return this.radius = Math.sqrt(a), this } copy(e) { return this.center.copy(e.center), this.radius = e.radius, this } isEmpty() { return this.radius < 0 } makeEmpty() { return this.center.set(0, 0, 0), this.radius = -1, this } containsPoint(e) { return e.distanceToSquared(this.center) <= this.radius * this.radius } distanceToPoint(e) { return e.distanceTo(this.center) - this.radius } intersectsSphere(e) { const i = this.radius + e.radius; return e.center.distanceToSquared(this.center) <= i * i } intersectsBox(e) { return e.intersectsSphere(this) } intersectsPlane(e) { return Math.abs(e.distanceToPoint(this.center)) <= this.radius } clampPoint(e, i) { const s = this.center.distanceToSquared(e); return i.copy(e), s > this.radius * this.radius && (i.sub(this.center).normalize(), i.multiplyScalar(this.radius).add(this.center)), i } getBoundingBox(e) { return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e) } applyMatrix4(e) { return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this } translate(e) { return this.center.add(e), this } expandByPoint(e) { if (this.isEmpty()) return this.center.copy(e), this.radius = 0, this; _v1$6$1.subVectors(e, this.center); const i = _v1$6$1.lengthSq(); if (i > this.radius * this.radius) { const s = Math.sqrt(i), a = (s - this.radius) * .5; this.center.addScaledVector(_v1$6$1, a / s), this.radius += a } return this } union(e) { return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (_v2$3$1.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(_v1$6$1.copy(e.center).add(_v2$3$1)), this.expandByPoint(_v1$6$1.copy(e.center).sub(_v2$3$1))), this) } equals(e) { return e.center.equals(this.center) && e.radius === this.radius } clone() { return new this.constructor().copy(this) } toJSON() { return { radius: this.radius, center: this.center.toArray() } } fromJSON(e) { return this.radius = e.radius, this.center.fromArray(e.center), this } } const _vector$a = new Vector3, _segCenter = new Vector3, _segDir = new Vector3, _diff = new Vector3, _edge1 = new Vector3, _edge2 = new Vector3, _normal$1 = new Vector3; class Ray { constructor(e = new Vector3, i = new Vector3(0, 0, -1)) { this.origin = e, this.direction = i } set(e, i) { return this.origin.copy(e), this.direction.copy(i), this } copy(e) { return this.origin.copy(e.origin), this.direction.copy(e.direction), this } at(e, i) { return i.copy(this.origin).addScaledVector(this.direction, e) } lookAt(e) { return this.direction.copy(e).sub(this.origin).normalize(), this } recast(e) { return this.origin.copy(this.at(e, _vector$a)), this } closestPointToPoint(e, i) { i.subVectors(e, this.origin); const s = i.dot(this.direction); return s < 0 ? i.copy(this.origin) : i.copy(this.origin).addScaledVector(this.direction, s) } distanceToPoint(e) { return Math.sqrt(this.distanceSqToPoint(e)) } distanceSqToPoint(e) { const i = _vector$a.subVectors(e, this.origin).dot(this.direction); return i < 0 ? this.origin.distanceToSquared(e) : (_vector$a.copy(this.origin).addScaledVector(this.direction, i), _vector$a.distanceToSquared(e)) } distanceSqToSegment(e, i, s, a) { _segCenter.copy(e).add(i).multiplyScalar(.5), _segDir.copy(i).sub(e).normalize(), _diff.copy(this.origin).sub(_segCenter); const o = e.distanceTo(i) * .5, l = -this.direction.dot(_segDir), c = _diff.dot(this.direction), h = -_diff.dot(_segDir), d = _diff.lengthSq(), p = Math.abs(1 - l * l); let f, _, x, b; if (p > 0) if (f = l * h - c, _ = l * c - h, b = o * p, f >= 0) if (_ >= -b) if (_ <= b) { const T = 1 / p; f *= T, _ *= T, x = f * (f + l * _ + 2 * c) + _ * (l * f + _ + 2 * h) + d } else _ = o, f = Math.max(0, -(l * _ + c)), x = -f * f + _ * (_ + 2 * h) + d; else _ = -o, f = Math.max(0, -(l * _ + c)), x = -f * f + _ * (_ + 2 * h) + d; else _ <= -b ? (f = Math.max(0, -(-l * o + c)), _ = f > 0 ? -o : Math.min(Math.max(-o, -h), o), x = -f * f + _ * (_ + 2 * h) + d) : _ <= b ? (f = 0, _ = Math.min(Math.max(-o, -h), o), x = _ * (_ + 2 * h) + d) : (f = Math.max(0, -(l * o + c)), _ = f > 0 ? o : Math.min(Math.max(-o, -h), o), x = -f * f + _ * (_ + 2 * h) + d); else _ = l > 0 ? -o : o, f = Math.max(0, -(l * _ + c)), x = -f * f + _ * (_ + 2 * h) + d; return s && s.copy(this.origin).addScaledVector(this.direction, f), a && a.copy(_segCenter).addScaledVector(_segDir, _), x } intersectSphere(e, i) { _vector$a.subVectors(e.center, this.origin); const s = _vector$a.dot(this.direction), a = _vector$a.dot(_vector$a) - s * s, o = e.radius * e.radius; if (a > o) return null; const l = Math.sqrt(o - a), c = s - l, h = s + l; return h < 0 ? null : c < 0 ? this.at(h, i) : this.at(c, i) } intersectsSphere(e) { return e.radius < 0 ? !1 : this.distanceSqToPoint(e.center) <= e.radius * e.radius } distanceToPlane(e) { const i = e.normal.dot(this.direction); if (i === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null; const s = -(this.origin.dot(e.normal) + e.constant) / i; return s >= 0 ? s : null } intersectPlane(e, i) { const s = this.distanceToPlane(e); return s === null ? null : this.at(s, i) } intersectsPlane(e) { const i = e.distanceToPoint(this.origin); return i === 0 || e.normal.dot(this.direction) * i < 0 } intersectBox(e, i) { let s, a, o, l, c, h; const d = 1 / this.direction.x, p = 1 / this.direction.y, f = 1 / this.direction.z, _ = this.origin; return d >= 0 ? (s = (e.min.x - _.x) * d, a = (e.max.x - _.x) * d) : (s = (e.max.x - _.x) * d, a = (e.min.x - _.x) * d), p >= 0 ? (o = (e.min.y - _.y) * p, l = (e.max.y - _.y) * p) : (o = (e.max.y - _.y) * p, l = (e.min.y - _.y) * p), s > l || o > a || ((o > s || isNaN(s)) && (s = o), (l < a || isNaN(a)) && (a = l), f >= 0 ? (c = (e.min.z - _.z) * f, h = (e.max.z - _.z) * f) : (c = (e.max.z - _.z) * f, h = (e.min.z - _.z) * f), s > h || c > a) || ((c > s || s !== s) && (s = c), (h < a || a !== a) && (a = h), a < 0) ? null : this.at(s >= 0 ? s : a, i) } intersectsBox(e) { return this.intersectBox(e, _vector$a) !== null } intersectTriangle(e, i, s, a, o) { _edge1.subVectors(i, e), _edge2.subVectors(s, e), _normal$1.crossVectors(_edge1, _edge2); let l = this.direction.dot(_normal$1), c; if (l > 0) { if (a) return null; c = 1 } else if (l < 0) c = -1, l = -l; else return null; _diff.subVectors(this.origin, e); const h = c * this.direction.dot(_edge2.crossVectors(_diff, _edge2)); if (h < 0) return null; const d = c * this.direction.dot(_edge1.cross(_diff)); if (d < 0 || h + d > l) return null; const p = -c * _diff.dot(_normal$1); return p < 0 ? null : this.at(p / l, o) } applyMatrix4(e) { return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this } equals(e) { return e.origin.equals(this.origin) && e.direction.equals(this.direction) } clone() { return new this.constructor().copy(this) } } class Matrix4 { constructor(e, i, s, a, o, l, c, h, d, p, f, _, x, b, T, M) { Matrix4.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], e !== void 0 && this.set(e, i, s, a, o, l, c, h, d, p, f, _, x, b, T, M) } set(e, i, s, a, o, l, c, h, d, p, f, _, x, b, T, M) { const w = this.elements; return w[0] = e, w[4] = i, w[8] = s, w[12] = a, w[1] = o, w[5] = l, w[9] = c, w[13] = h, w[2] = d, w[6] = p, w[10] = f, w[14] = _, w[3] = x, w[7] = b, w[11] = T, w[15] = M, this } identity() { return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } clone() { return new Matrix4().fromArray(this.elements) } copy(e) { const i = this.elements, s = e.elements; return i[0] = s[0], i[1] = s[1], i[2] = s[2], i[3] = s[3], i[4] = s[4], i[5] = s[5], i[6] = s[6], i[7] = s[7], i[8] = s[8], i[9] = s[9], i[10] = s[10], i[11] = s[11], i[12] = s[12], i[13] = s[13], i[14] = s[14], i[15] = s[15], this } copyPosition(e) { const i = this.elements, s = e.elements; return i[12] = s[12], i[13] = s[13], i[14] = s[14], this } setFromMatrix3(e) { const i = e.elements; return this.set(i[0], i[3], i[6], 0, i[1], i[4], i[7], 0, i[2], i[5], i[8], 0, 0, 0, 0, 1), this } extractBasis(e, i, s) { return e.setFromMatrixColumn(this, 0), i.setFromMatrixColumn(this, 1), s.setFromMatrixColumn(this, 2), this } makeBasis(e, i, s) { return this.set(e.x, i.x, s.x, 0, e.y, i.y, s.y, 0, e.z, i.z, s.z, 0, 0, 0, 0, 1), this } extractRotation(e) { const i = this.elements, s = e.elements, a = 1 / _v1$5$1.setFromMatrixColumn(e, 0).length(), o = 1 / _v1$5$1.setFromMatrixColumn(e, 1).length(), l = 1 / _v1$5$1.setFromMatrixColumn(e, 2).length(); return i[0] = s[0] * a, i[1] = s[1] * a, i[2] = s[2] * a, i[3] = 0, i[4] = s[4] * o, i[5] = s[5] * o, i[6] = s[6] * o, i[7] = 0, i[8] = s[8] * l, i[9] = s[9] * l, i[10] = s[10] * l, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, this } makeRotationFromEuler(e) { const i = this.elements, s = e.x, a = e.y, o = e.z, l = Math.cos(s), c = Math.sin(s), h = Math.cos(a), d = Math.sin(a), p = Math.cos(o), f = Math.sin(o); if (e.order === "XYZ") { const _ = l * p, x = l * f, b = c * p, T = c * f; i[0] = h * p, i[4] = -h * f, i[8] = d, i[1] = x + b * d, i[5] = _ - T * d, i[9] = -c * h, i[2] = T - _ * d, i[6] = b + x * d, i[10] = l * h } else if (e.order === "YXZ") { const _ = h * p, x = h * f, b = d * p, T = d * f; i[0] = _ + T * c, i[4] = b * c - x, i[8] = l * d, i[1] = l * f, i[5] = l * p, i[9] = -c, i[2] = x * c - b, i[6] = T + _ * c, i[10] = l * h } else if (e.order === "ZXY") { const _ = h * p, x = h * f, b = d * p, T = d * f; i[0] = _ - T * c, i[4] = -l * f, i[8] = b + x * c, i[1] = x + b * c, i[5] = l * p, i[9] = T - _ * c, i[2] = -l * d, i[6] = c, i[10] = l * h } else if (e.order === "ZYX") { const _ = l * p, x = l * f, b = c * p, T = c * f; i[0] = h * p, i[4] = b * d - x, i[8] = _ * d + T, i[1] = h * f, i[5] = T * d + _, i[9] = x * d - b, i[2] = -d, i[6] = c * h, i[10] = l * h } else if (e.order === "YZX") { const _ = l * h, x = l * d, b = c * h, T = c * d; i[0] = h * p, i[4] = T - _ * f, i[8] = b * f + x, i[1] = f, i[5] = l * p, i[9] = -c * p, i[2] = -d * p, i[6] = x * f + b, i[10] = _ - T * f } else if (e.order === "XZY") { const _ = l * h, x = l * d, b = c * h, T = c * d; i[0] = h * p, i[4] = -f, i[8] = d * p, i[1] = _ * f + T, i[5] = l * p, i[9] = x * f - b, i[2] = b * f - x, i[6] = c * p, i[10] = T * f + _ } return i[3] = 0, i[7] = 0, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, this } makeRotationFromQuaternion(e) { return this.compose(_zero, e, _one) } lookAt(e, i, s) { const a = this.elements; return _z.subVectors(e, i), _z.lengthSq() === 0 && (_z.z = 1), _z.normalize(), _x.crossVectors(s, _z), _x.lengthSq() === 0 && (Math.abs(s.z) === 1 ? _z.x += 1e-4 : _z.z += 1e-4, _z.normalize(), _x.crossVectors(s, _z)), _x.normalize(), _y.crossVectors(_z, _x), a[0] = _x.x, a[4] = _y.x, a[8] = _z.x, a[1] = _x.y, a[5] = _y.y, a[9] = _z.y, a[2] = _x.z, a[6] = _y.z, a[10] = _z.z, this } multiply(e) { return this.multiplyMatrices(this, e) } premultiply(e) { return this.multiplyMatrices(e, this) } multiplyMatrices(e, i) { const s = e.elements, a = i.elements, o = this.elements, l = s[0], c = s[4], h = s[8], d = s[12], p = s[1], f = s[5], _ = s[9], x = s[13], b = s[2], T = s[6], M = s[10], w = s[14], D = s[3], R = s[7], P = s[11], U = s[15], O = a[0], N = a[4], H = a[8], F = a[12], k = a[1], W = a[5], $ = a[9], Z = a[13], J = a[2], se = a[6], re = a[10], ce = a[14], ee = a[3], Me = a[7], Ee = a[11], Ue = a[15]; return o[0] = l * O + c * k + h * J + d * ee, o[4] = l * N + c * W + h * se + d * Me, o[8] = l * H + c * $ + h * re + d * Ee, o[12] = l * F + c * Z + h * ce + d * Ue, o[1] = p * O + f * k + _ * J + x * ee, o[5] = p * N + f * W + _ * se + x * Me, o[9] = p * H + f * $ + _ * re + x * Ee, o[13] = p * F + f * Z + _ * ce + x * Ue, o[2] = b * O + T * k + M * J + w * ee, o[6] = b * N + T * W + M * se + w * Me, o[10] = b * H + T * $ + M * re + w * Ee, o[14] = b * F + T * Z + M * ce + w * Ue, o[3] = D * O + R * k + P * J + U * ee, o[7] = D * N + R * W + P * se + U * Me, o[11] = D * H + R * $ + P * re + U * Ee, o[15] = D * F + R * Z + P * ce + U * Ue, this } multiplyScalar(e) { const i = this.elements; return i[0] *= e, i[4] *= e, i[8] *= e, i[12] *= e, i[1] *= e, i[5] *= e, i[9] *= e, i[13] *= e, i[2] *= e, i[6] *= e, i[10] *= e, i[14] *= e, i[3] *= e, i[7] *= e, i[11] *= e, i[15] *= e, this } determinant() { const e = this.elements, i = e[0], s = e[4], a = e[8], o = e[12], l = e[1], c = e[5], h = e[9], d = e[13], p = e[2], f = e[6], _ = e[10], x = e[14], b = e[3], T = e[7], M = e[11], w = e[15]; return b * (+o * h * f - a * d * f - o * c * _ + s * d * _ + a * c * x - s * h * x) + T * (+i * h * x - i * d * _ + o * l * _ - a * l * x + a * d * p - o * h * p) + M * (+i * d * f - i * c * x - o * l * f + s * l * x + o * c * p - s * d * p) + w * (-a * c * p - i * h * f + i * c * _ + a * l * f - s * l * _ + s * h * p) } transpose() { const e = this.elements; let i; return i = e[1], e[1] = e[4], e[4] = i, i = e[2], e[2] = e[8], e[8] = i, i = e[6], e[6] = e[9], e[9] = i, i = e[3], e[3] = e[12], e[12] = i, i = e[7], e[7] = e[13], e[13] = i, i = e[11], e[11] = e[14], e[14] = i, this } setPosition(e, i, s) { const a = this.elements; return e.isVector3 ? (a[12] = e.x, a[13] = e.y, a[14] = e.z) : (a[12] = e, a[13] = i, a[14] = s), this } invert() { const e = this.elements, i = e[0], s = e[1], a = e[2], o = e[3], l = e[4], c = e[5], h = e[6], d = e[7], p = e[8], f = e[9], _ = e[10], x = e[11], b = e[12], T = e[13], M = e[14], w = e[15], D = f * M * d - T * _ * d + T * h * x - c * M * x - f * h * w + c * _ * w, R = b * _ * d - p * M * d - b * h * x + l * M * x + p * h * w - l * _ * w, P = p * T * d - b * f * d + b * c * x - l * T * x - p * c * w + l * f * w, U = b * f * h - p * T * h - b * c * _ + l * T * _ + p * c * M - l * f * M, O = i * D + s * R + a * P + o * U; if (O === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0); const N = 1 / O; return e[0] = D * N, e[1] = (T * _ * o - f * M * o - T * a * x + s * M * x + f * a * w - s * _ * w) * N, e[2] = (c * M * o - T * h * o + T * a * d - s * M * d - c * a * w + s * h * w) * N, e[3] = (f * h * o - c * _ * o - f * a * d + s * _ * d + c * a * x - s * h * x) * N, e[4] = R * N, e[5] = (p * M * o - b * _ * o + b * a * x - i * M * x - p * a * w + i * _ * w) * N, e[6] = (b * h * o - l * M * o - b * a * d + i * M * d + l * a * w - i * h * w) * N, e[7] = (l * _ * o - p * h * o + p * a * d - i * _ * d - l * a * x + i * h * x) * N, e[8] = P * N, e[9] = (b * f * o - p * T * o - b * s * x + i * T * x + p * s * w - i * f * w) * N, e[10] = (l * T * o - b * c * o + b * s * d - i * T * d - l * s * w + i * c * w) * N, e[11] = (p * c * o - l * f * o - p * s * d + i * f * d + l * s * x - i * c * x) * N, e[12] = U * N, e[13] = (p * T * a - b * f * a + b * s * _ - i * T * _ - p * s * M + i * f * M) * N, e[14] = (b * c * a - l * T * a - b * s * h + i * T * h + l * s * M - i * c * M) * N, e[15] = (l * f * a - p * c * a + p * s * h - i * f * h - l * s * _ + i * c * _) * N, this } scale(e) { const i = this.elements, s = e.x, a = e.y, o = e.z; return i[0] *= s, i[4] *= a, i[8] *= o, i[1] *= s, i[5] *= a, i[9] *= o, i[2] *= s, i[6] *= a, i[10] *= o, i[3] *= s, i[7] *= a, i[11] *= o, this } getMaxScaleOnAxis() { const e = this.elements, i = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], s = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], a = e[8] * e[8] + e[9] * e[9] + e[10] * e[10]; return Math.sqrt(Math.max(i, s, a)) } makeTranslation(e, i, s) { return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, i, 0, 0, 1, s, 0, 0, 0, 1), this } makeRotationX(e) { const i = Math.cos(e), s = Math.sin(e); return this.set(1, 0, 0, 0, 0, i, -s, 0, 0, s, i, 0, 0, 0, 0, 1), this } makeRotationY(e) { const i = Math.cos(e), s = Math.sin(e); return this.set(i, 0, s, 0, 0, 1, 0, 0, -s, 0, i, 0, 0, 0, 0, 1), this } makeRotationZ(e) { const i = Math.cos(e), s = Math.sin(e); return this.set(i, -s, 0, 0, s, i, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } makeRotationAxis(e, i) { const s = Math.cos(i), a = Math.sin(i), o = 1 - s, l = e.x, c = e.y, h = e.z, d = o * l, p = o * c; return this.set(d * l + s, d * c - a * h, d * h + a * c, 0, d * c + a * h, p * c + s, p * h - a * l, 0, d * h - a * c, p * h + a * l, o * h * h + s, 0, 0, 0, 0, 1), this } makeScale(e, i, s) { return this.set(e, 0, 0, 0, 0, i, 0, 0, 0, 0, s, 0, 0, 0, 0, 1), this } makeShear(e, i, s, a, o, l) { return this.set(1, s, o, 0, e, 1, l, 0, i, a, 1, 0, 0, 0, 0, 1), this } compose(e, i, s) { const a = this.elements, o = i._x, l = i._y, c = i._z, h = i._w, d = o + o, p = l + l, f = c + c, _ = o * d, x = o * p, b = o * f, T = l * p, M = l * f, w = c * f, D = h * d, R = h * p, P = h * f, U = s.x, O = s.y, N = s.z; return a[0] = (1 - (T + w)) * U, a[1] = (x + P) * U, a[2] = (b - R) * U, a[3] = 0, a[4] = (x - P) * O, a[5] = (1 - (_ + w)) * O, a[6] = (M + D) * O, a[7] = 0, a[8] = (b + R) * N, a[9] = (M - D) * N, a[10] = (1 - (_ + T)) * N, a[11] = 0, a[12] = e.x, a[13] = e.y, a[14] = e.z, a[15] = 1, this } decompose(e, i, s) { const a = this.elements; let o = _v1$5$1.set(a[0], a[1], a[2]).length(); const l = _v1$5$1.set(a[4], a[5], a[6]).length(), c = _v1$5$1.set(a[8], a[9], a[10]).length(); this.determinant() < 0 && (o = -o), e.x = a[12], e.y = a[13], e.z = a[14], _m1$2.copy(this); const d = 1 / o, p = 1 / l, f = 1 / c; return _m1$2.elements[0] *= d, _m1$2.elements[1] *= d, _m1$2.elements[2] *= d, _m1$2.elements[4] *= p, _m1$2.elements[5] *= p, _m1$2.elements[6] *= p, _m1$2.elements[8] *= f, _m1$2.elements[9] *= f, _m1$2.elements[10] *= f, i.setFromRotationMatrix(_m1$2), s.x = o, s.y = l, s.z = c, this } makePerspective(e, i, s, a, o, l, c = WebGLCoordinateSystem, h = !1) { const d = this.elements, p = 2 * o / (i - e), f = 2 * o / (s - a), _ = (i + e) / (i - e), x = (s + a) / (s - a); let b, T; if (h) b = o / (l - o), T = l * o / (l - o); else if (c === WebGLCoordinateSystem) b = -(l + o) / (l - o), T = -2 * l * o / (l - o); else if (c === WebGPUCoordinateSystem) b = -l / (l - o), T = -l * o / (l - o); else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + c); return d[0] = p, d[4] = 0, d[8] = _, d[12] = 0, d[1] = 0, d[5] = f, d[9] = x, d[13] = 0, d[2] = 0, d[6] = 0, d[10] = b, d[14] = T, d[3] = 0, d[7] = 0, d[11] = -1, d[15] = 0, this } makeOrthographic(e, i, s, a, o, l, c = WebGLCoordinateSystem, h = !1) { const d = this.elements, p = 2 / (i - e), f = 2 / (s - a), _ = -(i + e) / (i - e), x = -(s + a) / (s - a); let b, T; if (h) b = 1 / (l - o), T = l / (l - o); else if (c === WebGLCoordinateSystem) b = -2 / (l - o), T = -(l + o) / (l - o); else if (c === WebGPUCoordinateSystem) b = -1 / (l - o), T = -o / (l - o); else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + c); return d[0] = p, d[4] = 0, d[8] = 0, d[12] = _, d[1] = 0, d[5] = f, d[9] = 0, d[13] = x, d[2] = 0, d[6] = 0, d[10] = b, d[14] = T, d[3] = 0, d[7] = 0, d[11] = 0, d[15] = 1, this } equals(e) { const i = this.elements, s = e.elements; for (let a = 0; a < 16; a++)if (i[a] !== s[a]) return !1; return !0 } fromArray(e, i = 0) { for (let s = 0; s < 16; s++)this.elements[s] = e[s + i]; return this } toArray(e = [], i = 0) { const s = this.elements; return e[i] = s[0], e[i + 1] = s[1], e[i + 2] = s[2], e[i + 3] = s[3], e[i + 4] = s[4], e[i + 5] = s[5], e[i + 6] = s[6], e[i + 7] = s[7], e[i + 8] = s[8], e[i + 9] = s[9], e[i + 10] = s[10], e[i + 11] = s[11], e[i + 12] = s[12], e[i + 13] = s[13], e[i + 14] = s[14], e[i + 15] = s[15], e } } const _v1$5$1 = new Vector3, _m1$2 = new Matrix4, _zero = new Vector3(0, 0, 0), _one = new Vector3(1, 1, 1), _x = new Vector3, _y = new Vector3, _z = new Vector3, _matrix$2 = new Matrix4, _quaternion$3 = new Quaternion; class Euler { constructor(e = 0, i = 0, s = 0, a = Euler.DEFAULT_ORDER) { this.isEuler = !0, this._x = e, this._y = i, this._z = s, this._order = a } get x() { return this._x } set x(e) { this._x = e, this._onChangeCallback() } get y() { return this._y } set y(e) { this._y = e, this._onChangeCallback() } get z() { return this._z } set z(e) { this._z = e, this._onChangeCallback() } get order() { return this._order } set order(e) { this._order = e, this._onChangeCallback() } set(e, i, s, a = this._order) { return this._x = e, this._y = i, this._z = s, this._order = a, this._onChangeCallback(), this } clone() { return new this.constructor(this._x, this._y, this._z, this._order) } copy(e) { return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this } setFromRotationMatrix(e, i = this._order, s = !0) { const a = e.elements, o = a[0], l = a[4], c = a[8], h = a[1], d = a[5], p = a[9], f = a[2], _ = a[6], x = a[10]; switch (i) { case "XYZ": this._y = Math.asin(clamp(c, -1, 1)), Math.abs(c) < .9999999 ? (this._x = Math.atan2(-p, x), this._z = Math.atan2(-l, o)) : (this._x = Math.atan2(_, d), this._z = 0); break; case "YXZ": this._x = Math.asin(-clamp(p, -1, 1)), Math.abs(p) < .9999999 ? (this._y = Math.atan2(c, x), this._z = Math.atan2(h, d)) : (this._y = Math.atan2(-f, o), this._z = 0); break; case "ZXY": this._x = Math.asin(clamp(_, -1, 1)), Math.abs(_) < .9999999 ? (this._y = Math.atan2(-f, x), this._z = Math.atan2(-l, d)) : (this._y = 0, this._z = Math.atan2(h, o)); break; case "ZYX": this._y = Math.asin(-clamp(f, -1, 1)), Math.abs(f) < .9999999 ? (this._x = Math.atan2(_, x), this._z = Math.atan2(h, o)) : (this._x = 0, this._z = Math.atan2(-l, d)); break; case "YZX": this._z = Math.asin(clamp(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(-p, d), this._y = Math.atan2(-f, o)) : (this._x = 0, this._y = Math.atan2(c, x)); break; case "XZY": this._z = Math.asin(-clamp(l, -1, 1)), Math.abs(l) < .9999999 ? (this._x = Math.atan2(_, d), this._y = Math.atan2(c, o)) : (this._x = Math.atan2(-p, x), this._y = 0); break; default: console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + i) }return this._order = i, s === !0 && this._onChangeCallback(), this } setFromQuaternion(e, i, s) { return _matrix$2.makeRotationFromQuaternion(e), this.setFromRotationMatrix(_matrix$2, i, s) } setFromVector3(e, i = this._order) { return this.set(e.x, e.y, e.z, i) } reorder(e) { return _quaternion$3.setFromEuler(this), this.setFromQuaternion(_quaternion$3, e) } equals(e) { return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order } fromArray(e) { return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this } toArray(e = [], i = 0) { return e[i] = this._x, e[i + 1] = this._y, e[i + 2] = this._z, e[i + 3] = this._order, e } _onChange(e) { return this._onChangeCallback = e, this } _onChangeCallback() { } *[Symbol.iterator]() { yield this._x, yield this._y, yield this._z, yield this._order } } Euler.DEFAULT_ORDER = "XYZ"; class Layers { constructor() { this.mask = 1 } set(e) { this.mask = (1 << e | 0) >>> 0 } enable(e) { this.mask |= 1 << e | 0 } enableAll() { this.mask = -1 } toggle(e) { this.mask ^= 1 << e | 0 } disable(e) { this.mask &= ~(1 << e | 0) } disableAll() { this.mask = 0 } test(e) { return (this.mask & e.mask) !== 0 } isEnabled(e) { return (this.mask & (1 << e | 0)) !== 0 } } let _object3DId = 0; const _v1$4$1 = new Vector3, _q1$2 = new Quaternion, _m1$1$1 = new Matrix4, _target = new Vector3, _position$3 = new Vector3, _scale$2 = new Vector3, _quaternion$2 = new Quaternion, _xAxis = new Vector3(1, 0, 0), _yAxis = new Vector3(0, 1, 0), _zAxis = new Vector3(0, 0, 1), _addedEvent = { type: "added" }, _removedEvent = { type: "removed" }, _childaddedEvent = { type: "childadded", child: null }, _childremovedEvent = { type: "childremoved", child: null }; class Object3D extends EventDispatcher { constructor() { super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: _object3DId++ }), this.uuid = generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Object3D.DEFAULT_UP.clone(); const e = new Vector3, i = new Euler, s = new Quaternion, a = new Vector3(1, 1, 1); function o() { s.setFromEuler(i, !1) } function l() { i.setFromQuaternion(s, void 0, !1) } i._onChange(o), s._onChange(l), Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: e }, rotation: { configurable: !0, enumerable: !0, value: i }, quaternion: { configurable: !0, enumerable: !0, value: s }, scale: { configurable: !0, enumerable: !0, value: a }, modelViewMatrix: { value: new Matrix4 }, normalMatrix: { value: new Matrix3 } }), this.matrix = new Matrix4, this.matrixWorld = new Matrix4, this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new Layers, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.customDepthMaterial = void 0, this.customDistanceMaterial = void 0, this.userData = {} } onBeforeShadow() { } onAfterShadow() { } onBeforeRender() { } onAfterRender() { } applyMatrix4(e) { this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale) } applyQuaternion(e) { return this.quaternion.premultiply(e), this } setRotationFromAxisAngle(e, i) { this.quaternion.setFromAxisAngle(e, i) } setRotationFromEuler(e) { this.quaternion.setFromEuler(e, !0) } setRotationFromMatrix(e) { this.quaternion.setFromRotationMatrix(e) } setRotationFromQuaternion(e) { this.quaternion.copy(e) } rotateOnAxis(e, i) { return _q1$2.setFromAxisAngle(e, i), this.quaternion.multiply(_q1$2), this } rotateOnWorldAxis(e, i) { return _q1$2.setFromAxisAngle(e, i), this.quaternion.premultiply(_q1$2), this } rotateX(e) { return this.rotateOnAxis(_xAxis, e) } rotateY(e) { return this.rotateOnAxis(_yAxis, e) } rotateZ(e) { return this.rotateOnAxis(_zAxis, e) } translateOnAxis(e, i) { return _v1$4$1.copy(e).applyQuaternion(this.quaternion), this.position.add(_v1$4$1.multiplyScalar(i)), this } translateX(e) { return this.translateOnAxis(_xAxis, e) } translateY(e) { return this.translateOnAxis(_yAxis, e) } translateZ(e) { return this.translateOnAxis(_zAxis, e) } localToWorld(e) { return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld) } worldToLocal(e) { return this.updateWorldMatrix(!0, !1), e.applyMatrix4(_m1$1$1.copy(this.matrixWorld).invert()) } lookAt(e, i, s) { e.isVector3 ? _target.copy(e) : _target.set(e, i, s); const a = this.parent; this.updateWorldMatrix(!0, !1), _position$3.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? _m1$1$1.lookAt(_position$3, _target, this.up) : _m1$1$1.lookAt(_target, _position$3, this.up), this.quaternion.setFromRotationMatrix(_m1$1$1), a && (_m1$1$1.extractRotation(a.matrixWorld), _q1$2.setFromRotationMatrix(_m1$1$1), this.quaternion.premultiply(_q1$2.invert())) } add(e) { if (arguments.length > 1) { for (let i = 0; i < arguments.length; i++)this.add(arguments[i]); return this } return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(_addedEvent), _childaddedEvent.child = e, this.dispatchEvent(_childaddedEvent), _childaddedEvent.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this) } remove(e) { if (arguments.length > 1) { for (let s = 0; s < arguments.length; s++)this.remove(arguments[s]); return this } const i = this.children.indexOf(e); return i !== -1 && (e.parent = null, this.children.splice(i, 1), e.dispatchEvent(_removedEvent), _childremovedEvent.child = e, this.dispatchEvent(_childremovedEvent), _childremovedEvent.child = null), this } removeFromParent() { const e = this.parent; return e !== null && e.remove(this), this } clear() { return this.remove(...this.children) } attach(e) { return this.updateWorldMatrix(!0, !1), _m1$1$1.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), _m1$1$1.multiply(e.parent.matrixWorld)), e.applyMatrix4(_m1$1$1), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(!1, !0), e.dispatchEvent(_addedEvent), _childaddedEvent.child = e, this.dispatchEvent(_childaddedEvent), _childaddedEvent.child = null, this } getObjectById(e) { return this.getObjectByProperty("id", e) } getObjectByName(e) { return this.getObjectByProperty("name", e) } getObjectByProperty(e, i) { if (this[e] === i) return this; for (let s = 0, a = this.children.length; s < a; s++) { const l = this.children[s].getObjectByProperty(e, i); if (l !== void 0) return l } } getObjectsByProperty(e, i, s = []) { this[e] === i && s.push(this); const a = this.children; for (let o = 0, l = a.length; o < l; o++)a[o].getObjectsByProperty(e, i, s); return s } getWorldPosition(e) { return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld) } getWorldQuaternion(e) { return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(_position$3, e, _scale$2), e } getWorldScale(e) { return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(_position$3, _quaternion$2, e), e } getWorldDirection(e) { this.updateWorldMatrix(!0, !1); const i = this.matrixWorld.elements; return e.set(i[8], i[9], i[10]).normalize() } raycast() { } traverse(e) { e(this); const i = this.children; for (let s = 0, a = i.length; s < a; s++)i[s].traverse(e) } traverseVisible(e) { if (this.visible === !1) return; e(this); const i = this.children; for (let s = 0, a = i.length; s < a; s++)i[s].traverseVisible(e) } traverseAncestors(e) { const i = this.parent; i !== null && (e(i), i.traverseAncestors(e)) } updateMatrix() { this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0 } updateMatrixWorld(e) { this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, e = !0); const i = this.children; for (let s = 0, a = i.length; s < a; s++)i[s].updateMatrixWorld(e) } updateWorldMatrix(e, i) { const s = this.parent; if (e === !0 && s !== null && s.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), i === !0) { const a = this.children; for (let o = 0, l = a.length; o < l; o++)a[o].updateWorldMatrix(!1, !0) } } toJSON(e) { const i = e === void 0 || typeof e == "string", s = {}; i && (e = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {}, nodes: {} }, s.metadata = { version: 4.7, type: "Object", generator: "Object3D.toJSON" }); const a = {}; a.uuid = this.uuid, a.type = this.type, this.name !== "" && (a.name = this.name), this.castShadow === !0 && (a.castShadow = !0), this.receiveShadow === !0 && (a.receiveShadow = !0), this.visible === !1 && (a.visible = !1), this.frustumCulled === !1 && (a.frustumCulled = !1), this.renderOrder !== 0 && (a.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (a.userData = this.userData), a.layers = this.layers.mask, a.matrix = this.matrix.toArray(), a.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (a.matrixAutoUpdate = !1), this.isInstancedMesh && (a.type = "InstancedMesh", a.count = this.count, a.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (a.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (a.type = "BatchedMesh", a.perObjectFrustumCulled = this.perObjectFrustumCulled, a.sortObjects = this.sortObjects, a.drawRanges = this._drawRanges, a.reservedRanges = this._reservedRanges, a.geometryInfo = this._geometryInfo.map(c => ({ ...c, boundingBox: c.boundingBox ? c.boundingBox.toJSON() : void 0, boundingSphere: c.boundingSphere ? c.boundingSphere.toJSON() : void 0 })), a.instanceInfo = this._instanceInfo.map(c => ({ ...c })), a.availableInstanceIds = this._availableInstanceIds.slice(), a.availableGeometryIds = this._availableGeometryIds.slice(), a.nextIndexStart = this._nextIndexStart, a.nextVertexStart = this._nextVertexStart, a.geometryCount = this._geometryCount, a.maxInstanceCount = this._maxInstanceCount, a.maxVertexCount = this._maxVertexCount, a.maxIndexCount = this._maxIndexCount, a.geometryInitialized = this._geometryInitialized, a.matricesTexture = this._matricesTexture.toJSON(e), a.indirectTexture = this._indirectTexture.toJSON(e), this._colorsTexture !== null && (a.colorsTexture = this._colorsTexture.toJSON(e)), this.boundingSphere !== null && (a.boundingSphere = this.boundingSphere.toJSON()), this.boundingBox !== null && (a.boundingBox = this.boundingBox.toJSON())); function o(c, h) { return c[h.uuid] === void 0 && (c[h.uuid] = h.toJSON(e)), h.uuid } if (this.isScene) this.background && (this.background.isColor ? a.background = this.background.toJSON() : this.background.isTexture && (a.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (a.environment = this.environment.toJSON(e).uuid); else if (this.isMesh || this.isLine || this.isPoints) { a.geometry = o(e.geometries, this.geometry); const c = this.geometry.parameters; if (c !== void 0 && c.shapes !== void 0) { const h = c.shapes; if (Array.isArray(h)) for (let d = 0, p = h.length; d < p; d++) { const f = h[d]; o(e.shapes, f) } else o(e.shapes, h) } } if (this.isSkinnedMesh && (a.bindMode = this.bindMode, a.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (o(e.skeletons, this.skeleton), a.skeleton = this.skeleton.uuid)), this.material !== void 0) if (Array.isArray(this.material)) { const c = []; for (let h = 0, d = this.material.length; h < d; h++)c.push(o(e.materials, this.material[h])); a.material = c } else a.material = o(e.materials, this.material); if (this.children.length > 0) { a.children = []; for (let c = 0; c < this.children.length; c++)a.children.push(this.children[c].toJSON(e).object) } if (this.animations.length > 0) { a.animations = []; for (let c = 0; c < this.animations.length; c++) { const h = this.animations[c]; a.animations.push(o(e.animations, h)) } } if (i) { const c = l(e.geometries), h = l(e.materials), d = l(e.textures), p = l(e.images), f = l(e.shapes), _ = l(e.skeletons), x = l(e.animations), b = l(e.nodes); c.length > 0 && (s.geometries = c), h.length > 0 && (s.materials = h), d.length > 0 && (s.textures = d), p.length > 0 && (s.images = p), f.length > 0 && (s.shapes = f), _.length > 0 && (s.skeletons = _), x.length > 0 && (s.animations = x), b.length > 0 && (s.nodes = b) } return s.object = a, s; function l(c) { const h = []; for (const d in c) { const p = c[d]; delete p.metadata, h.push(p) } return h } } clone(e) { return new this.constructor().copy(this, e) } copy(e, i = !0) { if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), i === !0) for (let s = 0; s < e.children.length; s++) { const a = e.children[s]; this.add(a.clone()) } return this } } Object3D.DEFAULT_UP = new Vector3(0, 1, 0); Object3D.DEFAULT_MATRIX_AUTO_UPDATE = !0; Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0; const _v0$1$1 = new Vector3, _v1$3$1 = new Vector3, _v2$2$1 = new Vector3, _v3$2 = new Vector3, _vab = new Vector3, _vac = new Vector3, _vbc = new Vector3, _vap = new Vector3, _vbp = new Vector3, _vcp = new Vector3, _v40 = new Vector4, _v41 = new Vector4, _v42 = new Vector4; class Triangle { constructor(e = new Vector3, i = new Vector3, s = new Vector3) { this.a = e, this.b = i, this.c = s } static getNormal(e, i, s, a) { a.subVectors(s, i), _v0$1$1.subVectors(e, i), a.cross(_v0$1$1); const o = a.lengthSq(); return o > 0 ? a.multiplyScalar(1 / Math.sqrt(o)) : a.set(0, 0, 0) } static getBarycoord(e, i, s, a, o) { _v0$1$1.subVectors(a, i), _v1$3$1.subVectors(s, i), _v2$2$1.subVectors(e, i); const l = _v0$1$1.dot(_v0$1$1), c = _v0$1$1.dot(_v1$3$1), h = _v0$1$1.dot(_v2$2$1), d = _v1$3$1.dot(_v1$3$1), p = _v1$3$1.dot(_v2$2$1), f = l * d - c * c; if (f === 0) return o.set(0, 0, 0), null; const _ = 1 / f, x = (d * h - c * p) * _, b = (l * p - c * h) * _; return o.set(1 - x - b, b, x) } static containsPoint(e, i, s, a) { return this.getBarycoord(e, i, s, a, _v3$2) === null ? !1 : _v3$2.x >= 0 && _v3$2.y >= 0 && _v3$2.x + _v3$2.y <= 1 } static getInterpolation(e, i, s, a, o, l, c, h) { return this.getBarycoord(e, i, s, a, _v3$2) === null ? (h.x = 0, h.y = 0, "z" in h && (h.z = 0), "w" in h && (h.w = 0), null) : (h.setScalar(0), h.addScaledVector(o, _v3$2.x), h.addScaledVector(l, _v3$2.y), h.addScaledVector(c, _v3$2.z), h) } static getInterpolatedAttribute(e, i, s, a, o, l) { return _v40.setScalar(0), _v41.setScalar(0), _v42.setScalar(0), _v40.fromBufferAttribute(e, i), _v41.fromBufferAttribute(e, s), _v42.fromBufferAttribute(e, a), l.setScalar(0), l.addScaledVector(_v40, o.x), l.addScaledVector(_v41, o.y), l.addScaledVector(_v42, o.z), l } static isFrontFacing(e, i, s, a) { return _v0$1$1.subVectors(s, i), _v1$3$1.subVectors(e, i), _v0$1$1.cross(_v1$3$1).dot(a) < 0 } set(e, i, s) { return this.a.copy(e), this.b.copy(i), this.c.copy(s), this } setFromPointsAndIndices(e, i, s, a) { return this.a.copy(e[i]), this.b.copy(e[s]), this.c.copy(e[a]), this } setFromAttributeAndIndices(e, i, s, a) { return this.a.fromBufferAttribute(e, i), this.b.fromBufferAttribute(e, s), this.c.fromBufferAttribute(e, a), this } clone() { return new this.constructor().copy(this) } copy(e) { return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this } getArea() { return _v0$1$1.subVectors(this.c, this.b), _v1$3$1.subVectors(this.a, this.b), _v0$1$1.cross(_v1$3$1).length() * .5 } getMidpoint(e) { return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3) } getNormal(e) { return Triangle.getNormal(this.a, this.b, this.c, e) } getPlane(e) { return e.setFromCoplanarPoints(this.a, this.b, this.c) } getBarycoord(e, i) { return Triangle.getBarycoord(e, this.a, this.b, this.c, i) } getInterpolation(e, i, s, a, o) { return Triangle.getInterpolation(e, this.a, this.b, this.c, i, s, a, o) } containsPoint(e) { return Triangle.containsPoint(e, this.a, this.b, this.c) } isFrontFacing(e) { return Triangle.isFrontFacing(this.a, this.b, this.c, e) } intersectsBox(e) { return e.intersectsTriangle(this) } closestPointToPoint(e, i) { const s = this.a, a = this.b, o = this.c; let l, c; _vab.subVectors(a, s), _vac.subVectors(o, s), _vap.subVectors(e, s); const h = _vab.dot(_vap), d = _vac.dot(_vap); if (h <= 0 && d <= 0) return i.copy(s); _vbp.subVectors(e, a); const p = _vab.dot(_vbp), f = _vac.dot(_vbp); if (p >= 0 && f <= p) return i.copy(a); const _ = h * f - p * d; if (_ <= 0 && h >= 0 && p <= 0) return l = h / (h - p), i.copy(s).addScaledVector(_vab, l); _vcp.subVectors(e, o); const x = _vab.dot(_vcp), b = _vac.dot(_vcp); if (b >= 0 && x <= b) return i.copy(o); const T = x * d - h * b; if (T <= 0 && d >= 0 && b <= 0) return c = d / (d - b), i.copy(s).addScaledVector(_vac, c); const M = p * b - x * f; if (M <= 0 && f - p >= 0 && x - b >= 0) return _vbc.subVectors(o, a), c = (f - p) / (f - p + (x - b)), i.copy(a).addScaledVector(_vbc, c); const w = 1 / (M + T + _); return l = T * w, c = _ * w, i.copy(s).addScaledVector(_vab, l).addScaledVector(_vac, c) } equals(e) { return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c) } } const _colorKeywords = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, _hslA = { h: 0, s: 0, l: 0 }, _hslB = { h: 0, s: 0, l: 0 }; function hue2rgb(r, e, i) { return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? r + (e - r) * 6 * i : i < 1 / 2 ? e : i < 2 / 3 ? r + (e - r) * 6 * (2 / 3 - i) : r } class Color { constructor(e, i, s) { return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, i, s) } set(e, i, s) { if (i === void 0 && s === void 0) { const a = e; a && a.isColor ? this.copy(a) : typeof a == "number" ? this.setHex(a) : typeof a == "string" && this.setStyle(a) } else this.setRGB(e, i, s); return this } setScalar(e) { return this.r = e, this.g = e, this.b = e, this } setHex(e, i = SRGBColorSpace) { return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, ColorManagement.colorSpaceToWorking(this, i), this } setRGB(e, i, s, a = ColorManagement.workingColorSpace) { return this.r = e, this.g = i, this.b = s, ColorManagement.colorSpaceToWorking(this, a), this } setHSL(e, i, s, a = ColorManagement.workingColorSpace) { if (e = euclideanModulo(e, 1), i = clamp(i, 0, 1), s = clamp(s, 0, 1), i === 0) this.r = this.g = this.b = s; else { const o = s <= .5 ? s * (1 + i) : s + i - s * i, l = 2 * s - o; this.r = hue2rgb(l, o, e + 1 / 3), this.g = hue2rgb(l, o, e), this.b = hue2rgb(l, o, e - 1 / 3) } return ColorManagement.colorSpaceToWorking(this, a), this } setStyle(e, i = SRGBColorSpace) { function s(o) { o !== void 0 && parseFloat(o) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.") } let a; if (a = /^(\w+)\(([^\)]*)\)/.exec(e)) { let o; const l = a[1], c = a[2]; switch (l) { case "rgb": case "rgba": if (o = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(c)) return s(o[4]), this.setRGB(Math.min(255, parseInt(o[1], 10)) / 255, Math.min(255, parseInt(o[2], 10)) / 255, Math.min(255, parseInt(o[3], 10)) / 255, i); if (o = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(c)) return s(o[4]), this.setRGB(Math.min(100, parseInt(o[1], 10)) / 100, Math.min(100, parseInt(o[2], 10)) / 100, Math.min(100, parseInt(o[3], 10)) / 100, i); break; case "hsl": case "hsla": if (o = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(c)) return s(o[4]), this.setHSL(parseFloat(o[1]) / 360, parseFloat(o[2]) / 100, parseFloat(o[3]) / 100, i); break; default: console.warn("THREE.Color: Unknown color model " + e) } } else if (a = /^\#([A-Fa-f\d]+)$/.exec(e)) { const o = a[1], l = o.length; if (l === 3) return this.setRGB(parseInt(o.charAt(0), 16) / 15, parseInt(o.charAt(1), 16) / 15, parseInt(o.charAt(2), 16) / 15, i); if (l === 6) return this.setHex(parseInt(o, 16), i); console.warn("THREE.Color: Invalid hex color " + e) } else if (e && e.length > 0) return this.setColorName(e, i); return this } setColorName(e, i = SRGBColorSpace) { const s = _colorKeywords[e.toLowerCase()]; return s !== void 0 ? this.setHex(s, i) : console.warn("THREE.Color: Unknown color " + e), this } clone() { return new this.constructor(this.r, this.g, this.b) } copy(e) { return this.r = e.r, this.g = e.g, this.b = e.b, this } copySRGBToLinear(e) { return this.r = SRGBToLinear(e.r), this.g = SRGBToLinear(e.g), this.b = SRGBToLinear(e.b), this } copyLinearToSRGB(e) { return this.r = LinearToSRGB(e.r), this.g = LinearToSRGB(e.g), this.b = LinearToSRGB(e.b), this } convertSRGBToLinear() { return this.copySRGBToLinear(this), this } convertLinearToSRGB() { return this.copyLinearToSRGB(this), this } getHex(e = SRGBColorSpace) { return ColorManagement.workingToColorSpace(_color.copy(this), e), Math.round(clamp(_color.r * 255, 0, 255)) * 65536 + Math.round(clamp(_color.g * 255, 0, 255)) * 256 + Math.round(clamp(_color.b * 255, 0, 255)) } getHexString(e = SRGBColorSpace) { return ("000000" + this.getHex(e).toString(16)).slice(-6) } getHSL(e, i = ColorManagement.workingColorSpace) { ColorManagement.workingToColorSpace(_color.copy(this), i); const s = _color.r, a = _color.g, o = _color.b, l = Math.max(s, a, o), c = Math.min(s, a, o); let h, d; const p = (c + l) / 2; if (c === l) h = 0, d = 0; else { const f = l - c; switch (d = p <= .5 ? f / (l + c) : f / (2 - l - c), l) { case s: h = (a - o) / f + (a < o ? 6 : 0); break; case a: h = (o - s) / f + 2; break; case o: h = (s - a) / f + 4; break }h /= 6 } return e.h = h, e.s = d, e.l = p, e } getRGB(e, i = ColorManagement.workingColorSpace) { return ColorManagement.workingToColorSpace(_color.copy(this), i), e.r = _color.r, e.g = _color.g, e.b = _color.b, e } getStyle(e = SRGBColorSpace) { ColorManagement.workingToColorSpace(_color.copy(this), e); const i = _color.r, s = _color.g, a = _color.b; return e !== SRGBColorSpace ? `color(${e} ${i.toFixed(3)} ${s.toFixed(3)} ${a.toFixed(3)})` : `rgb(${Math.round(i * 255)},${Math.round(s * 255)},${Math.round(a * 255)})` } offsetHSL(e, i, s) { return this.getHSL(_hslA), this.setHSL(_hslA.h + e, _hslA.s + i, _hslA.l + s) } add(e) { return this.r += e.r, this.g += e.g, this.b += e.b, this } addColors(e, i) { return this.r = e.r + i.r, this.g = e.g + i.g, this.b = e.b + i.b, this } addScalar(e) { return this.r += e, this.g += e, this.b += e, this } sub(e) { return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this } multiply(e) { return this.r *= e.r, this.g *= e.g, this.b *= e.b, this } multiplyScalar(e) { return this.r *= e, this.g *= e, this.b *= e, this } lerp(e, i) { return this.r += (e.r - this.r) * i, this.g += (e.g - this.g) * i, this.b += (e.b - this.b) * i, this } lerpColors(e, i, s) { return this.r = e.r + (i.r - e.r) * s, this.g = e.g + (i.g - e.g) * s, this.b = e.b + (i.b - e.b) * s, this } lerpHSL(e, i) { this.getHSL(_hslA), e.getHSL(_hslB); const s = lerp(_hslA.h, _hslB.h, i), a = lerp(_hslA.s, _hslB.s, i), o = lerp(_hslA.l, _hslB.l, i); return this.setHSL(s, a, o), this } setFromVector3(e) { return this.r = e.x, this.g = e.y, this.b = e.z, this } applyMatrix3(e) { const i = this.r, s = this.g, a = this.b, o = e.elements; return this.r = o[0] * i + o[3] * s + o[6] * a, this.g = o[1] * i + o[4] * s + o[7] * a, this.b = o[2] * i + o[5] * s + o[8] * a, this } equals(e) { return e.r === this.r && e.g === this.g && e.b === this.b } fromArray(e, i = 0) { return this.r = e[i], this.g = e[i + 1], this.b = e[i + 2], this } toArray(e = [], i = 0) { return e[i] = this.r, e[i + 1] = this.g, e[i + 2] = this.b, e } fromBufferAttribute(e, i) { return this.r = e.getX(i), this.g = e.getY(i), this.b = e.getZ(i), this } toJSON() { return this.getHex() } *[Symbol.iterator]() { yield this.r, yield this.g, yield this.b } } const _color = new Color; Color.NAMES = _colorKeywords; let _materialId = 0; class Material extends EventDispatcher { constructor() { super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: _materialId++ }), this.uuid = generateUUID(), this.name = "", this.type = "Material", this.blending = NormalBlending, this.side = FrontSide, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = SrcAlphaFactor, this.blendDst = OneMinusSrcAlphaFactor, this.blendEquation = AddEquation, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new Color(0, 0, 0), this.blendAlpha = 0, this.depthFunc = LessEqualDepth, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = AlwaysStencilFunc, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = KeepStencilOp, this.stencilZFail = KeepStencilOp, this.stencilZPass = KeepStencilOp, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.allowOverride = !0, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0 } get alphaTest() { return this._alphaTest } set alphaTest(e) { this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e } onBeforeRender() { } onBeforeCompile() { } customProgramCacheKey() { return this.onBeforeCompile.toString() } setValues(e) { if (e !== void 0) for (const i in e) { const s = e[i]; if (s === void 0) { console.warn(`THREE.Material: parameter '${i}' has value of undefined.`); continue } const a = this[i]; if (a === void 0) { console.warn(`THREE.Material: '${i}' is not a property of THREE.${this.type}.`); continue } a && a.isColor ? a.set(s) : a && a.isVector3 && s && s.isVector3 ? a.copy(s) : this[i] = s } } toJSON(e) { const i = e === void 0 || typeof e == "string"; i && (e = { textures: {}, images: {} }); const s = { metadata: { version: 4.7, type: "Material", generator: "Material.toJSON" } }; s.uuid = this.uuid, s.type = this.type, this.name !== "" && (s.name = this.name), this.color && this.color.isColor && (s.color = this.color.getHex()), this.roughness !== void 0 && (s.roughness = this.roughness), this.metalness !== void 0 && (s.metalness = this.metalness), this.sheen !== void 0 && (s.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (s.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (s.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (s.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (s.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (s.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (s.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (s.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (s.shininess = this.shininess), this.clearcoat !== void 0 && (s.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (s.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (s.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (s.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (s.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, s.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.sheenColorMap && this.sheenColorMap.isTexture && (s.sheenColorMap = this.sheenColorMap.toJSON(e).uuid), this.sheenRoughnessMap && this.sheenRoughnessMap.isTexture && (s.sheenRoughnessMap = this.sheenRoughnessMap.toJSON(e).uuid), this.dispersion !== void 0 && (s.dispersion = this.dispersion), this.iridescence !== void 0 && (s.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (s.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (s.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (s.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (s.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (s.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (s.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (s.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (s.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (s.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (s.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (s.lightMap = this.lightMap.toJSON(e).uuid, s.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (s.aoMap = this.aoMap.toJSON(e).uuid, s.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (s.bumpMap = this.bumpMap.toJSON(e).uuid, s.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (s.normalMap = this.normalMap.toJSON(e).uuid, s.normalMapType = this.normalMapType, s.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (s.displacementMap = this.displacementMap.toJSON(e).uuid, s.displacementScale = this.displacementScale, s.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (s.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (s.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (s.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (s.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (s.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (s.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (s.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (s.combine = this.combine)), this.envMapRotation !== void 0 && (s.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (s.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (s.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (s.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (s.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (s.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (s.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (s.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (s.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (s.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (s.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (s.size = this.size), this.shadowSide !== null && (s.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (s.sizeAttenuation = this.sizeAttenuation), this.blending !== NormalBlending && (s.blending = this.blending), this.side !== FrontSide && (s.side = this.side), this.vertexColors === !0 && (s.vertexColors = !0), this.opacity < 1 && (s.opacity = this.opacity), this.transparent === !0 && (s.transparent = !0), this.blendSrc !== SrcAlphaFactor && (s.blendSrc = this.blendSrc), this.blendDst !== OneMinusSrcAlphaFactor && (s.blendDst = this.blendDst), this.blendEquation !== AddEquation && (s.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (s.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (s.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (s.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (s.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (s.blendAlpha = this.blendAlpha), this.depthFunc !== LessEqualDepth && (s.depthFunc = this.depthFunc), this.depthTest === !1 && (s.depthTest = this.depthTest), this.depthWrite === !1 && (s.depthWrite = this.depthWrite), this.colorWrite === !1 && (s.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (s.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== AlwaysStencilFunc && (s.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (s.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (s.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== KeepStencilOp && (s.stencilFail = this.stencilFail), this.stencilZFail !== KeepStencilOp && (s.stencilZFail = this.stencilZFail), this.stencilZPass !== KeepStencilOp && (s.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (s.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (s.rotation = this.rotation), this.polygonOffset === !0 && (s.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (s.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (s.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (s.linewidth = this.linewidth), this.dashSize !== void 0 && (s.dashSize = this.dashSize), this.gapSize !== void 0 && (s.gapSize = this.gapSize), this.scale !== void 0 && (s.scale = this.scale), this.dithering === !0 && (s.dithering = !0), this.alphaTest > 0 && (s.alphaTest = this.alphaTest), this.alphaHash === !0 && (s.alphaHash = !0), this.alphaToCoverage === !0 && (s.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (s.premultipliedAlpha = !0), this.forceSinglePass === !0 && (s.forceSinglePass = !0), this.wireframe === !0 && (s.wireframe = !0), this.wireframeLinewidth > 1 && (s.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (s.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (s.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (s.flatShading = !0), this.visible === !1 && (s.visible = !1), this.toneMapped === !1 && (s.toneMapped = !1), this.fog === !1 && (s.fog = !1), Object.keys(this.userData).length > 0 && (s.userData = this.userData); function a(o) { const l = []; for (const c in o) { const h = o[c]; delete h.metadata, l.push(h) } return l } if (i) { const o = a(e.textures), l = a(e.images); o.length > 0 && (s.textures = o), l.length > 0 && (s.images = l) } return s } clone() { return new this.constructor().copy(this) } copy(e) { this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite; const i = e.clippingPlanes; let s = null; if (i !== null) { const a = i.length; s = new Array(a); for (let o = 0; o !== a; ++o)s[o] = i[o].clone() } return this.clippingPlanes = s, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this } dispose() { this.dispatchEvent({ type: "dispose" }) } set needsUpdate(e) { e === !0 && this.version++ } } class MeshBasicMaterial extends Material { constructor(e) { super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new Color(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Euler, this.combine = MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this } } const _vector$9 = new Vector3, _vector2$1 = new Vector2; let _id$2 = 0; class BufferAttribute { constructor(e, i, s = !1) { if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); this.isBufferAttribute = !0, Object.defineProperty(this, "id", { value: _id$2++ }), this.name = "", this.array = e, this.itemSize = i, this.count = e !== void 0 ? e.length / i : 0, this.normalized = s, this.usage = StaticDrawUsage, this.updateRanges = [], this.gpuType = FloatType, this.version = 0 } onUploadCallback() { } set needsUpdate(e) { e === !0 && this.version++ } setUsage(e) { return this.usage = e, this } addUpdateRange(e, i) { this.updateRanges.push({ start: e, count: i }) } clearUpdateRanges() { this.updateRanges.length = 0 } copy(e) { return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this } copyAt(e, i, s) { e *= this.itemSize, s *= i.itemSize; for (let a = 0, o = this.itemSize; a < o; a++)this.array[e + a] = i.array[s + a]; return this } copyArray(e) { return this.array.set(e), this } applyMatrix3(e) { if (this.itemSize === 2) for (let i = 0, s = this.count; i < s; i++)_vector2$1.fromBufferAttribute(this, i), _vector2$1.applyMatrix3(e), this.setXY(i, _vector2$1.x, _vector2$1.y); else if (this.itemSize === 3) for (let i = 0, s = this.count; i < s; i++)_vector$9.fromBufferAttribute(this, i), _vector$9.applyMatrix3(e), this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z); return this } applyMatrix4(e) { for (let i = 0, s = this.count; i < s; i++)_vector$9.fromBufferAttribute(this, i), _vector$9.applyMatrix4(e), this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z); return this } applyNormalMatrix(e) { for (let i = 0, s = this.count; i < s; i++)_vector$9.fromBufferAttribute(this, i), _vector$9.applyNormalMatrix(e), this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z); return this } transformDirection(e) { for (let i = 0, s = this.count; i < s; i++)_vector$9.fromBufferAttribute(this, i), _vector$9.transformDirection(e), this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z); return this } set(e, i = 0) { return this.array.set(e, i), this } getComponent(e, i) { let s = this.array[e * this.itemSize + i]; return this.normalized && (s = denormalize(s, this.array)), s } setComponent(e, i, s) { return this.normalized && (s = normalize(s, this.array)), this.array[e * this.itemSize + i] = s, this } getX(e) { let i = this.array[e * this.itemSize]; return this.normalized && (i = denormalize(i, this.array)), i } setX(e, i) { return this.normalized && (i = normalize(i, this.array)), this.array[e * this.itemSize] = i, this } getY(e) { let i = this.array[e * this.itemSize + 1]; return this.normalized && (i = denormalize(i, this.array)), i } setY(e, i) { return this.normalized && (i = normalize(i, this.array)), this.array[e * this.itemSize + 1] = i, this } getZ(e) { let i = this.array[e * this.itemSize + 2]; return this.normalized && (i = denormalize(i, this.array)), i } setZ(e, i) { return this.normalized && (i = normalize(i, this.array)), this.array[e * this.itemSize + 2] = i, this } getW(e) { let i = this.array[e * this.itemSize + 3]; return this.normalized && (i = denormalize(i, this.array)), i } setW(e, i) { return this.normalized && (i = normalize(i, this.array)), this.array[e * this.itemSize + 3] = i, this } setXY(e, i, s) { return e *= this.itemSize, this.normalized && (i = normalize(i, this.array), s = normalize(s, this.array)), this.array[e + 0] = i, this.array[e + 1] = s, this } setXYZ(e, i, s, a) { return e *= this.itemSize, this.normalized && (i = normalize(i, this.array), s = normalize(s, this.array), a = normalize(a, this.array)), this.array[e + 0] = i, this.array[e + 1] = s, this.array[e + 2] = a, this } setXYZW(e, i, s, a, o) { return e *= this.itemSize, this.normalized && (i = normalize(i, this.array), s = normalize(s, this.array), a = normalize(a, this.array), o = normalize(o, this.array)), this.array[e + 0] = i, this.array[e + 1] = s, this.array[e + 2] = a, this.array[e + 3] = o, this } onUpload(e) { return this.onUploadCallback = e, this } clone() { return new this.constructor(this.array, this.itemSize).copy(this) } toJSON() { const e = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.from(this.array), normalized: this.normalized }; return this.name !== "" && (e.name = this.name), this.usage !== StaticDrawUsage && (e.usage = this.usage), e } } class Uint16BufferAttribute extends BufferAttribute { constructor(e, i, s) { super(new Uint16Array(e), i, s) } } class Uint32BufferAttribute extends BufferAttribute { constructor(e, i, s) { super(new Uint32Array(e), i, s) } } class Float32BufferAttribute extends BufferAttribute { constructor(e, i, s) { super(new Float32Array(e), i, s) } } let _id$1 = 0; const _m1$3 = new Matrix4, _obj$2 = new Object3D, _offset = new Vector3, _box$2 = new Box3, _boxMorphTargets = new Box3, _vector$8 = new Vector3; class BufferGeometry extends EventDispatcher { constructor() { super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: _id$1++ }), this.uuid = generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.indirect = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {} } getIndex() { return this.index } setIndex(e) { return Array.isArray(e) ? this.index = new (arrayNeedsUint32(e) ? Uint32BufferAttribute : Uint16BufferAttribute)(e, 1) : this.index = e, this } setIndirect(e) { return this.indirect = e, this } getIndirect() { return this.indirect } getAttribute(e) { return this.attributes[e] } setAttribute(e, i) { return this.attributes[e] = i, this } deleteAttribute(e) { return delete this.attributes[e], this } hasAttribute(e) { return this.attributes[e] !== void 0 } addGroup(e, i, s = 0) { this.groups.push({ start: e, count: i, materialIndex: s }) } clearGroups() { this.groups = [] } setDrawRange(e, i) { this.drawRange.start = e, this.drawRange.count = i } applyMatrix4(e) { const i = this.attributes.position; i !== void 0 && (i.applyMatrix4(e), i.needsUpdate = !0); const s = this.attributes.normal; if (s !== void 0) { const o = new Matrix3().getNormalMatrix(e); s.applyNormalMatrix(o), s.needsUpdate = !0 } const a = this.attributes.tangent; return a !== void 0 && (a.transformDirection(e), a.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this } applyQuaternion(e) { return _m1$3.makeRotationFromQuaternion(e), this.applyMatrix4(_m1$3), this } rotateX(e) { return _m1$3.makeRotationX(e), this.applyMatrix4(_m1$3), this } rotateY(e) { return _m1$3.makeRotationY(e), this.applyMatrix4(_m1$3), this } rotateZ(e) { return _m1$3.makeRotationZ(e), this.applyMatrix4(_m1$3), this } translate(e, i, s) { return _m1$3.makeTranslation(e, i, s), this.applyMatrix4(_m1$3), this } scale(e, i, s) { return _m1$3.makeScale(e, i, s), this.applyMatrix4(_m1$3), this } lookAt(e) { return _obj$2.lookAt(e), _obj$2.updateMatrix(), this.applyMatrix4(_obj$2.matrix), this } center() { return this.computeBoundingBox(), this.boundingBox.getCenter(_offset).negate(), this.translate(_offset.x, _offset.y, _offset.z), this } setFromPoints(e) { const i = this.getAttribute("position"); if (i === void 0) { const s = []; for (let a = 0, o = e.length; a < o; a++) { const l = e[a]; s.push(l.x, l.y, l.z || 0) } this.setAttribute("position", new Float32BufferAttribute(s, 3)) } else { const s = Math.min(e.length, i.count); for (let a = 0; a < s; a++) { const o = e[a]; i.setXYZ(a, o.x, o.y, o.z || 0) } e.length > i.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."), i.needsUpdate = !0 } return this } computeBoundingBox() { this.boundingBox === null && (this.boundingBox = new Box3); const e = this.attributes.position, i = this.morphAttributes.position; if (e && e.isGLBufferAttribute) { console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(new Vector3(-1 / 0, -1 / 0, -1 / 0), new Vector3(1 / 0, 1 / 0, 1 / 0)); return } if (e !== void 0) { if (this.boundingBox.setFromBufferAttribute(e), i) for (let s = 0, a = i.length; s < a; s++) { const o = i[s]; _box$2.setFromBufferAttribute(o), this.morphTargetsRelative ? (_vector$8.addVectors(this.boundingBox.min, _box$2.min), this.boundingBox.expandByPoint(_vector$8), _vector$8.addVectors(this.boundingBox.max, _box$2.max), this.boundingBox.expandByPoint(_vector$8)) : (this.boundingBox.expandByPoint(_box$2.min), this.boundingBox.expandByPoint(_box$2.max)) } } else this.boundingBox.makeEmpty(); (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this) } computeBoundingSphere() { this.boundingSphere === null && (this.boundingSphere = new Sphere); const e = this.attributes.position, i = this.morphAttributes.position; if (e && e.isGLBufferAttribute) { console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new Vector3, 1 / 0); return } if (e) { const s = this.boundingSphere.center; if (_box$2.setFromBufferAttribute(e), i) for (let o = 0, l = i.length; o < l; o++) { const c = i[o]; _boxMorphTargets.setFromBufferAttribute(c), this.morphTargetsRelative ? (_vector$8.addVectors(_box$2.min, _boxMorphTargets.min), _box$2.expandByPoint(_vector$8), _vector$8.addVectors(_box$2.max, _boxMorphTargets.max), _box$2.expandByPoint(_vector$8)) : (_box$2.expandByPoint(_boxMorphTargets.min), _box$2.expandByPoint(_boxMorphTargets.max)) } _box$2.getCenter(s); let a = 0; for (let o = 0, l = e.count; o < l; o++)_vector$8.fromBufferAttribute(e, o), a = Math.max(a, s.distanceToSquared(_vector$8)); if (i) for (let o = 0, l = i.length; o < l; o++) { const c = i[o], h = this.morphTargetsRelative; for (let d = 0, p = c.count; d < p; d++)_vector$8.fromBufferAttribute(c, d), h && (_offset.fromBufferAttribute(e, d), _vector$8.add(_offset)), a = Math.max(a, s.distanceToSquared(_vector$8)) } this.boundingSphere.radius = Math.sqrt(a), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this) } } computeTangents() { const e = this.index, i = this.attributes; if (e === null || i.position === void 0 || i.normal === void 0 || i.uv === void 0) { console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"); return } const s = i.position, a = i.normal, o = i.uv; this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * s.count), 4)); const l = this.getAttribute("tangent"), c = [], h = []; for (let H = 0; H < s.count; H++)c[H] = new Vector3, h[H] = new Vector3; const d = new Vector3, p = new Vector3, f = new Vector3, _ = new Vector2, x = new Vector2, b = new Vector2, T = new Vector3, M = new Vector3; function w(H, F, k) { d.fromBufferAttribute(s, H), p.fromBufferAttribute(s, F), f.fromBufferAttribute(s, k), _.fromBufferAttribute(o, H), x.fromBufferAttribute(o, F), b.fromBufferAttribute(o, k), p.sub(d), f.sub(d), x.sub(_), b.sub(_); const W = 1 / (x.x * b.y - b.x * x.y); isFinite(W) && (T.copy(p).multiplyScalar(b.y).addScaledVector(f, -x.y).multiplyScalar(W), M.copy(f).multiplyScalar(x.x).addScaledVector(p, -b.x).multiplyScalar(W), c[H].add(T), c[F].add(T), c[k].add(T), h[H].add(M), h[F].add(M), h[k].add(M)) } let D = this.groups; D.length === 0 && (D = [{ start: 0, count: e.count }]); for (let H = 0, F = D.length; H < F; ++H) { const k = D[H], W = k.start, $ = k.count; for (let Z = W, J = W + $; Z < J; Z += 3)w(e.getX(Z + 0), e.getX(Z + 1), e.getX(Z + 2)) } const R = new Vector3, P = new Vector3, U = new Vector3, O = new Vector3; function N(H) { U.fromBufferAttribute(a, H), O.copy(U); const F = c[H]; R.copy(F), R.sub(U.multiplyScalar(U.dot(F))).normalize(), P.crossVectors(O, F); const W = P.dot(h[H]) < 0 ? -1 : 1; l.setXYZW(H, R.x, R.y, R.z, W) } for (let H = 0, F = D.length; H < F; ++H) { const k = D[H], W = k.start, $ = k.count; for (let Z = W, J = W + $; Z < J; Z += 3)N(e.getX(Z + 0)), N(e.getX(Z + 1)), N(e.getX(Z + 2)) } } computeVertexNormals() { const e = this.index, i = this.getAttribute("position"); if (i !== void 0) { let s = this.getAttribute("normal"); if (s === void 0) s = new BufferAttribute(new Float32Array(i.count * 3), 3), this.setAttribute("normal", s); else for (let _ = 0, x = s.count; _ < x; _++)s.setXYZ(_, 0, 0, 0); const a = new Vector3, o = new Vector3, l = new Vector3, c = new Vector3, h = new Vector3, d = new Vector3, p = new Vector3, f = new Vector3; if (e) for (let _ = 0, x = e.count; _ < x; _ += 3) { const b = e.getX(_ + 0), T = e.getX(_ + 1), M = e.getX(_ + 2); a.fromBufferAttribute(i, b), o.fromBufferAttribute(i, T), l.fromBufferAttribute(i, M), p.subVectors(l, o), f.subVectors(a, o), p.cross(f), c.fromBufferAttribute(s, b), h.fromBufferAttribute(s, T), d.fromBufferAttribute(s, M), c.add(p), h.add(p), d.add(p), s.setXYZ(b, c.x, c.y, c.z), s.setXYZ(T, h.x, h.y, h.z), s.setXYZ(M, d.x, d.y, d.z) } else for (let _ = 0, x = i.count; _ < x; _ += 3)a.fromBufferAttribute(i, _ + 0), o.fromBufferAttribute(i, _ + 1), l.fromBufferAttribute(i, _ + 2), p.subVectors(l, o), f.subVectors(a, o), p.cross(f), s.setXYZ(_ + 0, p.x, p.y, p.z), s.setXYZ(_ + 1, p.x, p.y, p.z), s.setXYZ(_ + 2, p.x, p.y, p.z); this.normalizeNormals(), s.needsUpdate = !0 } } normalizeNormals() { const e = this.attributes.normal; for (let i = 0, s = e.count; i < s; i++)_vector$8.fromBufferAttribute(e, i), _vector$8.normalize(), e.setXYZ(i, _vector$8.x, _vector$8.y, _vector$8.z) } toNonIndexed() { function e(c, h) { const d = c.array, p = c.itemSize, f = c.normalized, _ = new d.constructor(h.length * p); let x = 0, b = 0; for (let T = 0, M = h.length; T < M; T++) { c.isInterleavedBufferAttribute ? x = h[T] * c.data.stride + c.offset : x = h[T] * p; for (let w = 0; w < p; w++)_[b++] = d[x++] } return new BufferAttribute(_, p, f) } if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this; const i = new BufferGeometry, s = this.index.array, a = this.attributes; for (const c in a) { const h = a[c], d = e(h, s); i.setAttribute(c, d) } const o = this.morphAttributes; for (const c in o) { const h = [], d = o[c]; for (let p = 0, f = d.length; p < f; p++) { const _ = d[p], x = e(_, s); h.push(x) } i.morphAttributes[c] = h } i.morphTargetsRelative = this.morphTargetsRelative; const l = this.groups; for (let c = 0, h = l.length; c < h; c++) { const d = l[c]; i.addGroup(d.start, d.count, d.materialIndex) } return i } toJSON() { const e = { metadata: { version: 4.7, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } }; if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) { const h = this.parameters; for (const d in h) h[d] !== void 0 && (e[d] = h[d]); return e } e.data = { attributes: {} }; const i = this.index; i !== null && (e.data.index = { type: i.array.constructor.name, array: Array.prototype.slice.call(i.array) }); const s = this.attributes; for (const h in s) { const d = s[h]; e.data.attributes[h] = d.toJSON(e.data) } const a = {}; let o = !1; for (const h in this.morphAttributes) { const d = this.morphAttributes[h], p = []; for (let f = 0, _ = d.length; f < _; f++) { const x = d[f]; p.push(x.toJSON(e.data)) } p.length > 0 && (a[h] = p, o = !0) } o && (e.data.morphAttributes = a, e.data.morphTargetsRelative = this.morphTargetsRelative); const l = this.groups; l.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(l))); const c = this.boundingSphere; return c !== null && (e.data.boundingSphere = c.toJSON()), e } clone() { return new this.constructor().copy(this) } copy(e) { this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null; const i = {}; this.name = e.name; const s = e.index; s !== null && this.setIndex(s.clone()); const a = e.attributes; for (const d in a) { const p = a[d]; this.setAttribute(d, p.clone(i)) } const o = e.morphAttributes; for (const d in o) { const p = [], f = o[d]; for (let _ = 0, x = f.length; _ < x; _++)p.push(f[_].clone(i)); this.morphAttributes[d] = p } this.morphTargetsRelative = e.morphTargetsRelative; const l = e.groups; for (let d = 0, p = l.length; d < p; d++) { const f = l[d]; this.addGroup(f.start, f.count, f.materialIndex) } const c = e.boundingBox; c !== null && (this.boundingBox = c.clone()); const h = e.boundingSphere; return h !== null && (this.boundingSphere = h.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this } dispose() { this.dispatchEvent({ type: "dispose" }) } } const _inverseMatrix$3 = new Matrix4, _ray$3 = new Ray, _sphere$6 = new Sphere, _sphereHitAt = new Vector3, _vA$1 = new Vector3, _vB$1 = new Vector3, _vC$1 = new Vector3, _tempA = new Vector3, _morphA = new Vector3, _intersectionPoint$1 = new Vector3, _intersectionPointWorld = new Vector3; class Mesh extends Object3D { constructor(e = new BufferGeometry, i = new MeshBasicMaterial) { super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = i, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.count = 1, this.updateMorphTargets() } copy(e, i) { return super.copy(e, i), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this } updateMorphTargets() { const i = this.geometry.morphAttributes, s = Object.keys(i); if (s.length > 0) { const a = i[s[0]]; if (a !== void 0) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let o = 0, l = a.length; o < l; o++) { const c = a[o].name || String(o); this.morphTargetInfluences.push(0), this.morphTargetDictionary[c] = o } } } } getVertexPosition(e, i) { const s = this.geometry, a = s.attributes.position, o = s.morphAttributes.position, l = s.morphTargetsRelative; i.fromBufferAttribute(a, e); const c = this.morphTargetInfluences; if (o && c) { _morphA.set(0, 0, 0); for (let h = 0, d = o.length; h < d; h++) { const p = c[h], f = o[h]; p !== 0 && (_tempA.fromBufferAttribute(f, e), l ? _morphA.addScaledVector(_tempA, p) : _morphA.addScaledVector(_tempA.sub(i), p)) } i.add(_morphA) } return i } raycast(e, i) { const s = this.geometry, a = this.material, o = this.matrixWorld; a !== void 0 && (s.boundingSphere === null && s.computeBoundingSphere(), _sphere$6.copy(s.boundingSphere), _sphere$6.applyMatrix4(o), _ray$3.copy(e.ray).recast(e.near), !(_sphere$6.containsPoint(_ray$3.origin) === !1 && (_ray$3.intersectSphere(_sphere$6, _sphereHitAt) === null || _ray$3.origin.distanceToSquared(_sphereHitAt) > (e.far - e.near) ** 2)) && (_inverseMatrix$3.copy(o).invert(), _ray$3.copy(e.ray).applyMatrix4(_inverseMatrix$3), !(s.boundingBox !== null && _ray$3.intersectsBox(s.boundingBox) === !1) && this._computeIntersections(e, i, _ray$3))) } _computeIntersections(e, i, s) { let a; const o = this.geometry, l = this.material, c = o.index, h = o.attributes.position, d = o.attributes.uv, p = o.attributes.uv1, f = o.attributes.normal, _ = o.groups, x = o.drawRange; if (c !== null) if (Array.isArray(l)) for (let b = 0, T = _.length; b < T; b++) { const M = _[b], w = l[M.materialIndex], D = Math.max(M.start, x.start), R = Math.min(c.count, Math.min(M.start + M.count, x.start + x.count)); for (let P = D, U = R; P < U; P += 3) { const O = c.getX(P), N = c.getX(P + 1), H = c.getX(P + 2); a = checkGeometryIntersection(this, w, e, s, d, p, f, O, N, H), a && (a.faceIndex = Math.floor(P / 3), a.face.materialIndex = M.materialIndex, i.push(a)) } } else { const b = Math.max(0, x.start), T = Math.min(c.count, x.start + x.count); for (let M = b, w = T; M < w; M += 3) { const D = c.getX(M), R = c.getX(M + 1), P = c.getX(M + 2); a = checkGeometryIntersection(this, l, e, s, d, p, f, D, R, P), a && (a.faceIndex = Math.floor(M / 3), i.push(a)) } } else if (h !== void 0) if (Array.isArray(l)) for (let b = 0, T = _.length; b < T; b++) { const M = _[b], w = l[M.materialIndex], D = Math.max(M.start, x.start), R = Math.min(h.count, Math.min(M.start + M.count, x.start + x.count)); for (let P = D, U = R; P < U; P += 3) { const O = P, N = P + 1, H = P + 2; a = checkGeometryIntersection(this, w, e, s, d, p, f, O, N, H), a && (a.faceIndex = Math.floor(P / 3), a.face.materialIndex = M.materialIndex, i.push(a)) } } else { const b = Math.max(0, x.start), T = Math.min(h.count, x.start + x.count); for (let M = b, w = T; M < w; M += 3) { const D = M, R = M + 1, P = M + 2; a = checkGeometryIntersection(this, l, e, s, d, p, f, D, R, P), a && (a.faceIndex = Math.floor(M / 3), i.push(a)) } } } } function checkIntersection$1(r, e, i, s, a, o, l, c) { let h; if (e.side === BackSide ? h = s.intersectTriangle(l, o, a, !0, c) : h = s.intersectTriangle(a, o, l, e.side === FrontSide, c), h === null) return null; _intersectionPointWorld.copy(c), _intersectionPointWorld.applyMatrix4(r.matrixWorld); const d = i.ray.origin.distanceTo(_intersectionPointWorld); return d < i.near || d > i.far ? null : { distance: d, point: _intersectionPointWorld.clone(), object: r } } function checkGeometryIntersection(r, e, i, s, a, o, l, c, h, d) { r.getVertexPosition(c, _vA$1), r.getVertexPosition(h, _vB$1), r.getVertexPosition(d, _vC$1); const p = checkIntersection$1(r, e, i, s, _vA$1, _vB$1, _vC$1, _intersectionPoint$1); if (p) { const f = new Vector3; Triangle.getBarycoord(_intersectionPoint$1, _vA$1, _vB$1, _vC$1, f), a && (p.uv = Triangle.getInterpolatedAttribute(a, c, h, d, f, new Vector2)), o && (p.uv1 = Triangle.getInterpolatedAttribute(o, c, h, d, f, new Vector2)), l && (p.normal = Triangle.getInterpolatedAttribute(l, c, h, d, f, new Vector3), p.normal.dot(s.direction) > 0 && p.normal.multiplyScalar(-1)); const _ = { a: c, b: h, c: d, normal: new Vector3, materialIndex: 0 }; Triangle.getNormal(_vA$1, _vB$1, _vC$1, _.normal), p.face = _, p.barycoord = f } return p } class BoxGeometry extends BufferGeometry { constructor(e = 1, i = 1, s = 1, a = 1, o = 1, l = 1) { super(), this.type = "BoxGeometry", this.parameters = { width: e, height: i, depth: s, widthSegments: a, heightSegments: o, depthSegments: l }; const c = this; a = Math.floor(a), o = Math.floor(o), l = Math.floor(l); const h = [], d = [], p = [], f = []; let _ = 0, x = 0; b("z", "y", "x", -1, -1, s, i, e, l, o, 0), b("z", "y", "x", 1, -1, s, i, -e, l, o, 1), b("x", "z", "y", 1, 1, e, s, i, a, l, 2), b("x", "z", "y", 1, -1, e, s, -i, a, l, 3), b("x", "y", "z", 1, -1, e, i, s, a, o, 4), b("x", "y", "z", -1, -1, e, i, -s, a, o, 5), this.setIndex(h), this.setAttribute("position", new Float32BufferAttribute(d, 3)), this.setAttribute("normal", new Float32BufferAttribute(p, 3)), this.setAttribute("uv", new Float32BufferAttribute(f, 2)); function b(T, M, w, D, R, P, U, O, N, H, F) { const k = P / N, W = U / H, $ = P / 2, Z = U / 2, J = O / 2, se = N + 1, re = H + 1; let ce = 0, ee = 0; const Me = new Vector3; for (let Ee = 0; Ee < re; Ee++) { const Ue = Ee * W - Z; for (let nt = 0; nt < se; nt++) { const mt = nt * k - $; Me[T] = mt * D, Me[M] = Ue * R, Me[w] = J, d.push(Me.x, Me.y, Me.z), Me[T] = 0, Me[M] = 0, Me[w] = O > 0 ? 1 : -1, p.push(Me.x, Me.y, Me.z), f.push(nt / N), f.push(1 - Ee / H), ce += 1 } } for (let Ee = 0; Ee < H; Ee++)for (let Ue = 0; Ue < N; Ue++) { const nt = _ + Ue + se * Ee, mt = _ + Ue + se * (Ee + 1), ve = _ + (Ue + 1) + se * (Ee + 1), ne = _ + (Ue + 1) + se * Ee; h.push(nt, mt, ne), h.push(mt, ve, ne), ee += 6 } c.addGroup(x, ee, F), x += ee, _ += ce } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new BoxGeometry(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments) } } function cloneUniforms(r) { const e = {}; for (const i in r) { e[i] = {}; for (const s in r[i]) { const a = r[i][s]; a && (a.isColor || a.isMatrix3 || a.isMatrix4 || a.isVector2 || a.isVector3 || a.isVector4 || a.isTexture || a.isQuaternion) ? a.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[i][s] = null) : e[i][s] = a.clone() : Array.isArray(a) ? e[i][s] = a.slice() : e[i][s] = a } } return e } function mergeUniforms(r) { const e = {}; for (let i = 0; i < r.length; i++) { const s = cloneUniforms(r[i]); for (const a in s) e[a] = s[a] } return e } function cloneUniformsGroups(r) { const e = []; for (let i = 0; i < r.length; i++)e.push(r[i].clone()); return e } function getUnlitUniformColorSpace(r) { const e = r.getRenderTarget(); return e === null ? r.outputColorSpace : e.isXRRenderTarget === !0 ? e.texture.colorSpace : ColorManagement.workingColorSpace } const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms }; var default_vertex = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, default_fragment = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`; class ShaderMaterial extends Material { constructor(e) { super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = default_vertex, this.fragmentShader = default_fragment, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = { clipCullDistance: !1, multiDraw: !1 }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv1: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e) } copy(e) { return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = cloneUniforms(e.uniforms), this.uniformsGroups = cloneUniformsGroups(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this } toJSON(e) { const i = super.toJSON(e); i.glslVersion = this.glslVersion, i.uniforms = {}; for (const a in this.uniforms) { const l = this.uniforms[a].value; l && l.isTexture ? i.uniforms[a] = { type: "t", value: l.toJSON(e).uuid } : l && l.isColor ? i.uniforms[a] = { type: "c", value: l.getHex() } : l && l.isVector2 ? i.uniforms[a] = { type: "v2", value: l.toArray() } : l && l.isVector3 ? i.uniforms[a] = { type: "v3", value: l.toArray() } : l && l.isVector4 ? i.uniforms[a] = { type: "v4", value: l.toArray() } : l && l.isMatrix3 ? i.uniforms[a] = { type: "m3", value: l.toArray() } : l && l.isMatrix4 ? i.uniforms[a] = { type: "m4", value: l.toArray() } : i.uniforms[a] = { value: l } } Object.keys(this.defines).length > 0 && (i.defines = this.defines), i.vertexShader = this.vertexShader, i.fragmentShader = this.fragmentShader, i.lights = this.lights, i.clipping = this.clipping; const s = {}; for (const a in this.extensions) this.extensions[a] === !0 && (s[a] = !0); return Object.keys(s).length > 0 && (i.extensions = s), i } } class Camera extends Object3D { constructor() { super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Matrix4, this.projectionMatrix = new Matrix4, this.projectionMatrixInverse = new Matrix4, this.coordinateSystem = WebGLCoordinateSystem, this._reversedDepth = !1 } get reversedDepth() { return this._reversedDepth } copy(e, i) { return super.copy(e, i), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this } getWorldDirection(e) { return super.getWorldDirection(e).negate() } updateMatrixWorld(e) { super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert() } updateWorldMatrix(e, i) { super.updateWorldMatrix(e, i), this.matrixWorldInverse.copy(this.matrixWorld).invert() } clone() { return new this.constructor().copy(this) } } const _v3$1 = new Vector3, _minTarget = new Vector2, _maxTarget = new Vector2; class PerspectiveCamera extends Camera { constructor(e = 50, i = 1, s = .1, a = 2e3) { super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = s, this.far = a, this.focus = 10, this.aspect = i, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix() } copy(e, i) { return super.copy(e, i), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this } setFocalLength(e) { const i = .5 * this.getFilmHeight() / e; this.fov = RAD2DEG * 2 * Math.atan(i), this.updateProjectionMatrix() } getFocalLength() { const e = Math.tan(DEG2RAD * .5 * this.fov); return .5 * this.getFilmHeight() / e } getEffectiveFOV() { return RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * .5 * this.fov) / this.zoom) } getFilmWidth() { return this.filmGauge * Math.min(this.aspect, 1) } getFilmHeight() { return this.filmGauge / Math.max(this.aspect, 1) } getViewBounds(e, i, s) { _v3$1.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse), i.set(_v3$1.x, _v3$1.y).multiplyScalar(-e / _v3$1.z), _v3$1.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse), s.set(_v3$1.x, _v3$1.y).multiplyScalar(-e / _v3$1.z) } getViewSize(e, i) { return this.getViewBounds(e, _minTarget, _maxTarget), i.subVectors(_maxTarget, _minTarget) } setViewOffset(e, i, s, a, o, l) { this.aspect = e / i, this.view === null && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = i, this.view.offsetX = s, this.view.offsetY = a, this.view.width = o, this.view.height = l, this.updateProjectionMatrix() } clearViewOffset() { this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix() } updateProjectionMatrix() { const e = this.near; let i = e * Math.tan(DEG2RAD * .5 * this.fov) / this.zoom, s = 2 * i, a = this.aspect * s, o = -.5 * a; const l = this.view; if (this.view !== null && this.view.enabled) { const h = l.fullWidth, d = l.fullHeight; o += l.offsetX * a / h, i -= l.offsetY * s / d, a *= l.width / h, s *= l.height / d } const c = this.filmOffset; c !== 0 && (o += e * c / this.getFilmWidth()), this.projectionMatrix.makePerspective(o, o + a, i, i - s, e, this.far, this.coordinateSystem, this.reversedDepth), this.projectionMatrixInverse.copy(this.projectionMatrix).invert() } toJSON(e) { const i = super.toJSON(e); return i.object.fov = this.fov, i.object.zoom = this.zoom, i.object.near = this.near, i.object.far = this.far, i.object.focus = this.focus, i.object.aspect = this.aspect, this.view !== null && (i.object.view = Object.assign({}, this.view)), i.object.filmGauge = this.filmGauge, i.object.filmOffset = this.filmOffset, i } } const fov = -90, aspect = 1; class CubeCamera extends Object3D { constructor(e, i, s) { super(), this.type = "CubeCamera", this.renderTarget = s, this.coordinateSystem = null, this.activeMipmapLevel = 0; const a = new PerspectiveCamera(fov, aspect, e, i); a.layers = this.layers, this.add(a); const o = new PerspectiveCamera(fov, aspect, e, i); o.layers = this.layers, this.add(o); const l = new PerspectiveCamera(fov, aspect, e, i); l.layers = this.layers, this.add(l); const c = new PerspectiveCamera(fov, aspect, e, i); c.layers = this.layers, this.add(c); const h = new PerspectiveCamera(fov, aspect, e, i); h.layers = this.layers, this.add(h); const d = new PerspectiveCamera(fov, aspect, e, i); d.layers = this.layers, this.add(d) } updateCoordinateSystem() { const e = this.coordinateSystem, i = this.children.concat(), [s, a, o, l, c, h] = i; for (const d of i) this.remove(d); if (e === WebGLCoordinateSystem) s.up.set(0, 1, 0), s.lookAt(1, 0, 0), a.up.set(0, 1, 0), a.lookAt(-1, 0, 0), o.up.set(0, 0, -1), o.lookAt(0, 1, 0), l.up.set(0, 0, 1), l.lookAt(0, -1, 0), c.up.set(0, 1, 0), c.lookAt(0, 0, 1), h.up.set(0, 1, 0), h.lookAt(0, 0, -1); else if (e === WebGPUCoordinateSystem) s.up.set(0, -1, 0), s.lookAt(-1, 0, 0), a.up.set(0, -1, 0), a.lookAt(1, 0, 0), o.up.set(0, 0, 1), o.lookAt(0, 1, 0), l.up.set(0, 0, -1), l.lookAt(0, -1, 0), c.up.set(0, -1, 0), c.lookAt(0, 0, 1), h.up.set(0, -1, 0), h.lookAt(0, 0, -1); else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e); for (const d of i) this.add(d), d.updateMatrixWorld() } update(e, i) { this.parent === null && this.updateMatrixWorld(); const { renderTarget: s, activeMipmapLevel: a } = this; this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem()); const [o, l, c, h, d, p] = this.children, f = e.getRenderTarget(), _ = e.getActiveCubeFace(), x = e.getActiveMipmapLevel(), b = e.xr.enabled; e.xr.enabled = !1; const T = s.texture.generateMipmaps; s.texture.generateMipmaps = !1, e.setRenderTarget(s, 0, a), e.render(i, o), e.setRenderTarget(s, 1, a), e.render(i, l), e.setRenderTarget(s, 2, a), e.render(i, c), e.setRenderTarget(s, 3, a), e.render(i, h), e.setRenderTarget(s, 4, a), e.render(i, d), s.texture.generateMipmaps = T, e.setRenderTarget(s, 5, a), e.render(i, p), e.setRenderTarget(f, _, x), e.xr.enabled = b, s.texture.needsPMREMUpdate = !0 } } class CubeTexture extends Texture { constructor(e = [], i = CubeReflectionMapping, s, a, o, l, c, h, d, p) { super(e, i, s, a, o, l, c, h, d, p), this.isCubeTexture = !0, this.flipY = !1 } get images() { return this.image } set images(e) { this.image = e } } class WebGLCubeRenderTarget extends WebGLRenderTarget {
    constructor(e = 1, i = {}) { super(e, e, i), this.isWebGLCubeRenderTarget = !0; const s = { width: e, height: e, depth: 1 }, a = [s, s, s, s, s, s]; this.texture = new CubeTexture(a), this._setTextureOptions(i), this.texture.isRenderTargetTexture = !0 } fromEquirectangularTexture(e, i) {
        this.texture.type = i.type, this.texture.colorSpace = i.colorSpace, this.texture.generateMipmaps = i.generateMipmaps, this.texture.minFilter = i.minFilter, this.texture.magFilter = i.magFilter; const s = {
            uniforms: { tEquirect: { value: null } }, vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`, fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`}, a = new BoxGeometry(5, 5, 5), o = new ShaderMaterial({ name: "CubemapFromEquirect", uniforms: cloneUniforms(s.uniforms), vertexShader: s.vertexShader, fragmentShader: s.fragmentShader, side: BackSide, blending: NoBlending }); o.uniforms.tEquirect.value = i; const l = new Mesh(a, o), c = i.minFilter; return i.minFilter === LinearMipmapLinearFilter && (i.minFilter = LinearFilter), new CubeCamera(1, 10, this).update(e, l), i.minFilter = c, l.geometry.dispose(), l.material.dispose(), this
    } clear(e, i = !0, s = !0, a = !0) { const o = e.getRenderTarget(); for (let l = 0; l < 6; l++)e.setRenderTarget(this, l), e.clear(i, s, a); e.setRenderTarget(o) }
} class Group extends Object3D { constructor() { super(), this.isGroup = !0, this.type = "Group" } } const _moveEvent = { type: "move" }; class WebXRController { constructor() { this._targetRay = null, this._grip = null, this._hand = null } getHandSpace() { return this._hand === null && (this._hand = new Group, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand } getTargetRaySpace() { return this._targetRay === null && (this._targetRay = new Group, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new Vector3, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new Vector3), this._targetRay } getGripSpace() { return this._grip === null && (this._grip = new Group, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new Vector3, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new Vector3), this._grip } dispatchEvent(e) { return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this } connect(e) { if (e && e.hand) { const i = this._hand; if (i) for (const s of e.hand.values()) this._getHandJoint(i, s) } return this.dispatchEvent({ type: "connected", data: e }), this } disconnect(e) { return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this } update(e, i, s) { let a = null, o = null, l = null; const c = this._targetRay, h = this._grip, d = this._hand; if (e && i.session.visibilityState !== "visible-blurred") { if (d && e.hand) { l = !0; for (const T of e.hand.values()) { const M = i.getJointPose(T, s), w = this._getHandJoint(d, T); M !== null && (w.matrix.fromArray(M.transform.matrix), w.matrix.decompose(w.position, w.rotation, w.scale), w.matrixWorldNeedsUpdate = !0, w.jointRadius = M.radius), w.visible = M !== null } const p = d.joints["index-finger-tip"], f = d.joints["thumb-tip"], _ = p.position.distanceTo(f.position), x = .02, b = .005; d.inputState.pinching && _ > x + b ? (d.inputState.pinching = !1, this.dispatchEvent({ type: "pinchend", handedness: e.handedness, target: this })) : !d.inputState.pinching && _ <= x - b && (d.inputState.pinching = !0, this.dispatchEvent({ type: "pinchstart", handedness: e.handedness, target: this })) } else h !== null && e.gripSpace && (o = i.getPose(e.gripSpace, s), o !== null && (h.matrix.fromArray(o.transform.matrix), h.matrix.decompose(h.position, h.rotation, h.scale), h.matrixWorldNeedsUpdate = !0, o.linearVelocity ? (h.hasLinearVelocity = !0, h.linearVelocity.copy(o.linearVelocity)) : h.hasLinearVelocity = !1, o.angularVelocity ? (h.hasAngularVelocity = !0, h.angularVelocity.copy(o.angularVelocity)) : h.hasAngularVelocity = !1)); c !== null && (a = i.getPose(e.targetRaySpace, s), a === null && o !== null && (a = o), a !== null && (c.matrix.fromArray(a.transform.matrix), c.matrix.decompose(c.position, c.rotation, c.scale), c.matrixWorldNeedsUpdate = !0, a.linearVelocity ? (c.hasLinearVelocity = !0, c.linearVelocity.copy(a.linearVelocity)) : c.hasLinearVelocity = !1, a.angularVelocity ? (c.hasAngularVelocity = !0, c.angularVelocity.copy(a.angularVelocity)) : c.hasAngularVelocity = !1, this.dispatchEvent(_moveEvent))) } return c !== null && (c.visible = a !== null), h !== null && (h.visible = o !== null), d !== null && (d.visible = l !== null), this } _getHandJoint(e, i) { if (e.joints[i.jointName] === void 0) { const s = new Group; s.matrixAutoUpdate = !1, s.visible = !1, e.joints[i.jointName] = s, e.add(s) } return e.joints[i.jointName] } } class Scene extends Object3D { constructor() { super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new Euler, this.environmentIntensity = 1, this.environmentRotation = new Euler, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } copy(e, i) { return super.copy(e, i), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this } toJSON(e) { const i = super.toJSON(e); return this.fog !== null && (i.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (i.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (i.object.backgroundIntensity = this.backgroundIntensity), i.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (i.object.environmentIntensity = this.environmentIntensity), i.object.environmentRotation = this.environmentRotation.toArray(), i } } class InterleavedBuffer { constructor(e, i) { this.isInterleavedBuffer = !0, this.array = e, this.stride = i, this.count = e !== void 0 ? e.length / i : 0, this.usage = StaticDrawUsage, this.updateRanges = [], this.version = 0, this.uuid = generateUUID() } onUploadCallback() { } set needsUpdate(e) { e === !0 && this.version++ } setUsage(e) { return this.usage = e, this } addUpdateRange(e, i) { this.updateRanges.push({ start: e, count: i }) } clearUpdateRanges() { this.updateRanges.length = 0 } copy(e) { return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this } copyAt(e, i, s) { e *= this.stride, s *= i.stride; for (let a = 0, o = this.stride; a < o; a++)this.array[e + a] = i.array[s + a]; return this } set(e, i = 0) { return this.array.set(e, i), this } clone(e) { e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = generateUUID()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer); const i = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), s = new this.constructor(i, this.stride); return s.setUsage(this.usage), s } onUpload(e) { return this.onUploadCallback = e, this } toJSON(e) { return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = generateUUID()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride } } } const _vector$7 = new Vector3; class InterleavedBufferAttribute { constructor(e, i, s, a = !1) { this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = i, this.offset = s, this.normalized = a } get count() { return this.data.count } get array() { return this.data.array } set needsUpdate(e) { this.data.needsUpdate = e } applyMatrix4(e) { for (let i = 0, s = this.data.count; i < s; i++)_vector$7.fromBufferAttribute(this, i), _vector$7.applyMatrix4(e), this.setXYZ(i, _vector$7.x, _vector$7.y, _vector$7.z); return this } applyNormalMatrix(e) { for (let i = 0, s = this.count; i < s; i++)_vector$7.fromBufferAttribute(this, i), _vector$7.applyNormalMatrix(e), this.setXYZ(i, _vector$7.x, _vector$7.y, _vector$7.z); return this } transformDirection(e) { for (let i = 0, s = this.count; i < s; i++)_vector$7.fromBufferAttribute(this, i), _vector$7.transformDirection(e), this.setXYZ(i, _vector$7.x, _vector$7.y, _vector$7.z); return this } getComponent(e, i) { let s = this.array[e * this.data.stride + this.offset + i]; return this.normalized && (s = denormalize(s, this.array)), s } setComponent(e, i, s) { return this.normalized && (s = normalize(s, this.array)), this.data.array[e * this.data.stride + this.offset + i] = s, this } setX(e, i) { return this.normalized && (i = normalize(i, this.array)), this.data.array[e * this.data.stride + this.offset] = i, this } setY(e, i) { return this.normalized && (i = normalize(i, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = i, this } setZ(e, i) { return this.normalized && (i = normalize(i, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = i, this } setW(e, i) { return this.normalized && (i = normalize(i, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = i, this } getX(e) { let i = this.data.array[e * this.data.stride + this.offset]; return this.normalized && (i = denormalize(i, this.array)), i } getY(e) { let i = this.data.array[e * this.data.stride + this.offset + 1]; return this.normalized && (i = denormalize(i, this.array)), i } getZ(e) { let i = this.data.array[e * this.data.stride + this.offset + 2]; return this.normalized && (i = denormalize(i, this.array)), i } getW(e) { let i = this.data.array[e * this.data.stride + this.offset + 3]; return this.normalized && (i = denormalize(i, this.array)), i } setXY(e, i, s) { return e = e * this.data.stride + this.offset, this.normalized && (i = normalize(i, this.array), s = normalize(s, this.array)), this.data.array[e + 0] = i, this.data.array[e + 1] = s, this } setXYZ(e, i, s, a) { return e = e * this.data.stride + this.offset, this.normalized && (i = normalize(i, this.array), s = normalize(s, this.array), a = normalize(a, this.array)), this.data.array[e + 0] = i, this.data.array[e + 1] = s, this.data.array[e + 2] = a, this } setXYZW(e, i, s, a, o) { return e = e * this.data.stride + this.offset, this.normalized && (i = normalize(i, this.array), s = normalize(s, this.array), a = normalize(a, this.array), o = normalize(o, this.array)), this.data.array[e + 0] = i, this.data.array[e + 1] = s, this.data.array[e + 2] = a, this.data.array[e + 3] = o, this } clone(e) { if (e === void 0) { console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."); const i = []; for (let s = 0; s < this.count; s++) { const a = s * this.data.stride + this.offset; for (let o = 0; o < this.itemSize; o++)i.push(this.data.array[a + o]) } return new BufferAttribute(new this.array.constructor(i), this.itemSize, this.normalized) } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new InterleavedBufferAttribute(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized) } toJSON(e) { if (e === void 0) { console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."); const i = []; for (let s = 0; s < this.count; s++) { const a = s * this.data.stride + this.offset; for (let o = 0; o < this.itemSize; o++)i.push(this.data.array[a + o]) } return { itemSize: this.itemSize, type: this.array.constructor.name, array: i, normalized: this.normalized } } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), { isInterleavedBufferAttribute: !0, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized } } } const _basePosition = new Vector3, _skinIndex = new Vector4, _skinWeight = new Vector4, _vector3 = new Vector3, _matrix4 = new Matrix4, _vertex = new Vector3, _sphere$5 = new Sphere, _inverseMatrix$2 = new Matrix4, _ray$2 = new Ray; class SkinnedMesh extends Mesh { constructor(e, i) { super(e, i), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = AttachedBindMode, this.bindMatrix = new Matrix4, this.bindMatrixInverse = new Matrix4, this.boundingBox = null, this.boundingSphere = null } computeBoundingBox() { const e = this.geometry; this.boundingBox === null && (this.boundingBox = new Box3), this.boundingBox.makeEmpty(); const i = e.getAttribute("position"); for (let s = 0; s < i.count; s++)this.getVertexPosition(s, _vertex), this.boundingBox.expandByPoint(_vertex) } computeBoundingSphere() { const e = this.geometry; this.boundingSphere === null && (this.boundingSphere = new Sphere), this.boundingSphere.makeEmpty(); const i = e.getAttribute("position"); for (let s = 0; s < i.count; s++)this.getVertexPosition(s, _vertex), this.boundingSphere.expandByPoint(_vertex) } copy(e, i) { return super.copy(e, i), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this } raycast(e, i) { const s = this.material, a = this.matrixWorld; s !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), _sphere$5.copy(this.boundingSphere), _sphere$5.applyMatrix4(a), e.ray.intersectsSphere(_sphere$5) !== !1 && (_inverseMatrix$2.copy(a).invert(), _ray$2.copy(e.ray).applyMatrix4(_inverseMatrix$2), !(this.boundingBox !== null && _ray$2.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, i, _ray$2))) } getVertexPosition(e, i) { return super.getVertexPosition(e, i), this.applyBoneTransform(e, i), i } bind(e, i) { this.skeleton = e, i === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), i = this.matrixWorld), this.bindMatrix.copy(i), this.bindMatrixInverse.copy(i).invert() } pose() { this.skeleton.pose() } normalizeSkinWeights() { const e = new Vector4, i = this.geometry.attributes.skinWeight; for (let s = 0, a = i.count; s < a; s++) { e.fromBufferAttribute(i, s); const o = 1 / e.manhattanLength(); o !== 1 / 0 ? e.multiplyScalar(o) : e.set(1, 0, 0, 0), i.setXYZW(s, e.x, e.y, e.z, e.w) } } updateMatrixWorld(e) { super.updateMatrixWorld(e), this.bindMode === AttachedBindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === DetachedBindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode) } applyBoneTransform(e, i) { const s = this.skeleton, a = this.geometry; _skinIndex.fromBufferAttribute(a.attributes.skinIndex, e), _skinWeight.fromBufferAttribute(a.attributes.skinWeight, e), _basePosition.copy(i).applyMatrix4(this.bindMatrix), i.set(0, 0, 0); for (let o = 0; o < 4; o++) { const l = _skinWeight.getComponent(o); if (l !== 0) { const c = _skinIndex.getComponent(o); _matrix4.multiplyMatrices(s.bones[c].matrixWorld, s.boneInverses[c]), i.addScaledVector(_vector3.copy(_basePosition).applyMatrix4(_matrix4), l) } } return i.applyMatrix4(this.bindMatrixInverse) } } class Bone extends Object3D { constructor() { super(), this.isBone = !0, this.type = "Bone" } } class DataTexture extends Texture { constructor(e = null, i = 1, s = 1, a, o, l, c, h, d = NearestFilter, p = NearestFilter, f, _) { super(null, l, c, h, d, p, a, o, f, _), this.isDataTexture = !0, this.image = { data: e, width: i, height: s }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 } } const _offsetMatrix = new Matrix4, _identityMatrix$1 = new Matrix4; class Skeleton { constructor(e = [], i = []) { this.uuid = generateUUID(), this.bones = e.slice(0), this.boneInverses = i, this.boneMatrices = null, this.boneTexture = null, this.init() } init() { const e = this.bones, i = this.boneInverses; if (this.boneMatrices = new Float32Array(e.length * 16), i.length === 0) this.calculateInverses(); else if (e.length !== i.length) { console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = []; for (let s = 0, a = this.bones.length; s < a; s++)this.boneInverses.push(new Matrix4) } } calculateInverses() { this.boneInverses.length = 0; for (let e = 0, i = this.bones.length; e < i; e++) { const s = new Matrix4; this.bones[e] && s.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(s) } } pose() { for (let e = 0, i = this.bones.length; e < i; e++) { const s = this.bones[e]; s && s.matrixWorld.copy(this.boneInverses[e]).invert() } for (let e = 0, i = this.bones.length; e < i; e++) { const s = this.bones[e]; s && (s.parent && s.parent.isBone ? (s.matrix.copy(s.parent.matrixWorld).invert(), s.matrix.multiply(s.matrixWorld)) : s.matrix.copy(s.matrixWorld), s.matrix.decompose(s.position, s.quaternion, s.scale)) } } update() { const e = this.bones, i = this.boneInverses, s = this.boneMatrices, a = this.boneTexture; for (let o = 0, l = e.length; o < l; o++) { const c = e[o] ? e[o].matrixWorld : _identityMatrix$1; _offsetMatrix.multiplyMatrices(c, i[o]), _offsetMatrix.toArray(s, o * 16) } a !== null && (a.needsUpdate = !0) } clone() { return new Skeleton(this.bones, this.boneInverses) } computeBoneTexture() { let e = Math.sqrt(this.bones.length * 4); e = Math.ceil(e / 4) * 4, e = Math.max(e, 4); const i = new Float32Array(e * e * 4); i.set(this.boneMatrices); const s = new DataTexture(i, e, e, RGBAFormat, FloatType); return s.needsUpdate = !0, this.boneMatrices = i, this.boneTexture = s, this } getBoneByName(e) { for (let i = 0, s = this.bones.length; i < s; i++) { const a = this.bones[i]; if (a.name === e) return a } } dispose() { this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null) } fromJSON(e, i) { this.uuid = e.uuid; for (let s = 0, a = e.bones.length; s < a; s++) { const o = e.bones[s]; let l = i[o]; l === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", o), l = new Bone), this.bones.push(l), this.boneInverses.push(new Matrix4().fromArray(e.boneInverses[s])) } return this.init(), this } toJSON() { const e = { metadata: { version: 4.7, type: "Skeleton", generator: "Skeleton.toJSON" }, bones: [], boneInverses: [] }; e.uuid = this.uuid; const i = this.bones, s = this.boneInverses; for (let a = 0, o = i.length; a < o; a++) { const l = i[a]; e.bones.push(l.uuid); const c = s[a]; e.boneInverses.push(c.toArray()) } return e } } class InstancedBufferAttribute extends BufferAttribute { constructor(e, i, s, a = 1) { super(e, i, s), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = a } copy(e) { return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this } toJSON() { const e = super.toJSON(); return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e } } const _instanceLocalMatrix = new Matrix4, _instanceWorldMatrix = new Matrix4, _instanceIntersects = [], _box3 = new Box3, _identity = new Matrix4, _mesh$1 = new Mesh, _sphere$4 = new Sphere; class InstancedMesh extends Mesh { constructor(e, i, s) { super(e, i), this.isInstancedMesh = !0, this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(s * 16), 16), this.instanceColor = null, this.morphTexture = null, this.count = s, this.boundingBox = null, this.boundingSphere = null; for (let a = 0; a < s; a++)this.setMatrixAt(a, _identity) } computeBoundingBox() { const e = this.geometry, i = this.count; this.boundingBox === null && (this.boundingBox = new Box3), e.boundingBox === null && e.computeBoundingBox(), this.boundingBox.makeEmpty(); for (let s = 0; s < i; s++)this.getMatrixAt(s, _instanceLocalMatrix), _box3.copy(e.boundingBox).applyMatrix4(_instanceLocalMatrix), this.boundingBox.union(_box3) } computeBoundingSphere() { const e = this.geometry, i = this.count; this.boundingSphere === null && (this.boundingSphere = new Sphere), e.boundingSphere === null && e.computeBoundingSphere(), this.boundingSphere.makeEmpty(); for (let s = 0; s < i; s++)this.getMatrixAt(s, _instanceLocalMatrix), _sphere$4.copy(e.boundingSphere).applyMatrix4(_instanceLocalMatrix), this.boundingSphere.union(_sphere$4) } copy(e, i) { return super.copy(e, i), this.instanceMatrix.copy(e.instanceMatrix), e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this } getColorAt(e, i) { i.fromArray(this.instanceColor.array, e * 3) } getMatrixAt(e, i) { i.fromArray(this.instanceMatrix.array, e * 16) } getMorphAt(e, i) { const s = i.morphTargetInfluences, a = this.morphTexture.source.data.data, o = s.length + 1, l = e * o + 1; for (let c = 0; c < s.length; c++)s[c] = a[l + c] } raycast(e, i) { const s = this.matrixWorld, a = this.count; if (_mesh$1.geometry = this.geometry, _mesh$1.material = this.material, _mesh$1.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), _sphere$4.copy(this.boundingSphere), _sphere$4.applyMatrix4(s), e.ray.intersectsSphere(_sphere$4) !== !1)) for (let o = 0; o < a; o++) { this.getMatrixAt(o, _instanceLocalMatrix), _instanceWorldMatrix.multiplyMatrices(s, _instanceLocalMatrix), _mesh$1.matrixWorld = _instanceWorldMatrix, _mesh$1.raycast(e, _instanceIntersects); for (let l = 0, c = _instanceIntersects.length; l < c; l++) { const h = _instanceIntersects[l]; h.instanceId = o, h.object = this, i.push(h) } _instanceIntersects.length = 0 } } setColorAt(e, i) { this.instanceColor === null && (this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3).fill(1), 3)), i.toArray(this.instanceColor.array, e * 3) } setMatrixAt(e, i) { i.toArray(this.instanceMatrix.array, e * 16) } setMorphAt(e, i) { const s = i.morphTargetInfluences, a = s.length + 1; this.morphTexture === null && (this.morphTexture = new DataTexture(new Float32Array(a * this.count), a, this.count, RedFormat, FloatType)); const o = this.morphTexture.source.data.data; let l = 0; for (let d = 0; d < s.length; d++)l += s[d]; const c = this.geometry.morphTargetsRelative ? 1 : 1 - l, h = a * e; o[h] = c, o.set(s, h + 1) } updateMorphTargets() { } dispose() { this.dispatchEvent({ type: "dispose" }), this.morphTexture !== null && (this.morphTexture.dispose(), this.morphTexture = null) } } const _vector1 = new Vector3, _vector2 = new Vector3, _normalMatrix = new Matrix3; class Plane { constructor(e = new Vector3(1, 0, 0), i = 0) { this.isPlane = !0, this.normal = e, this.constant = i } set(e, i) { return this.normal.copy(e), this.constant = i, this } setComponents(e, i, s, a) { return this.normal.set(e, i, s), this.constant = a, this } setFromNormalAndCoplanarPoint(e, i) { return this.normal.copy(e), this.constant = -i.dot(this.normal), this } setFromCoplanarPoints(e, i, s) { const a = _vector1.subVectors(s, i).cross(_vector2.subVectors(e, i)).normalize(); return this.setFromNormalAndCoplanarPoint(a, e), this } copy(e) { return this.normal.copy(e.normal), this.constant = e.constant, this } normalize() { const e = 1 / this.normal.length(); return this.normal.multiplyScalar(e), this.constant *= e, this } negate() { return this.constant *= -1, this.normal.negate(), this } distanceToPoint(e) { return this.normal.dot(e) + this.constant } distanceToSphere(e) { return this.distanceToPoint(e.center) - e.radius } projectPoint(e, i) { return i.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e)) } intersectLine(e, i) { const s = e.delta(_vector1), a = this.normal.dot(s); if (a === 0) return this.distanceToPoint(e.start) === 0 ? i.copy(e.start) : null; const o = -(e.start.dot(this.normal) + this.constant) / a; return o < 0 || o > 1 ? null : i.copy(e.start).addScaledVector(s, o) } intersectsLine(e) { const i = this.distanceToPoint(e.start), s = this.distanceToPoint(e.end); return i < 0 && s > 0 || s < 0 && i > 0 } intersectsBox(e) { return e.intersectsPlane(this) } intersectsSphere(e) { return e.intersectsPlane(this) } coplanarPoint(e) { return e.copy(this.normal).multiplyScalar(-this.constant) } applyMatrix4(e, i) { const s = i || _normalMatrix.getNormalMatrix(e), a = this.coplanarPoint(_vector1).applyMatrix4(e), o = this.normal.applyMatrix3(s).normalize(); return this.constant = -a.dot(o), this } translate(e) { return this.constant -= e.dot(this.normal), this } equals(e) { return e.normal.equals(this.normal) && e.constant === this.constant } clone() { return new this.constructor().copy(this) } } const _sphere$3 = new Sphere, _defaultSpriteCenter = new Vector2(.5, .5), _vector$6 = new Vector3; class Frustum { constructor(e = new Plane, i = new Plane, s = new Plane, a = new Plane, o = new Plane, l = new Plane) { this.planes = [e, i, s, a, o, l] } set(e, i, s, a, o, l) { const c = this.planes; return c[0].copy(e), c[1].copy(i), c[2].copy(s), c[3].copy(a), c[4].copy(o), c[5].copy(l), this } copy(e) { const i = this.planes; for (let s = 0; s < 6; s++)i[s].copy(e.planes[s]); return this } setFromProjectionMatrix(e, i = WebGLCoordinateSystem, s = !1) { const a = this.planes, o = e.elements, l = o[0], c = o[1], h = o[2], d = o[3], p = o[4], f = o[5], _ = o[6], x = o[7], b = o[8], T = o[9], M = o[10], w = o[11], D = o[12], R = o[13], P = o[14], U = o[15]; if (a[0].setComponents(d - l, x - p, w - b, U - D).normalize(), a[1].setComponents(d + l, x + p, w + b, U + D).normalize(), a[2].setComponents(d + c, x + f, w + T, U + R).normalize(), a[3].setComponents(d - c, x - f, w - T, U - R).normalize(), s) a[4].setComponents(h, _, M, P).normalize(), a[5].setComponents(d - h, x - _, w - M, U - P).normalize(); else if (a[4].setComponents(d - h, x - _, w - M, U - P).normalize(), i === WebGLCoordinateSystem) a[5].setComponents(d + h, x + _, w + M, U + P).normalize(); else if (i === WebGPUCoordinateSystem) a[5].setComponents(h, _, M, P).normalize(); else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + i); return this } intersectsObject(e) { if (e.boundingSphere !== void 0) e.boundingSphere === null && e.computeBoundingSphere(), _sphere$3.copy(e.boundingSphere).applyMatrix4(e.matrixWorld); else { const i = e.geometry; i.boundingSphere === null && i.computeBoundingSphere(), _sphere$3.copy(i.boundingSphere).applyMatrix4(e.matrixWorld) } return this.intersectsSphere(_sphere$3) } intersectsSprite(e) { _sphere$3.center.set(0, 0, 0); const i = _defaultSpriteCenter.distanceTo(e.center); return _sphere$3.radius = .7071067811865476 + i, _sphere$3.applyMatrix4(e.matrixWorld), this.intersectsSphere(_sphere$3) } intersectsSphere(e) { const i = this.planes, s = e.center, a = -e.radius; for (let o = 0; o < 6; o++)if (i[o].distanceToPoint(s) < a) return !1; return !0 } intersectsBox(e) { const i = this.planes; for (let s = 0; s < 6; s++) { const a = i[s]; if (_vector$6.x = a.normal.x > 0 ? e.max.x : e.min.x, _vector$6.y = a.normal.y > 0 ? e.max.y : e.min.y, _vector$6.z = a.normal.z > 0 ? e.max.z : e.min.z, a.distanceToPoint(_vector$6) < 0) return !1 } return !0 } containsPoint(e) { const i = this.planes; for (let s = 0; s < 6; s++)if (i[s].distanceToPoint(e) < 0) return !1; return !0 } clone() { return new this.constructor().copy(this) } } const _projScreenMatrix$2 = new Matrix4, _frustum$1 = new Frustum; class FrustumArray { constructor() { this.coordinateSystem = WebGLCoordinateSystem } intersectsObject(e, i) { if (!i.isArrayCamera || i.cameras.length === 0) return !1; for (let s = 0; s < i.cameras.length; s++) { const a = i.cameras[s]; if (_projScreenMatrix$2.multiplyMatrices(a.projectionMatrix, a.matrixWorldInverse), _frustum$1.setFromProjectionMatrix(_projScreenMatrix$2, a.coordinateSystem, a.reversedDepth), _frustum$1.intersectsObject(e)) return !0 } return !1 } intersectsSprite(e, i) { if (!i || !i.cameras || i.cameras.length === 0) return !1; for (let s = 0; s < i.cameras.length; s++) { const a = i.cameras[s]; if (_projScreenMatrix$2.multiplyMatrices(a.projectionMatrix, a.matrixWorldInverse), _frustum$1.setFromProjectionMatrix(_projScreenMatrix$2, a.coordinateSystem, a.reversedDepth), _frustum$1.intersectsSprite(e)) return !0 } return !1 } intersectsSphere(e, i) { if (!i || !i.cameras || i.cameras.length === 0) return !1; for (let s = 0; s < i.cameras.length; s++) { const a = i.cameras[s]; if (_projScreenMatrix$2.multiplyMatrices(a.projectionMatrix, a.matrixWorldInverse), _frustum$1.setFromProjectionMatrix(_projScreenMatrix$2, a.coordinateSystem, a.reversedDepth), _frustum$1.intersectsSphere(e)) return !0 } return !1 } intersectsBox(e, i) { if (!i || !i.cameras || i.cameras.length === 0) return !1; for (let s = 0; s < i.cameras.length; s++) { const a = i.cameras[s]; if (_projScreenMatrix$2.multiplyMatrices(a.projectionMatrix, a.matrixWorldInverse), _frustum$1.setFromProjectionMatrix(_projScreenMatrix$2, a.coordinateSystem, a.reversedDepth), _frustum$1.intersectsBox(e)) return !0 } return !1 } containsPoint(e, i) { if (!i || !i.cameras || i.cameras.length === 0) return !1; for (let s = 0; s < i.cameras.length; s++) { const a = i.cameras[s]; if (_projScreenMatrix$2.multiplyMatrices(a.projectionMatrix, a.matrixWorldInverse), _frustum$1.setFromProjectionMatrix(_projScreenMatrix$2, a.coordinateSystem, a.reversedDepth), _frustum$1.containsPoint(e)) return !0 } return !1 } clone() { return new FrustumArray } } function ascIdSort(r, e) { return r - e } function sortOpaque(r, e) { return r.z - e.z } function sortTransparent(r, e) { return e.z - r.z } class MultiDrawRenderList { constructor() { this.index = 0, this.pool = [], this.list = [] } push(e, i, s, a) { const o = this.pool, l = this.list; this.index >= o.length && o.push({ start: -1, count: -1, z: -1, index: -1 }); const c = o[this.index]; l.push(c), this.index++, c.start = e, c.count = i, c.z = s, c.index = a } reset() { this.list.length = 0, this.index = 0 } } const _matrix$1 = new Matrix4, _whiteColor = new Color(1, 1, 1), _frustum$2 = new Frustum, _frustumArray = new FrustumArray, _box$1 = new Box3, _sphere$2 = new Sphere, _vector$5 = new Vector3, _forward$1 = new Vector3, _temp = new Vector3, _renderList = new MultiDrawRenderList, _mesh$2 = new Mesh, _batchIntersects$1 = []; function copyAttributeData(r, e, i = 0) { const s = e.itemSize; if (r.isInterleavedBufferAttribute || r.array.constructor !== e.array.constructor) { const a = r.count; for (let o = 0; o < a; o++)for (let l = 0; l < s; l++)e.setComponent(o + i, l, r.getComponent(o, l)) } else e.array.set(r.array, i * s); e.needsUpdate = !0 } function copyArrayContents(r, e) { if (r.constructor !== e.constructor) { const i = Math.min(r.length, e.length); for (let s = 0; s < i; s++)e[s] = r[s] } else { const i = Math.min(r.length, e.length); e.set(new r.constructor(r.buffer, 0, i)) } } class BatchedMesh extends Mesh { constructor(e, i, s = i * 2, a) { super(new BufferGeometry, a), this.isBatchedMesh = !0, this.perObjectFrustumCulled = !0, this.sortObjects = !0, this.boundingBox = null, this.boundingSphere = null, this.customSort = null, this._instanceInfo = [], this._geometryInfo = [], this._availableInstanceIds = [], this._availableGeometryIds = [], this._nextIndexStart = 0, this._nextVertexStart = 0, this._geometryCount = 0, this._visibilityChanged = !0, this._geometryInitialized = !1, this._maxInstanceCount = e, this._maxVertexCount = i, this._maxIndexCount = s, this._multiDrawCounts = new Int32Array(e), this._multiDrawStarts = new Int32Array(e), this._multiDrawCount = 0, this._multiDrawInstances = null, this._matricesTexture = null, this._indirectTexture = null, this._colorsTexture = null, this._initMatricesTexture(), this._initIndirectTexture() } get maxInstanceCount() { return this._maxInstanceCount } get instanceCount() { return this._instanceInfo.length - this._availableInstanceIds.length } get unusedVertexCount() { return this._maxVertexCount - this._nextVertexStart } get unusedIndexCount() { return this._maxIndexCount - this._nextIndexStart } _initMatricesTexture() { let e = Math.sqrt(this._maxInstanceCount * 4); e = Math.ceil(e / 4) * 4, e = Math.max(e, 4); const i = new Float32Array(e * e * 4), s = new DataTexture(i, e, e, RGBAFormat, FloatType); this._matricesTexture = s } _initIndirectTexture() { let e = Math.sqrt(this._maxInstanceCount); e = Math.ceil(e); const i = new Uint32Array(e * e), s = new DataTexture(i, e, e, RedIntegerFormat, UnsignedIntType); this._indirectTexture = s } _initColorsTexture() { let e = Math.sqrt(this._maxInstanceCount); e = Math.ceil(e); const i = new Float32Array(e * e * 4).fill(1), s = new DataTexture(i, e, e, RGBAFormat, FloatType); s.colorSpace = ColorManagement.workingColorSpace, this._colorsTexture = s } _initializeGeometry(e) { const i = this.geometry, s = this._maxVertexCount, a = this._maxIndexCount; if (this._geometryInitialized === !1) { for (const o in e.attributes) { const l = e.getAttribute(o), { array: c, itemSize: h, normalized: d } = l, p = new c.constructor(s * h), f = new BufferAttribute(p, h, d); i.setAttribute(o, f) } if (e.getIndex() !== null) { const o = s > 65535 ? new Uint32Array(a) : new Uint16Array(a); i.setIndex(new BufferAttribute(o, 1)) } this._geometryInitialized = !0 } } _validateGeometry(e) { const i = this.geometry; if (!!e.getIndex() != !!i.getIndex()) throw new Error('THREE.BatchedMesh: All geometries must consistently have "index".'); for (const s in i.attributes) { if (!e.hasAttribute(s)) throw new Error(`THREE.BatchedMesh: Added geometry missing "${s}". All geometries must have consistent attributes.`); const a = e.getAttribute(s), o = i.getAttribute(s); if (a.itemSize !== o.itemSize || a.normalized !== o.normalized) throw new Error("THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value.") } } validateInstanceId(e) { const i = this._instanceInfo; if (e < 0 || e >= i.length || i[e].active === !1) throw new Error(`THREE.BatchedMesh: Invalid instanceId ${e}. Instance is either out of range or has been deleted.`) } validateGeometryId(e) { const i = this._geometryInfo; if (e < 0 || e >= i.length || i[e].active === !1) throw new Error(`THREE.BatchedMesh: Invalid geometryId ${e}. Geometry is either out of range or has been deleted.`) } setCustomSort(e) { return this.customSort = e, this } computeBoundingBox() { this.boundingBox === null && (this.boundingBox = new Box3); const e = this.boundingBox, i = this._instanceInfo; e.makeEmpty(); for (let s = 0, a = i.length; s < a; s++) { if (i[s].active === !1) continue; const o = i[s].geometryIndex; this.getMatrixAt(s, _matrix$1), this.getBoundingBoxAt(o, _box$1).applyMatrix4(_matrix$1), e.union(_box$1) } } computeBoundingSphere() { this.boundingSphere === null && (this.boundingSphere = new Sphere); const e = this.boundingSphere, i = this._instanceInfo; e.makeEmpty(); for (let s = 0, a = i.length; s < a; s++) { if (i[s].active === !1) continue; const o = i[s].geometryIndex; this.getMatrixAt(s, _matrix$1), this.getBoundingSphereAt(o, _sphere$2).applyMatrix4(_matrix$1), e.union(_sphere$2) } } addInstance(e) { if (this._instanceInfo.length >= this.maxInstanceCount && this._availableInstanceIds.length === 0) throw new Error("THREE.BatchedMesh: Maximum item count reached."); const s = { visible: !0, active: !0, geometryIndex: e }; let a = null; this._availableInstanceIds.length > 0 ? (this._availableInstanceIds.sort(ascIdSort), a = this._availableInstanceIds.shift(), this._instanceInfo[a] = s) : (a = this._instanceInfo.length, this._instanceInfo.push(s)); const o = this._matricesTexture; _matrix$1.identity().toArray(o.image.data, a * 16), o.needsUpdate = !0; const l = this._colorsTexture; return l && (_whiteColor.toArray(l.image.data, a * 4), l.needsUpdate = !0), this._visibilityChanged = !0, a } addGeometry(e, i = -1, s = -1) { this._initializeGeometry(e), this._validateGeometry(e); const a = { vertexStart: -1, vertexCount: -1, reservedVertexCount: -1, indexStart: -1, indexCount: -1, reservedIndexCount: -1, start: -1, count: -1, boundingBox: null, boundingSphere: null, active: !0 }, o = this._geometryInfo; a.vertexStart = this._nextVertexStart, a.reservedVertexCount = i === -1 ? e.getAttribute("position").count : i; const l = e.getIndex(); if (l !== null && (a.indexStart = this._nextIndexStart, a.reservedIndexCount = s === -1 ? l.count : s), a.indexStart !== -1 && a.indexStart + a.reservedIndexCount > this._maxIndexCount || a.vertexStart + a.reservedVertexCount > this._maxVertexCount) throw new Error("THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size."); let h; return this._availableGeometryIds.length > 0 ? (this._availableGeometryIds.sort(ascIdSort), h = this._availableGeometryIds.shift(), o[h] = a) : (h = this._geometryCount, this._geometryCount++, o.push(a)), this.setGeometryAt(h, e), this._nextIndexStart = a.indexStart + a.reservedIndexCount, this._nextVertexStart = a.vertexStart + a.reservedVertexCount, h } setGeometryAt(e, i) { if (e >= this._geometryCount) throw new Error("THREE.BatchedMesh: Maximum geometry count reached."); this._validateGeometry(i); const s = this.geometry, a = s.getIndex() !== null, o = s.getIndex(), l = i.getIndex(), c = this._geometryInfo[e]; if (a && l.count > c.reservedIndexCount || i.attributes.position.count > c.reservedVertexCount) throw new Error("THREE.BatchedMesh: Reserved space not large enough for provided geometry."); const h = c.vertexStart, d = c.reservedVertexCount; c.vertexCount = i.getAttribute("position").count; for (const p in s.attributes) { const f = i.getAttribute(p), _ = s.getAttribute(p); copyAttributeData(f, _, h); const x = f.itemSize; for (let b = f.count, T = d; b < T; b++) { const M = h + b; for (let w = 0; w < x; w++)_.setComponent(M, w, 0) } _.needsUpdate = !0, _.addUpdateRange(h * x, d * x) } if (a) { const p = c.indexStart, f = c.reservedIndexCount; c.indexCount = i.getIndex().count; for (let _ = 0; _ < l.count; _++)o.setX(p + _, h + l.getX(_)); for (let _ = l.count, x = f; _ < x; _++)o.setX(p + _, h); o.needsUpdate = !0, o.addUpdateRange(p, c.reservedIndexCount) } return c.start = a ? c.indexStart : c.vertexStart, c.count = a ? c.indexCount : c.vertexCount, c.boundingBox = null, i.boundingBox !== null && (c.boundingBox = i.boundingBox.clone()), c.boundingSphere = null, i.boundingSphere !== null && (c.boundingSphere = i.boundingSphere.clone()), this._visibilityChanged = !0, e } deleteGeometry(e) { const i = this._geometryInfo; if (e >= i.length || i[e].active === !1) return this; const s = this._instanceInfo; for (let a = 0, o = s.length; a < o; a++)s[a].active && s[a].geometryIndex === e && this.deleteInstance(a); return i[e].active = !1, this._availableGeometryIds.push(e), this._visibilityChanged = !0, this } deleteInstance(e) { return this.validateInstanceId(e), this._instanceInfo[e].active = !1, this._availableInstanceIds.push(e), this._visibilityChanged = !0, this } optimize() { let e = 0, i = 0; const s = this._geometryInfo, a = s.map((l, c) => c).sort((l, c) => s[l].vertexStart - s[c].vertexStart), o = this.geometry; for (let l = 0, c = s.length; l < c; l++) { const h = a[l], d = s[h]; if (d.active !== !1) { if (o.index !== null) { if (d.indexStart !== i) { const { indexStart: p, vertexStart: f, reservedIndexCount: _ } = d, x = o.index, b = x.array, T = e - f; for (let M = p; M < p + _; M++)b[M] = b[M] + T; x.array.copyWithin(i, p, p + _), x.addUpdateRange(i, _), d.indexStart = i } i += d.reservedIndexCount } if (d.vertexStart !== e) { const { vertexStart: p, reservedVertexCount: f } = d, _ = o.attributes; for (const x in _) { const b = _[x], { array: T, itemSize: M } = b; T.copyWithin(e * M, p * M, (p + f) * M), b.addUpdateRange(e * M, f * M) } d.vertexStart = e } e += d.reservedVertexCount, d.start = o.index ? d.indexStart : d.vertexStart, this._nextIndexStart = o.index ? d.indexStart + d.reservedIndexCount : 0, this._nextVertexStart = d.vertexStart + d.reservedVertexCount } } return this } getBoundingBoxAt(e, i) { if (e >= this._geometryCount) return null; const s = this.geometry, a = this._geometryInfo[e]; if (a.boundingBox === null) { const o = new Box3, l = s.index, c = s.attributes.position; for (let h = a.start, d = a.start + a.count; h < d; h++) { let p = h; l && (p = l.getX(p)), o.expandByPoint(_vector$5.fromBufferAttribute(c, p)) } a.boundingBox = o } return i.copy(a.boundingBox), i } getBoundingSphereAt(e, i) { if (e >= this._geometryCount) return null; const s = this.geometry, a = this._geometryInfo[e]; if (a.boundingSphere === null) { const o = new Sphere; this.getBoundingBoxAt(e, _box$1), _box$1.getCenter(o.center); const l = s.index, c = s.attributes.position; let h = 0; for (let d = a.start, p = a.start + a.count; d < p; d++) { let f = d; l && (f = l.getX(f)), _vector$5.fromBufferAttribute(c, f), h = Math.max(h, o.center.distanceToSquared(_vector$5)) } o.radius = Math.sqrt(h), a.boundingSphere = o } return i.copy(a.boundingSphere), i } setMatrixAt(e, i) { this.validateInstanceId(e); const s = this._matricesTexture, a = this._matricesTexture.image.data; return i.toArray(a, e * 16), s.needsUpdate = !0, this } getMatrixAt(e, i) { return this.validateInstanceId(e), i.fromArray(this._matricesTexture.image.data, e * 16) } setColorAt(e, i) { return this.validateInstanceId(e), this._colorsTexture === null && this._initColorsTexture(), i.toArray(this._colorsTexture.image.data, e * 4), this._colorsTexture.needsUpdate = !0, this } getColorAt(e, i) { return this.validateInstanceId(e), i.fromArray(this._colorsTexture.image.data, e * 4) } setVisibleAt(e, i) { return this.validateInstanceId(e), this._instanceInfo[e].visible === i ? this : (this._instanceInfo[e].visible = i, this._visibilityChanged = !0, this) } getVisibleAt(e) { return this.validateInstanceId(e), this._instanceInfo[e].visible } setGeometryIdAt(e, i) { return this.validateInstanceId(e), this.validateGeometryId(i), this._instanceInfo[e].geometryIndex = i, this } getGeometryIdAt(e) { return this.validateInstanceId(e), this._instanceInfo[e].geometryIndex } getGeometryRangeAt(e, i = {}) { this.validateGeometryId(e); const s = this._geometryInfo[e]; return i.vertexStart = s.vertexStart, i.vertexCount = s.vertexCount, i.reservedVertexCount = s.reservedVertexCount, i.indexStart = s.indexStart, i.indexCount = s.indexCount, i.reservedIndexCount = s.reservedIndexCount, i.start = s.start, i.count = s.count, i } setInstanceCount(e) { const i = this._availableInstanceIds, s = this._instanceInfo; for (i.sort(ascIdSort); i[i.length - 1] === s.length - 1;)s.pop(), i.pop(); if (e < s.length) throw new Error(`BatchedMesh: Instance ids outside the range ${e} are being used. Cannot shrink instance count.`); const a = new Int32Array(e), o = new Int32Array(e); copyArrayContents(this._multiDrawCounts, a), copyArrayContents(this._multiDrawStarts, o), this._multiDrawCounts = a, this._multiDrawStarts = o, this._maxInstanceCount = e; const l = this._indirectTexture, c = this._matricesTexture, h = this._colorsTexture; l.dispose(), this._initIndirectTexture(), copyArrayContents(l.image.data, this._indirectTexture.image.data), c.dispose(), this._initMatricesTexture(), copyArrayContents(c.image.data, this._matricesTexture.image.data), h && (h.dispose(), this._initColorsTexture(), copyArrayContents(h.image.data, this._colorsTexture.image.data)) } setGeometrySize(e, i) { const s = [...this._geometryInfo].filter(c => c.active); if (Math.max(...s.map(c => c.vertexStart + c.reservedVertexCount)) > e) throw new Error(`BatchedMesh: Geometry vertex values are being used outside the range ${i}. Cannot shrink further.`); if (this.geometry.index && Math.max(...s.map(h => h.indexStart + h.reservedIndexCount)) > i) throw new Error(`BatchedMesh: Geometry index values are being used outside the range ${i}. Cannot shrink further.`); const o = this.geometry; o.dispose(), this._maxVertexCount = e, this._maxIndexCount = i, this._geometryInitialized && (this._geometryInitialized = !1, this.geometry = new BufferGeometry, this._initializeGeometry(o)); const l = this.geometry; o.index && copyArrayContents(o.index.array, l.index.array); for (const c in o.attributes) copyArrayContents(o.attributes[c].array, l.attributes[c].array) } raycast(e, i) { const s = this._instanceInfo, a = this._geometryInfo, o = this.matrixWorld, l = this.geometry; _mesh$2.material = this.material, _mesh$2.geometry.index = l.index, _mesh$2.geometry.attributes = l.attributes, _mesh$2.geometry.boundingBox === null && (_mesh$2.geometry.boundingBox = new Box3), _mesh$2.geometry.boundingSphere === null && (_mesh$2.geometry.boundingSphere = new Sphere); for (let c = 0, h = s.length; c < h; c++) { if (!s[c].visible || !s[c].active) continue; const d = s[c].geometryIndex, p = a[d]; _mesh$2.geometry.setDrawRange(p.start, p.count), this.getMatrixAt(c, _mesh$2.matrixWorld).premultiply(o), this.getBoundingBoxAt(d, _mesh$2.geometry.boundingBox), this.getBoundingSphereAt(d, _mesh$2.geometry.boundingSphere), _mesh$2.raycast(e, _batchIntersects$1); for (let f = 0, _ = _batchIntersects$1.length; f < _; f++) { const x = _batchIntersects$1[f]; x.object = this, x.batchId = c, i.push(x) } _batchIntersects$1.length = 0 } _mesh$2.material = null, _mesh$2.geometry.index = null, _mesh$2.geometry.attributes = {}, _mesh$2.geometry.setDrawRange(0, 1 / 0) } copy(e) { return super.copy(e), this.geometry = e.geometry.clone(), this.perObjectFrustumCulled = e.perObjectFrustumCulled, this.sortObjects = e.sortObjects, this.boundingBox = e.boundingBox !== null ? e.boundingBox.clone() : null, this.boundingSphere = e.boundingSphere !== null ? e.boundingSphere.clone() : null, this._geometryInfo = e._geometryInfo.map(i => ({ ...i, boundingBox: i.boundingBox !== null ? i.boundingBox.clone() : null, boundingSphere: i.boundingSphere !== null ? i.boundingSphere.clone() : null })), this._instanceInfo = e._instanceInfo.map(i => ({ ...i })), this._availableInstanceIds = e._availableInstanceIds.slice(), this._availableGeometryIds = e._availableGeometryIds.slice(), this._nextIndexStart = e._nextIndexStart, this._nextVertexStart = e._nextVertexStart, this._geometryCount = e._geometryCount, this._maxInstanceCount = e._maxInstanceCount, this._maxVertexCount = e._maxVertexCount, this._maxIndexCount = e._maxIndexCount, this._geometryInitialized = e._geometryInitialized, this._multiDrawCounts = e._multiDrawCounts.slice(), this._multiDrawStarts = e._multiDrawStarts.slice(), this._indirectTexture = e._indirectTexture.clone(), this._indirectTexture.image.data = this._indirectTexture.image.data.slice(), this._matricesTexture = e._matricesTexture.clone(), this._matricesTexture.image.data = this._matricesTexture.image.data.slice(), this._colorsTexture !== null && (this._colorsTexture = e._colorsTexture.clone(), this._colorsTexture.image.data = this._colorsTexture.image.data.slice()), this } dispose() { this.geometry.dispose(), this._matricesTexture.dispose(), this._matricesTexture = null, this._indirectTexture.dispose(), this._indirectTexture = null, this._colorsTexture !== null && (this._colorsTexture.dispose(), this._colorsTexture = null) } onBeforeRender(e, i, s, a, o) { if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects) return; const l = a.getIndex(), c = l === null ? 1 : l.array.BYTES_PER_ELEMENT, h = this._instanceInfo, d = this._multiDrawStarts, p = this._multiDrawCounts, f = this._geometryInfo, _ = this.perObjectFrustumCulled, x = this._indirectTexture, b = x.image.data, T = s.isArrayCamera ? _frustumArray : _frustum$2; _ && !s.isArrayCamera && (_matrix$1.multiplyMatrices(s.projectionMatrix, s.matrixWorldInverse).multiply(this.matrixWorld), _frustum$2.setFromProjectionMatrix(_matrix$1, s.coordinateSystem, s.reversedDepth)); let M = 0; if (this.sortObjects) { _matrix$1.copy(this.matrixWorld).invert(), _vector$5.setFromMatrixPosition(s.matrixWorld).applyMatrix4(_matrix$1), _forward$1.set(0, 0, -1).transformDirection(s.matrixWorld).transformDirection(_matrix$1); for (let R = 0, P = h.length; R < P; R++)if (h[R].visible && h[R].active) { const U = h[R].geometryIndex; this.getMatrixAt(R, _matrix$1), this.getBoundingSphereAt(U, _sphere$2).applyMatrix4(_matrix$1); let O = !1; if (_ && (O = !T.intersectsSphere(_sphere$2, s)), !O) { const N = f[U], H = _temp.subVectors(_sphere$2.center, _vector$5).dot(_forward$1); _renderList.push(N.start, N.count, H, R) } } const w = _renderList.list, D = this.customSort; D === null ? w.sort(o.transparent ? sortTransparent : sortOpaque) : D.call(this, w, s); for (let R = 0, P = w.length; R < P; R++) { const U = w[R]; d[M] = U.start * c, p[M] = U.count, b[M] = U.index, M++ } _renderList.reset() } else for (let w = 0, D = h.length; w < D; w++)if (h[w].visible && h[w].active) { const R = h[w].geometryIndex; let P = !1; if (_ && (this.getMatrixAt(w, _matrix$1), this.getBoundingSphereAt(R, _sphere$2).applyMatrix4(_matrix$1), P = !T.intersectsSphere(_sphere$2, s)), !P) { const U = f[R]; d[M] = U.start * c, p[M] = U.count, b[M] = w, M++ } } x.needsUpdate = !0, this._multiDrawCount = M, this._visibilityChanged = !1 } onBeforeShadow(e, i, s, a, o, l) { this.onBeforeRender(e, null, a, o, l) } } class LineBasicMaterial extends Material { constructor(e) { super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new Color(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this } } const _vStart = new Vector3, _vEnd = new Vector3, _inverseMatrix$1 = new Matrix4, _ray$1 = new Ray, _sphere$1 = new Sphere, _intersectPointOnRay = new Vector3, _intersectPointOnSegment = new Vector3; class Line extends Object3D { constructor(e = new BufferGeometry, i = new LineBasicMaterial) { super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = i, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets() } copy(e, i) { return super.copy(e, i), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this } computeLineDistances() { const e = this.geometry; if (e.index === null) { const i = e.attributes.position, s = [0]; for (let a = 1, o = i.count; a < o; a++)_vStart.fromBufferAttribute(i, a - 1), _vEnd.fromBufferAttribute(i, a), s[a] = s[a - 1], s[a] += _vStart.distanceTo(_vEnd); e.setAttribute("lineDistance", new Float32BufferAttribute(s, 1)) } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); return this } raycast(e, i) { const s = this.geometry, a = this.matrixWorld, o = e.params.Line.threshold, l = s.drawRange; if (s.boundingSphere === null && s.computeBoundingSphere(), _sphere$1.copy(s.boundingSphere), _sphere$1.applyMatrix4(a), _sphere$1.radius += o, e.ray.intersectsSphere(_sphere$1) === !1) return; _inverseMatrix$1.copy(a).invert(), _ray$1.copy(e.ray).applyMatrix4(_inverseMatrix$1); const c = o / ((this.scale.x + this.scale.y + this.scale.z) / 3), h = c * c, d = this.isLineSegments ? 2 : 1, p = s.index, _ = s.attributes.position; if (p !== null) { const x = Math.max(0, l.start), b = Math.min(p.count, l.start + l.count); for (let T = x, M = b - 1; T < M; T += d) { const w = p.getX(T), D = p.getX(T + 1), R = checkIntersection$2(this, e, _ray$1, h, w, D, T); R && i.push(R) } if (this.isLineLoop) { const T = p.getX(b - 1), M = p.getX(x), w = checkIntersection$2(this, e, _ray$1, h, T, M, b - 1); w && i.push(w) } } else { const x = Math.max(0, l.start), b = Math.min(_.count, l.start + l.count); for (let T = x, M = b - 1; T < M; T += d) { const w = checkIntersection$2(this, e, _ray$1, h, T, T + 1, T); w && i.push(w) } if (this.isLineLoop) { const T = checkIntersection$2(this, e, _ray$1, h, b - 1, x, b - 1); T && i.push(T) } } } updateMorphTargets() { const i = this.geometry.morphAttributes, s = Object.keys(i); if (s.length > 0) { const a = i[s[0]]; if (a !== void 0) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let o = 0, l = a.length; o < l; o++) { const c = a[o].name || String(o); this.morphTargetInfluences.push(0), this.morphTargetDictionary[c] = o } } } } } function checkIntersection$2(r, e, i, s, a, o, l) { const c = r.geometry.attributes.position; if (_vStart.fromBufferAttribute(c, a), _vEnd.fromBufferAttribute(c, o), i.distanceSqToSegment(_vStart, _vEnd, _intersectPointOnRay, _intersectPointOnSegment) > s) return; _intersectPointOnRay.applyMatrix4(r.matrixWorld); const d = e.ray.origin.distanceTo(_intersectPointOnRay); if (!(d < e.near || d > e.far)) return { distance: d, point: _intersectPointOnSegment.clone().applyMatrix4(r.matrixWorld), index: l, face: null, faceIndex: null, barycoord: null, object: r } } const _start = new Vector3, _end = new Vector3; class LineSegments extends Line { constructor(e, i) { super(e, i), this.isLineSegments = !0, this.type = "LineSegments" } computeLineDistances() { const e = this.geometry; if (e.index === null) { const i = e.attributes.position, s = []; for (let a = 0, o = i.count; a < o; a += 2)_start.fromBufferAttribute(i, a), _end.fromBufferAttribute(i, a + 1), s[a] = a === 0 ? 0 : s[a - 1], s[a + 1] = s[a] + _start.distanceTo(_end); e.setAttribute("lineDistance", new Float32BufferAttribute(s, 1)) } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); return this } } class LineLoop extends Line { constructor(e, i) { super(e, i), this.isLineLoop = !0, this.type = "LineLoop" } } class PointsMaterial extends Material { constructor(e) { super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new Color(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this } } const _inverseMatrix = new Matrix4, _ray = new Ray, _sphere$7 = new Sphere, _position$2 = new Vector3; class Points extends Object3D { constructor(e = new BufferGeometry, i = new PointsMaterial) { super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = i, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets() } copy(e, i) { return super.copy(e, i), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this } raycast(e, i) { const s = this.geometry, a = this.matrixWorld, o = e.params.Points.threshold, l = s.drawRange; if (s.boundingSphere === null && s.computeBoundingSphere(), _sphere$7.copy(s.boundingSphere), _sphere$7.applyMatrix4(a), _sphere$7.radius += o, e.ray.intersectsSphere(_sphere$7) === !1) return; _inverseMatrix.copy(a).invert(), _ray.copy(e.ray).applyMatrix4(_inverseMatrix); const c = o / ((this.scale.x + this.scale.y + this.scale.z) / 3), h = c * c, d = s.index, f = s.attributes.position; if (d !== null) { const _ = Math.max(0, l.start), x = Math.min(d.count, l.start + l.count); for (let b = _, T = x; b < T; b++) { const M = d.getX(b); _position$2.fromBufferAttribute(f, M), testPoint(_position$2, M, h, a, e, i, this) } } else { const _ = Math.max(0, l.start), x = Math.min(f.count, l.start + l.count); for (let b = _, T = x; b < T; b++)_position$2.fromBufferAttribute(f, b), testPoint(_position$2, b, h, a, e, i, this) } } updateMorphTargets() { const i = this.geometry.morphAttributes, s = Object.keys(i); if (s.length > 0) { const a = i[s[0]]; if (a !== void 0) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let o = 0, l = a.length; o < l; o++) { const c = a[o].name || String(o); this.morphTargetInfluences.push(0), this.morphTargetDictionary[c] = o } } } } } function testPoint(r, e, i, s, a, o, l) { const c = _ray.distanceSqToPoint(r); if (c < i) { const h = new Vector3; _ray.closestPointToPoint(r, h), h.applyMatrix4(s); const d = a.ray.origin.distanceTo(h); if (d < a.near || d > a.far) return; o.push({ distance: d, distanceToRay: Math.sqrt(c), point: h, index: e, face: null, faceIndex: null, barycoord: null, object: l }) } } class VideoTexture extends Texture { constructor(e, i, s, a, o = LinearFilter, l = LinearFilter, c, h, d) { super(e, i, s, a, o, l, c, h, d), this.isVideoTexture = !0, this.generateMipmaps = !1, this._requestVideoFrameCallbackId = 0; const p = this; function f() { p.needsUpdate = !0, p._requestVideoFrameCallbackId = e.requestVideoFrameCallback(f) } "requestVideoFrameCallback" in e && (this._requestVideoFrameCallbackId = e.requestVideoFrameCallback(f)) } clone() { return new this.constructor(this.image).copy(this) } update() { const e = this.image; "requestVideoFrameCallback" in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0) } dispose() { this._requestVideoFrameCallbackId !== 0 && this.source.data.cancelVideoFrameCallback(this._requestVideoFrameCallbackId), super.dispose() } } class CompressedTexture extends Texture { constructor(e, i, s, a, o, l, c, h, d, p, f, _) { super(null, l, c, h, d, p, a, o, f, _), this.isCompressedTexture = !0, this.image = { width: i, height: s }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1 } } class CompressedArrayTexture extends CompressedTexture { constructor(e, i, s, a, o, l) { super(e, i, s, o, l), this.isCompressedArrayTexture = !0, this.image.depth = a, this.wrapR = ClampToEdgeWrapping, this.layerUpdates = new Set } addLayerUpdate(e) { this.layerUpdates.add(e) } clearLayerUpdates() { this.layerUpdates.clear() } } class CompressedCubeTexture extends CompressedTexture { constructor(e, i, s) { super(void 0, e[0].width, e[0].height, i, s, CubeReflectionMapping), this.isCompressedCubeTexture = !0, this.isCubeTexture = !0, this.image = e } } class DepthTexture extends Texture { constructor(e, i, s = UnsignedIntType, a, o, l, c = NearestFilter, h = NearestFilter, d, p = DepthFormat, f = 1) { if (p !== DepthFormat && p !== DepthStencilFormat) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"); const _ = { width: e, height: i, depth: f }; super(_, a, o, l, c, h, p, s, d), this.isDepthTexture = !0, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null } copy(e) { return super.copy(e), this.source = new Source(Object.assign({}, e.image)), this.compareFunction = e.compareFunction, this } toJSON(e) { const i = super.toJSON(e); return this.compareFunction !== null && (i.compareFunction = this.compareFunction), i } } class ExternalTexture extends Texture { constructor(e = null) { super(), this.sourceTexture = e, this.isExternalTexture = !0 } copy(e) { return super.copy(e), this.sourceTexture = e.sourceTexture, this } } class Curve { constructor() { this.type = "Curve", this.arcLengthDivisions = 200, this.needsUpdate = !1, this.cacheArcLengths = null } getPoint() { console.warn("THREE.Curve: .getPoint() not implemented.") } getPointAt(e, i) { const s = this.getUtoTmapping(e); return this.getPoint(s, i) } getPoints(e = 5) { const i = []; for (let s = 0; s <= e; s++)i.push(this.getPoint(s / e)); return i } getSpacedPoints(e = 5) { const i = []; for (let s = 0; s <= e; s++)i.push(this.getPointAt(s / e)); return i } getLength() { const e = this.getLengths(); return e[e.length - 1] } getLengths(e = this.arcLengthDivisions) { if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths; this.needsUpdate = !1; const i = []; let s, a = this.getPoint(0), o = 0; i.push(0); for (let l = 1; l <= e; l++)s = this.getPoint(l / e), o += s.distanceTo(a), i.push(o), a = s; return this.cacheArcLengths = i, i } updateArcLengths() { this.needsUpdate = !0, this.getLengths() } getUtoTmapping(e, i = null) { const s = this.getLengths(); let a = 0; const o = s.length; let l; i ? l = i : l = e * s[o - 1]; let c = 0, h = o - 1, d; for (; c <= h;)if (a = Math.floor(c + (h - c) / 2), d = s[a] - l, d < 0) c = a + 1; else if (d > 0) h = a - 1; else { h = a; break } if (a = h, s[a] === l) return a / (o - 1); const p = s[a], _ = s[a + 1] - p, x = (l - p) / _; return (a + x) / (o - 1) } getTangent(e, i) { let a = e - 1e-4, o = e + 1e-4; a < 0 && (a = 0), o > 1 && (o = 1); const l = this.getPoint(a), c = this.getPoint(o), h = i || (l.isVector2 ? new Vector2 : new Vector3); return h.copy(c).sub(l).normalize(), h } getTangentAt(e, i) { const s = this.getUtoTmapping(e); return this.getTangent(s, i) } computeFrenetFrames(e, i = !1) { const s = new Vector3, a = [], o = [], l = [], c = new Vector3, h = new Matrix4; for (let x = 0; x <= e; x++) { const b = x / e; a[x] = this.getTangentAt(b, new Vector3) } o[0] = new Vector3, l[0] = new Vector3; let d = Number.MAX_VALUE; const p = Math.abs(a[0].x), f = Math.abs(a[0].y), _ = Math.abs(a[0].z); p <= d && (d = p, s.set(1, 0, 0)), f <= d && (d = f, s.set(0, 1, 0)), _ <= d && s.set(0, 0, 1), c.crossVectors(a[0], s).normalize(), o[0].crossVectors(a[0], c), l[0].crossVectors(a[0], o[0]); for (let x = 1; x <= e; x++) { if (o[x] = o[x - 1].clone(), l[x] = l[x - 1].clone(), c.crossVectors(a[x - 1], a[x]), c.length() > Number.EPSILON) { c.normalize(); const b = Math.acos(clamp(a[x - 1].dot(a[x]), -1, 1)); o[x].applyMatrix4(h.makeRotationAxis(c, b)) } l[x].crossVectors(a[x], o[x]) } if (i === !0) { let x = Math.acos(clamp(o[0].dot(o[e]), -1, 1)); x /= e, a[0].dot(c.crossVectors(o[0], o[e])) > 0 && (x = -x); for (let b = 1; b <= e; b++)o[b].applyMatrix4(h.makeRotationAxis(a[b], x * b)), l[b].crossVectors(a[b], o[b]) } return { tangents: a, normals: o, binormals: l } } clone() { return new this.constructor().copy(this) } copy(e) { return this.arcLengthDivisions = e.arcLengthDivisions, this } toJSON() { const e = { metadata: { version: 4.7, type: "Curve", generator: "Curve.toJSON" } }; return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e } fromJSON(e) { return this.arcLengthDivisions = e.arcLengthDivisions, this } } class EllipseCurve extends Curve { constructor(e = 0, i = 0, s = 1, a = 1, o = 0, l = Math.PI * 2, c = !1, h = 0) { super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = i, this.xRadius = s, this.yRadius = a, this.aStartAngle = o, this.aEndAngle = l, this.aClockwise = c, this.aRotation = h } getPoint(e, i = new Vector2) { const s = i, a = Math.PI * 2; let o = this.aEndAngle - this.aStartAngle; const l = Math.abs(o) < Number.EPSILON; for (; o < 0;)o += a; for (; o > a;)o -= a; o < Number.EPSILON && (l ? o = 0 : o = a), this.aClockwise === !0 && !l && (o === a ? o = -a : o = o - a); const c = this.aStartAngle + e * o; let h = this.aX + this.xRadius * Math.cos(c), d = this.aY + this.yRadius * Math.sin(c); if (this.aRotation !== 0) { const p = Math.cos(this.aRotation), f = Math.sin(this.aRotation), _ = h - this.aX, x = d - this.aY; h = _ * p - x * f + this.aX, d = _ * f + x * p + this.aY } return s.set(h, d) } copy(e) { return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this } toJSON() { const e = super.toJSON(); return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e } fromJSON(e) { return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this } } class ArcCurve extends EllipseCurve { constructor(e, i, s, a, o, l) { super(e, i, s, s, a, o, l), this.isArcCurve = !0, this.type = "ArcCurve" } } function CubicPoly() { let r = 0, e = 0, i = 0, s = 0; function a(o, l, c, h) { r = o, e = c, i = -3 * o + 3 * l - 2 * c - h, s = 2 * o - 2 * l + c + h } return { initCatmullRom: function (o, l, c, h, d) { a(l, c, d * (c - o), d * (h - l)) }, initNonuniformCatmullRom: function (o, l, c, h, d, p, f) { let _ = (l - o) / d - (c - o) / (d + p) + (c - l) / p, x = (c - l) / p - (h - l) / (p + f) + (h - c) / f; _ *= p, x *= p, a(l, c, _, x) }, calc: function (o) { const l = o * o, c = l * o; return r + e * o + i * l + s * c } } } const tmp = new Vector3, px = new CubicPoly, py = new CubicPoly, pz = new CubicPoly; class CatmullRomCurve3 extends Curve { constructor(e = [], i = !1, s = "centripetal", a = .5) { super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = i, this.curveType = s, this.tension = a } getPoint(e, i = new Vector3) { const s = i, a = this.points, o = a.length, l = (o - (this.closed ? 0 : 1)) * e; let c = Math.floor(l), h = l - c; this.closed ? c += c > 0 ? 0 : (Math.floor(Math.abs(c) / o) + 1) * o : h === 0 && c === o - 1 && (c = o - 2, h = 1); let d, p; this.closed || c > 0 ? d = a[(c - 1) % o] : (tmp.subVectors(a[0], a[1]).add(a[0]), d = tmp); const f = a[c % o], _ = a[(c + 1) % o]; if (this.closed || c + 2 < o ? p = a[(c + 2) % o] : (tmp.subVectors(a[o - 1], a[o - 2]).add(a[o - 1]), p = tmp), this.curveType === "centripetal" || this.curveType === "chordal") { const x = this.curveType === "chordal" ? .5 : .25; let b = Math.pow(d.distanceToSquared(f), x), T = Math.pow(f.distanceToSquared(_), x), M = Math.pow(_.distanceToSquared(p), x); T < 1e-4 && (T = 1), b < 1e-4 && (b = T), M < 1e-4 && (M = T), px.initNonuniformCatmullRom(d.x, f.x, _.x, p.x, b, T, M), py.initNonuniformCatmullRom(d.y, f.y, _.y, p.y, b, T, M), pz.initNonuniformCatmullRom(d.z, f.z, _.z, p.z, b, T, M) } else this.curveType === "catmullrom" && (px.initCatmullRom(d.x, f.x, _.x, p.x, this.tension), py.initCatmullRom(d.y, f.y, _.y, p.y, this.tension), pz.initCatmullRom(d.z, f.z, _.z, p.z, this.tension)); return s.set(px.calc(h), py.calc(h), pz.calc(h)), s } copy(e) { super.copy(e), this.points = []; for (let i = 0, s = e.points.length; i < s; i++) { const a = e.points[i]; this.points.push(a.clone()) } return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this } toJSON() { const e = super.toJSON(); e.points = []; for (let i = 0, s = this.points.length; i < s; i++) { const a = this.points[i]; e.points.push(a.toArray()) } return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e } fromJSON(e) { super.fromJSON(e), this.points = []; for (let i = 0, s = e.points.length; i < s; i++) { const a = e.points[i]; this.points.push(new Vector3().fromArray(a)) } return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this } } function CatmullRom(r, e, i, s, a) { const o = (s - e) * .5, l = (a - i) * .5, c = r * r, h = r * c; return (2 * i - 2 * s + o + l) * h + (-3 * i + 3 * s - 2 * o - l) * c + o * r + i } function QuadraticBezierP0(r, e) { const i = 1 - r; return i * i * e } function QuadraticBezierP1(r, e) { return 2 * (1 - r) * r * e } function QuadraticBezierP2(r, e) { return r * r * e } function QuadraticBezier(r, e, i, s) { return QuadraticBezierP0(r, e) + QuadraticBezierP1(r, i) + QuadraticBezierP2(r, s) } function CubicBezierP0(r, e) { const i = 1 - r; return i * i * i * e } function CubicBezierP1(r, e) { const i = 1 - r; return 3 * i * i * r * e } function CubicBezierP2(r, e) { return 3 * (1 - r) * r * r * e } function CubicBezierP3(r, e) { return r * r * r * e } function CubicBezier(r, e, i, s, a) { return CubicBezierP0(r, e) + CubicBezierP1(r, i) + CubicBezierP2(r, s) + CubicBezierP3(r, a) } class CubicBezierCurve extends Curve { constructor(e = new Vector2, i = new Vector2, s = new Vector2, a = new Vector2) { super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = i, this.v2 = s, this.v3 = a } getPoint(e, i = new Vector2) { const s = i, a = this.v0, o = this.v1, l = this.v2, c = this.v3; return s.set(CubicBezier(e, a.x, o.x, l.x, c.x), CubicBezier(e, a.y, o.y, l.y, c.y)), s } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this } } class CubicBezierCurve3 extends Curve { constructor(e = new Vector3, i = new Vector3, s = new Vector3, a = new Vector3) { super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = i, this.v2 = s, this.v3 = a } getPoint(e, i = new Vector3) { const s = i, a = this.v0, o = this.v1, l = this.v2, c = this.v3; return s.set(CubicBezier(e, a.x, o.x, l.x, c.x), CubicBezier(e, a.y, o.y, l.y, c.y), CubicBezier(e, a.z, o.z, l.z, c.z)), s } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this } } class LineCurve extends Curve { constructor(e = new Vector2, i = new Vector2) { super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = i } getPoint(e, i = new Vector2) { const s = i; return e === 1 ? s.copy(this.v2) : (s.copy(this.v2).sub(this.v1), s.multiplyScalar(e).add(this.v1)), s } getPointAt(e, i) { return this.getPoint(e, i) } getTangent(e, i = new Vector2) { return i.subVectors(this.v2, this.v1).normalize() } getTangentAt(e, i) { return this.getTangent(e, i) } copy(e) { return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } class LineCurve3 extends Curve { constructor(e = new Vector3, i = new Vector3) { super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = i } getPoint(e, i = new Vector3) { const s = i; return e === 1 ? s.copy(this.v2) : (s.copy(this.v2).sub(this.v1), s.multiplyScalar(e).add(this.v1)), s } getPointAt(e, i) { return this.getPoint(e, i) } getTangent(e, i = new Vector3) { return i.subVectors(this.v2, this.v1).normalize() } getTangentAt(e, i) { return this.getTangent(e, i) } copy(e) { return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } class QuadraticBezierCurve extends Curve { constructor(e = new Vector2, i = new Vector2, s = new Vector2) { super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = i, this.v2 = s } getPoint(e, i = new Vector2) { const s = i, a = this.v0, o = this.v1, l = this.v2; return s.set(QuadraticBezier(e, a.x, o.x, l.x), QuadraticBezier(e, a.y, o.y, l.y)), s } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } class QuadraticBezierCurve3 extends Curve { constructor(e = new Vector3, i = new Vector3, s = new Vector3) { super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = i, this.v2 = s } getPoint(e, i = new Vector3) { const s = i, a = this.v0, o = this.v1, l = this.v2; return s.set(QuadraticBezier(e, a.x, o.x, l.x), QuadraticBezier(e, a.y, o.y, l.y), QuadraticBezier(e, a.z, o.z, l.z)), s } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } class SplineCurve extends Curve { constructor(e = []) { super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e } getPoint(e, i = new Vector2) { const s = i, a = this.points, o = (a.length - 1) * e, l = Math.floor(o), c = o - l, h = a[l === 0 ? l : l - 1], d = a[l], p = a[l > a.length - 2 ? a.length - 1 : l + 1], f = a[l > a.length - 3 ? a.length - 1 : l + 2]; return s.set(CatmullRom(c, h.x, d.x, p.x, f.x), CatmullRom(c, h.y, d.y, p.y, f.y)), s } copy(e) { super.copy(e), this.points = []; for (let i = 0, s = e.points.length; i < s; i++) { const a = e.points[i]; this.points.push(a.clone()) } return this } toJSON() { const e = super.toJSON(); e.points = []; for (let i = 0, s = this.points.length; i < s; i++) { const a = this.points[i]; e.points.push(a.toArray()) } return e } fromJSON(e) { super.fromJSON(e), this.points = []; for (let i = 0, s = e.points.length; i < s; i++) { const a = e.points[i]; this.points.push(new Vector2().fromArray(a)) } return this } } var Curves = Object.freeze({ __proto__: null, ArcCurve, CatmullRomCurve3, CubicBezierCurve, CubicBezierCurve3, EllipseCurve, LineCurve, LineCurve3, QuadraticBezierCurve, QuadraticBezierCurve3, SplineCurve }); class CurvePath extends Curve { constructor() { super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1 } add(e) { this.curves.push(e) } closePath() { const e = this.curves[0].getPoint(0), i = this.curves[this.curves.length - 1].getPoint(1); if (!e.equals(i)) { const s = e.isVector2 === !0 ? "LineCurve" : "LineCurve3"; this.curves.push(new Curves[s](i, e)) } return this } getPoint(e, i) { const s = e * this.getLength(), a = this.getCurveLengths(); let o = 0; for (; o < a.length;) { if (a[o] >= s) { const l = a[o] - s, c = this.curves[o], h = c.getLength(), d = h === 0 ? 0 : 1 - l / h; return c.getPointAt(d, i) } o++ } return null } getLength() { const e = this.getCurveLengths(); return e[e.length - 1] } updateArcLengths() { this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths() } getCurveLengths() { if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths; const e = []; let i = 0; for (let s = 0, a = this.curves.length; s < a; s++)i += this.curves[s].getLength(), e.push(i); return this.cacheLengths = e, e } getSpacedPoints(e = 40) { const i = []; for (let s = 0; s <= e; s++)i.push(this.getPoint(s / e)); return this.autoClose && i.push(i[0]), i } getPoints(e = 12) { const i = []; let s; for (let a = 0, o = this.curves; a < o.length; a++) { const l = o[a], c = l.isEllipseCurve ? e * 2 : l.isLineCurve || l.isLineCurve3 ? 1 : l.isSplineCurve ? e * l.points.length : e, h = l.getPoints(c); for (let d = 0; d < h.length; d++) { const p = h[d]; s && s.equals(p) || (i.push(p), s = p) } } return this.autoClose && i.length > 1 && !i[i.length - 1].equals(i[0]) && i.push(i[0]), i } copy(e) { super.copy(e), this.curves = []; for (let i = 0, s = e.curves.length; i < s; i++) { const a = e.curves[i]; this.curves.push(a.clone()) } return this.autoClose = e.autoClose, this } toJSON() { const e = super.toJSON(); e.autoClose = this.autoClose, e.curves = []; for (let i = 0, s = this.curves.length; i < s; i++) { const a = this.curves[i]; e.curves.push(a.toJSON()) } return e } fromJSON(e) { super.fromJSON(e), this.autoClose = e.autoClose, this.curves = []; for (let i = 0, s = e.curves.length; i < s; i++) { const a = e.curves[i]; this.curves.push(new Curves[a.type]().fromJSON(a)) } return this } } class Path extends CurvePath { constructor(e) { super(), this.type = "Path", this.currentPoint = new Vector2, e && this.setFromPoints(e) } setFromPoints(e) { this.moveTo(e[0].x, e[0].y); for (let i = 1, s = e.length; i < s; i++)this.lineTo(e[i].x, e[i].y); return this } moveTo(e, i) { return this.currentPoint.set(e, i), this } lineTo(e, i) { const s = new LineCurve(this.currentPoint.clone(), new Vector2(e, i)); return this.curves.push(s), this.currentPoint.set(e, i), this } quadraticCurveTo(e, i, s, a) { const o = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(e, i), new Vector2(s, a)); return this.curves.push(o), this.currentPoint.set(s, a), this } bezierCurveTo(e, i, s, a, o, l) { const c = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(e, i), new Vector2(s, a), new Vector2(o, l)); return this.curves.push(c), this.currentPoint.set(o, l), this } splineThru(e) { const i = [this.currentPoint.clone()].concat(e), s = new SplineCurve(i); return this.curves.push(s), this.currentPoint.copy(e[e.length - 1]), this } arc(e, i, s, a, o, l) { const c = this.currentPoint.x, h = this.currentPoint.y; return this.absarc(e + c, i + h, s, a, o, l), this } absarc(e, i, s, a, o, l) { return this.absellipse(e, i, s, s, a, o, l), this } ellipse(e, i, s, a, o, l, c, h) { const d = this.currentPoint.x, p = this.currentPoint.y; return this.absellipse(e + d, i + p, s, a, o, l, c, h), this } absellipse(e, i, s, a, o, l, c, h) { const d = new EllipseCurve(e, i, s, a, o, l, c, h); if (this.curves.length > 0) { const f = d.getPoint(0); f.equals(this.currentPoint) || this.lineTo(f.x, f.y) } this.curves.push(d); const p = d.getPoint(1); return this.currentPoint.copy(p), this } copy(e) { return super.copy(e), this.currentPoint.copy(e.currentPoint), this } toJSON() { const e = super.toJSON(); return e.currentPoint = this.currentPoint.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this } } class Shape extends Path { constructor(e) { super(e), this.uuid = generateUUID(), this.type = "Shape", this.holes = [] } getPointsHoles(e) { const i = []; for (let s = 0, a = this.holes.length; s < a; s++)i[s] = this.holes[s].getPoints(e); return i } extractPoints(e) { return { shape: this.getPoints(e), holes: this.getPointsHoles(e) } } copy(e) { super.copy(e), this.holes = []; for (let i = 0, s = e.holes.length; i < s; i++) { const a = e.holes[i]; this.holes.push(a.clone()) } return this } toJSON() { const e = super.toJSON(); e.uuid = this.uuid, e.holes = []; for (let i = 0, s = this.holes.length; i < s; i++) { const a = this.holes[i]; e.holes.push(a.toJSON()) } return e } fromJSON(e) { super.fromJSON(e), this.uuid = e.uuid, this.holes = []; for (let i = 0, s = e.holes.length; i < s; i++) { const a = e.holes[i]; this.holes.push(new Path().fromJSON(a)) } return this } } function earcut(r, e, i = 2) { const s = e && e.length, a = s ? e[0] * i : r.length; let o = linkedList(r, 0, a, i, !0); const l = []; if (!o || o.next === o.prev) return l; let c, h, d; if (s && (o = eliminateHoles(r, e, o, i)), r.length > 80 * i) { c = 1 / 0, h = 1 / 0; let p = -1 / 0, f = -1 / 0; for (let _ = i; _ < a; _ += i) { const x = r[_], b = r[_ + 1]; x < c && (c = x), b < h && (h = b), x > p && (p = x), b > f && (f = b) } d = Math.max(p - c, f - h), d = d !== 0 ? 32767 / d : 0 } return earcutLinked(o, l, i, c, h, d, 0), l } function linkedList(r, e, i, s, a) { let o; if (a === signedArea(r, e, i, s) > 0) for (let l = e; l < i; l += s)o = insertNode(l / s | 0, r[l], r[l + 1], o); else for (let l = i - s; l >= e; l -= s)o = insertNode(l / s | 0, r[l], r[l + 1], o); return o && equals(o, o.next) && (removeNode(o), o = o.next), o } function filterPoints(r, e) { if (!r) return r; e || (e = r); let i = r, s; do if (s = !1, !i.steiner && (equals(i, i.next) || area(i.prev, i, i.next) === 0)) { if (removeNode(i), i = e = i.prev, i === i.next) break; s = !0 } else i = i.next; while (s || i !== e); return e } function earcutLinked(r, e, i, s, a, o, l) { if (!r) return; !l && o && indexCurve(r, s, a, o); let c = r; for (; r.prev !== r.next;) { const h = r.prev, d = r.next; if (o ? isEarHashed(r, s, a, o) : isEar(r)) { e.push(h.i, r.i, d.i), removeNode(r), r = d.next, c = d.next; continue } if (r = d, r === c) { l ? l === 1 ? (r = cureLocalIntersections(filterPoints(r), e), earcutLinked(r, e, i, s, a, o, 2)) : l === 2 && splitEarcut(r, e, i, s, a, o) : earcutLinked(filterPoints(r), e, i, s, a, o, 1); break } } } function isEar(r) { const e = r.prev, i = r, s = r.next; if (area(e, i, s) >= 0) return !1; const a = e.x, o = i.x, l = s.x, c = e.y, h = i.y, d = s.y, p = Math.min(a, o, l), f = Math.min(c, h, d), _ = Math.max(a, o, l), x = Math.max(c, h, d); let b = s.next; for (; b !== e;) { if (b.x >= p && b.x <= _ && b.y >= f && b.y <= x && pointInTriangleExceptFirst(a, c, o, h, l, d, b.x, b.y) && area(b.prev, b, b.next) >= 0) return !1; b = b.next } return !0 } function isEarHashed(r, e, i, s) { const a = r.prev, o = r, l = r.next; if (area(a, o, l) >= 0) return !1; const c = a.x, h = o.x, d = l.x, p = a.y, f = o.y, _ = l.y, x = Math.min(c, h, d), b = Math.min(p, f, _), T = Math.max(c, h, d), M = Math.max(p, f, _), w = zOrder(x, b, e, i, s), D = zOrder(T, M, e, i, s); let R = r.prevZ, P = r.nextZ; for (; R && R.z >= w && P && P.z <= D;) { if (R.x >= x && R.x <= T && R.y >= b && R.y <= M && R !== a && R !== l && pointInTriangleExceptFirst(c, p, h, f, d, _, R.x, R.y) && area(R.prev, R, R.next) >= 0 || (R = R.prevZ, P.x >= x && P.x <= T && P.y >= b && P.y <= M && P !== a && P !== l && pointInTriangleExceptFirst(c, p, h, f, d, _, P.x, P.y) && area(P.prev, P, P.next) >= 0)) return !1; P = P.nextZ } for (; R && R.z >= w;) { if (R.x >= x && R.x <= T && R.y >= b && R.y <= M && R !== a && R !== l && pointInTriangleExceptFirst(c, p, h, f, d, _, R.x, R.y) && area(R.prev, R, R.next) >= 0) return !1; R = R.prevZ } for (; P && P.z <= D;) { if (P.x >= x && P.x <= T && P.y >= b && P.y <= M && P !== a && P !== l && pointInTriangleExceptFirst(c, p, h, f, d, _, P.x, P.y) && area(P.prev, P, P.next) >= 0) return !1; P = P.nextZ } return !0 } function cureLocalIntersections(r, e) { let i = r; do { const s = i.prev, a = i.next.next; !equals(s, a) && intersects(s, i, i.next, a) && locallyInside(s, a) && locallyInside(a, s) && (e.push(s.i, i.i, a.i), removeNode(i), removeNode(i.next), i = r = a), i = i.next } while (i !== r); return filterPoints(i) } function splitEarcut(r, e, i, s, a, o) { let l = r; do { let c = l.next.next; for (; c !== l.prev;) { if (l.i !== c.i && isValidDiagonal(l, c)) { let h = splitPolygon(l, c); l = filterPoints(l, l.next), h = filterPoints(h, h.next), earcutLinked(l, e, i, s, a, o, 0), earcutLinked(h, e, i, s, a, o, 0); return } c = c.next } l = l.next } while (l !== r) } function eliminateHoles(r, e, i, s) { const a = []; for (let o = 0, l = e.length; o < l; o++) { const c = e[o] * s, h = o < l - 1 ? e[o + 1] * s : r.length, d = linkedList(r, c, h, s, !1); d === d.next && (d.steiner = !0), a.push(getLeftmost(d)) } a.sort(compareXYSlope); for (let o = 0; o < a.length; o++)i = eliminateHole(a[o], i); return i } function compareXYSlope(r, e) { let i = r.x - e.x; if (i === 0 && (i = r.y - e.y, i === 0)) { const s = (r.next.y - r.y) / (r.next.x - r.x), a = (e.next.y - e.y) / (e.next.x - e.x); i = s - a } return i } function eliminateHole(r, e) { const i = findHoleBridge(r, e); if (!i) return e; const s = splitPolygon(i, r); return filterPoints(s, s.next), filterPoints(i, i.next) } function findHoleBridge(r, e) { let i = e; const s = r.x, a = r.y; let o = -1 / 0, l; if (equals(r, i)) return i; do { if (equals(r, i.next)) return i.next; if (a <= i.y && a >= i.next.y && i.next.y !== i.y) { const f = i.x + (a - i.y) * (i.next.x - i.x) / (i.next.y - i.y); if (f <= s && f > o && (o = f, l = i.x < i.next.x ? i : i.next, f === s)) return l } i = i.next } while (i !== e); if (!l) return null; const c = l, h = l.x, d = l.y; let p = 1 / 0; i = l; do { if (s >= i.x && i.x >= h && s !== i.x && pointInTriangle(a < d ? s : o, a, h, d, a < d ? o : s, a, i.x, i.y)) { const f = Math.abs(a - i.y) / (s - i.x); locallyInside(i, r) && (f < p || f === p && (i.x > l.x || i.x === l.x && sectorContainsSector(l, i))) && (l = i, p = f) } i = i.next } while (i !== c); return l } function sectorContainsSector(r, e) { return area(r.prev, r, e.prev) < 0 && area(e.next, r, r.next) < 0 } function indexCurve(r, e, i, s) { let a = r; do a.z === 0 && (a.z = zOrder(a.x, a.y, e, i, s)), a.prevZ = a.prev, a.nextZ = a.next, a = a.next; while (a !== r); a.prevZ.nextZ = null, a.prevZ = null, sortLinked(a) } function sortLinked(r) { let e, i = 1; do { let s = r, a; r = null; let o = null; for (e = 0; s;) { e++; let l = s, c = 0; for (let d = 0; d < i && (c++, l = l.nextZ, !!l); d++); let h = i; for (; c > 0 || h > 0 && l;)c !== 0 && (h === 0 || !l || s.z <= l.z) ? (a = s, s = s.nextZ, c--) : (a = l, l = l.nextZ, h--), o ? o.nextZ = a : r = a, a.prevZ = o, o = a; s = l } o.nextZ = null, i *= 2 } while (e > 1); return r } function zOrder(r, e, i, s, a) { return r = (r - i) * a | 0, e = (e - s) * a | 0, r = (r | r << 8) & 16711935, r = (r | r << 4) & 252645135, r = (r | r << 2) & 858993459, r = (r | r << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, r | e << 1 } function getLeftmost(r) { let e = r, i = r; do (e.x < i.x || e.x === i.x && e.y < i.y) && (i = e), e = e.next; while (e !== r); return i } function pointInTriangle(r, e, i, s, a, o, l, c) { return (a - l) * (e - c) >= (r - l) * (o - c) && (r - l) * (s - c) >= (i - l) * (e - c) && (i - l) * (o - c) >= (a - l) * (s - c) } function pointInTriangleExceptFirst(r, e, i, s, a, o, l, c) { return !(r === l && e === c) && pointInTriangle(r, e, i, s, a, o, l, c) } function isValidDiagonal(r, e) { return r.next.i !== e.i && r.prev.i !== e.i && !intersectsPolygon(r, e) && (locallyInside(r, e) && locallyInside(e, r) && middleInside(r, e) && (area(r.prev, r, e.prev) || area(r, e.prev, e)) || equals(r, e) && area(r.prev, r, r.next) > 0 && area(e.prev, e, e.next) > 0) } function area(r, e, i) { return (e.y - r.y) * (i.x - e.x) - (e.x - r.x) * (i.y - e.y) } function equals(r, e) { return r.x === e.x && r.y === e.y } function intersects(r, e, i, s) { const a = sign(area(r, e, i)), o = sign(area(r, e, s)), l = sign(area(i, s, r)), c = sign(area(i, s, e)); return !!(a !== o && l !== c || a === 0 && onSegment(r, i, e) || o === 0 && onSegment(r, s, e) || l === 0 && onSegment(i, r, s) || c === 0 && onSegment(i, e, s)) } function onSegment(r, e, i) { return e.x <= Math.max(r.x, i.x) && e.x >= Math.min(r.x, i.x) && e.y <= Math.max(r.y, i.y) && e.y >= Math.min(r.y, i.y) } function sign(r) { return r > 0 ? 1 : r < 0 ? -1 : 0 } function intersectsPolygon(r, e) { let i = r; do { if (i.i !== r.i && i.next.i !== r.i && i.i !== e.i && i.next.i !== e.i && intersects(i, i.next, r, e)) return !0; i = i.next } while (i !== r); return !1 } function locallyInside(r, e) { return area(r.prev, r, r.next) < 0 ? area(r, e, r.next) >= 0 && area(r, r.prev, e) >= 0 : area(r, e, r.prev) < 0 || area(r, r.next, e) < 0 } function middleInside(r, e) { let i = r, s = !1; const a = (r.x + e.x) / 2, o = (r.y + e.y) / 2; do i.y > o != i.next.y > o && i.next.y !== i.y && a < (i.next.x - i.x) * (o - i.y) / (i.next.y - i.y) + i.x && (s = !s), i = i.next; while (i !== r); return s } function splitPolygon(r, e) { const i = createNode(r.i, r.x, r.y), s = createNode(e.i, e.x, e.y), a = r.next, o = e.prev; return r.next = e, e.prev = r, i.next = a, a.prev = i, s.next = i, i.prev = s, o.next = s, s.prev = o, s } function insertNode(r, e, i, s) { const a = createNode(r, e, i); return s ? (a.next = s.next, a.prev = s, s.next.prev = a, s.next = a) : (a.prev = a, a.next = a), a } function removeNode(r) { r.next.prev = r.prev, r.prev.next = r.next, r.prevZ && (r.prevZ.nextZ = r.nextZ), r.nextZ && (r.nextZ.prevZ = r.prevZ) } function createNode(r, e, i) { return { i: r, x: e, y: i, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: !1 } } function signedArea(r, e, i, s) { let a = 0; for (let o = e, l = i - s; o < i; o += s)a += (r[l] - r[o]) * (r[o + 1] + r[l + 1]), l = o; return a } class Earcut { static triangulate(e, i, s = 2) { return earcut(e, i, s) } } class ShapeUtils { static area(e) { const i = e.length; let s = 0; for (let a = i - 1, o = 0; o < i; a = o++)s += e[a].x * e[o].y - e[o].x * e[a].y; return s * .5 } static isClockWise(e) { return ShapeUtils.area(e) < 0 } static triangulateShape(e, i) { const s = [], a = [], o = []; removeDupEndPts(e), addContour(s, e); let l = e.length; i.forEach(removeDupEndPts); for (let h = 0; h < i.length; h++)a.push(l), l += i[h].length, addContour(s, i[h]); const c = Earcut.triangulate(s, a); for (let h = 0; h < c.length; h += 3)o.push(c.slice(h, h + 3)); return o } } function removeDupEndPts(r) { const e = r.length; e > 2 && r[e - 1].equals(r[0]) && r.pop() } function addContour(r, e) { for (let i = 0; i < e.length; i++)r.push(e[i].x), r.push(e[i].y) } class PlaneGeometry extends BufferGeometry { constructor(e = 1, i = 1, s = 1, a = 1) { super(), this.type = "PlaneGeometry", this.parameters = { width: e, height: i, widthSegments: s, heightSegments: a }; const o = e / 2, l = i / 2, c = Math.floor(s), h = Math.floor(a), d = c + 1, p = h + 1, f = e / c, _ = i / h, x = [], b = [], T = [], M = []; for (let w = 0; w < p; w++) { const D = w * _ - l; for (let R = 0; R < d; R++) { const P = R * f - o; b.push(P, -D, 0), T.push(0, 0, 1), M.push(R / c), M.push(1 - w / h) } } for (let w = 0; w < h; w++)for (let D = 0; D < c; D++) { const R = D + d * w, P = D + d * (w + 1), U = D + 1 + d * (w + 1), O = D + 1 + d * w; x.push(R, P, O), x.push(P, U, O) } this.setIndex(x), this.setAttribute("position", new Float32BufferAttribute(b, 3)), this.setAttribute("normal", new Float32BufferAttribute(T, 3)), this.setAttribute("uv", new Float32BufferAttribute(M, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new PlaneGeometry(e.width, e.height, e.widthSegments, e.heightSegments) } } class SphereGeometry extends BufferGeometry { constructor(e = 1, i = 32, s = 16, a = 0, o = Math.PI * 2, l = 0, c = Math.PI) { super(), this.type = "SphereGeometry", this.parameters = { radius: e, widthSegments: i, heightSegments: s, phiStart: a, phiLength: o, thetaStart: l, thetaLength: c }, i = Math.max(3, Math.floor(i)), s = Math.max(2, Math.floor(s)); const h = Math.min(l + c, Math.PI); let d = 0; const p = [], f = new Vector3, _ = new Vector3, x = [], b = [], T = [], M = []; for (let w = 0; w <= s; w++) { const D = [], R = w / s; let P = 0; w === 0 && l === 0 ? P = .5 / i : w === s && h === Math.PI && (P = -.5 / i); for (let U = 0; U <= i; U++) { const O = U / i; f.x = -e * Math.cos(a + O * o) * Math.sin(l + R * c), f.y = e * Math.cos(l + R * c), f.z = e * Math.sin(a + O * o) * Math.sin(l + R * c), b.push(f.x, f.y, f.z), _.copy(f).normalize(), T.push(_.x, _.y, _.z), M.push(O + P, 1 - R), D.push(d++) } p.push(D) } for (let w = 0; w < s; w++)for (let D = 0; D < i; D++) { const R = p[w][D + 1], P = p[w][D], U = p[w + 1][D], O = p[w + 1][D + 1]; (w !== 0 || l > 0) && x.push(R, P, O), (w !== s - 1 || h < Math.PI) && x.push(P, U, O) } this.setIndex(x), this.setAttribute("position", new Float32BufferAttribute(b, 3)), this.setAttribute("normal", new Float32BufferAttribute(T, 3)), this.setAttribute("uv", new Float32BufferAttribute(M, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new SphereGeometry(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength) } } class MeshStandardMaterial extends Material { constructor(e) { super(), this.isMeshStandardMaterial = !0, this.type = "MeshStandardMaterial", this.defines = { STANDARD: "" }, this.color = new Color(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Euler, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this } } class MeshPhysicalMaterial extends MeshStandardMaterial { constructor(e) { super(), this.isMeshPhysicalMaterial = !0, this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Vector2(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", { get: function () { return clamp(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1) }, set: function (i) { this.ior = (1 + .4 * i) / (1 - .4 * i) } }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new Color(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new Color(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Color(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e) } get anisotropy() { return this._anisotropy } set anisotropy(e) { this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e } get clearcoat() { return this._clearcoat } set clearcoat(e) { this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e } get iridescence() { return this._iridescence } set iridescence(e) { this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e } get dispersion() { return this._dispersion } set dispersion(e) { this._dispersion > 0 != e > 0 && this.version++, this._dispersion = e } get sheen() { return this._sheen } set sheen(e) { this._sheen > 0 != e > 0 && this.version++, this._sheen = e } get transmission() { return this._transmission } set transmission(e) { this._transmission > 0 != e > 0 && this.version++, this._transmission = e } copy(e) { return super.copy(e), this.defines = { STANDARD: "", PHYSICAL: "" }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.dispersion = e.dispersion, this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this } } class MeshNormalMaterial extends Material { constructor(e) { super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e) } copy(e) { return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this } } class MeshDepthMaterial extends Material { constructor(e) { super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = BasicDepthPacking, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e) } copy(e) { return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this } } class MeshDistanceMaterial extends Material { constructor(e) { super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e) } copy(e) { return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this } } function convertArray(r, e) { return !r || r.constructor === e ? r : typeof e.BYTES_PER_ELEMENT == "number" ? new e(r) : Array.prototype.slice.call(r) } function isTypedArray(r) { return ArrayBuffer.isView(r) && !(r instanceof DataView) } function getKeyframeOrder(r) { function e(a, o) { return r[a] - r[o] } const i = r.length, s = new Array(i); for (let a = 0; a !== i; ++a)s[a] = a; return s.sort(e), s } function sortedArray(r, e, i) { const s = r.length, a = new r.constructor(s); for (let o = 0, l = 0; l !== s; ++o) { const c = i[o] * e; for (let h = 0; h !== e; ++h)a[l++] = r[c + h] } return a } function flattenJSON(r, e, i, s) { let a = 1, o = r[0]; for (; o !== void 0 && o[s] === void 0;)o = r[a++]; if (o === void 0) return; let l = o[s]; if (l !== void 0) if (Array.isArray(l)) do l = o[s], l !== void 0 && (e.push(o.time), i.push(...l)), o = r[a++]; while (o !== void 0); else if (l.toArray !== void 0) do l = o[s], l !== void 0 && (e.push(o.time), l.toArray(i, i.length)), o = r[a++]; while (o !== void 0); else do l = o[s], l !== void 0 && (e.push(o.time), i.push(l)), o = r[a++]; while (o !== void 0) } class Interpolant { constructor(e, i, s, a) { this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = a !== void 0 ? a : new i.constructor(s), this.sampleValues = i, this.valueSize = s, this.settings = null, this.DefaultSettings_ = {} } evaluate(e) { const i = this.parameterPositions; let s = this._cachedIndex, a = i[s], o = i[s - 1]; e: { t: { let l; i: { n: if (!(e < a)) { for (let c = s + 2; ;) { if (a === void 0) { if (e < o) break n; return s = i.length, this._cachedIndex = s, this.copySampleValue_(s - 1) } if (s === c) break; if (o = a, a = i[++s], e < a) break t } l = i.length; break i } if (!(e >= o)) { const c = i[1]; e < c && (s = 2, o = c); for (let h = s - 2; ;) { if (o === void 0) return this._cachedIndex = 0, this.copySampleValue_(0); if (s === h) break; if (a = o, o = i[--s - 1], e >= o) break t } l = s, s = 0; break i } break e } for (; s < l;) { const c = s + l >>> 1; e < i[c] ? l = c : s = c + 1 } if (a = i[s], o = i[s - 1], o === void 0) return this._cachedIndex = 0, this.copySampleValue_(0); if (a === void 0) return s = i.length, this._cachedIndex = s, this.copySampleValue_(s - 1) } this._cachedIndex = s, this.intervalChanged_(s, o, a) } return this.interpolate_(s, o, e, a) } getSettings_() { return this.settings || this.DefaultSettings_ } copySampleValue_(e) { const i = this.resultBuffer, s = this.sampleValues, a = this.valueSize, o = e * a; for (let l = 0; l !== a; ++l)i[l] = s[o + l]; return i } interpolate_() { throw new Error("call to abstract method") } intervalChanged_() { } } class CubicInterpolant extends Interpolant { constructor(e, i, s, a) { super(e, i, s, a), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = { endingStart: ZeroCurvatureEnding, endingEnd: ZeroCurvatureEnding } } intervalChanged_(e, i, s) { const a = this.parameterPositions; let o = e - 2, l = e + 1, c = a[o], h = a[l]; if (c === void 0) switch (this.getSettings_().endingStart) { case ZeroSlopeEnding: o = e, c = 2 * i - s; break; case WrapAroundEnding: o = a.length - 2, c = i + a[o] - a[o + 1]; break; default: o = e, c = s }if (h === void 0) switch (this.getSettings_().endingEnd) { case ZeroSlopeEnding: l = e, h = 2 * s - i; break; case WrapAroundEnding: l = 1, h = s + a[1] - a[0]; break; default: l = e - 1, h = i }const d = (s - i) * .5, p = this.valueSize; this._weightPrev = d / (i - c), this._weightNext = d / (h - s), this._offsetPrev = o * p, this._offsetNext = l * p } interpolate_(e, i, s, a) { const o = this.resultBuffer, l = this.sampleValues, c = this.valueSize, h = e * c, d = h - c, p = this._offsetPrev, f = this._offsetNext, _ = this._weightPrev, x = this._weightNext, b = (s - i) / (a - i), T = b * b, M = T * b, w = -_ * M + 2 * _ * T - _ * b, D = (1 + _) * M + (-1.5 - 2 * _) * T + (-.5 + _) * b + 1, R = (-1 - x) * M + (1.5 + x) * T + .5 * b, P = x * M - x * T; for (let U = 0; U !== c; ++U)o[U] = w * l[p + U] + D * l[d + U] + R * l[h + U] + P * l[f + U]; return o } } class LinearInterpolant extends Interpolant { constructor(e, i, s, a) { super(e, i, s, a) } interpolate_(e, i, s, a) { const o = this.resultBuffer, l = this.sampleValues, c = this.valueSize, h = e * c, d = h - c, p = (s - i) / (a - i), f = 1 - p; for (let _ = 0; _ !== c; ++_)o[_] = l[d + _] * f + l[h + _] * p; return o } } class DiscreteInterpolant extends Interpolant { constructor(e, i, s, a) { super(e, i, s, a) } interpolate_(e) { return this.copySampleValue_(e - 1) } } class KeyframeTrack { constructor(e, i, s, a) { if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined"); if (i === void 0 || i.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e); this.name = e, this.times = convertArray(i, this.TimeBufferType), this.values = convertArray(s, this.ValueBufferType), this.setInterpolation(a || this.DefaultInterpolation) } static toJSON(e) { const i = e.constructor; let s; if (i.toJSON !== this.toJSON) s = i.toJSON(e); else { s = { name: e.name, times: convertArray(e.times, Array), values: convertArray(e.values, Array) }; const a = e.getInterpolation(); a !== e.DefaultInterpolation && (s.interpolation = a) } return s.type = e.ValueTypeName, s } InterpolantFactoryMethodDiscrete(e) { return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), e) } InterpolantFactoryMethodLinear(e) { return new LinearInterpolant(this.times, this.values, this.getValueSize(), e) } InterpolantFactoryMethodSmooth(e) { return new CubicInterpolant(this.times, this.values, this.getValueSize(), e) } setInterpolation(e) { let i; switch (e) { case InterpolateDiscrete: i = this.InterpolantFactoryMethodDiscrete; break; case InterpolateLinear: i = this.InterpolantFactoryMethodLinear; break; case InterpolateSmooth: i = this.InterpolantFactoryMethodSmooth; break }if (i === void 0) { const s = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name; if (this.createInterpolant === void 0) if (e !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation); else throw new Error(s); return console.warn("THREE.KeyframeTrack:", s), this } return this.createInterpolant = i, this } getInterpolation() { switch (this.createInterpolant) { case this.InterpolantFactoryMethodDiscrete: return InterpolateDiscrete; case this.InterpolantFactoryMethodLinear: return InterpolateLinear; case this.InterpolantFactoryMethodSmooth: return InterpolateSmooth } } getValueSize() { return this.values.length / this.times.length } shift(e) { if (e !== 0) { const i = this.times; for (let s = 0, a = i.length; s !== a; ++s)i[s] += e } return this } scale(e) { if (e !== 1) { const i = this.times; for (let s = 0, a = i.length; s !== a; ++s)i[s] *= e } return this } trim(e, i) { const s = this.times, a = s.length; let o = 0, l = a - 1; for (; o !== a && s[o] < e;)++o; for (; l !== -1 && s[l] > i;)--l; if (++l, o !== 0 || l !== a) { o >= l && (l = Math.max(l, 1), o = l - 1); const c = this.getValueSize(); this.times = s.slice(o, l), this.values = this.values.slice(o * c, l * c) } return this } validate() { let e = !0; const i = this.getValueSize(); i - Math.floor(i) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1); const s = this.times, a = this.values, o = s.length; o === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1); let l = null; for (let c = 0; c !== o; c++) { const h = s[c]; if (typeof h == "number" && isNaN(h)) { console.error("THREE.KeyframeTrack: Time is not a valid number.", this, c, h), e = !1; break } if (l !== null && l > h) { console.error("THREE.KeyframeTrack: Out of order keys.", this, c, h, l), e = !1; break } l = h } if (a !== void 0 && isTypedArray(a)) for (let c = 0, h = a.length; c !== h; ++c) { const d = a[c]; if (isNaN(d)) { console.error("THREE.KeyframeTrack: Value is not a valid number.", this, c, d), e = !1; break } } return e } optimize() { const e = this.times.slice(), i = this.values.slice(), s = this.getValueSize(), a = this.getInterpolation() === InterpolateSmooth, o = e.length - 1; let l = 1; for (let c = 1; c < o; ++c) { let h = !1; const d = e[c], p = e[c + 1]; if (d !== p && (c !== 1 || d !== e[0])) if (a) h = !0; else { const f = c * s, _ = f - s, x = f + s; for (let b = 0; b !== s; ++b) { const T = i[f + b]; if (T !== i[_ + b] || T !== i[x + b]) { h = !0; break } } } if (h) { if (c !== l) { e[l] = e[c]; const f = c * s, _ = l * s; for (let x = 0; x !== s; ++x)i[_ + x] = i[f + x] } ++l } } if (o > 0) { e[l] = e[o]; for (let c = o * s, h = l * s, d = 0; d !== s; ++d)i[h + d] = i[c + d]; ++l } return l !== e.length ? (this.times = e.slice(0, l), this.values = i.slice(0, l * s)) : (this.times = e, this.values = i), this } clone() { const e = this.times.slice(), i = this.values.slice(), s = this.constructor, a = new s(this.name, e, i); return a.createInterpolant = this.createInterpolant, a } } KeyframeTrack.prototype.ValueTypeName = ""; KeyframeTrack.prototype.TimeBufferType = Float32Array; KeyframeTrack.prototype.ValueBufferType = Float32Array; KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear; class BooleanKeyframeTrack extends KeyframeTrack { constructor(e, i, s) { super(e, i, s) } } BooleanKeyframeTrack.prototype.ValueTypeName = "bool"; BooleanKeyframeTrack.prototype.ValueBufferType = Array; BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete; BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0; BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0; class ColorKeyframeTrack extends KeyframeTrack { constructor(e, i, s, a) { super(e, i, s, a) } } ColorKeyframeTrack.prototype.ValueTypeName = "color"; class NumberKeyframeTrack extends KeyframeTrack { constructor(e, i, s, a) { super(e, i, s, a) } } NumberKeyframeTrack.prototype.ValueTypeName = "number"; class QuaternionLinearInterpolant extends Interpolant { constructor(e, i, s, a) { super(e, i, s, a) } interpolate_(e, i, s, a) { const o = this.resultBuffer, l = this.sampleValues, c = this.valueSize, h = (s - i) / (a - i); let d = e * c; for (let p = d + c; d !== p; d += 4)Quaternion.slerpFlat(o, 0, l, d - c, l, d, h); return o } } class QuaternionKeyframeTrack extends KeyframeTrack { constructor(e, i, s, a) { super(e, i, s, a) } InterpolantFactoryMethodLinear(e) { return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), e) } } QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion"; QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0; class StringKeyframeTrack extends KeyframeTrack { constructor(e, i, s) { super(e, i, s) } } StringKeyframeTrack.prototype.ValueTypeName = "string"; StringKeyframeTrack.prototype.ValueBufferType = Array; StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete; StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0; StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0; class VectorKeyframeTrack extends KeyframeTrack { constructor(e, i, s, a) { super(e, i, s, a) } } VectorKeyframeTrack.prototype.ValueTypeName = "vector"; class AnimationClip { constructor(e = "", i = -1, s = [], a = NormalAnimationBlendMode) { this.name = e, this.tracks = s, this.duration = i, this.blendMode = a, this.uuid = generateUUID(), this.userData = {}, this.duration < 0 && this.resetDuration() } static parse(e) { const i = [], s = e.tracks, a = 1 / (e.fps || 1); for (let l = 0, c = s.length; l !== c; ++l)i.push(parseKeyframeTrack(s[l]).scale(a)); const o = new this(e.name, e.duration, i, e.blendMode); return o.uuid = e.uuid, o.userData = JSON.parse(e.userData || "{}"), o } static toJSON(e) { const i = [], s = e.tracks, a = { name: e.name, duration: e.duration, tracks: i, uuid: e.uuid, blendMode: e.blendMode, userData: JSON.stringify(e.userData) }; for (let o = 0, l = s.length; o !== l; ++o)i.push(KeyframeTrack.toJSON(s[o])); return a } static CreateFromMorphTargetSequence(e, i, s, a) { const o = i.length, l = []; for (let c = 0; c < o; c++) { let h = [], d = []; h.push((c + o - 1) % o, c, (c + 1) % o), d.push(0, 1, 0); const p = getKeyframeOrder(h); h = sortedArray(h, 1, p), d = sortedArray(d, 1, p), !a && h[0] === 0 && (h.push(o), d.push(d[0])), l.push(new NumberKeyframeTrack(".morphTargetInfluences[" + i[c].name + "]", h, d).scale(1 / s)) } return new this(e, -1, l) } static findByName(e, i) { let s = e; if (!Array.isArray(e)) { const a = e; s = a.geometry && a.geometry.animations || a.animations } for (let a = 0; a < s.length; a++)if (s[a].name === i) return s[a]; return null } static CreateClipsFromMorphTargetSequences(e, i, s) { const a = {}, o = /^([\w-]*?)([\d]+)$/; for (let c = 0, h = e.length; c < h; c++) { const d = e[c], p = d.name.match(o); if (p && p.length > 1) { const f = p[1]; let _ = a[f]; _ || (a[f] = _ = []), _.push(d) } } const l = []; for (const c in a) l.push(this.CreateFromMorphTargetSequence(c, a[c], i, s)); return l } static parseAnimation(e, i) { if (console.warn("THREE.AnimationClip: parseAnimation() is deprecated and will be removed with r185"), !e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null; const s = function (f, _, x, b, T) { if (x.length !== 0) { const M = [], w = []; flattenJSON(x, M, w, b), M.length !== 0 && T.push(new f(_, M, w)) } }, a = [], o = e.name || "default", l = e.fps || 30, c = e.blendMode; let h = e.length || -1; const d = e.hierarchy || []; for (let f = 0; f < d.length; f++) { const _ = d[f].keys; if (!(!_ || _.length === 0)) if (_[0].morphTargets) { const x = {}; let b; for (b = 0; b < _.length; b++)if (_[b].morphTargets) for (let T = 0; T < _[b].morphTargets.length; T++)x[_[b].morphTargets[T]] = -1; for (const T in x) { const M = [], w = []; for (let D = 0; D !== _[b].morphTargets.length; ++D) { const R = _[b]; M.push(R.time), w.push(R.morphTarget === T ? 1 : 0) } a.push(new NumberKeyframeTrack(".morphTargetInfluence[" + T + "]", M, w)) } h = x.length * l } else { const x = ".bones[" + i[f].name + "]"; s(VectorKeyframeTrack, x + ".position", _, "pos", a), s(QuaternionKeyframeTrack, x + ".quaternion", _, "rot", a), s(VectorKeyframeTrack, x + ".scale", _, "scl", a) } } return a.length === 0 ? null : new this(o, h, a, c) } resetDuration() { const e = this.tracks; let i = 0; for (let s = 0, a = e.length; s !== a; ++s) { const o = this.tracks[s]; i = Math.max(i, o.times[o.times.length - 1]) } return this.duration = i, this } trim() { for (let e = 0; e < this.tracks.length; e++)this.tracks[e].trim(0, this.duration); return this } validate() { let e = !0; for (let i = 0; i < this.tracks.length; i++)e = e && this.tracks[i].validate(); return e } optimize() { for (let e = 0; e < this.tracks.length; e++)this.tracks[e].optimize(); return this } clone() { const e = []; for (let s = 0; s < this.tracks.length; s++)e.push(this.tracks[s].clone()); const i = new this.constructor(this.name, this.duration, e, this.blendMode); return i.userData = JSON.parse(JSON.stringify(this.userData)), i } toJSON() { return this.constructor.toJSON(this) } } function getTrackTypeForValueTypeName(r) { switch (r.toLowerCase()) { case "scalar": case "double": case "float": case "number": case "integer": return NumberKeyframeTrack; case "vector": case "vector2": case "vector3": case "vector4": return VectorKeyframeTrack; case "color": return ColorKeyframeTrack; case "quaternion": return QuaternionKeyframeTrack; case "bool": case "boolean": return BooleanKeyframeTrack; case "string": return StringKeyframeTrack }throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + r) } function parseKeyframeTrack(r) { if (r.type === void 0) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse"); const e = getTrackTypeForValueTypeName(r.type); if (r.times === void 0) { const i = [], s = []; flattenJSON(r.keys, i, s, "value"), r.times = i, r.values = s } return e.parse !== void 0 ? e.parse(r) : new e(r.name, r.times, r.values, r.interpolation) } const Cache = { enabled: !1, files: {}, add: function (r, e) { this.enabled !== !1 && (this.files[r] = e) }, get: function (r) { if (this.enabled !== !1) return this.files[r] }, remove: function (r) { delete this.files[r] }, clear: function () { this.files = {} } }; class LoadingManager { constructor(e, i, s) { const a = this; let o = !1, l = 0, c = 0, h; const d = []; this.onStart = void 0, this.onLoad = e, this.onProgress = i, this.onError = s, this.abortController = new AbortController, this.itemStart = function (p) { c++, o === !1 && a.onStart !== void 0 && a.onStart(p, l, c), o = !0 }, this.itemEnd = function (p) { l++, a.onProgress !== void 0 && a.onProgress(p, l, c), l === c && (o = !1, a.onLoad !== void 0 && a.onLoad()) }, this.itemError = function (p) { a.onError !== void 0 && a.onError(p) }, this.resolveURL = function (p) { return h ? h(p) : p }, this.setURLModifier = function (p) { return h = p, this }, this.addHandler = function (p, f) { return d.push(p, f), this }, this.removeHandler = function (p) { const f = d.indexOf(p); return f !== -1 && d.splice(f, 2), this }, this.getHandler = function (p) { for (let f = 0, _ = d.length; f < _; f += 2) { const x = d[f], b = d[f + 1]; if (x.global && (x.lastIndex = 0), x.test(p)) return b } return null }, this.abort = function () { return this.abortController.abort(), this.abortController = new AbortController, this } } } const DefaultLoadingManager = new LoadingManager; let Loader$1 = class { constructor(e) { this.manager = e !== void 0 ? e : DefaultLoadingManager, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {} } load() { } loadAsync(e, i) { const s = this; return new Promise(function (a, o) { s.load(e, a, i, o) }) } parse() { } setCrossOrigin(e) { return this.crossOrigin = e, this } setWithCredentials(e) { return this.withCredentials = e, this } setPath(e) { return this.path = e, this } setResourcePath(e) { return this.resourcePath = e, this } setRequestHeader(e) { return this.requestHeader = e, this } abort() { return this } }; Loader$1.DEFAULT_MATERIAL_NAME = "__DEFAULT"; const loading = {}; class HttpError extends Error { constructor(e, i) { super(e), this.response = i } } class FileLoader extends Loader$1 { constructor(e) { super(e), this.mimeType = "", this.responseType = "", this._abortController = new AbortController } load(e, i, s, a) { e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e); const o = Cache.get(`file:${e}`); if (o !== void 0) return this.manager.itemStart(e), setTimeout(() => { i && i(o), this.manager.itemEnd(e) }, 0), o; if (loading[e] !== void 0) { loading[e].push({ onLoad: i, onProgress: s, onError: a }); return } loading[e] = [], loading[e].push({ onLoad: i, onProgress: s, onError: a }); const l = new Request(e, { headers: new Headers(this.requestHeader), credentials: this.withCredentials ? "include" : "same-origin", signal: typeof AbortSignal.any == "function" ? AbortSignal.any([this._abortController.signal, this.manager.abortController.signal]) : this._abortController.signal }), c = this.mimeType, h = this.responseType; fetch(l).then(d => { if (d.status === 200 || d.status === 0) { if (d.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || d.body === void 0 || d.body.getReader === void 0) return d; const p = loading[e], f = d.body.getReader(), _ = d.headers.get("X-File-Size") || d.headers.get("Content-Length"), x = _ ? parseInt(_) : 0, b = x !== 0; let T = 0; const M = new ReadableStream({ start(w) { D(); function D() { f.read().then(({ done: R, value: P }) => { if (R) w.close(); else { T += P.byteLength; const U = new ProgressEvent("progress", { lengthComputable: b, loaded: T, total: x }); for (let O = 0, N = p.length; O < N; O++) { const H = p[O]; H.onProgress && H.onProgress(U) } w.enqueue(P), D() } }, R => { w.error(R) }) } } }); return new Response(M) } else throw new HttpError(`fetch for "${d.url}" responded with ${d.status}: ${d.statusText}`, d) }).then(d => { switch (h) { case "arraybuffer": return d.arrayBuffer(); case "blob": return d.blob(); case "document": return d.text().then(p => new DOMParser().parseFromString(p, c)); case "json": return d.json(); default: if (c === "") return d.text(); { const f = /charset="?([^;"\s]*)"?/i.exec(c), _ = f && f[1] ? f[1].toLowerCase() : void 0, x = new TextDecoder(_); return d.arrayBuffer().then(b => x.decode(b)) } } }).then(d => { Cache.add(`file:${e}`, d); const p = loading[e]; delete loading[e]; for (let f = 0, _ = p.length; f < _; f++) { const x = p[f]; x.onLoad && x.onLoad(d) } }).catch(d => { const p = loading[e]; if (p === void 0) throw this.manager.itemError(e), d; delete loading[e]; for (let f = 0, _ = p.length; f < _; f++) { const x = p[f]; x.onError && x.onError(d) } this.manager.itemError(e) }).finally(() => { this.manager.itemEnd(e) }), this.manager.itemStart(e) } setResponseType(e) { return this.responseType = e, this } setMimeType(e) { return this.mimeType = e, this } abort() { return this._abortController.abort(), this._abortController = new AbortController, this } } const _loading = new WeakMap; class ImageLoader extends Loader$1 { constructor(e) { super(e) } load(e, i, s, a) { this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e); const o = this, l = Cache.get(`image:${e}`); if (l !== void 0) { if (l.complete === !0) o.manager.itemStart(e), setTimeout(function () { i && i(l), o.manager.itemEnd(e) }, 0); else { let f = _loading.get(l); f === void 0 && (f = [], _loading.set(l, f)), f.push({ onLoad: i, onError: a }) } return l } const c = createElementNS("img"); function h() { p(), i && i(this); const f = _loading.get(this) || []; for (let _ = 0; _ < f.length; _++) { const x = f[_]; x.onLoad && x.onLoad(this) } _loading.delete(this), o.manager.itemEnd(e) } function d(f) { p(), a && a(f), Cache.remove(`image:${e}`); const _ = _loading.get(this) || []; for (let x = 0; x < _.length; x++) { const b = _[x]; b.onError && b.onError(f) } _loading.delete(this), o.manager.itemError(e), o.manager.itemEnd(e) } function p() { c.removeEventListener("load", h, !1), c.removeEventListener("error", d, !1) } return c.addEventListener("load", h, !1), c.addEventListener("error", d, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (c.crossOrigin = this.crossOrigin), Cache.add(`image:${e}`, c), o.manager.itemStart(e), c.src = e, c } } class TextureLoader extends Loader$1 { constructor(e) { super(e) } load(e, i, s, a) { const o = new Texture, l = new ImageLoader(this.manager); return l.setCrossOrigin(this.crossOrigin), l.setPath(this.path), l.load(e, function (c) { o.image = c, o.needsUpdate = !0, i !== void 0 && i(o) }, s, a), o } } class Light extends Object3D { constructor(e, i = 1) { super(), this.isLight = !0, this.type = "Light", this.color = new Color(e), this.intensity = i } dispose() { } copy(e, i) { return super.copy(e, i), this.color.copy(e.color), this.intensity = e.intensity, this } toJSON(e) { const i = super.toJSON(e); return i.object.color = this.color.getHex(), i.object.intensity = this.intensity, this.groundColor !== void 0 && (i.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (i.object.distance = this.distance), this.angle !== void 0 && (i.object.angle = this.angle), this.decay !== void 0 && (i.object.decay = this.decay), this.penumbra !== void 0 && (i.object.penumbra = this.penumbra), this.shadow !== void 0 && (i.object.shadow = this.shadow.toJSON()), this.target !== void 0 && (i.object.target = this.target.uuid), i } } const _projScreenMatrix$1 = new Matrix4, _lightPositionWorld$1 = new Vector3, _lookTarget$1 = new Vector3; class LightShadow { constructor(e) { this.camera = e, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Vector2(512, 512), this.mapType = UnsignedByteType, this.map = null, this.mapPass = null, this.matrix = new Matrix4, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Frustum, this._frameExtents = new Vector2(1, 1), this._viewportCount = 1, this._viewports = [new Vector4(0, 0, 1, 1)] } getViewportCount() { return this._viewportCount } getFrustum() { return this._frustum } updateMatrices(e) { const i = this.camera, s = this.matrix; _lightPositionWorld$1.setFromMatrixPosition(e.matrixWorld), i.position.copy(_lightPositionWorld$1), _lookTarget$1.setFromMatrixPosition(e.target.matrixWorld), i.lookAt(_lookTarget$1), i.updateMatrixWorld(), _projScreenMatrix$1.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this._frustum.setFromProjectionMatrix(_projScreenMatrix$1, i.coordinateSystem, i.reversedDepth), i.reversedDepth ? s.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, 1, 0, 0, 0, 0, 1) : s.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), s.multiply(_projScreenMatrix$1) } getViewport(e) { return this._viewports[e] } getFrameExtents() { return this._frameExtents } dispose() { this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose() } copy(e) { return this.camera = e.camera.clone(), this.intensity = e.intensity, this.bias = e.bias, this.radius = e.radius, this.autoUpdate = e.autoUpdate, this.needsUpdate = e.needsUpdate, this.normalBias = e.normalBias, this.blurSamples = e.blurSamples, this.mapSize.copy(e.mapSize), this } clone() { return new this.constructor().copy(this) } toJSON() { const e = {}; return this.intensity !== 1 && (e.intensity = this.intensity), this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e } } class SpotLightShadow extends LightShadow { constructor() { super(new PerspectiveCamera(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1, this.aspect = 1 } updateMatrices(e) { const i = this.camera, s = RAD2DEG * 2 * e.angle * this.focus, a = this.mapSize.width / this.mapSize.height * this.aspect, o = e.distance || i.far; (s !== i.fov || a !== i.aspect || o !== i.far) && (i.fov = s, i.aspect = a, i.far = o, i.updateProjectionMatrix()), super.updateMatrices(e) } copy(e) { return super.copy(e), this.focus = e.focus, this } } class SpotLight extends Light { constructor(e, i, s = 0, a = Math.PI / 3, o = 0, l = 2) { super(e, i), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(Object3D.DEFAULT_UP), this.updateMatrix(), this.target = new Object3D, this.distance = s, this.angle = a, this.penumbra = o, this.decay = l, this.map = null, this.shadow = new SpotLightShadow } get power() { return this.intensity * Math.PI } set power(e) { this.intensity = e / Math.PI } dispose() { this.shadow.dispose() } copy(e, i) { return super.copy(e, i), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this } } const _projScreenMatrix = new Matrix4, _lightPositionWorld = new Vector3, _lookTarget = new Vector3; class PointLightShadow extends LightShadow { constructor() { super(new PerspectiveCamera(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new Vector2(4, 2), this._viewportCount = 6, this._viewports = [new Vector4(2, 1, 1, 1), new Vector4(0, 1, 1, 1), new Vector4(3, 1, 1, 1), new Vector4(1, 1, 1, 1), new Vector4(3, 0, 1, 1), new Vector4(1, 0, 1, 1)], this._cubeDirections = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)], this._cubeUps = [new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)] } updateMatrices(e, i = 0) { const s = this.camera, a = this.matrix, o = e.distance || s.far; o !== s.far && (s.far = o, s.updateProjectionMatrix()), _lightPositionWorld.setFromMatrixPosition(e.matrixWorld), s.position.copy(_lightPositionWorld), _lookTarget.copy(s.position), _lookTarget.add(this._cubeDirections[i]), s.up.copy(this._cubeUps[i]), s.lookAt(_lookTarget), s.updateMatrixWorld(), a.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z), _projScreenMatrix.multiplyMatrices(s.projectionMatrix, s.matrixWorldInverse), this._frustum.setFromProjectionMatrix(_projScreenMatrix, s.coordinateSystem, s.reversedDepth) } } class PointLight extends Light { constructor(e, i, s = 0, a = 2) { super(e, i), this.isPointLight = !0, this.type = "PointLight", this.distance = s, this.decay = a, this.shadow = new PointLightShadow } get power() { return this.intensity * 4 * Math.PI } set power(e) { this.intensity = e / (4 * Math.PI) } dispose() { this.shadow.dispose() } copy(e, i) { return super.copy(e, i), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this } } class OrthographicCamera extends Camera { constructor(e = -1, i = 1, s = 1, a = -1, o = .1, l = 2e3) { super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = i, this.top = s, this.bottom = a, this.near = o, this.far = l, this.updateProjectionMatrix() } copy(e, i) { return super.copy(e, i), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this } setViewOffset(e, i, s, a, o, l) { this.view === null && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = i, this.view.offsetX = s, this.view.offsetY = a, this.view.width = o, this.view.height = l, this.updateProjectionMatrix() } clearViewOffset() { this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix() } updateProjectionMatrix() { const e = (this.right - this.left) / (2 * this.zoom), i = (this.top - this.bottom) / (2 * this.zoom), s = (this.right + this.left) / 2, a = (this.top + this.bottom) / 2; let o = s - e, l = s + e, c = a + i, h = a - i; if (this.view !== null && this.view.enabled) { const d = (this.right - this.left) / this.view.fullWidth / this.zoom, p = (this.top - this.bottom) / this.view.fullHeight / this.zoom; o += d * this.view.offsetX, l = o + d * this.view.width, c -= p * this.view.offsetY, h = c - p * this.view.height } this.projectionMatrix.makeOrthographic(o, l, c, h, this.near, this.far, this.coordinateSystem, this.reversedDepth), this.projectionMatrixInverse.copy(this.projectionMatrix).invert() } toJSON(e) { const i = super.toJSON(e); return i.object.zoom = this.zoom, i.object.left = this.left, i.object.right = this.right, i.object.top = this.top, i.object.bottom = this.bottom, i.object.near = this.near, i.object.far = this.far, this.view !== null && (i.object.view = Object.assign({}, this.view)), i } } class DirectionalLightShadow extends LightShadow { constructor() { super(new OrthographicCamera(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0 } } class DirectionalLight extends Light { constructor(e, i) { super(e, i), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(Object3D.DEFAULT_UP), this.updateMatrix(), this.target = new Object3D, this.shadow = new DirectionalLightShadow } dispose() { this.shadow.dispose() } copy(e) { return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this } } class LoaderUtils { static extractUrlBase(e) { const i = e.lastIndexOf("/"); return i === -1 ? "./" : e.slice(0, i + 1) } static resolveURL(e, i) { return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(i) && /^\//.test(e) && (i = i.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : i + e) } } class InstancedBufferGeometry extends BufferGeometry { constructor() { super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0 } copy(e) { return super.copy(e), this.instanceCount = e.instanceCount, this } toJSON() { const e = super.toJSON(); return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e } } class BufferGeometryLoader extends Loader$1 { constructor(e) { super(e) } load(e, i, s, a) { const o = this, l = new FileLoader(o.manager); l.setPath(o.path), l.setRequestHeader(o.requestHeader), l.setWithCredentials(o.withCredentials), l.load(e, function (c) { try { i(o.parse(JSON.parse(c))) } catch (h) { a ? a(h) : console.error(h), o.manager.itemError(e) } }, s, a) } parse(e) { const i = {}, s = {}; function a(x, b) { if (i[b] !== void 0) return i[b]; const M = x.interleavedBuffers[b], w = o(x, M.buffer), D = getTypedArray(M.type, w), R = new InterleavedBuffer(D, M.stride); return R.uuid = M.uuid, i[b] = R, R } function o(x, b) { if (s[b] !== void 0) return s[b]; const M = x.arrayBuffers[b], w = new Uint32Array(M).buffer; return s[b] = w, w } const l = e.isInstancedBufferGeometry ? new InstancedBufferGeometry : new BufferGeometry, c = e.data.index; if (c !== void 0) { const x = getTypedArray(c.type, c.array); l.setIndex(new BufferAttribute(x, 1)) } const h = e.data.attributes; for (const x in h) { const b = h[x]; let T; if (b.isInterleavedBufferAttribute) { const M = a(e.data, b.data); T = new InterleavedBufferAttribute(M, b.itemSize, b.offset, b.normalized) } else { const M = getTypedArray(b.type, b.array), w = b.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute; T = new w(M, b.itemSize, b.normalized) } b.name !== void 0 && (T.name = b.name), b.usage !== void 0 && T.setUsage(b.usage), l.setAttribute(x, T) } const d = e.data.morphAttributes; if (d) for (const x in d) { const b = d[x], T = []; for (let M = 0, w = b.length; M < w; M++) { const D = b[M]; let R; if (D.isInterleavedBufferAttribute) { const P = a(e.data, D.data); R = new InterleavedBufferAttribute(P, D.itemSize, D.offset, D.normalized) } else { const P = getTypedArray(D.type, D.array); R = new BufferAttribute(P, D.itemSize, D.normalized) } D.name !== void 0 && (R.name = D.name), T.push(R) } l.morphAttributes[x] = T } e.data.morphTargetsRelative && (l.morphTargetsRelative = !0); const f = e.data.groups || e.data.drawcalls || e.data.offsets; if (f !== void 0) for (let x = 0, b = f.length; x !== b; ++x) { const T = f[x]; l.addGroup(T.start, T.count, T.materialIndex) } const _ = e.data.boundingSphere; return _ !== void 0 && (l.boundingSphere = new Sphere().fromJSON(_)), e.name && (l.name = e.name), e.userData && (l.userData = e.userData), l } } const _errorMap = new WeakMap; class ImageBitmapLoader extends Loader$1 { constructor(e) { super(e), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" }, this._abortController = new AbortController } setOptions(e) { return this.options = e, this } load(e, i, s, a) { e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e); const o = this, l = Cache.get(`image-bitmap:${e}`); if (l !== void 0) { if (o.manager.itemStart(e), l.then) { l.then(d => { if (_errorMap.has(l) === !0) a && a(_errorMap.get(l)), o.manager.itemError(e), o.manager.itemEnd(e); else return i && i(d), o.manager.itemEnd(e), d }); return } return setTimeout(function () { i && i(l), o.manager.itemEnd(e) }, 0), l } const c = {}; c.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", c.headers = this.requestHeader, c.signal = typeof AbortSignal.any == "function" ? AbortSignal.any([this._abortController.signal, this.manager.abortController.signal]) : this._abortController.signal; const h = fetch(e, c).then(function (d) { return d.blob() }).then(function (d) { return createImageBitmap(d, Object.assign(o.options, { colorSpaceConversion: "none" })) }).then(function (d) { return Cache.add(`image-bitmap:${e}`, d), i && i(d), o.manager.itemEnd(e), d }).catch(function (d) { a && a(d), _errorMap.set(h, d), Cache.remove(`image-bitmap:${e}`), o.manager.itemError(e), o.manager.itemEnd(e) }); Cache.add(`image-bitmap:${e}`, h), o.manager.itemStart(e) } abort() { return this._abortController.abort(), this._abortController = new AbortController, this } } let _context; class AudioContext { static getContext() { return _context === void 0 && (_context = new (window.AudioContext || window.webkitAudioContext)), _context } static setContext(e) { _context = e } } class ArrayCamera extends PerspectiveCamera { constructor(e = []) { super(), this.isArrayCamera = !0, this.isMultiViewCamera = !1, this.cameras = e } } class Clock { constructor(e = !0) { this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1 } start() { this.startTime = performance.now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0 } stop() { this.getElapsedTime(), this.running = !1, this.autoStart = !1 } getElapsedTime() { return this.getDelta(), this.elapsedTime } getDelta() { let e = 0; if (this.autoStart && !this.running) return this.start(), 0; if (this.running) { const i = performance.now(); e = (i - this.oldTime) / 1e3, this.oldTime = i, this.elapsedTime += e } return e } } const _position$1 = new Vector3, _quaternion$1 = new Quaternion, _scale$1 = new Vector3, _forward$2 = new Vector3, _up$1 = new Vector3; class AudioListener extends Object3D { constructor() { super(), this.type = "AudioListener", this.context = AudioContext.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new Clock } getInput() { return this.gain } removeFilter() { return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this } getFilter() { return this.filter } setFilter(e) { return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this } getMasterVolume() { return this.gain.gain.value } setMasterVolume(e) { return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this } updateMatrixWorld(e) { super.updateMatrixWorld(e); const i = this.context.listener; if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(_position$1, _quaternion$1, _scale$1), _forward$2.set(0, 0, -1).applyQuaternion(_quaternion$1), _up$1.set(0, 1, 0).applyQuaternion(_quaternion$1), i.positionX) { const s = this.context.currentTime + this.timeDelta; i.positionX.linearRampToValueAtTime(_position$1.x, s), i.positionY.linearRampToValueAtTime(_position$1.y, s), i.positionZ.linearRampToValueAtTime(_position$1.z, s), i.forwardX.linearRampToValueAtTime(_forward$2.x, s), i.forwardY.linearRampToValueAtTime(_forward$2.y, s), i.forwardZ.linearRampToValueAtTime(_forward$2.z, s), i.upX.linearRampToValueAtTime(_up$1.x, s), i.upY.linearRampToValueAtTime(_up$1.y, s), i.upZ.linearRampToValueAtTime(_up$1.z, s) } else i.setPosition(_position$1.x, _position$1.y, _position$1.z), i.setOrientation(_forward$2.x, _forward$2.y, _forward$2.z, _up$1.x, _up$1.y, _up$1.z) } } class Audio extends Object3D { constructor(e) { super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [] } getOutput() { return this.gain } setNodeSource(e) { return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this } setMediaElementSource(e) { return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this } setMediaStreamSource(e) { return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this } setBuffer(e) { return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this } play(e = 0) { if (this.isPlaying === !0) { console.warn("THREE.Audio: Audio is already playing."); return } if (this.hasPlaybackControl === !1) { console.warn("THREE.Audio: this Audio has no playback control."); return } this._startedAt = this.context.currentTime + e; const i = this.context.createBufferSource(); return i.buffer = this.buffer, i.loop = this.loop, i.loopStart = this.loopStart, i.loopEnd = this.loopEnd, i.onended = this.onEnded.bind(this), i.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = i, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect() } pause() { if (this.hasPlaybackControl === !1) { console.warn("THREE.Audio: this Audio has no playback control."); return } return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this } stop(e = 0) { if (this.hasPlaybackControl === !1) { console.warn("THREE.Audio: this Audio has no playback control."); return } return this._progress = 0, this.source !== null && (this.source.stop(this.context.currentTime + e), this.source.onended = null), this.isPlaying = !1, this } connect() { if (this.filters.length > 0) { this.source.connect(this.filters[0]); for (let e = 1, i = this.filters.length; e < i; e++)this.filters[e - 1].connect(this.filters[e]); this.filters[this.filters.length - 1].connect(this.getOutput()) } else this.source.connect(this.getOutput()); return this._connected = !0, this } disconnect() { if (this._connected !== !1) { if (this.filters.length > 0) { this.source.disconnect(this.filters[0]); for (let e = 1, i = this.filters.length; e < i; e++)this.filters[e - 1].disconnect(this.filters[e]); this.filters[this.filters.length - 1].disconnect(this.getOutput()) } else this.source.disconnect(this.getOutput()); return this._connected = !1, this } } getFilters() { return this.filters } setFilters(e) { return e || (e = []), this._connected === !0 ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this } setDetune(e) { return this.detune = e, this.isPlaying === !0 && this.source.detune !== void 0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this } getDetune() { return this.detune } getFilter() { return this.getFilters()[0] } setFilter(e) { return this.setFilters(e ? [e] : []) } setPlaybackRate(e) { if (this.hasPlaybackControl === !1) { console.warn("THREE.Audio: this Audio has no playback control."); return } return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this } getPlaybackRate() { return this.playbackRate } onEnded() { this.isPlaying = !1, this._progress = 0 } getLoop() { return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop } setLoop(e) { if (this.hasPlaybackControl === !1) { console.warn("THREE.Audio: this Audio has no playback control."); return } return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this } setLoopStart(e) { return this.loopStart = e, this } setLoopEnd(e) { return this.loopEnd = e, this } getVolume() { return this.gain.gain.value } setVolume(e) { return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this } copy(e, i) { return super.copy(e, i), e.sourceType !== "buffer" ? (console.warn("THREE.Audio: Audio source type cannot be copied."), this) : (this.autoplay = e.autoplay, this.buffer = e.buffer, this.detune = e.detune, this.loop = e.loop, this.loopStart = e.loopStart, this.loopEnd = e.loopEnd, this.offset = e.offset, this.duration = e.duration, this.playbackRate = e.playbackRate, this.hasPlaybackControl = e.hasPlaybackControl, this.sourceType = e.sourceType, this.filters = e.filters.slice(), this) } clone(e) { return new this.constructor(this.listener).copy(this, e) } } const _position = new Vector3, _quaternion$5 = new Quaternion, _scale = new Vector3, _orientation = new Vector3; class PositionalAudio extends Audio { constructor(e) { super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain) } connect() { return super.connect(), this.panner.connect(this.gain), this } disconnect() { return super.disconnect(), this.panner.disconnect(this.gain), this } getOutput() { return this.panner } getRefDistance() { return this.panner.refDistance } setRefDistance(e) { return this.panner.refDistance = e, this } getRolloffFactor() { return this.panner.rolloffFactor } setRolloffFactor(e) { return this.panner.rolloffFactor = e, this } getDistanceModel() { return this.panner.distanceModel } setDistanceModel(e) { return this.panner.distanceModel = e, this } getMaxDistance() { return this.panner.maxDistance } setMaxDistance(e) { return this.panner.maxDistance = e, this } setDirectionalCone(e, i, s) { return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = i, this.panner.coneOuterGain = s, this } updateMatrixWorld(e) { if (super.updateMatrixWorld(e), this.hasPlaybackControl === !0 && this.isPlaying === !1) return; this.matrixWorld.decompose(_position, _quaternion$5, _scale), _orientation.set(0, 0, 1).applyQuaternion(_quaternion$5); const i = this.panner; if (i.positionX) { const s = this.context.currentTime + this.listener.timeDelta; i.positionX.linearRampToValueAtTime(_position.x, s), i.positionY.linearRampToValueAtTime(_position.y, s), i.positionZ.linearRampToValueAtTime(_position.z, s), i.orientationX.linearRampToValueAtTime(_orientation.x, s), i.orientationY.linearRampToValueAtTime(_orientation.y, s), i.orientationZ.linearRampToValueAtTime(_orientation.z, s) } else i.setPosition(_position.x, _position.y, _position.z), i.setOrientation(_orientation.x, _orientation.y, _orientation.z) } } class PropertyMixer { constructor(e, i, s) { this.binding = e, this.valueSize = s; let a, o, l; switch (i) { case "quaternion": a = this._slerp, o = this._slerpAdditive, l = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(s * 6), this._workIndex = 5; break; case "string": case "bool": a = this._select, o = this._select, l = this._setAdditiveIdentityOther, this.buffer = new Array(s * 5); break; default: a = this._lerp, o = this._lerpAdditive, l = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(s * 5) }this._mixBufferRegion = a, this._mixBufferRegionAdditive = o, this._setIdentity = l, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0 } accumulate(e, i) { const s = this.buffer, a = this.valueSize, o = e * a + a; let l = this.cumulativeWeight; if (l === 0) { for (let c = 0; c !== a; ++c)s[o + c] = s[c]; l = i } else { l += i; const c = i / l; this._mixBufferRegion(s, o, 0, c, a) } this.cumulativeWeight = l } accumulateAdditive(e) { const i = this.buffer, s = this.valueSize, a = s * this._addIndex; this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(i, a, 0, e, s), this.cumulativeWeightAdditive += e } apply(e) { const i = this.valueSize, s = this.buffer, a = e * i + i, o = this.cumulativeWeight, l = this.cumulativeWeightAdditive, c = this.binding; if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, o < 1) { const h = i * this._origIndex; this._mixBufferRegion(s, a, h, 1 - o, i) } l > 0 && this._mixBufferRegionAdditive(s, a, this._addIndex * i, 1, i); for (let h = i, d = i + i; h !== d; ++h)if (s[h] !== s[h + i]) { c.setValue(s, a); break } } saveOriginalState() { const e = this.binding, i = this.buffer, s = this.valueSize, a = s * this._origIndex; e.getValue(i, a); for (let o = s, l = a; o !== l; ++o)i[o] = i[a + o % s]; this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0 } restoreOriginalState() { const e = this.valueSize * 3; this.binding.setValue(this.buffer, e) } _setAdditiveIdentityNumeric() { const e = this._addIndex * this.valueSize, i = e + this.valueSize; for (let s = e; s < i; s++)this.buffer[s] = 0 } _setAdditiveIdentityQuaternion() { this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1 } _setAdditiveIdentityOther() { const e = this._origIndex * this.valueSize, i = this._addIndex * this.valueSize; for (let s = 0; s < this.valueSize; s++)this.buffer[i + s] = this.buffer[e + s] } _select(e, i, s, a, o) { if (a >= .5) for (let l = 0; l !== o; ++l)e[i + l] = e[s + l] } _slerp(e, i, s, a) { Quaternion.slerpFlat(e, i, e, i, e, s, a) } _slerpAdditive(e, i, s, a, o) { const l = this._workIndex * o; Quaternion.multiplyQuaternionsFlat(e, l, e, i, e, s), Quaternion.slerpFlat(e, i, e, i, e, l, a) } _lerp(e, i, s, a, o) { const l = 1 - a; for (let c = 0; c !== o; ++c) { const h = i + c; e[h] = e[h] * l + e[s + c] * a } } _lerpAdditive(e, i, s, a, o) { for (let l = 0; l !== o; ++l) { const c = i + l; e[c] = e[c] + e[s + l] * a } } } const _RESERVED_CHARS_RE = "\\[\\]\\.:\\/", _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g"), _wordChar = "[^" + _RESERVED_CHARS_RE + "]", _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]", _directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar), _nodeRe = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot), _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar), _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar), _trackRe = new RegExp("^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$"), _supportedObjectNames = ["material", "materials", "bones", "map"]; class Composite { constructor(e, i, s) { const a = s || PropertyBinding.parseTrackName(i); this._targetGroup = e, this._bindings = e.subscribe_(i, a) } getValue(e, i) { this.bind(); const s = this._targetGroup.nCachedObjects_, a = this._bindings[s]; a !== void 0 && a.getValue(e, i) } setValue(e, i) { const s = this._bindings; for (let a = this._targetGroup.nCachedObjects_, o = s.length; a !== o; ++a)s[a].setValue(e, i) } bind() { const e = this._bindings; for (let i = this._targetGroup.nCachedObjects_, s = e.length; i !== s; ++i)e[i].bind() } unbind() { const e = this._bindings; for (let i = this._targetGroup.nCachedObjects_, s = e.length; i !== s; ++i)e[i].unbind() } } class PropertyBinding { constructor(e, i, s) { this.path = i, this.parsedPath = s || PropertyBinding.parseTrackName(i), this.node = PropertyBinding.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } static create(e, i, s) { return e && e.isAnimationObjectGroup ? new PropertyBinding.Composite(e, i, s) : new PropertyBinding(e, i, s) } static sanitizeNodeName(e) { return e.replace(/\s/g, "_").replace(_reservedRe, "") } static parseTrackName(e) { const i = _trackRe.exec(e); if (i === null) throw new Error("PropertyBinding: Cannot parse trackName: " + e); const s = { nodeName: i[2], objectName: i[3], objectIndex: i[4], propertyName: i[5], propertyIndex: i[6] }, a = s.nodeName && s.nodeName.lastIndexOf("."); if (a !== void 0 && a !== -1) { const o = s.nodeName.substring(a + 1); _supportedObjectNames.indexOf(o) !== -1 && (s.nodeName = s.nodeName.substring(0, a), s.objectName = o) } if (s.propertyName === null || s.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e); return s } static findNode(e, i) { if (i === void 0 || i === "" || i === "." || i === -1 || i === e.name || i === e.uuid) return e; if (e.skeleton) { const s = e.skeleton.getBoneByName(i); if (s !== void 0) return s } if (e.children) { const s = function (o) { for (let l = 0; l < o.length; l++) { const c = o[l]; if (c.name === i || c.uuid === i) return c; const h = s(c.children); if (h) return h } return null }, a = s(e.children); if (a) return a } return null } _getValue_unavailable() { } _setValue_unavailable() { } _getValue_direct(e, i) { e[i] = this.targetObject[this.propertyName] } _getValue_array(e, i) { const s = this.resolvedProperty; for (let a = 0, o = s.length; a !== o; ++a)e[i++] = s[a] } _getValue_arrayElement(e, i) { e[i] = this.resolvedProperty[this.propertyIndex] } _getValue_toArray(e, i) { this.resolvedProperty.toArray(e, i) } _setValue_direct(e, i) { this.targetObject[this.propertyName] = e[i] } _setValue_direct_setNeedsUpdate(e, i) { this.targetObject[this.propertyName] = e[i], this.targetObject.needsUpdate = !0 } _setValue_direct_setMatrixWorldNeedsUpdate(e, i) { this.targetObject[this.propertyName] = e[i], this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_array(e, i) { const s = this.resolvedProperty; for (let a = 0, o = s.length; a !== o; ++a)s[a] = e[i++] } _setValue_array_setNeedsUpdate(e, i) { const s = this.resolvedProperty; for (let a = 0, o = s.length; a !== o; ++a)s[a] = e[i++]; this.targetObject.needsUpdate = !0 } _setValue_array_setMatrixWorldNeedsUpdate(e, i) { const s = this.resolvedProperty; for (let a = 0, o = s.length; a !== o; ++a)s[a] = e[i++]; this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_arrayElement(e, i) { this.resolvedProperty[this.propertyIndex] = e[i] } _setValue_arrayElement_setNeedsUpdate(e, i) { this.resolvedProperty[this.propertyIndex] = e[i], this.targetObject.needsUpdate = !0 } _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, i) { this.resolvedProperty[this.propertyIndex] = e[i], this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_fromArray(e, i) { this.resolvedProperty.fromArray(e, i) } _setValue_fromArray_setNeedsUpdate(e, i) { this.resolvedProperty.fromArray(e, i), this.targetObject.needsUpdate = !0 } _setValue_fromArray_setMatrixWorldNeedsUpdate(e, i) { this.resolvedProperty.fromArray(e, i), this.targetObject.matrixWorldNeedsUpdate = !0 } _getValue_unbound(e, i) { this.bind(), this.getValue(e, i) } _setValue_unbound(e, i) { this.bind(), this.setValue(e, i) } bind() { let e = this.node; const i = this.parsedPath, s = i.objectName, a = i.propertyName; let o = i.propertyIndex; if (e || (e = PropertyBinding.findNode(this.rootNode, i.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) { console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + "."); return } if (s) { let d = i.objectIndex; switch (s) { case "materials": if (!e.material) { console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); return } if (!e.material.materials) { console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this); return } e = e.material.materials; break; case "bones": if (!e.skeleton) { console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this); return } e = e.skeleton.bones; for (let p = 0; p < e.length; p++)if (e[p].name === d) { d = p; break } break; case "map": if ("map" in e) { e = e.map; break } if (!e.material) { console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); return } if (!e.material.map) { console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this); return } e = e.material.map; break; default: if (e[s] === void 0) { console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this); return } e = e[s] }if (d !== void 0) { if (e[d] === void 0) { console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e); return } e = e[d] } } const l = e[a]; if (l === void 0) { const d = i.nodeName; console.error("THREE.PropertyBinding: Trying to update property for track: " + d + "." + a + " but it wasn't found.", e); return } let c = this.Versioning.None; this.targetObject = e, e.isMaterial === !0 ? c = this.Versioning.NeedsUpdate : e.isObject3D === !0 && (c = this.Versioning.MatrixWorldNeedsUpdate); let h = this.BindingType.Direct; if (o !== void 0) { if (a === "morphTargetInfluences") { if (!e.geometry) { console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this); return } if (!e.geometry.morphAttributes) { console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this); return } e.morphTargetDictionary[o] !== void 0 && (o = e.morphTargetDictionary[o]) } h = this.BindingType.ArrayElement, this.resolvedProperty = l, this.propertyIndex = o } else l.fromArray !== void 0 && l.toArray !== void 0 ? (h = this.BindingType.HasFromToArray, this.resolvedProperty = l) : Array.isArray(l) ? (h = this.BindingType.EntireArray, this.resolvedProperty = l) : this.propertyName = a; this.getValue = this.GetterByBindingType[h], this.setValue = this.SetterByBindingTypeAndVersioning[h][c] } unbind() { this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } } PropertyBinding.Composite = Composite; PropertyBinding.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }; PropertyBinding.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }; PropertyBinding.prototype.GetterByBindingType = [PropertyBinding.prototype._getValue_direct, PropertyBinding.prototype._getValue_array, PropertyBinding.prototype._getValue_arrayElement, PropertyBinding.prototype._getValue_toArray]; PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [[PropertyBinding.prototype._setValue_direct, PropertyBinding.prototype._setValue_direct_setNeedsUpdate, PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [PropertyBinding.prototype._setValue_array, PropertyBinding.prototype._setValue_array_setNeedsUpdate, PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate], [PropertyBinding.prototype._setValue_arrayElement, PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate, PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [PropertyBinding.prototype._setValue_fromArray, PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate, PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]]; class AnimationAction { constructor(e, i, s = null, a = i.blendMode) { this._mixer = e, this._clip = i, this._localRoot = s, this.blendMode = a; const o = i.tracks, l = o.length, c = new Array(l), h = { endingStart: ZeroCurvatureEnding, endingEnd: ZeroCurvatureEnding }; for (let d = 0; d !== l; ++d) { const p = o[d].createInterpolant(null); c[d] = p, p.settings = h } this._interpolantSettings = h, this._interpolants = c, this._propertyBindings = new Array(l), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = LoopRepeat, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0 } play() { return this._mixer._activateAction(this), this } stop() { return this._mixer._deactivateAction(this), this.reset() } reset() { return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping() } isRunning() { return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this) } isScheduled() { return this._mixer._isActiveAction(this) } startAt(e) { return this._startTime = e, this } setLoop(e, i) { return this.loop = e, this.repetitions = i, this } setEffectiveWeight(e) { return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading() } getEffectiveWeight() { return this._effectiveWeight } fadeIn(e) { return this._scheduleFading(e, 0, 1) } fadeOut(e) { return this._scheduleFading(e, 1, 0) } crossFadeFrom(e, i, s = !1) { if (e.fadeOut(i), this.fadeIn(i), s === !0) { const a = this._clip.duration, o = e._clip.duration, l = o / a, c = a / o; e.warp(1, l, i), this.warp(c, 1, i) } return this } crossFadeTo(e, i, s = !1) { return e.crossFadeFrom(this, i, s) } stopFading() { const e = this._weightInterpolant; return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this } setEffectiveTimeScale(e) { return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping() } getEffectiveTimeScale() { return this._effectiveTimeScale } setDuration(e) { return this.timeScale = this._clip.duration / e, this.stopWarping() } syncWith(e) { return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping() } halt(e) { return this.warp(this._effectiveTimeScale, 0, e) } warp(e, i, s) { const a = this._mixer, o = a.time, l = this.timeScale; let c = this._timeScaleInterpolant; c === null && (c = a._lendControlInterpolant(), this._timeScaleInterpolant = c); const h = c.parameterPositions, d = c.sampleValues; return h[0] = o, h[1] = o + s, d[0] = e / l, d[1] = i / l, this } stopWarping() { const e = this._timeScaleInterpolant; return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this } getMixer() { return this._mixer } getClip() { return this._clip } getRoot() { return this._localRoot || this._mixer._root } _update(e, i, s, a) { if (!this.enabled) { this._updateWeight(e); return } const o = this._startTime; if (o !== null) { const h = (e - o) * s; h < 0 || s === 0 ? i = 0 : (this._startTime = null, i = s * h) } i *= this._updateTimeScale(e); const l = this._updateTime(i), c = this._updateWeight(e); if (c > 0) { const h = this._interpolants, d = this._propertyBindings; switch (this.blendMode) { case AdditiveAnimationBlendMode: for (let p = 0, f = h.length; p !== f; ++p)h[p].evaluate(l), d[p].accumulateAdditive(c); break; case NormalAnimationBlendMode: default: for (let p = 0, f = h.length; p !== f; ++p)h[p].evaluate(l), d[p].accumulate(a, c) } } } _updateWeight(e) { let i = 0; if (this.enabled) { i = this.weight; const s = this._weightInterpolant; if (s !== null) { const a = s.evaluate(e)[0]; i *= a, e > s.parameterPositions[1] && (this.stopFading(), a === 0 && (this.enabled = !1)) } } return this._effectiveWeight = i, i } _updateTimeScale(e) { let i = 0; if (!this.paused) { i = this.timeScale; const s = this._timeScaleInterpolant; if (s !== null) { const a = s.evaluate(e)[0]; i *= a, e > s.parameterPositions[1] && (this.stopWarping(), i === 0 ? this.paused = !0 : this.timeScale = i) } } return this._effectiveTimeScale = i, i } _updateTime(e) { const i = this._clip.duration, s = this.loop; let a = this.time + e, o = this._loopCount; const l = s === LoopPingPong; if (e === 0) return o === -1 ? a : l && (o & 1) === 1 ? i - a : a; if (s === LoopOnce) { o === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1)); e: { if (a >= i) a = i; else if (a < 0) a = 0; else { this.time = a; break e } this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = a, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e < 0 ? -1 : 1 }) } } else { if (o === -1 && (e >= 0 ? (o = 0, this._setEndings(!0, this.repetitions === 0, l)) : this._setEndings(this.repetitions === 0, !0, l)), a >= i || a < 0) { const c = Math.floor(a / i); a -= i * c, o += Math.abs(c); const h = this.repetitions - o; if (h <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, a = e > 0 ? i : 0, this.time = a, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e > 0 ? 1 : -1 }); else { if (h === 1) { const d = e < 0; this._setEndings(d, !d, l) } else this._setEndings(!1, !1, l); this._loopCount = o, this.time = a, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: c }) } } else this.time = a; if (l && (o & 1) === 1) return i - a } return a } _setEndings(e, i, s) { const a = this._interpolantSettings; s ? (a.endingStart = ZeroSlopeEnding, a.endingEnd = ZeroSlopeEnding) : (e ? a.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding : a.endingStart = WrapAroundEnding, i ? a.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding : a.endingEnd = WrapAroundEnding) } _scheduleFading(e, i, s) { const a = this._mixer, o = a.time; let l = this._weightInterpolant; l === null && (l = a._lendControlInterpolant(), this._weightInterpolant = l); const c = l.parameterPositions, h = l.sampleValues; return c[0] = o, h[0] = i, c[1] = o + e, h[1] = s, this } } const _controlInterpolantsResultBuffer = new Float32Array(1); class AnimationMixer extends EventDispatcher { constructor(e) { super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1 } _bindAction(e, i) { const s = e._localRoot || this._root, a = e._clip.tracks, o = a.length, l = e._propertyBindings, c = e._interpolants, h = s.uuid, d = this._bindingsByRootAndName; let p = d[h]; p === void 0 && (p = {}, d[h] = p); for (let f = 0; f !== o; ++f) { const _ = a[f], x = _.name; let b = p[x]; if (b !== void 0) ++b.referenceCount, l[f] = b; else { if (b = l[f], b !== void 0) { b._cacheIndex === null && (++b.referenceCount, this._addInactiveBinding(b, h, x)); continue } const T = i && i._propertyBindings[f].binding.parsedPath; b = new PropertyMixer(PropertyBinding.create(s, x, T), _.ValueTypeName, _.getValueSize()), ++b.referenceCount, this._addInactiveBinding(b, h, x), l[f] = b } c[f].resultBuffer = b.buffer } } _activateAction(e) { if (!this._isActiveAction(e)) { if (e._cacheIndex === null) { const s = (e._localRoot || this._root).uuid, a = e._clip.uuid, o = this._actionsByClip[a]; this._bindAction(e, o && o.knownActions[0]), this._addInactiveAction(e, a, s) } const i = e._propertyBindings; for (let s = 0, a = i.length; s !== a; ++s) { const o = i[s]; o.useCount++ === 0 && (this._lendBinding(o), o.saveOriginalState()) } this._lendAction(e) } } _deactivateAction(e) { if (this._isActiveAction(e)) { const i = e._propertyBindings; for (let s = 0, a = i.length; s !== a; ++s) { const o = i[s]; --o.useCount === 0 && (o.restoreOriginalState(), this._takeBackBinding(o)) } this._takeBackAction(e) } } _initMemoryManager() { this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0; const e = this; this.stats = { actions: { get total() { return e._actions.length }, get inUse() { return e._nActiveActions } }, bindings: { get total() { return e._bindings.length }, get inUse() { return e._nActiveBindings } }, controlInterpolants: { get total() { return e._controlInterpolants.length }, get inUse() { return e._nActiveControlInterpolants } } } } _isActiveAction(e) { const i = e._cacheIndex; return i !== null && i < this._nActiveActions } _addInactiveAction(e, i, s) { const a = this._actions, o = this._actionsByClip; let l = o[i]; if (l === void 0) l = { knownActions: [e], actionByRoot: {} }, e._byClipCacheIndex = 0, o[i] = l; else { const c = l.knownActions; e._byClipCacheIndex = c.length, c.push(e) } e._cacheIndex = a.length, a.push(e), l.actionByRoot[s] = e } _removeInactiveAction(e) { const i = this._actions, s = i[i.length - 1], a = e._cacheIndex; s._cacheIndex = a, i[a] = s, i.pop(), e._cacheIndex = null; const o = e._clip.uuid, l = this._actionsByClip, c = l[o], h = c.knownActions, d = h[h.length - 1], p = e._byClipCacheIndex; d._byClipCacheIndex = p, h[p] = d, h.pop(), e._byClipCacheIndex = null; const f = c.actionByRoot, _ = (e._localRoot || this._root).uuid; delete f[_], h.length === 0 && delete l[o], this._removeInactiveBindingsForAction(e) } _removeInactiveBindingsForAction(e) { const i = e._propertyBindings; for (let s = 0, a = i.length; s !== a; ++s) { const o = i[s]; --o.referenceCount === 0 && this._removeInactiveBinding(o) } } _lendAction(e) { const i = this._actions, s = e._cacheIndex, a = this._nActiveActions++, o = i[a]; e._cacheIndex = a, i[a] = e, o._cacheIndex = s, i[s] = o } _takeBackAction(e) { const i = this._actions, s = e._cacheIndex, a = --this._nActiveActions, o = i[a]; e._cacheIndex = a, i[a] = e, o._cacheIndex = s, i[s] = o } _addInactiveBinding(e, i, s) { const a = this._bindingsByRootAndName, o = this._bindings; let l = a[i]; l === void 0 && (l = {}, a[i] = l), l[s] = e, e._cacheIndex = o.length, o.push(e) } _removeInactiveBinding(e) { const i = this._bindings, s = e.binding, a = s.rootNode.uuid, o = s.path, l = this._bindingsByRootAndName, c = l[a], h = i[i.length - 1], d = e._cacheIndex; h._cacheIndex = d, i[d] = h, i.pop(), delete c[o], Object.keys(c).length === 0 && delete l[a] } _lendBinding(e) { const i = this._bindings, s = e._cacheIndex, a = this._nActiveBindings++, o = i[a]; e._cacheIndex = a, i[a] = e, o._cacheIndex = s, i[s] = o } _takeBackBinding(e) { const i = this._bindings, s = e._cacheIndex, a = --this._nActiveBindings, o = i[a]; e._cacheIndex = a, i[a] = e, o._cacheIndex = s, i[s] = o } _lendControlInterpolant() { const e = this._controlInterpolants, i = this._nActiveControlInterpolants++; let s = e[i]; return s === void 0 && (s = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, _controlInterpolantsResultBuffer), s.__cacheIndex = i, e[i] = s), s } _takeBackControlInterpolant(e) { const i = this._controlInterpolants, s = e.__cacheIndex, a = --this._nActiveControlInterpolants, o = i[a]; e.__cacheIndex = a, i[a] = e, o.__cacheIndex = s, i[s] = o } clipAction(e, i, s) { const a = i || this._root, o = a.uuid; let l = typeof e == "string" ? AnimationClip.findByName(a, e) : e; const c = l !== null ? l.uuid : e, h = this._actionsByClip[c]; let d = null; if (s === void 0 && (l !== null ? s = l.blendMode : s = NormalAnimationBlendMode), h !== void 0) { const f = h.actionByRoot[o]; if (f !== void 0 && f.blendMode === s) return f; d = h.knownActions[0], l === null && (l = d._clip) } if (l === null) return null; const p = new AnimationAction(this, l, i, s); return this._bindAction(p, d), this._addInactiveAction(p, c, o), p } existingAction(e, i) { const s = i || this._root, a = s.uuid, o = typeof e == "string" ? AnimationClip.findByName(s, e) : e, l = o ? o.uuid : e, c = this._actionsByClip[l]; return c !== void 0 && c.actionByRoot[a] || null } stopAllAction() { const e = this._actions, i = this._nActiveActions; for (let s = i - 1; s >= 0; --s)e[s].stop(); return this } update(e) { e *= this.timeScale; const i = this._actions, s = this._nActiveActions, a = this.time += e, o = Math.sign(e), l = this._accuIndex ^= 1; for (let d = 0; d !== s; ++d)i[d]._update(a, e, o, l); const c = this._bindings, h = this._nActiveBindings; for (let d = 0; d !== h; ++d)c[d].apply(l); return this } setTime(e) { this.time = 0; for (let i = 0; i < this._actions.length; i++)this._actions[i].time = 0; return this.update(e) } getRoot() { return this._root } uncacheClip(e) { const i = this._actions, s = e.uuid, a = this._actionsByClip, o = a[s]; if (o !== void 0) { const l = o.knownActions; for (let c = 0, h = l.length; c !== h; ++c) { const d = l[c]; this._deactivateAction(d); const p = d._cacheIndex, f = i[i.length - 1]; d._cacheIndex = null, d._byClipCacheIndex = null, f._cacheIndex = p, i[p] = f, i.pop(), this._removeInactiveBindingsForAction(d) } delete a[s] } } uncacheRoot(e) { const i = e.uuid, s = this._actionsByClip; for (const l in s) { const c = s[l].actionByRoot, h = c[i]; h !== void 0 && (this._deactivateAction(h), this._removeInactiveAction(h)) } const a = this._bindingsByRootAndName, o = a[i]; if (o !== void 0) for (const l in o) { const c = o[l]; c.restoreOriginalState(), this._removeInactiveBinding(c) } } uncacheAction(e, i) { const s = this.existingAction(e, i); s !== null && (this._deactivateAction(s), this._removeInactiveAction(s)) } } class Uniform { constructor(e) { this.value = e } clone() { return new Uniform(this.value.clone === void 0 ? this.value : this.value.clone()) } } let _id$3 = 0; class UniformsGroup extends EventDispatcher { constructor() { super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", { value: _id$3++ }), this.name = "", this.usage = StaticDrawUsage, this.uniforms = [] } add(e) { return this.uniforms.push(e), this } remove(e) { const i = this.uniforms.indexOf(e); return i !== -1 && this.uniforms.splice(i, 1), this } setName(e) { return this.name = e, this } setUsage(e) { return this.usage = e, this } dispose() { this.dispatchEvent({ type: "dispose" }) } copy(e) { this.name = e.name, this.usage = e.usage; const i = e.uniforms; this.uniforms.length = 0; for (let s = 0, a = i.length; s < a; s++) { const o = Array.isArray(i[s]) ? i[s] : [i[s]]; for (let l = 0; l < o.length; l++)this.uniforms.push(o[l].clone()) } return this } clone() { return new this.constructor().copy(this) } } const _matrix$3 = new Matrix4; class Raycaster { constructor(e, i, s = 0, a = 1 / 0) { this.ray = new Ray(e, i), this.near = s, this.far = a, this.camera = null, this.layers = new Layers, this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} } } set(e, i) { this.ray.set(e, i) } setFromCamera(e, i) { i.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(i.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(i).sub(this.ray.origin).normalize(), this.camera = i) : i.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (i.near + i.far) / (i.near - i.far)).unproject(i), this.ray.direction.set(0, 0, -1).transformDirection(i.matrixWorld), this.camera = i) : console.error("THREE.Raycaster: Unsupported camera type: " + i.type) } setFromXRController(e) { return _matrix$3.identity().extractRotation(e.matrixWorld), this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(_matrix$3), this } intersectObject(e, i = !0, s = []) { return intersect(e, this, s, i), s.sort(ascSort), s } intersectObjects(e, i = !0, s = []) { for (let a = 0, o = e.length; a < o; a++)intersect(e[a], this, s, i); return s.sort(ascSort), s } } function ascSort(r, e) { return r.distance - e.distance } function intersect(r, e, i, s) { let a = !0; if (r.layers.test(e.layers) && r.raycast(e, i) === !1 && (a = !1), a === !0 && s === !0) { const o = r.children; for (let l = 0, c = o.length; l < c; l++)intersect(o[l], e, i, !0) } } class Spherical { constructor(e = 1, i = 0, s = 0) { this.radius = e, this.phi = i, this.theta = s } set(e, i, s) { return this.radius = e, this.phi = i, this.theta = s, this } copy(e) { return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this } makeSafe() { return this.phi = clamp(this.phi, 1e-6, Math.PI - 1e-6), this } setFromVector3(e) { return this.setFromCartesianCoords(e.x, e.y, e.z) } setFromCartesianCoords(e, i, s) { return this.radius = Math.sqrt(e * e + i * i + s * s), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, s), this.phi = Math.acos(clamp(i / this.radius, -1, 1))), this } clone() { return new this.constructor().copy(this) } } const _vector$4 = new Vector2; class Box2 { constructor(e = new Vector2(1 / 0, 1 / 0), i = new Vector2(-1 / 0, -1 / 0)) { this.isBox2 = !0, this.min = e, this.max = i } set(e, i) { return this.min.copy(e), this.max.copy(i), this } setFromPoints(e) { this.makeEmpty(); for (let i = 0, s = e.length; i < s; i++)this.expandByPoint(e[i]); return this } setFromCenterAndSize(e, i) { const s = _vector$4.copy(i).multiplyScalar(.5); return this.min.copy(e).sub(s), this.max.copy(e).add(s), this } clone() { return new this.constructor().copy(this) } copy(e) { return this.min.copy(e.min), this.max.copy(e.max), this } makeEmpty() { return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this } isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y } getCenter(e) { return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5) } getSize(e) { return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min) } expandByPoint(e) { return this.min.min(e), this.max.max(e), this } expandByVector(e) { return this.min.sub(e), this.max.add(e), this } expandByScalar(e) { return this.min.addScalar(-e), this.max.addScalar(e), this } containsPoint(e) { return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y } containsBox(e) { return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y } getParameter(e, i) { return i.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y)) } intersectsBox(e) { return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y } clampPoint(e, i) { return i.copy(e).clamp(this.min, this.max) } distanceToPoint(e) { return this.clampPoint(e, _vector$4).distanceTo(e) } intersect(e) { return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this } union(e) { return this.min.min(e.min), this.max.max(e.max), this } translate(e) { return this.min.add(e), this.max.add(e), this } equals(e) { return e.min.equals(this.min) && e.max.equals(this.max) } } const _startP = new Vector3, _startEnd = new Vector3, _d1 = new Vector3, _d2 = new Vector3, _r = new Vector3, _c1 = new Vector3, _c2 = new Vector3; class Line3 { constructor(e = new Vector3, i = new Vector3) { this.start = e, this.end = i } set(e, i) { return this.start.copy(e), this.end.copy(i), this } copy(e) { return this.start.copy(e.start), this.end.copy(e.end), this } getCenter(e) { return e.addVectors(this.start, this.end).multiplyScalar(.5) } delta(e) { return e.subVectors(this.end, this.start) } distanceSq() { return this.start.distanceToSquared(this.end) } distance() { return this.start.distanceTo(this.end) } at(e, i) { return this.delta(i).multiplyScalar(e).add(this.start) } closestPointToPointParameter(e, i) { _startP.subVectors(e, this.start), _startEnd.subVectors(this.end, this.start); const s = _startEnd.dot(_startEnd); let o = _startEnd.dot(_startP) / s; return i && (o = clamp(o, 0, 1)), o } closestPointToPoint(e, i, s) { const a = this.closestPointToPointParameter(e, i); return this.delta(s).multiplyScalar(a).add(this.start) } distanceSqToLine3(e, i = _c1, s = _c2) { const a = 10000000000000001e-32; let o, l; const c = this.start, h = e.start, d = this.end, p = e.end; _d1.subVectors(d, c), _d2.subVectors(p, h), _r.subVectors(c, h); const f = _d1.dot(_d1), _ = _d2.dot(_d2), x = _d2.dot(_r); if (f <= a && _ <= a) return i.copy(c), s.copy(h), i.sub(s), i.dot(i); if (f <= a) o = 0, l = x / _, l = clamp(l, 0, 1); else { const b = _d1.dot(_r); if (_ <= a) l = 0, o = clamp(-b / f, 0, 1); else { const T = _d1.dot(_d2), M = f * _ - T * T; M !== 0 ? o = clamp((T * x - b * _) / M, 0, 1) : o = 0, l = (T * o + x) / _, l < 0 ? (l = 0, o = clamp(-b / f, 0, 1)) : l > 1 && (l = 1, o = clamp((T - b) / f, 0, 1)) } } return i.copy(c).add(_d1.multiplyScalar(o)), s.copy(h).add(_d2.multiplyScalar(l)), i.sub(s), i.dot(i) } applyMatrix4(e) { return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this } equals(e) { return e.start.equals(this.start) && e.end.equals(this.end) } clone() { return new this.constructor().copy(this) } } class ShapePath { constructor() { this.type = "ShapePath", this.color = new Color, this.subPaths = [], this.currentPath = null } moveTo(e, i) { return this.currentPath = new Path, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, i), this } lineTo(e, i) { return this.currentPath.lineTo(e, i), this } quadraticCurveTo(e, i, s, a) { return this.currentPath.quadraticCurveTo(e, i, s, a), this } bezierCurveTo(e, i, s, a, o, l) { return this.currentPath.bezierCurveTo(e, i, s, a, o, l), this } splineThru(e) { return this.currentPath.splineThru(e), this } toShapes(e) { function i(w) { const D = []; for (let R = 0, P = w.length; R < P; R++) { const U = w[R], O = new Shape; O.curves = U.curves, D.push(O) } return D } function s(w, D) { const R = D.length; let P = !1; for (let U = R - 1, O = 0; O < R; U = O++) { let N = D[U], H = D[O], F = H.x - N.x, k = H.y - N.y; if (Math.abs(k) > Number.EPSILON) { if (k < 0 && (N = D[O], F = -F, H = D[U], k = -k), w.y < N.y || w.y > H.y) continue; if (w.y === N.y) { if (w.x === N.x) return !0 } else { const W = k * (w.x - N.x) - F * (w.y - N.y); if (W === 0) return !0; if (W < 0) continue; P = !P } } else { if (w.y !== N.y) continue; if (H.x <= w.x && w.x <= N.x || N.x <= w.x && w.x <= H.x) return !0 } } return P } const a = ShapeUtils.isClockWise, o = this.subPaths; if (o.length === 0) return []; let l, c, h; const d = []; if (o.length === 1) return c = o[0], h = new Shape, h.curves = c.curves, d.push(h), d; let p = !a(o[0].getPoints()); p = e ? !p : p; const f = [], _ = []; let x = [], b = 0, T; _[b] = void 0, x[b] = []; for (let w = 0, D = o.length; w < D; w++)c = o[w], T = c.getPoints(), l = a(T), l = e ? !l : l, l ? (!p && _[b] && b++, _[b] = { s: new Shape, p: T }, _[b].s.curves = c.curves, p && b++, x[b] = []) : x[b].push({ h: c, p: T[0] }); if (!_[0]) return i(o); if (_.length > 1) { let w = !1, D = 0; for (let R = 0, P = _.length; R < P; R++)f[R] = []; for (let R = 0, P = _.length; R < P; R++) { const U = x[R]; for (let O = 0; O < U.length; O++) { const N = U[O]; let H = !0; for (let F = 0; F < _.length; F++)s(N.p, _[F].p) && (R !== F && D++, H ? (H = !1, f[F].push(N)) : w = !0); H && f[R].push(N) } } D > 0 && w === !1 && (x = f) } let M; for (let w = 0, D = _.length; w < D; w++) { h = _[w].s, d.push(h), M = x[w]; for (let R = 0, P = M.length; R < P; R++)h.holes.push(M[R].h) } return d } } function getByteLength(r, e, i, s) { const a = getTextureTypeByteLength(s); switch (i) { case AlphaFormat: return r * e; case RedFormat: return r * e / a.components * a.byteLength; case RedIntegerFormat: return r * e / a.components * a.byteLength; case RGFormat: return r * e * 2 / a.components * a.byteLength; case RGIntegerFormat: return r * e * 2 / a.components * a.byteLength; case RGBFormat: return r * e * 3 / a.components * a.byteLength; case RGBAFormat: return r * e * 4 / a.components * a.byteLength; case RGBAIntegerFormat: return r * e * 4 / a.components * a.byteLength; case RGB_S3TC_DXT1_Format: case RGBA_S3TC_DXT1_Format: return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 8; case RGBA_S3TC_DXT3_Format: case RGBA_S3TC_DXT5_Format: return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16; case RGB_PVRTC_2BPPV1_Format: case RGBA_PVRTC_2BPPV1_Format: return Math.max(r, 16) * Math.max(e, 8) / 4; case RGB_PVRTC_4BPPV1_Format: case RGBA_PVRTC_4BPPV1_Format: return Math.max(r, 8) * Math.max(e, 8) / 2; case RGB_ETC1_Format: case RGB_ETC2_Format: return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 8; case RGBA_ETC2_EAC_Format: return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16; case RGBA_ASTC_4x4_Format: return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16; case RGBA_ASTC_5x4_Format: return Math.floor((r + 4) / 5) * Math.floor((e + 3) / 4) * 16; case RGBA_ASTC_5x5_Format: return Math.floor((r + 4) / 5) * Math.floor((e + 4) / 5) * 16; case RGBA_ASTC_6x5_Format: return Math.floor((r + 5) / 6) * Math.floor((e + 4) / 5) * 16; case RGBA_ASTC_6x6_Format: return Math.floor((r + 5) / 6) * Math.floor((e + 5) / 6) * 16; case RGBA_ASTC_8x5_Format: return Math.floor((r + 7) / 8) * Math.floor((e + 4) / 5) * 16; case RGBA_ASTC_8x6_Format: return Math.floor((r + 7) / 8) * Math.floor((e + 5) / 6) * 16; case RGBA_ASTC_8x8_Format: return Math.floor((r + 7) / 8) * Math.floor((e + 7) / 8) * 16; case RGBA_ASTC_10x5_Format: return Math.floor((r + 9) / 10) * Math.floor((e + 4) / 5) * 16; case RGBA_ASTC_10x6_Format: return Math.floor((r + 9) / 10) * Math.floor((e + 5) / 6) * 16; case RGBA_ASTC_10x8_Format: return Math.floor((r + 9) / 10) * Math.floor((e + 7) / 8) * 16; case RGBA_ASTC_10x10_Format: return Math.floor((r + 9) / 10) * Math.floor((e + 9) / 10) * 16; case RGBA_ASTC_12x10_Format: return Math.floor((r + 11) / 12) * Math.floor((e + 9) / 10) * 16; case RGBA_ASTC_12x12_Format: return Math.floor((r + 11) / 12) * Math.floor((e + 11) / 12) * 16; case RGBA_BPTC_Format: case RGB_BPTC_SIGNED_Format: case RGB_BPTC_UNSIGNED_Format: return Math.ceil(r / 4) * Math.ceil(e / 4) * 16; case RED_RGTC1_Format: case SIGNED_RED_RGTC1_Format: return Math.ceil(r / 4) * Math.ceil(e / 4) * 8; case RED_GREEN_RGTC2_Format: case SIGNED_RED_GREEN_RGTC2_Format: return Math.ceil(r / 4) * Math.ceil(e / 4) * 16 }throw new Error(`Unable to determine texture byte length for ${i} format.`) } function getTextureTypeByteLength(r) { switch (r) { case UnsignedByteType: case ByteType: return { byteLength: 1, components: 1 }; case UnsignedShortType: case ShortType: case HalfFloatType: return { byteLength: 2, components: 1 }; case UnsignedShort4444Type: case UnsignedShort5551Type: return { byteLength: 2, components: 4 }; case UnsignedIntType: case IntType: case FloatType: return { byteLength: 4, components: 1 }; case UnsignedInt5999Type: case UnsignedInt101111Type: return { byteLength: 4, components: 3 } }throw new Error(`Unknown texture type ${r}.`) } typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: REVISION } })); typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = REVISION);/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */function WebGLAnimation() { let r = null, e = !1, i = null, s = null; function a(o, l) { i(o, l), s = r.requestAnimationFrame(a) } return { start: function () { e !== !0 && i !== null && (s = r.requestAnimationFrame(a), e = !0) }, stop: function () { r.cancelAnimationFrame(s), e = !1 }, setAnimationLoop: function (o) { i = o }, setContext: function (o) { r = o } } } function WebGLAttributes(r) { const e = new WeakMap; function i(c, h) { const d = c.array, p = c.usage, f = d.byteLength, _ = r.createBuffer(); r.bindBuffer(h, _), r.bufferData(h, d, p), c.onUploadCallback(); let x; if (d instanceof Float32Array) x = r.FLOAT; else if (typeof Float16Array < "u" && d instanceof Float16Array) x = r.HALF_FLOAT; else if (d instanceof Uint16Array) c.isFloat16BufferAttribute ? x = r.HALF_FLOAT : x = r.UNSIGNED_SHORT; else if (d instanceof Int16Array) x = r.SHORT; else if (d instanceof Uint32Array) x = r.UNSIGNED_INT; else if (d instanceof Int32Array) x = r.INT; else if (d instanceof Int8Array) x = r.BYTE; else if (d instanceof Uint8Array) x = r.UNSIGNED_BYTE; else if (d instanceof Uint8ClampedArray) x = r.UNSIGNED_BYTE; else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + d); return { buffer: _, type: x, bytesPerElement: d.BYTES_PER_ELEMENT, version: c.version, size: f } } function s(c, h, d) { const p = h.array, f = h.updateRanges; if (r.bindBuffer(d, c), f.length === 0) r.bufferSubData(d, 0, p); else { f.sort((x, b) => x.start - b.start); let _ = 0; for (let x = 1; x < f.length; x++) { const b = f[_], T = f[x]; T.start <= b.start + b.count + 1 ? b.count = Math.max(b.count, T.start + T.count - b.start) : (++_, f[_] = T) } f.length = _ + 1; for (let x = 0, b = f.length; x < b; x++) { const T = f[x]; r.bufferSubData(d, T.start * p.BYTES_PER_ELEMENT, p, T.start, T.count) } h.clearUpdateRanges() } h.onUploadCallback() } function a(c) { return c.isInterleavedBufferAttribute && (c = c.data), e.get(c) } function o(c) { c.isInterleavedBufferAttribute && (c = c.data); const h = e.get(c); h && (r.deleteBuffer(h.buffer), e.delete(c)) } function l(c, h) { if (c.isInterleavedBufferAttribute && (c = c.data), c.isGLBufferAttribute) { const p = e.get(c); (!p || p.version < c.version) && e.set(c, { buffer: c.buffer, type: c.type, bytesPerElement: c.elementSize, version: c.version }); return } const d = e.get(c); if (d === void 0) e.set(c, i(c, h)); else if (d.version < c.version) { if (d.size !== c.array.byteLength) throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported."); s(d.buffer, c, h), d.version = c.version } } return { get: a, remove: o, update: l } } var alphahash_fragment = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, alphahash_pars_fragment = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, alphamap_fragment = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, alphamap_pars_fragment = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, alphatest_fragment = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`, alphatest_pars_fragment = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, aomap_fragment = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, aomap_pars_fragment = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, batching_pars_vertex = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`, batching_vertex = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`, begin_vertex = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, beginnormal_vertex = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, bsdfs = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, iridescence_fragment = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, bumpmap_pars_fragment = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, clipping_planes_fragment = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`, clipping_planes_pars_fragment = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, clipping_planes_pars_vertex = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, clipping_planes_vertex = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, color_fragment = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, color_pars_fragment = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, color_pars_vertex = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`, color_vertex = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`, common = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, cube_uv_reflection_fragment = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, defaultnormal_vertex = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, displacementmap_pars_vertex = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, displacementmap_vertex = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, emissivemap_fragment = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, emissivemap_pars_fragment = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, colorspace_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );", colorspace_pars_fragment = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, envmap_fragment = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, envmap_common_pars_fragment = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, envmap_pars_fragment = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, envmap_pars_vertex = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, envmap_vertex = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, fog_vertex = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, fog_pars_vertex = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, fog_fragment = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, fog_pars_fragment = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, gradientmap_pars_fragment = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, lightmap_pars_fragment = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, lights_lambert_fragment = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, lights_lambert_pars_fragment = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, lights_pars_begin = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, envmap_physical_pars_fragment = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, lights_toon_fragment = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, lights_toon_pars_fragment = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, lights_phong_fragment = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, lights_phong_pars_fragment = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, lights_physical_fragment = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, lights_physical_pars_fragment = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, lights_fragment_begin = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, lights_fragment_maps = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, lights_fragment_end = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, logdepthbuf_fragment = `#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, logdepthbuf_pars_fragment = `#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, logdepthbuf_pars_vertex = `#ifdef USE_LOGARITHMIC_DEPTH_BUFFER
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, logdepthbuf_vertex = `#ifdef USE_LOGARITHMIC_DEPTH_BUFFER
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`, map_fragment = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, map_pars_fragment = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, map_particle_fragment = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, map_particle_pars_fragment = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, metalnessmap_fragment = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, metalnessmap_pars_fragment = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, morphinstance_vertex = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`, morphcolor_vertex = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, morphnormal_vertex = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, morphtarget_pars_vertex = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`, morphtarget_vertex = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, normal_fragment_begin = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, normal_fragment_maps = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, normal_pars_fragment = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, normal_pars_vertex = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, normal_vertex = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, normalmap_pars_fragment = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, clearcoat_normal_fragment_begin = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, clearcoat_normal_fragment_maps = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, clearcoat_pars_fragment = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, iridescence_pars_fragment = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, opaque_fragment = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, packing = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, premultiplied_alpha_fragment = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, project_vertex = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, dithering_fragment = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, dithering_pars_fragment = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, roughnessmap_fragment = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, roughnessmap_pars_fragment = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, shadowmap_pars_fragment = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		float depth = unpackRGBAToDepth( texture2D( depths, uv ) );
		#ifdef USE_REVERSED_DEPTH_BUFFER
			return step( depth, compare );
		#else
			return step( compare, depth );
		#endif
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow( sampler2D shadow, vec2 uv, float compare ) {
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		#ifdef USE_REVERSED_DEPTH_BUFFER
			float hard_shadow = step( distribution.x, compare );
		#else
			float hard_shadow = step( compare, distribution.x );
		#endif
		if ( hard_shadow != 1.0 ) {
			float distance = compare - distribution.x;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`, shadowmap_pars_vertex = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, shadowmap_vertex = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, shadowmask_pars_fragment = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, skinbase_vertex = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, skinning_pars_vertex = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, skinning_vertex = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, skinnormal_vertex = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, specularmap_fragment = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, specularmap_pars_fragment = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, tonemapping_fragment = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, tonemapping_pars_fragment = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, transmission_fragment = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, transmission_pars_fragment = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, uv_pars_fragment = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, uv_pars_vertex = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, uv_vertex = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, worldpos_vertex = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`; const vertex$h = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, fragment$h = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, vertex$g = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, fragment$g = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, vertex$f = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, fragment$f = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, vertex$e = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, fragment$e = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	#ifdef USE_REVERSED_DEPTH_BUFFER
		float fragCoordZ = vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ];
	#else
		float fragCoordZ = 0.5 * vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ] + 0.5;
	#endif
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`, vertex$d = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, fragment$d = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, vertex$c = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, fragment$c = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, vertex$b = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, fragment$b = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, vertex$a = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, fragment$a = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, vertex$9 = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, fragment$9 = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, vertex$8 = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, fragment$8 = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, vertex$7 = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, fragment$7 = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, vertex$6 = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, fragment$6 = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, vertex$5 = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, fragment$5 = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, vertex$4 = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, fragment$4 = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, vertex$3 = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, fragment$3 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, vertex$2 = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, fragment$2 = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, vertex$1 = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, fragment$1 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, ShaderChunk = { alphahash_fragment, alphahash_pars_fragment, alphamap_fragment, alphamap_pars_fragment, alphatest_fragment, alphatest_pars_fragment, aomap_fragment, aomap_pars_fragment, batching_pars_vertex, batching_vertex, begin_vertex, beginnormal_vertex, bsdfs, iridescence_fragment, bumpmap_pars_fragment, clipping_planes_fragment, clipping_planes_pars_fragment, clipping_planes_pars_vertex, clipping_planes_vertex, color_fragment, color_pars_fragment, color_pars_vertex, color_vertex, common, cube_uv_reflection_fragment, defaultnormal_vertex, displacementmap_pars_vertex, displacementmap_vertex, emissivemap_fragment, emissivemap_pars_fragment, colorspace_fragment, colorspace_pars_fragment, envmap_fragment, envmap_common_pars_fragment, envmap_pars_fragment, envmap_pars_vertex, envmap_physical_pars_fragment, envmap_vertex, fog_vertex, fog_pars_vertex, fog_fragment, fog_pars_fragment, gradientmap_pars_fragment, lightmap_pars_fragment, lights_lambert_fragment, lights_lambert_pars_fragment, lights_pars_begin, lights_toon_fragment, lights_toon_pars_fragment, lights_phong_fragment, lights_phong_pars_fragment, lights_physical_fragment, lights_physical_pars_fragment, lights_fragment_begin, lights_fragment_maps, lights_fragment_end, logdepthbuf_fragment, logdepthbuf_pars_fragment, logdepthbuf_pars_vertex, logdepthbuf_vertex, map_fragment, map_pars_fragment, map_particle_fragment, map_particle_pars_fragment, metalnessmap_fragment, metalnessmap_pars_fragment, morphinstance_vertex, morphcolor_vertex, morphnormal_vertex, morphtarget_pars_vertex, morphtarget_vertex, normal_fragment_begin, normal_fragment_maps, normal_pars_fragment, normal_pars_vertex, normal_vertex, normalmap_pars_fragment, clearcoat_normal_fragment_begin, clearcoat_normal_fragment_maps, clearcoat_pars_fragment, iridescence_pars_fragment, opaque_fragment, packing, premultiplied_alpha_fragment, project_vertex, dithering_fragment, dithering_pars_fragment, roughnessmap_fragment, roughnessmap_pars_fragment, shadowmap_pars_fragment, shadowmap_pars_vertex, shadowmap_vertex, shadowmask_pars_fragment, skinbase_vertex, skinning_pars_vertex, skinning_vertex, skinnormal_vertex, specularmap_fragment, specularmap_pars_fragment, tonemapping_fragment, tonemapping_pars_fragment, transmission_fragment, transmission_pars_fragment, uv_pars_fragment, uv_pars_vertex, uv_vertex, worldpos_vertex, background_vert: vertex$h, background_frag: fragment$h, backgroundCube_vert: vertex$g, backgroundCube_frag: fragment$g, cube_vert: vertex$f, cube_frag: fragment$f, depth_vert: vertex$e, depth_frag: fragment$e, distanceRGBA_vert: vertex$d, distanceRGBA_frag: fragment$d, equirect_vert: vertex$c, equirect_frag: fragment$c, linedashed_vert: vertex$b, linedashed_frag: fragment$b, meshbasic_vert: vertex$a, meshbasic_frag: fragment$a, meshlambert_vert: vertex$9, meshlambert_frag: fragment$9, meshmatcap_vert: vertex$8, meshmatcap_frag: fragment$8, meshnormal_vert: vertex$7, meshnormal_frag: fragment$7, meshphong_vert: vertex$6, meshphong_frag: fragment$6, meshphysical_vert: vertex$5, meshphysical_frag: fragment$5, meshtoon_vert: vertex$4, meshtoon_frag: fragment$4, points_vert: vertex$3, points_frag: fragment$3, shadow_vert: vertex$2, shadow_frag: fragment$2, sprite_vert: vertex$1, sprite_frag: fragment$1 }, UniformsLib = { common: { diffuse: { value: new Color(16777215) }, opacity: { value: 1 }, map: { value: null }, mapTransform: { value: new Matrix3 }, alphaMap: { value: null }, alphaMapTransform: { value: new Matrix3 }, alphaTest: { value: 0 } }, specularmap: { specularMap: { value: null }, specularMapTransform: { value: new Matrix3 } }, envmap: { envMap: { value: null }, envMapRotation: { value: new Matrix3 }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, ior: { value: 1.5 }, refractionRatio: { value: .98 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 }, aoMapTransform: { value: new Matrix3 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 }, lightMapTransform: { value: new Matrix3 } }, bumpmap: { bumpMap: { value: null }, bumpMapTransform: { value: new Matrix3 }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalMapTransform: { value: new Matrix3 }, normalScale: { value: new Vector2(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementMapTransform: { value: new Matrix3 }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, emissivemap: { emissiveMap: { value: null }, emissiveMapTransform: { value: new Matrix3 } }, metalnessmap: { metalnessMap: { value: null }, metalnessMapTransform: { value: new Matrix3 } }, roughnessmap: { roughnessMap: { value: null }, roughnessMapTransform: { value: new Matrix3 } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new Color(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowIntensity: 1, shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowIntensity: 1, shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotLightMap: { value: [] }, spotShadowMap: { value: [] }, spotLightMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowIntensity: 1, shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new Color(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, alphaMapTransform: { value: new Matrix3 }, alphaTest: { value: 0 }, uvTransform: { value: new Matrix3 } }, sprite: { diffuse: { value: new Color(16777215) }, opacity: { value: 1 }, center: { value: new Vector2(.5, .5) }, rotation: { value: 0 }, map: { value: null }, mapTransform: { value: new Matrix3 }, alphaMap: { value: null }, alphaMapTransform: { value: new Matrix3 }, alphaTest: { value: 0 } } }, ShaderLib = { basic: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog]), vertexShader: ShaderChunk.meshbasic_vert, fragmentShader: ShaderChunk.meshbasic_frag }, lambert: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, { emissive: { value: new Color(0) } }]), vertexShader: ShaderChunk.meshlambert_vert, fragmentShader: ShaderChunk.meshlambert_frag }, phong: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, { emissive: { value: new Color(0) }, specular: { value: new Color(1118481) }, shininess: { value: 30 } }]), vertexShader: ShaderChunk.meshphong_vert, fragmentShader: ShaderChunk.meshphong_frag }, standard: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, { emissive: { value: new Color(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: ShaderChunk.meshphysical_vert, fragmentShader: ShaderChunk.meshphysical_frag }, toon: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, { emissive: { value: new Color(0) } }]), vertexShader: ShaderChunk.meshtoon_vert, fragmentShader: ShaderChunk.meshtoon_frag }, matcap: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, { matcap: { value: null } }]), vertexShader: ShaderChunk.meshmatcap_vert, fragmentShader: ShaderChunk.meshmatcap_frag }, points: { uniforms: mergeUniforms([UniformsLib.points, UniformsLib.fog]), vertexShader: ShaderChunk.points_vert, fragmentShader: ShaderChunk.points_frag }, dashed: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: ShaderChunk.linedashed_vert, fragmentShader: ShaderChunk.linedashed_frag }, depth: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap]), vertexShader: ShaderChunk.depth_vert, fragmentShader: ShaderChunk.depth_frag }, normal: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, { opacity: { value: 1 } }]), vertexShader: ShaderChunk.meshnormal_vert, fragmentShader: ShaderChunk.meshnormal_frag }, sprite: { uniforms: mergeUniforms([UniformsLib.sprite, UniformsLib.fog]), vertexShader: ShaderChunk.sprite_vert, fragmentShader: ShaderChunk.sprite_frag }, background: { uniforms: { uvTransform: { value: new Matrix3 }, t2D: { value: null }, backgroundIntensity: { value: 1 } }, vertexShader: ShaderChunk.background_vert, fragmentShader: ShaderChunk.background_frag }, backgroundCube: { uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 }, backgroundBlurriness: { value: 0 }, backgroundIntensity: { value: 1 }, backgroundRotation: { value: new Matrix3 } }, vertexShader: ShaderChunk.backgroundCube_vert, fragmentShader: ShaderChunk.backgroundCube_frag }, cube: { uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } }, vertexShader: ShaderChunk.cube_vert, fragmentShader: ShaderChunk.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: ShaderChunk.equirect_vert, fragmentShader: ShaderChunk.equirect_frag }, distanceRGBA: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap, { referencePosition: { value: new Vector3 }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: ShaderChunk.distanceRGBA_vert, fragmentShader: ShaderChunk.distanceRGBA_frag }, shadow: { uniforms: mergeUniforms([UniformsLib.lights, UniformsLib.fog, { color: { value: new Color(0) }, opacity: { value: 1 } }]), vertexShader: ShaderChunk.shadow_vert, fragmentShader: ShaderChunk.shadow_frag } }; ShaderLib.physical = { uniforms: mergeUniforms([ShaderLib.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatMapTransform: { value: new Matrix3 }, clearcoatNormalMap: { value: null }, clearcoatNormalMapTransform: { value: new Matrix3 }, clearcoatNormalScale: { value: new Vector2(1, 1) }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatRoughnessMapTransform: { value: new Matrix3 }, dispersion: { value: 0 }, iridescence: { value: 0 }, iridescenceMap: { value: null }, iridescenceMapTransform: { value: new Matrix3 }, iridescenceIOR: { value: 1.3 }, iridescenceThicknessMinimum: { value: 100 }, iridescenceThicknessMaximum: { value: 400 }, iridescenceThicknessMap: { value: null }, iridescenceThicknessMapTransform: { value: new Matrix3 }, sheen: { value: 0 }, sheenColor: { value: new Color(0) }, sheenColorMap: { value: null }, sheenColorMapTransform: { value: new Matrix3 }, sheenRoughness: { value: 1 }, sheenRoughnessMap: { value: null }, sheenRoughnessMapTransform: { value: new Matrix3 }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionMapTransform: { value: new Matrix3 }, transmissionSamplerSize: { value: new Vector2 }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, thicknessMapTransform: { value: new Matrix3 }, attenuationDistance: { value: 0 }, attenuationColor: { value: new Color(0) }, specularColor: { value: new Color(1, 1, 1) }, specularColorMap: { value: null }, specularColorMapTransform: { value: new Matrix3 }, specularIntensity: { value: 1 }, specularIntensityMap: { value: null }, specularIntensityMapTransform: { value: new Matrix3 }, anisotropyVector: { value: new Vector2 }, anisotropyMap: { value: null }, anisotropyMapTransform: { value: new Matrix3 } }]), vertexShader: ShaderChunk.meshphysical_vert, fragmentShader: ShaderChunk.meshphysical_frag }; const _rgb = { r: 0, b: 0, g: 0 }, _e1$1 = new Euler, _m1$1 = new Matrix4; function WebGLBackground(r, e, i, s, a, o, l) { const c = new Color(0); let h = o === !0 ? 0 : 1, d, p, f = null, _ = 0, x = null; function b(R) { let P = R.isScene === !0 ? R.background : null; return P && P.isTexture && (P = (R.backgroundBlurriness > 0 ? i : e).get(P)), P } function T(R) { let P = !1; const U = b(R); U === null ? w(c, h) : U && U.isColor && (w(U, 1), P = !0); const O = r.xr.getEnvironmentBlendMode(); O === "additive" ? s.buffers.color.setClear(0, 0, 0, 1, l) : O === "alpha-blend" && s.buffers.color.setClear(0, 0, 0, 0, l), (r.autoClear || P) && (s.buffers.depth.setTest(!0), s.buffers.depth.setMask(!0), s.buffers.color.setMask(!0), r.clear(r.autoClearColor, r.autoClearDepth, r.autoClearStencil)) } function M(R, P) { const U = b(P); U && (U.isCubeTexture || U.mapping === CubeUVReflectionMapping) ? (p === void 0 && (p = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({ name: "BackgroundCubeMaterial", uniforms: cloneUniforms(ShaderLib.backgroundCube.uniforms), vertexShader: ShaderLib.backgroundCube.vertexShader, fragmentShader: ShaderLib.backgroundCube.fragmentShader, side: BackSide, depthTest: !1, depthWrite: !1, fog: !1, allowOverride: !1 })), p.geometry.deleteAttribute("normal"), p.geometry.deleteAttribute("uv"), p.onBeforeRender = function (O, N, H) { this.matrixWorld.copyPosition(H.matrixWorld) }, Object.defineProperty(p.material, "envMap", { get: function () { return this.uniforms.envMap.value } }), a.update(p)), _e1$1.copy(P.backgroundRotation), _e1$1.x *= -1, _e1$1.y *= -1, _e1$1.z *= -1, U.isCubeTexture && U.isRenderTargetTexture === !1 && (_e1$1.y *= -1, _e1$1.z *= -1), p.material.uniforms.envMap.value = U, p.material.uniforms.flipEnvMap.value = U.isCubeTexture && U.isRenderTargetTexture === !1 ? -1 : 1, p.material.uniforms.backgroundBlurriness.value = P.backgroundBlurriness, p.material.uniforms.backgroundIntensity.value = P.backgroundIntensity, p.material.uniforms.backgroundRotation.value.setFromMatrix4(_m1$1.makeRotationFromEuler(_e1$1)), p.material.toneMapped = ColorManagement.getTransfer(U.colorSpace) !== SRGBTransfer, (f !== U || _ !== U.version || x !== r.toneMapping) && (p.material.needsUpdate = !0, f = U, _ = U.version, x = r.toneMapping), p.layers.enableAll(), R.unshift(p, p.geometry, p.material, 0, 0, null)) : U && U.isTexture && (d === void 0 && (d = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({ name: "BackgroundMaterial", uniforms: cloneUniforms(ShaderLib.background.uniforms), vertexShader: ShaderLib.background.vertexShader, fragmentShader: ShaderLib.background.fragmentShader, side: FrontSide, depthTest: !1, depthWrite: !1, fog: !1, allowOverride: !1 })), d.geometry.deleteAttribute("normal"), Object.defineProperty(d.material, "map", { get: function () { return this.uniforms.t2D.value } }), a.update(d)), d.material.uniforms.t2D.value = U, d.material.uniforms.backgroundIntensity.value = P.backgroundIntensity, d.material.toneMapped = ColorManagement.getTransfer(U.colorSpace) !== SRGBTransfer, U.matrixAutoUpdate === !0 && U.updateMatrix(), d.material.uniforms.uvTransform.value.copy(U.matrix), (f !== U || _ !== U.version || x !== r.toneMapping) && (d.material.needsUpdate = !0, f = U, _ = U.version, x = r.toneMapping), d.layers.enableAll(), R.unshift(d, d.geometry, d.material, 0, 0, null)) } function w(R, P) { R.getRGB(_rgb, getUnlitUniformColorSpace(r)), s.buffers.color.setClear(_rgb.r, _rgb.g, _rgb.b, P, l) } function D() { p !== void 0 && (p.geometry.dispose(), p.material.dispose(), p = void 0), d !== void 0 && (d.geometry.dispose(), d.material.dispose(), d = void 0) } return { getClearColor: function () { return c }, setClearColor: function (R, P = 1) { c.set(R), h = P, w(c, h) }, getClearAlpha: function () { return h }, setClearAlpha: function (R) { h = R, w(c, h) }, render: T, addToRenderList: M, dispose: D } } function WebGLBindingStates(r, e) { const i = r.getParameter(r.MAX_VERTEX_ATTRIBS), s = {}, a = _(null); let o = a, l = !1; function c(k, W, $, Z, J) { let se = !1; const re = f(Z, $, W); o !== re && (o = re, d(o.object)), se = x(k, Z, $, J), se && b(k, Z, $, J), J !== null && e.update(J, r.ELEMENT_ARRAY_BUFFER), (se || l) && (l = !1, P(k, W, $, Z), J !== null && r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, e.get(J).buffer)) } function h() { return r.createVertexArray() } function d(k) { return r.bindVertexArray(k) } function p(k) { return r.deleteVertexArray(k) } function f(k, W, $) { const Z = $.wireframe === !0; let J = s[k.id]; J === void 0 && (J = {}, s[k.id] = J); let se = J[W.id]; se === void 0 && (se = {}, J[W.id] = se); let re = se[Z]; return re === void 0 && (re = _(h()), se[Z] = re), re } function _(k) { const W = [], $ = [], Z = []; for (let J = 0; J < i; J++)W[J] = 0, $[J] = 0, Z[J] = 0; return { geometry: null, program: null, wireframe: !1, newAttributes: W, enabledAttributes: $, attributeDivisors: Z, object: k, attributes: {}, index: null } } function x(k, W, $, Z) { const J = o.attributes, se = W.attributes; let re = 0; const ce = $.getAttributes(); for (const ee in ce) if (ce[ee].location >= 0) { const Ee = J[ee]; let Ue = se[ee]; if (Ue === void 0 && (ee === "instanceMatrix" && k.instanceMatrix && (Ue = k.instanceMatrix), ee === "instanceColor" && k.instanceColor && (Ue = k.instanceColor)), Ee === void 0 || Ee.attribute !== Ue || Ue && Ee.data !== Ue.data) return !0; re++ } return o.attributesNum !== re || o.index !== Z } function b(k, W, $, Z) { const J = {}, se = W.attributes; let re = 0; const ce = $.getAttributes(); for (const ee in ce) if (ce[ee].location >= 0) { let Ee = se[ee]; Ee === void 0 && (ee === "instanceMatrix" && k.instanceMatrix && (Ee = k.instanceMatrix), ee === "instanceColor" && k.instanceColor && (Ee = k.instanceColor)); const Ue = {}; Ue.attribute = Ee, Ee && Ee.data && (Ue.data = Ee.data), J[ee] = Ue, re++ } o.attributes = J, o.attributesNum = re, o.index = Z } function T() { const k = o.newAttributes; for (let W = 0, $ = k.length; W < $; W++)k[W] = 0 } function M(k) { w(k, 0) } function w(k, W) { const $ = o.newAttributes, Z = o.enabledAttributes, J = o.attributeDivisors; $[k] = 1, Z[k] === 0 && (r.enableVertexAttribArray(k), Z[k] = 1), J[k] !== W && (r.vertexAttribDivisor(k, W), J[k] = W) } function D() { const k = o.newAttributes, W = o.enabledAttributes; for (let $ = 0, Z = W.length; $ < Z; $++)W[$] !== k[$] && (r.disableVertexAttribArray($), W[$] = 0) } function R(k, W, $, Z, J, se, re) { re === !0 ? r.vertexAttribIPointer(k, W, $, J, se) : r.vertexAttribPointer(k, W, $, Z, J, se) } function P(k, W, $, Z) { T(); const J = Z.attributes, se = $.getAttributes(), re = W.defaultAttributeValues; for (const ce in se) { const ee = se[ce]; if (ee.location >= 0) { let Me = J[ce]; if (Me === void 0 && (ce === "instanceMatrix" && k.instanceMatrix && (Me = k.instanceMatrix), ce === "instanceColor" && k.instanceColor && (Me = k.instanceColor)), Me !== void 0) { const Ee = Me.normalized, Ue = Me.itemSize, nt = e.get(Me); if (nt === void 0) continue; const mt = nt.buffer, ve = nt.type, ne = nt.bytesPerElement, z = ve === r.INT || ve === r.UNSIGNED_INT || Me.gpuType === IntType; if (Me.isInterleavedBufferAttribute) { const V = Me.data, _e = V.stride, Le = Me.offset; if (V.isInstancedInterleavedBuffer) { for (let fe = 0; fe < ee.locationSize; fe++)w(ee.location + fe, V.meshPerAttribute); k.isInstancedMesh !== !0 && Z._maxInstanceCount === void 0 && (Z._maxInstanceCount = V.meshPerAttribute * V.count) } else for (let fe = 0; fe < ee.locationSize; fe++)M(ee.location + fe); r.bindBuffer(r.ARRAY_BUFFER, mt); for (let fe = 0; fe < ee.locationSize; fe++)R(ee.location + fe, Ue / ee.locationSize, ve, Ee, _e * ne, (Le + Ue / ee.locationSize * fe) * ne, z) } else { if (Me.isInstancedBufferAttribute) { for (let V = 0; V < ee.locationSize; V++)w(ee.location + V, Me.meshPerAttribute); k.isInstancedMesh !== !0 && Z._maxInstanceCount === void 0 && (Z._maxInstanceCount = Me.meshPerAttribute * Me.count) } else for (let V = 0; V < ee.locationSize; V++)M(ee.location + V); r.bindBuffer(r.ARRAY_BUFFER, mt); for (let V = 0; V < ee.locationSize; V++)R(ee.location + V, Ue / ee.locationSize, ve, Ee, Ue * ne, Ue / ee.locationSize * V * ne, z) } } else if (re !== void 0) { const Ee = re[ce]; if (Ee !== void 0) switch (Ee.length) { case 2: r.vertexAttrib2fv(ee.location, Ee); break; case 3: r.vertexAttrib3fv(ee.location, Ee); break; case 4: r.vertexAttrib4fv(ee.location, Ee); break; default: r.vertexAttrib1fv(ee.location, Ee) } } } } D() } function U() { H(); for (const k in s) { const W = s[k]; for (const $ in W) { const Z = W[$]; for (const J in Z) p(Z[J].object), delete Z[J]; delete W[$] } delete s[k] } } function O(k) { if (s[k.id] === void 0) return; const W = s[k.id]; for (const $ in W) { const Z = W[$]; for (const J in Z) p(Z[J].object), delete Z[J]; delete W[$] } delete s[k.id] } function N(k) { for (const W in s) { const $ = s[W]; if ($[k.id] === void 0) continue; const Z = $[k.id]; for (const J in Z) p(Z[J].object), delete Z[J]; delete $[k.id] } } function H() { F(), l = !0, o !== a && (o = a, d(o.object)) } function F() { a.geometry = null, a.program = null, a.wireframe = !1 } return { setup: c, reset: H, resetDefaultState: F, dispose: U, releaseStatesOfGeometry: O, releaseStatesOfProgram: N, initAttributes: T, enableAttribute: M, disableUnusedAttributes: D } } function WebGLBufferRenderer(r, e, i) { let s; function a(d) { s = d } function o(d, p) { r.drawArrays(s, d, p), i.update(p, s, 1) } function l(d, p, f) { f !== 0 && (r.drawArraysInstanced(s, d, p, f), i.update(p, s, f)) } function c(d, p, f) { if (f === 0) return; e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(s, d, 0, p, 0, f); let x = 0; for (let b = 0; b < f; b++)x += p[b]; i.update(x, s, 1) } function h(d, p, f, _) { if (f === 0) return; const x = e.get("WEBGL_multi_draw"); if (x === null) for (let b = 0; b < d.length; b++)l(d[b], p[b], _[b]); else { x.multiDrawArraysInstancedWEBGL(s, d, 0, p, 0, _, 0, f); let b = 0; for (let T = 0; T < f; T++)b += p[T] * _[T]; i.update(b, s, 1) } } this.setMode = a, this.render = o, this.renderInstances = l, this.renderMultiDraw = c, this.renderMultiDrawInstances = h } function WebGLCapabilities(r, e, i, s) { let a; function o() { if (a !== void 0) return a; if (e.has("EXT_texture_filter_anisotropic") === !0) { const N = e.get("EXT_texture_filter_anisotropic"); a = r.getParameter(N.MAX_TEXTURE_MAX_ANISOTROPY_EXT) } else a = 0; return a } function l(N) { return !(N !== RGBAFormat && s.convert(N) !== r.getParameter(r.IMPLEMENTATION_COLOR_READ_FORMAT)) } function c(N) { const H = N === HalfFloatType && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float")); return !(N !== UnsignedByteType && s.convert(N) !== r.getParameter(r.IMPLEMENTATION_COLOR_READ_TYPE) && N !== FloatType && !H) } function h(N) { if (N === "highp") { if (r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.HIGH_FLOAT).precision > 0 && r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.HIGH_FLOAT).precision > 0) return "highp"; N = "mediump" } return N === "mediump" && r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.MEDIUM_FLOAT).precision > 0 && r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp" } let d = i.precision !== void 0 ? i.precision : "highp"; const p = h(d); p !== d && (console.warn("THREE.WebGLRenderer:", d, "not supported, using", p, "instead."), d = p); const f = i.logarithmicDepthBuffer === !0, _ = i.reversedDepthBuffer === !0 && e.has("EXT_clip_control"), x = r.getParameter(r.MAX_TEXTURE_IMAGE_UNITS), b = r.getParameter(r.MAX_VERTEX_TEXTURE_IMAGE_UNITS), T = r.getParameter(r.MAX_TEXTURE_SIZE), M = r.getParameter(r.MAX_CUBE_MAP_TEXTURE_SIZE), w = r.getParameter(r.MAX_VERTEX_ATTRIBS), D = r.getParameter(r.MAX_VERTEX_UNIFORM_VECTORS), R = r.getParameter(r.MAX_VARYING_VECTORS), P = r.getParameter(r.MAX_FRAGMENT_UNIFORM_VECTORS), U = b > 0, O = r.getParameter(r.MAX_SAMPLES); return { isWebGL2: !0, getMaxAnisotropy: o, getMaxPrecision: h, textureFormatReadable: l, textureTypeReadable: c, precision: d, logarithmicDepthBuffer: f, reversedDepthBuffer: _, maxTextures: x, maxVertexTextures: b, maxTextureSize: T, maxCubemapSize: M, maxAttributes: w, maxVertexUniforms: D, maxVaryings: R, maxFragmentUniforms: P, vertexTextures: U, maxSamples: O } } function WebGLClipping(r) { const e = this; let i = null, s = 0, a = !1, o = !1; const l = new Plane, c = new Matrix3, h = { value: null, needsUpdate: !1 }; this.uniform = h, this.numPlanes = 0, this.numIntersection = 0, this.init = function (f, _) { const x = f.length !== 0 || _ || s !== 0 || a; return a = _, s = f.length, x }, this.beginShadows = function () { o = !0, p(null) }, this.endShadows = function () { o = !1 }, this.setGlobalState = function (f, _) { i = p(f, _, 0) }, this.setState = function (f, _, x) { const b = f.clippingPlanes, T = f.clipIntersection, M = f.clipShadows, w = r.get(f); if (!a || b === null || b.length === 0 || o && !M) o ? p(null) : d(); else { const D = o ? 0 : s, R = D * 4; let P = w.clippingState || null; h.value = P, P = p(b, _, R, x); for (let U = 0; U !== R; ++U)P[U] = i[U]; w.clippingState = P, this.numIntersection = T ? this.numPlanes : 0, this.numPlanes += D } }; function d() { h.value !== i && (h.value = i, h.needsUpdate = s > 0), e.numPlanes = s, e.numIntersection = 0 } function p(f, _, x, b) { const T = f !== null ? f.length : 0; let M = null; if (T !== 0) { if (M = h.value, b !== !0 || M === null) { const w = x + T * 4, D = _.matrixWorldInverse; c.getNormalMatrix(D), (M === null || M.length < w) && (M = new Float32Array(w)); for (let R = 0, P = x; R !== T; ++R, P += 4)l.copy(f[R]).applyMatrix4(D, c), l.normal.toArray(M, P), M[P + 3] = l.constant } h.value = M, h.needsUpdate = !0 } return e.numPlanes = T, e.numIntersection = 0, M } } function WebGLCubeMaps(r) { let e = new WeakMap; function i(l, c) { return c === EquirectangularReflectionMapping ? l.mapping = CubeReflectionMapping : c === EquirectangularRefractionMapping && (l.mapping = CubeRefractionMapping), l } function s(l) { if (l && l.isTexture) { const c = l.mapping; if (c === EquirectangularReflectionMapping || c === EquirectangularRefractionMapping) if (e.has(l)) { const h = e.get(l).texture; return i(h, l.mapping) } else { const h = l.image; if (h && h.height > 0) { const d = new WebGLCubeRenderTarget(h.height); return d.fromEquirectangularTexture(r, l), e.set(l, d), l.addEventListener("dispose", a), i(d.texture, l.mapping) } else return null } } return l } function a(l) { const c = l.target; c.removeEventListener("dispose", a); const h = e.get(c); h !== void 0 && (e.delete(c), h.dispose()) } function o() { e = new WeakMap } return { get: s, dispose: o } } const LOD_MIN = 4, EXTRA_LOD_SIGMA = [.125, .215, .35, .446, .526, .582], MAX_SAMPLES = 20, _flatCamera = new OrthographicCamera, _clearColor$1 = new Color; let _oldTarget = null, _oldActiveCubeFace = 0, _oldActiveMipmapLevel = 0, _oldXrEnabled = !1; const PHI = (1 + Math.sqrt(5)) / 2, INV_PHI = 1 / PHI, _axisDirections = [new Vector3(-PHI, INV_PHI, 0), new Vector3(PHI, INV_PHI, 0), new Vector3(-INV_PHI, 0, PHI), new Vector3(INV_PHI, 0, PHI), new Vector3(0, PHI, -INV_PHI), new Vector3(0, PHI, INV_PHI), new Vector3(-1, 1, -1), new Vector3(1, 1, -1), new Vector3(-1, 1, 1), new Vector3(1, 1, 1)], _origin = new Vector3; class PMREMGenerator { constructor(e) { this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial) } fromScene(e, i = 0, s = .1, a = 100, o = {}) { const { size: l = 256, position: c = _origin } = o; _oldTarget = this._renderer.getRenderTarget(), _oldActiveCubeFace = this._renderer.getActiveCubeFace(), _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel(), _oldXrEnabled = this._renderer.xr.enabled, this._renderer.xr.enabled = !1, this._setSize(l); const h = this._allocateTargets(); return h.depthBuffer = !0, this._sceneToCubeUV(e, s, a, h, c), i > 0 && this._blur(h, 0, 0, i), this._applyPMREM(h), this._cleanup(h), h } fromEquirectangular(e, i = null) { return this._fromTexture(e, i) } fromCubemap(e, i = null) { return this._fromTexture(e, i) } compileCubemapShader() { this._cubemapMaterial === null && (this._cubemapMaterial = _getCubemapMaterial(), this._compileMaterial(this._cubemapMaterial)) } compileEquirectangularShader() { this._equirectMaterial === null && (this._equirectMaterial = _getEquirectMaterial(), this._compileMaterial(this._equirectMaterial)) } dispose() { this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose() } _setSize(e) { this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax) } _dispose() { this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose(); for (let e = 0; e < this._lodPlanes.length; e++)this._lodPlanes[e].dispose() } _cleanup(e) { this._renderer.setRenderTarget(_oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel), this._renderer.xr.enabled = _oldXrEnabled, e.scissorTest = !1, _setViewport(e, 0, 0, e.width, e.height) } _fromTexture(e, i) { e.mapping === CubeReflectionMapping || e.mapping === CubeRefractionMapping ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), _oldTarget = this._renderer.getRenderTarget(), _oldActiveCubeFace = this._renderer.getActiveCubeFace(), _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel(), _oldXrEnabled = this._renderer.xr.enabled, this._renderer.xr.enabled = !1; const s = i || this._allocateTargets(); return this._textureToCubeUV(e, s), this._applyPMREM(s), this._cleanup(s), s } _allocateTargets() { const e = 3 * Math.max(this._cubeSize, 112), i = 4 * this._cubeSize, s = { magFilter: LinearFilter, minFilter: LinearFilter, generateMipmaps: !1, type: HalfFloatType, format: RGBAFormat, colorSpace: LinearSRGBColorSpace, depthBuffer: !1 }, a = _createRenderTarget(e, i, s); if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== i) { this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = _createRenderTarget(e, i, s); const { _lodMax: o } = this; ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = _createPlanes(o)), this._blurMaterial = _getBlurShader(o, e, i) } return a } _compileMaterial(e) { const i = new Mesh(this._lodPlanes[0], e); this._renderer.compile(i, _flatCamera) } _sceneToCubeUV(e, i, s, a, o) { const h = new PerspectiveCamera(90, 1, i, s), d = [1, -1, 1, 1, 1, 1], p = [1, 1, 1, -1, -1, -1], f = this._renderer, _ = f.autoClear, x = f.toneMapping; f.getClearColor(_clearColor$1), f.toneMapping = NoToneMapping, f.autoClear = !1, f.state.buffers.depth.getReversed() && (f.setRenderTarget(a), f.clearDepth(), f.setRenderTarget(null)); const T = new MeshBasicMaterial({ name: "PMREM.Background", side: BackSide, depthWrite: !1, depthTest: !1 }), M = new Mesh(new BoxGeometry, T); let w = !1; const D = e.background; D ? D.isColor && (T.color.copy(D), e.background = null, w = !0) : (T.color.copy(_clearColor$1), w = !0); for (let R = 0; R < 6; R++) { const P = R % 3; P === 0 ? (h.up.set(0, d[R], 0), h.position.set(o.x, o.y, o.z), h.lookAt(o.x + p[R], o.y, o.z)) : P === 1 ? (h.up.set(0, 0, d[R]), h.position.set(o.x, o.y, o.z), h.lookAt(o.x, o.y + p[R], o.z)) : (h.up.set(0, d[R], 0), h.position.set(o.x, o.y, o.z), h.lookAt(o.x, o.y, o.z + p[R])); const U = this._cubeSize; _setViewport(a, P * U, R > 2 ? U : 0, U, U), f.setRenderTarget(a), w && f.render(M, h), f.render(e, h) } M.geometry.dispose(), M.material.dispose(), f.toneMapping = x, f.autoClear = _, e.background = D } _textureToCubeUV(e, i) { const s = this._renderer, a = e.mapping === CubeReflectionMapping || e.mapping === CubeRefractionMapping; a ? (this._cubemapMaterial === null && (this._cubemapMaterial = _getCubemapMaterial()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = _getEquirectMaterial()); const o = a ? this._cubemapMaterial : this._equirectMaterial, l = new Mesh(this._lodPlanes[0], o), c = o.uniforms; c.envMap.value = e; const h = this._cubeSize; _setViewport(i, 0, 0, 3 * h, 2 * h), s.setRenderTarget(i), s.render(l, _flatCamera) } _applyPMREM(e) { const i = this._renderer, s = i.autoClear; i.autoClear = !1; const a = this._lodPlanes.length; for (let o = 1; o < a; o++) { const l = Math.sqrt(this._sigmas[o] * this._sigmas[o] - this._sigmas[o - 1] * this._sigmas[o - 1]), c = _axisDirections[(a - o - 1) % _axisDirections.length]; this._blur(e, o - 1, o, l, c) } i.autoClear = s } _blur(e, i, s, a, o) { const l = this._pingPongRenderTarget; this._halfBlur(e, l, i, s, a, "latitudinal", o), this._halfBlur(l, e, s, s, a, "longitudinal", o) } _halfBlur(e, i, s, a, o, l, c) { const h = this._renderer, d = this._blurMaterial; l !== "latitudinal" && l !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!"); const p = 3, f = new Mesh(this._lodPlanes[a], d), _ = d.uniforms, x = this._sizeLods[s] - 1, b = isFinite(o) ? Math.PI / (2 * x) : 2 * Math.PI / (2 * MAX_SAMPLES - 1), T = o / b, M = isFinite(o) ? 1 + Math.floor(p * T) : MAX_SAMPLES; M > MAX_SAMPLES && console.warn(`sigmaRadians, ${o}, is too large and will clip, as it requested ${M} samples when the maximum is set to ${MAX_SAMPLES}`); const w = []; let D = 0; for (let N = 0; N < MAX_SAMPLES; ++N) { const H = N / T, F = Math.exp(-H * H / 2); w.push(F), N === 0 ? D += F : N < M && (D += 2 * F) } for (let N = 0; N < w.length; N++)w[N] = w[N] / D; _.envMap.value = e.texture, _.samples.value = M, _.weights.value = w, _.latitudinal.value = l === "latitudinal", c && (_.poleAxis.value = c); const { _lodMax: R } = this; _.dTheta.value = b, _.mipInt.value = R - s; const P = this._sizeLods[a], U = 3 * P * (a > R - LOD_MIN ? a - R + LOD_MIN : 0), O = 4 * (this._cubeSize - P); _setViewport(i, U, O, 3 * P, 2 * P), h.setRenderTarget(i), h.render(f, _flatCamera) } } function _createPlanes(r) { const e = [], i = [], s = []; let a = r; const o = r - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length; for (let l = 0; l < o; l++) { const c = Math.pow(2, a); i.push(c); let h = 1 / c; l > r - LOD_MIN ? h = EXTRA_LOD_SIGMA[l - r + LOD_MIN - 1] : l === 0 && (h = 0), s.push(h); const d = 1 / (c - 2), p = -d, f = 1 + d, _ = [p, p, f, p, f, f, p, p, f, f, p, f], x = 6, b = 6, T = 3, M = 2, w = 1, D = new Float32Array(T * b * x), R = new Float32Array(M * b * x), P = new Float32Array(w * b * x); for (let O = 0; O < x; O++) { const N = O % 3 * 2 / 3 - 1, H = O > 2 ? 0 : -1, F = [N, H, 0, N + 2 / 3, H, 0, N + 2 / 3, H + 1, 0, N, H, 0, N + 2 / 3, H + 1, 0, N, H + 1, 0]; D.set(F, T * b * O), R.set(_, M * b * O); const k = [O, O, O, O, O, O]; P.set(k, w * b * O) } const U = new BufferGeometry; U.setAttribute("position", new BufferAttribute(D, T)), U.setAttribute("uv", new BufferAttribute(R, M)), U.setAttribute("faceIndex", new BufferAttribute(P, w)), e.push(U), a > LOD_MIN && a-- } return { lodPlanes: e, sizeLods: i, sigmas: s } } function _createRenderTarget(r, e, i) { const s = new WebGLRenderTarget(r, e, i); return s.texture.mapping = CubeUVReflectionMapping, s.texture.name = "PMREM.cubeUv", s.scissorTest = !0, s } function _setViewport(r, e, i, s, a) { r.viewport.set(e, i, s, a), r.scissor.set(e, i, s, a) } function _getBlurShader(r, e, i) {
    const s = new Float32Array(MAX_SAMPLES), a = new Vector3(0, 1, 0); return new ShaderMaterial({
        name: "SphericalGaussianBlur", defines: { n: MAX_SAMPLES, CUBEUV_TEXEL_WIDTH: 1 / e, CUBEUV_TEXEL_HEIGHT: 1 / i, CUBEUV_MAX_MIP: `${r}.0` }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: s }, latitudinal: { value: !1 }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: a } }, vertexShader: _getCommonVertexShader(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`, blending: NoBlending, depthTest: !1, depthWrite: !1
    })
} function _getEquirectMaterial() {
    return new ShaderMaterial({
        name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null } }, vertexShader: _getCommonVertexShader(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`, blending: NoBlending, depthTest: !1, depthWrite: !1
    })
} function _getCubemapMaterial() {
    return new ShaderMaterial({
        name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } }, vertexShader: _getCommonVertexShader(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`, blending: NoBlending, depthTest: !1, depthWrite: !1
    })
} function _getCommonVertexShader() {
    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`} function WebGLCubeUVMaps(r) { let e = new WeakMap, i = null; function s(c) { if (c && c.isTexture) { const h = c.mapping, d = h === EquirectangularReflectionMapping || h === EquirectangularRefractionMapping, p = h === CubeReflectionMapping || h === CubeRefractionMapping; if (d || p) { let f = e.get(c); const _ = f !== void 0 ? f.texture.pmremVersion : 0; if (c.isRenderTargetTexture && c.pmremVersion !== _) return i === null && (i = new PMREMGenerator(r)), f = d ? i.fromEquirectangular(c, f) : i.fromCubemap(c, f), f.texture.pmremVersion = c.pmremVersion, e.set(c, f), f.texture; if (f !== void 0) return f.texture; { const x = c.image; return d && x && x.height > 0 || p && x && a(x) ? (i === null && (i = new PMREMGenerator(r)), f = d ? i.fromEquirectangular(c) : i.fromCubemap(c), f.texture.pmremVersion = c.pmremVersion, e.set(c, f), c.addEventListener("dispose", o), f.texture) : null } } } return c } function a(c) { let h = 0; const d = 6; for (let p = 0; p < d; p++)c[p] !== void 0 && h++; return h === d } function o(c) { const h = c.target; h.removeEventListener("dispose", o); const d = e.get(h); d !== void 0 && (e.delete(h), d.dispose()) } function l() { e = new WeakMap, i !== null && (i.dispose(), i = null) } return { get: s, dispose: l } } function WebGLExtensions(r) { const e = {}; function i(s) { if (e[s] !== void 0) return e[s]; let a; switch (s) { case "WEBGL_depth_texture": a = r.getExtension("WEBGL_depth_texture") || r.getExtension("MOZ_WEBGL_depth_texture") || r.getExtension("WEBKIT_WEBGL_depth_texture"); break; case "EXT_texture_filter_anisotropic": a = r.getExtension("EXT_texture_filter_anisotropic") || r.getExtension("MOZ_EXT_texture_filter_anisotropic") || r.getExtension("WEBKIT_EXT_texture_filter_anisotropic"); break; case "WEBGL_compressed_texture_s3tc": a = r.getExtension("WEBGL_compressed_texture_s3tc") || r.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || r.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"); break; case "WEBGL_compressed_texture_pvrtc": a = r.getExtension("WEBGL_compressed_texture_pvrtc") || r.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"); break; default: a = r.getExtension(s) }return e[s] = a, a } return { has: function (s) { return i(s) !== null }, init: function () { i("EXT_color_buffer_float"), i("WEBGL_clip_cull_distance"), i("OES_texture_float_linear"), i("EXT_color_buffer_half_float"), i("WEBGL_multisampled_render_to_texture"), i("WEBGL_render_shared_exponent") }, get: function (s) { const a = i(s); return a === null && warnOnce("THREE.WebGLRenderer: " + s + " extension not supported."), a } } } function WebGLGeometries(r, e, i, s) { const a = {}, o = new WeakMap; function l(f) { const _ = f.target; _.index !== null && e.remove(_.index); for (const b in _.attributes) e.remove(_.attributes[b]); _.removeEventListener("dispose", l), delete a[_.id]; const x = o.get(_); x && (e.remove(x), o.delete(_)), s.releaseStatesOfGeometry(_), _.isInstancedBufferGeometry === !0 && delete _._maxInstanceCount, i.memory.geometries-- } function c(f, _) { return a[_.id] === !0 || (_.addEventListener("dispose", l), a[_.id] = !0, i.memory.geometries++), _ } function h(f) { const _ = f.attributes; for (const x in _) e.update(_[x], r.ARRAY_BUFFER) } function d(f) { const _ = [], x = f.index, b = f.attributes.position; let T = 0; if (x !== null) { const D = x.array; T = x.version; for (let R = 0, P = D.length; R < P; R += 3) { const U = D[R + 0], O = D[R + 1], N = D[R + 2]; _.push(U, O, O, N, N, U) } } else if (b !== void 0) { const D = b.array; T = b.version; for (let R = 0, P = D.length / 3 - 1; R < P; R += 3) { const U = R + 0, O = R + 1, N = R + 2; _.push(U, O, O, N, N, U) } } else return; const M = new (arrayNeedsUint32(_) ? Uint32BufferAttribute : Uint16BufferAttribute)(_, 1); M.version = T; const w = o.get(f); w && e.remove(w), o.set(f, M) } function p(f) { const _ = o.get(f); if (_) { const x = f.index; x !== null && _.version < x.version && d(f) } else d(f); return o.get(f) } return { get: c, update: h, getWireframeAttribute: p } } function WebGLIndexedBufferRenderer(r, e, i) { let s; function a(_) { s = _ } let o, l; function c(_) { o = _.type, l = _.bytesPerElement } function h(_, x) { r.drawElements(s, x, o, _ * l), i.update(x, s, 1) } function d(_, x, b) { b !== 0 && (r.drawElementsInstanced(s, x, o, _ * l, b), i.update(x, s, b)) } function p(_, x, b) { if (b === 0) return; e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(s, x, 0, o, _, 0, b); let M = 0; for (let w = 0; w < b; w++)M += x[w]; i.update(M, s, 1) } function f(_, x, b, T) { if (b === 0) return; const M = e.get("WEBGL_multi_draw"); if (M === null) for (let w = 0; w < _.length; w++)d(_[w] / l, x[w], T[w]); else { M.multiDrawElementsInstancedWEBGL(s, x, 0, o, _, 0, T, 0, b); let w = 0; for (let D = 0; D < b; D++)w += x[D] * T[D]; i.update(w, s, 1) } } this.setMode = a, this.setIndex = c, this.render = h, this.renderInstances = d, this.renderMultiDraw = p, this.renderMultiDrawInstances = f } function WebGLInfo(r) { const e = { geometries: 0, textures: 0 }, i = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }; function s(o, l, c) { switch (i.calls++, l) { case r.TRIANGLES: i.triangles += c * (o / 3); break; case r.LINES: i.lines += c * (o / 2); break; case r.LINE_STRIP: i.lines += c * (o - 1); break; case r.LINE_LOOP: i.lines += c * o; break; case r.POINTS: i.points += c * o; break; default: console.error("THREE.WebGLInfo: Unknown draw mode:", l); break } } function a() { i.calls = 0, i.triangles = 0, i.points = 0, i.lines = 0 } return { memory: e, render: i, programs: null, autoReset: !0, reset: a, update: s } } function WebGLMorphtargets(r, e, i) { const s = new WeakMap, a = new Vector4; function o(l, c, h) { const d = l.morphTargetInfluences, p = c.morphAttributes.position || c.morphAttributes.normal || c.morphAttributes.color, f = p !== void 0 ? p.length : 0; let _ = s.get(c); if (_ === void 0 || _.count !== f) { let F = function () { N.dispose(), s.delete(c), c.removeEventListener("dispose", F) }; _ !== void 0 && _.texture.dispose(); const x = c.morphAttributes.position !== void 0, b = c.morphAttributes.normal !== void 0, T = c.morphAttributes.color !== void 0, M = c.morphAttributes.position || [], w = c.morphAttributes.normal || [], D = c.morphAttributes.color || []; let R = 0; x === !0 && (R = 1), b === !0 && (R = 2), T === !0 && (R = 3); let P = c.attributes.position.count * R, U = 1; P > e.maxTextureSize && (U = Math.ceil(P / e.maxTextureSize), P = e.maxTextureSize); const O = new Float32Array(P * U * 4 * f), N = new DataArrayTexture(O, P, U, f); N.type = FloatType, N.needsUpdate = !0; const H = R * 4; for (let k = 0; k < f; k++) { const W = M[k], $ = w[k], Z = D[k], J = P * U * 4 * k; for (let se = 0; se < W.count; se++) { const re = se * H; x === !0 && (a.fromBufferAttribute(W, se), O[J + re + 0] = a.x, O[J + re + 1] = a.y, O[J + re + 2] = a.z, O[J + re + 3] = 0), b === !0 && (a.fromBufferAttribute($, se), O[J + re + 4] = a.x, O[J + re + 5] = a.y, O[J + re + 6] = a.z, O[J + re + 7] = 0), T === !0 && (a.fromBufferAttribute(Z, se), O[J + re + 8] = a.x, O[J + re + 9] = a.y, O[J + re + 10] = a.z, O[J + re + 11] = Z.itemSize === 4 ? a.w : 1) } } _ = { count: f, texture: N, size: new Vector2(P, U) }, s.set(c, _), c.addEventListener("dispose", F) } if (l.isInstancedMesh === !0 && l.morphTexture !== null) h.getUniforms().setValue(r, "morphTexture", l.morphTexture, i); else { let x = 0; for (let T = 0; T < d.length; T++)x += d[T]; const b = c.morphTargetsRelative ? 1 : 1 - x; h.getUniforms().setValue(r, "morphTargetBaseInfluence", b), h.getUniforms().setValue(r, "morphTargetInfluences", d) } h.getUniforms().setValue(r, "morphTargetsTexture", _.texture, i), h.getUniforms().setValue(r, "morphTargetsTextureSize", _.size) } return { update: o } } function WebGLObjects(r, e, i, s) { let a = new WeakMap; function o(h) { const d = s.render.frame, p = h.geometry, f = e.get(h, p); if (a.get(f) !== d && (e.update(f), a.set(f, d)), h.isInstancedMesh && (h.hasEventListener("dispose", c) === !1 && h.addEventListener("dispose", c), a.get(h) !== d && (i.update(h.instanceMatrix, r.ARRAY_BUFFER), h.instanceColor !== null && i.update(h.instanceColor, r.ARRAY_BUFFER), a.set(h, d))), h.isSkinnedMesh) { const _ = h.skeleton; a.get(_) !== d && (_.update(), a.set(_, d)) } return f } function l() { a = new WeakMap } function c(h) { const d = h.target; d.removeEventListener("dispose", c), i.remove(d.instanceMatrix), d.instanceColor !== null && i.remove(d.instanceColor) } return { update: o, dispose: l } } const emptyTexture = new Texture, emptyShadowTexture = new DepthTexture(1, 1), emptyArrayTexture = new DataArrayTexture, empty3dTexture = new Data3DTexture, emptyCubeTexture = new CubeTexture, arrayCacheF32 = [], arrayCacheI32 = [], mat4array = new Float32Array(16), mat3array = new Float32Array(9), mat2array = new Float32Array(4); function flatten(r, e, i) { const s = r[0]; if (s <= 0 || s > 0) return r; const a = e * i; let o = arrayCacheF32[a]; if (o === void 0 && (o = new Float32Array(a), arrayCacheF32[a] = o), e !== 0) { s.toArray(o, 0); for (let l = 1, c = 0; l !== e; ++l)c += i, r[l].toArray(o, c) } return o } function arraysEqual(r, e) { if (r.length !== e.length) return !1; for (let i = 0, s = r.length; i < s; i++)if (r[i] !== e[i]) return !1; return !0 } function copyArray(r, e) { for (let i = 0, s = e.length; i < s; i++)r[i] = e[i] } function allocTexUnits(r, e) { let i = arrayCacheI32[e]; i === void 0 && (i = new Int32Array(e), arrayCacheI32[e] = i); for (let s = 0; s !== e; ++s)i[s] = r.allocateTextureUnit(); return i } function setValueV1f(r, e) { const i = this.cache; i[0] !== e && (r.uniform1f(this.addr, e), i[0] = e) } function setValueV2f(r, e) { const i = this.cache; if (e.x !== void 0) (i[0] !== e.x || i[1] !== e.y) && (r.uniform2f(this.addr, e.x, e.y), i[0] = e.x, i[1] = e.y); else { if (arraysEqual(i, e)) return; r.uniform2fv(this.addr, e), copyArray(i, e) } } function setValueV3f(r, e) { const i = this.cache; if (e.x !== void 0) (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z) && (r.uniform3f(this.addr, e.x, e.y, e.z), i[0] = e.x, i[1] = e.y, i[2] = e.z); else if (e.r !== void 0) (i[0] !== e.r || i[1] !== e.g || i[2] !== e.b) && (r.uniform3f(this.addr, e.r, e.g, e.b), i[0] = e.r, i[1] = e.g, i[2] = e.b); else { if (arraysEqual(i, e)) return; r.uniform3fv(this.addr, e), copyArray(i, e) } } function setValueV4f(r, e) { const i = this.cache; if (e.x !== void 0) (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z || i[3] !== e.w) && (r.uniform4f(this.addr, e.x, e.y, e.z, e.w), i[0] = e.x, i[1] = e.y, i[2] = e.z, i[3] = e.w); else { if (arraysEqual(i, e)) return; r.uniform4fv(this.addr, e), copyArray(i, e) } } function setValueM2(r, e) { const i = this.cache, s = e.elements; if (s === void 0) { if (arraysEqual(i, e)) return; r.uniformMatrix2fv(this.addr, !1, e), copyArray(i, e) } else { if (arraysEqual(i, s)) return; mat2array.set(s), r.uniformMatrix2fv(this.addr, !1, mat2array), copyArray(i, s) } } function setValueM3(r, e) { const i = this.cache, s = e.elements; if (s === void 0) { if (arraysEqual(i, e)) return; r.uniformMatrix3fv(this.addr, !1, e), copyArray(i, e) } else { if (arraysEqual(i, s)) return; mat3array.set(s), r.uniformMatrix3fv(this.addr, !1, mat3array), copyArray(i, s) } } function setValueM4(r, e) { const i = this.cache, s = e.elements; if (s === void 0) { if (arraysEqual(i, e)) return; r.uniformMatrix4fv(this.addr, !1, e), copyArray(i, e) } else { if (arraysEqual(i, s)) return; mat4array.set(s), r.uniformMatrix4fv(this.addr, !1, mat4array), copyArray(i, s) } } function setValueV1i(r, e) { const i = this.cache; i[0] !== e && (r.uniform1i(this.addr, e), i[0] = e) } function setValueV2i(r, e) { const i = this.cache; if (e.x !== void 0) (i[0] !== e.x || i[1] !== e.y) && (r.uniform2i(this.addr, e.x, e.y), i[0] = e.x, i[1] = e.y); else { if (arraysEqual(i, e)) return; r.uniform2iv(this.addr, e), copyArray(i, e) } } function setValueV3i(r, e) { const i = this.cache; if (e.x !== void 0) (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z) && (r.uniform3i(this.addr, e.x, e.y, e.z), i[0] = e.x, i[1] = e.y, i[2] = e.z); else { if (arraysEqual(i, e)) return; r.uniform3iv(this.addr, e), copyArray(i, e) } } function setValueV4i(r, e) { const i = this.cache; if (e.x !== void 0) (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z || i[3] !== e.w) && (r.uniform4i(this.addr, e.x, e.y, e.z, e.w), i[0] = e.x, i[1] = e.y, i[2] = e.z, i[3] = e.w); else { if (arraysEqual(i, e)) return; r.uniform4iv(this.addr, e), copyArray(i, e) } } function setValueV1ui(r, e) { const i = this.cache; i[0] !== e && (r.uniform1ui(this.addr, e), i[0] = e) } function setValueV2ui(r, e) { const i = this.cache; if (e.x !== void 0) (i[0] !== e.x || i[1] !== e.y) && (r.uniform2ui(this.addr, e.x, e.y), i[0] = e.x, i[1] = e.y); else { if (arraysEqual(i, e)) return; r.uniform2uiv(this.addr, e), copyArray(i, e) } } function setValueV3ui(r, e) { const i = this.cache; if (e.x !== void 0) (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z) && (r.uniform3ui(this.addr, e.x, e.y, e.z), i[0] = e.x, i[1] = e.y, i[2] = e.z); else { if (arraysEqual(i, e)) return; r.uniform3uiv(this.addr, e), copyArray(i, e) } } function setValueV4ui(r, e) { const i = this.cache; if (e.x !== void 0) (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z || i[3] !== e.w) && (r.uniform4ui(this.addr, e.x, e.y, e.z, e.w), i[0] = e.x, i[1] = e.y, i[2] = e.z, i[3] = e.w); else { if (arraysEqual(i, e)) return; r.uniform4uiv(this.addr, e), copyArray(i, e) } } function setValueT1(r, e, i) { const s = this.cache, a = i.allocateTextureUnit(); s[0] !== a && (r.uniform1i(this.addr, a), s[0] = a); let o; this.type === r.SAMPLER_2D_SHADOW ? (emptyShadowTexture.compareFunction = LessEqualCompare, o = emptyShadowTexture) : o = emptyTexture, i.setTexture2D(e || o, a) } function setValueT3D1(r, e, i) { const s = this.cache, a = i.allocateTextureUnit(); s[0] !== a && (r.uniform1i(this.addr, a), s[0] = a), i.setTexture3D(e || empty3dTexture, a) } function setValueT6(r, e, i) { const s = this.cache, a = i.allocateTextureUnit(); s[0] !== a && (r.uniform1i(this.addr, a), s[0] = a), i.setTextureCube(e || emptyCubeTexture, a) } function setValueT2DArray1(r, e, i) { const s = this.cache, a = i.allocateTextureUnit(); s[0] !== a && (r.uniform1i(this.addr, a), s[0] = a), i.setTexture2DArray(e || emptyArrayTexture, a) } function getSingularSetter(r) { switch (r) { case 5126: return setValueV1f; case 35664: return setValueV2f; case 35665: return setValueV3f; case 35666: return setValueV4f; case 35674: return setValueM2; case 35675: return setValueM3; case 35676: return setValueM4; case 5124: case 35670: return setValueV1i; case 35667: case 35671: return setValueV2i; case 35668: case 35672: return setValueV3i; case 35669: case 35673: return setValueV4i; case 5125: return setValueV1ui; case 36294: return setValueV2ui; case 36295: return setValueV3ui; case 36296: return setValueV4ui; case 35678: case 36198: case 36298: case 36306: case 35682: return setValueT1; case 35679: case 36299: case 36307: return setValueT3D1; case 35680: case 36300: case 36308: case 36293: return setValueT6; case 36289: case 36303: case 36311: case 36292: return setValueT2DArray1 } } function setValueV1fArray(r, e) { r.uniform1fv(this.addr, e) } function setValueV2fArray(r, e) { const i = flatten(e, this.size, 2); r.uniform2fv(this.addr, i) } function setValueV3fArray(r, e) { const i = flatten(e, this.size, 3); r.uniform3fv(this.addr, i) } function setValueV4fArray(r, e) { const i = flatten(e, this.size, 4); r.uniform4fv(this.addr, i) } function setValueM2Array(r, e) { const i = flatten(e, this.size, 4); r.uniformMatrix2fv(this.addr, !1, i) } function setValueM3Array(r, e) { const i = flatten(e, this.size, 9); r.uniformMatrix3fv(this.addr, !1, i) } function setValueM4Array(r, e) { const i = flatten(e, this.size, 16); r.uniformMatrix4fv(this.addr, !1, i) } function setValueV1iArray(r, e) { r.uniform1iv(this.addr, e) } function setValueV2iArray(r, e) { r.uniform2iv(this.addr, e) } function setValueV3iArray(r, e) { r.uniform3iv(this.addr, e) } function setValueV4iArray(r, e) { r.uniform4iv(this.addr, e) } function setValueV1uiArray(r, e) { r.uniform1uiv(this.addr, e) } function setValueV2uiArray(r, e) { r.uniform2uiv(this.addr, e) } function setValueV3uiArray(r, e) { r.uniform3uiv(this.addr, e) } function setValueV4uiArray(r, e) { r.uniform4uiv(this.addr, e) } function setValueT1Array(r, e, i) { const s = this.cache, a = e.length, o = allocTexUnits(i, a); arraysEqual(s, o) || (r.uniform1iv(this.addr, o), copyArray(s, o)); for (let l = 0; l !== a; ++l)i.setTexture2D(e[l] || emptyTexture, o[l]) } function setValueT3DArray(r, e, i) { const s = this.cache, a = e.length, o = allocTexUnits(i, a); arraysEqual(s, o) || (r.uniform1iv(this.addr, o), copyArray(s, o)); for (let l = 0; l !== a; ++l)i.setTexture3D(e[l] || empty3dTexture, o[l]) } function setValueT6Array(r, e, i) { const s = this.cache, a = e.length, o = allocTexUnits(i, a); arraysEqual(s, o) || (r.uniform1iv(this.addr, o), copyArray(s, o)); for (let l = 0; l !== a; ++l)i.setTextureCube(e[l] || emptyCubeTexture, o[l]) } function setValueT2DArrayArray(r, e, i) { const s = this.cache, a = e.length, o = allocTexUnits(i, a); arraysEqual(s, o) || (r.uniform1iv(this.addr, o), copyArray(s, o)); for (let l = 0; l !== a; ++l)i.setTexture2DArray(e[l] || emptyArrayTexture, o[l]) } function getPureArraySetter(r) { switch (r) { case 5126: return setValueV1fArray; case 35664: return setValueV2fArray; case 35665: return setValueV3fArray; case 35666: return setValueV4fArray; case 35674: return setValueM2Array; case 35675: return setValueM3Array; case 35676: return setValueM4Array; case 5124: case 35670: return setValueV1iArray; case 35667: case 35671: return setValueV2iArray; case 35668: case 35672: return setValueV3iArray; case 35669: case 35673: return setValueV4iArray; case 5125: return setValueV1uiArray; case 36294: return setValueV2uiArray; case 36295: return setValueV3uiArray; case 36296: return setValueV4uiArray; case 35678: case 36198: case 36298: case 36306: case 35682: return setValueT1Array; case 35679: case 36299: case 36307: return setValueT3DArray; case 35680: case 36300: case 36308: case 36293: return setValueT6Array; case 36289: case 36303: case 36311: case 36292: return setValueT2DArrayArray } } class SingleUniform { constructor(e, i, s) { this.id = e, this.addr = s, this.cache = [], this.type = i.type, this.setValue = getSingularSetter(i.type) } } class PureArrayUniform { constructor(e, i, s) { this.id = e, this.addr = s, this.cache = [], this.type = i.type, this.size = i.size, this.setValue = getPureArraySetter(i.type) } } class StructuredUniform { constructor(e) { this.id = e, this.seq = [], this.map = {} } setValue(e, i, s) { const a = this.seq; for (let o = 0, l = a.length; o !== l; ++o) { const c = a[o]; c.setValue(e, i[c.id], s) } } } const RePathPart = /(\w+)(\])?(\[|\.)?/g; function addUniform(r, e) { r.seq.push(e), r.map[e.id] = e } function parseUniform(r, e, i) { const s = r.name, a = s.length; for (RePathPart.lastIndex = 0; ;) { const o = RePathPart.exec(s), l = RePathPart.lastIndex; let c = o[1]; const h = o[2] === "]", d = o[3]; if (h && (c = c | 0), d === void 0 || d === "[" && l + 2 === a) { addUniform(i, d === void 0 ? new SingleUniform(c, r, e) : new PureArrayUniform(c, r, e)); break } else { let f = i.map[c]; f === void 0 && (f = new StructuredUniform(c), addUniform(i, f)), i = f } } } class WebGLUniforms { constructor(e, i) { this.seq = [], this.map = {}; const s = e.getProgramParameter(i, e.ACTIVE_UNIFORMS); for (let a = 0; a < s; ++a) { const o = e.getActiveUniform(i, a), l = e.getUniformLocation(i, o.name); parseUniform(o, l, this) } } setValue(e, i, s, a) { const o = this.map[i]; o !== void 0 && o.setValue(e, s, a) } setOptional(e, i, s) { const a = i[s]; a !== void 0 && this.setValue(e, s, a) } static upload(e, i, s, a) { for (let o = 0, l = i.length; o !== l; ++o) { const c = i[o], h = s[c.id]; h.needsUpdate !== !1 && c.setValue(e, h.value, a) } } static seqWithValue(e, i) { const s = []; for (let a = 0, o = e.length; a !== o; ++a) { const l = e[a]; l.id in i && s.push(l) } return s } } function WebGLShader(r, e, i) { const s = r.createShader(e); return r.shaderSource(s, i), r.compileShader(s), s } const COMPLETION_STATUS_KHR = 37297; let programIdCount = 0; function handleSource(r, e) {
    const i = r.split(`
`), s = [], a = Math.max(e - 6, 0), o = Math.min(e + 6, i.length); for (let l = a; l < o; l++) { const c = l + 1; s.push(`${c === e ? ">" : " "} ${c}: ${i[l]}`) } return s.join(`
`)
} const _m0$5 = new Matrix3; function getEncodingComponents(r) { ColorManagement._getMatrix(_m0$5, ColorManagement.workingColorSpace, r); const e = `mat3( ${_m0$5.elements.map(i => i.toFixed(4))} )`; switch (ColorManagement.getTransfer(r)) { case LinearTransfer: return [e, "LinearTransferOETF"]; case SRGBTransfer: return [e, "sRGBTransferOETF"]; default: return console.warn("THREE.WebGLProgram: Unsupported color space: ", r), [e, "LinearTransferOETF"] } } function getShaderErrors(r, e, i) {
    const s = r.getShaderParameter(e, r.COMPILE_STATUS), o = (r.getShaderInfoLog(e) || "").trim(); if (s && o === "") return ""; const l = /ERROR: 0:(\d+)/.exec(o); if (l) {
        const c = parseInt(l[1]); return i.toUpperCase() + `

`+ o + `

`+ handleSource(r.getShaderSource(e), c)
    } else return o
} function getTexelEncodingFunction(r, e) {
    const i = getEncodingComponents(e); return [`vec4 ${r}( vec4 value ) {`, `	return ${i[1]}( vec4( value.rgb * ${i[0]}, value.a ) );`, "}"].join(`
`)
} function getToneMappingFunction(r, e) { let i; switch (e) { case LinearToneMapping: i = "Linear"; break; case ReinhardToneMapping: i = "Reinhard"; break; case CineonToneMapping: i = "Cineon"; break; case ACESFilmicToneMapping: i = "ACESFilmic"; break; case AgXToneMapping: i = "AgX"; break; case NeutralToneMapping: i = "Neutral"; break; case CustomToneMapping: i = "Custom"; break; default: console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), i = "Linear" }return "vec3 " + r + "( vec3 color ) { return " + i + "ToneMapping( color ); }" } const _v0$m = new Vector3; function getLuminanceFunction() {
    ColorManagement.getLuminanceCoefficients(_v0$m); const r = _v0$m.x.toFixed(4), e = _v0$m.y.toFixed(4), i = _v0$m.z.toFixed(4); return ["float luminance( const in vec3 rgb ) {", `	const vec3 weights = vec3( ${r}, ${e}, ${i} );`, "	return dot( weights, rgb );", "}"].join(`
`)
} function generateVertexExtensions(r) {
    return [r.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", r.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(filterEmptyLine).join(`
`)
} function generateDefines(r) {
    const e = []; for (const i in r) { const s = r[i]; s !== !1 && e.push("#define " + i + " " + s) } return e.join(`
`)
} function fetchAttributeLocations(r, e) { const i = {}, s = r.getProgramParameter(e, r.ACTIVE_ATTRIBUTES); for (let a = 0; a < s; a++) { const o = r.getActiveAttrib(e, a), l = o.name; let c = 1; o.type === r.FLOAT_MAT2 && (c = 2), o.type === r.FLOAT_MAT3 && (c = 3), o.type === r.FLOAT_MAT4 && (c = 4), i[l] = { type: o.type, location: r.getAttribLocation(e, l), locationSize: c } } return i } function filterEmptyLine(r) { return r !== "" } function replaceLightNums(r, e) { const i = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps; return r.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, i).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows) } function replaceClippingPlaneNums(r, e) { return r.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection) } const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm; function resolveIncludes(r) { return r.replace(includePattern, includeReplacer) } const shaderChunkMap = new Map; function includeReplacer(r, e) { let i = ShaderChunk[e]; if (i === void 0) { const s = shaderChunkMap.get(e); if (s !== void 0) i = ShaderChunk[s], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, s); else throw new Error("Can not resolve #include <" + e + ">") } return resolveIncludes(i) } const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g; function unrollLoops(r) { return r.replace(unrollLoopPattern, loopReplacer) } function loopReplacer(r, e, i, s) { let a = ""; for (let o = parseInt(e); o < parseInt(i); o++)a += s.replace(/\[\s*i\s*\]/g, "[ " + o + " ]").replace(/UNROLLED_LOOP_INDEX/g, o); return a } function generatePrecision(r) {
    let e = `precision ${r.precision} float;
	precision ${r.precision} int;
	precision ${r.precision} sampler2D;
	precision ${r.precision} samplerCube;
	precision ${r.precision} sampler3D;
	precision ${r.precision} sampler2DArray;
	precision ${r.precision} sampler2DShadow;
	precision ${r.precision} samplerCubeShadow;
	precision ${r.precision} sampler2DArrayShadow;
	precision ${r.precision} isampler2D;
	precision ${r.precision} isampler3D;
	precision ${r.precision} isamplerCube;
	precision ${r.precision} isampler2DArray;
	precision ${r.precision} usampler2D;
	precision ${r.precision} usampler3D;
	precision ${r.precision} usamplerCube;
	precision ${r.precision} usampler2DArray;
	`; return r.precision === "highp" ? e += `
#define HIGH_PRECISION`: r.precision === "mediump" ? e += `
#define MEDIUM_PRECISION`: r.precision === "lowp" && (e += `
#define LOW_PRECISION`), e
} function generateShadowMapTypeDefine(r) { let e = "SHADOWMAP_TYPE_BASIC"; return r.shadowMapType === PCFShadowMap ? e = "SHADOWMAP_TYPE_PCF" : r.shadowMapType === PCFSoftShadowMap ? e = "SHADOWMAP_TYPE_PCF_SOFT" : r.shadowMapType === VSMShadowMap && (e = "SHADOWMAP_TYPE_VSM"), e } function generateEnvMapTypeDefine(r) { let e = "ENVMAP_TYPE_CUBE"; if (r.envMap) switch (r.envMapMode) { case CubeReflectionMapping: case CubeRefractionMapping: e = "ENVMAP_TYPE_CUBE"; break; case CubeUVReflectionMapping: e = "ENVMAP_TYPE_CUBE_UV"; break }return e } function generateEnvMapModeDefine(r) { let e = "ENVMAP_MODE_REFLECTION"; if (r.envMap) switch (r.envMapMode) { case CubeRefractionMapping: e = "ENVMAP_MODE_REFRACTION"; break }return e } function generateEnvMapBlendingDefine(r) { let e = "ENVMAP_BLENDING_NONE"; if (r.envMap) switch (r.combine) { case MultiplyOperation: e = "ENVMAP_BLENDING_MULTIPLY"; break; case MixOperation: e = "ENVMAP_BLENDING_MIX"; break; case AddOperation: e = "ENVMAP_BLENDING_ADD"; break }return e } function generateCubeUVSize(r) { const e = r.envMapCubeUVHeight; if (e === null) return null; const i = Math.log2(e) - 2, s = 1 / e; return { texelWidth: 1 / (3 * Math.max(Math.pow(2, i), 7 * 16)), texelHeight: s, maxMip: i } } function WebGLProgram(r, e, i, s) {
    const a = r.getContext(), o = i.defines; let l = i.vertexShader, c = i.fragmentShader; const h = generateShadowMapTypeDefine(i), d = generateEnvMapTypeDefine(i), p = generateEnvMapModeDefine(i), f = generateEnvMapBlendingDefine(i), _ = generateCubeUVSize(i), x = generateVertexExtensions(i), b = generateDefines(o), T = a.createProgram(); let M, w, D = i.glslVersion ? "#version " + i.glslVersion + `
`: ""; i.isRawShaderMaterial ? (M = ["#define SHADER_TYPE " + i.shaderType, "#define SHADER_NAME " + i.shaderName, b].filter(filterEmptyLine).join(`
`), M.length > 0 && (M += `
`), w = ["#define SHADER_TYPE " + i.shaderType, "#define SHADER_NAME " + i.shaderName, b].filter(filterEmptyLine).join(`
`), w.length > 0 && (w += `
`)) : (M = [generatePrecision(i), "#define SHADER_TYPE " + i.shaderType, "#define SHADER_NAME " + i.shaderName, b, i.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", i.batching ? "#define USE_BATCHING" : "", i.batchingColor ? "#define USE_BATCHING_COLOR" : "", i.instancing ? "#define USE_INSTANCING" : "", i.instancingColor ? "#define USE_INSTANCING_COLOR" : "", i.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "", i.map ? "#define USE_MAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.envMap ? "#define " + p : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.aoMap ? "#define USE_AOMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", i.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", i.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", i.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i.anisotropy ? "#define USE_ANISOTROPY" : "", i.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", i.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", i.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i.metalnessMap ? "#define USE_METALNESSMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.alphaHash ? "#define USE_ALPHAHASH" : "", i.transmission ? "#define USE_TRANSMISSION" : "", i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i.thicknessMap ? "#define USE_THICKNESSMAP" : "", i.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", i.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", i.mapUv ? "#define MAP_UV " + i.mapUv : "", i.alphaMapUv ? "#define ALPHAMAP_UV " + i.alphaMapUv : "", i.lightMapUv ? "#define LIGHTMAP_UV " + i.lightMapUv : "", i.aoMapUv ? "#define AOMAP_UV " + i.aoMapUv : "", i.emissiveMapUv ? "#define EMISSIVEMAP_UV " + i.emissiveMapUv : "", i.bumpMapUv ? "#define BUMPMAP_UV " + i.bumpMapUv : "", i.normalMapUv ? "#define NORMALMAP_UV " + i.normalMapUv : "", i.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + i.displacementMapUv : "", i.metalnessMapUv ? "#define METALNESSMAP_UV " + i.metalnessMapUv : "", i.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + i.roughnessMapUv : "", i.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + i.anisotropyMapUv : "", i.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + i.clearcoatMapUv : "", i.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + i.clearcoatNormalMapUv : "", i.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + i.clearcoatRoughnessMapUv : "", i.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + i.iridescenceMapUv : "", i.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + i.iridescenceThicknessMapUv : "", i.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + i.sheenColorMapUv : "", i.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + i.sheenRoughnessMapUv : "", i.specularMapUv ? "#define SPECULARMAP_UV " + i.specularMapUv : "", i.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + i.specularColorMapUv : "", i.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + i.specularIntensityMapUv : "", i.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + i.transmissionMapUv : "", i.thicknessMapUv ? "#define THICKNESSMAP_UV " + i.thicknessMapUv : "", i.vertexTangents && i.flatShading === !1 ? "#define USE_TANGENT" : "", i.vertexColors ? "#define USE_COLOR" : "", i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", i.vertexUv1s ? "#define USE_UV1" : "", i.vertexUv2s ? "#define USE_UV2" : "", i.vertexUv3s ? "#define USE_UV3" : "", i.pointsUvs ? "#define USE_POINTS_UV" : "", i.flatShading ? "#define FLAT_SHADED" : "", i.skinning ? "#define USE_SKINNING" : "", i.morphTargets ? "#define USE_MORPHTARGETS" : "", i.morphNormals && i.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", i.morphColors ? "#define USE_MORPHCOLORS" : "", i.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + i.morphTextureStride : "", i.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + i.morphTargetsCount : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + h : "", i.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", i.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", i.logarithmicDepthBuffer ? "#define USE_LOGARITHMIC_DEPTH_BUFFER" : "", i.reversedDepthBuffer ? "#define USE_REVERSED_DEPTH_BUFFER" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "	uniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(filterEmptyLine).join(`
`), w = [generatePrecision(i), "#define SHADER_TYPE " + i.shaderType, "#define SHADER_NAME " + i.shaderName, b, i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "", i.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", i.map ? "#define USE_MAP" : "", i.matcap ? "#define USE_MATCAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.envMap ? "#define " + d : "", i.envMap ? "#define " + p : "", i.envMap ? "#define " + f : "", _ ? "#define CUBEUV_TEXEL_WIDTH " + _.texelWidth : "", _ ? "#define CUBEUV_TEXEL_HEIGHT " + _.texelHeight : "", _ ? "#define CUBEUV_MAX_MIP " + _.maxMip + ".0" : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.aoMap ? "#define USE_AOMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", i.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", i.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i.anisotropy ? "#define USE_ANISOTROPY" : "", i.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", i.clearcoat ? "#define USE_CLEARCOAT" : "", i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i.dispersion ? "#define USE_DISPERSION" : "", i.iridescence ? "#define USE_IRIDESCENCE" : "", i.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", i.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", i.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i.metalnessMap ? "#define USE_METALNESSMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.alphaTest ? "#define USE_ALPHATEST" : "", i.alphaHash ? "#define USE_ALPHAHASH" : "", i.sheen ? "#define USE_SHEEN" : "", i.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", i.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", i.transmission ? "#define USE_TRANSMISSION" : "", i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i.thicknessMap ? "#define USE_THICKNESSMAP" : "", i.vertexTangents && i.flatShading === !1 ? "#define USE_TANGENT" : "", i.vertexColors || i.instancingColor || i.batchingColor ? "#define USE_COLOR" : "", i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", i.vertexUv1s ? "#define USE_UV1" : "", i.vertexUv2s ? "#define USE_UV2" : "", i.vertexUv3s ? "#define USE_UV3" : "", i.pointsUvs ? "#define USE_POINTS_UV" : "", i.gradientMap ? "#define USE_GRADIENTMAP" : "", i.flatShading ? "#define FLAT_SHADED" : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + h : "", i.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", i.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", i.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", i.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "", i.logarithmicDepthBuffer ? "#define USE_LOGARITHMIC_DEPTH_BUFFER" : "", i.reversedDepthBuffer ? "#define USE_REVERSED_DEPTH_BUFFER" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", i.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "", i.toneMapping !== NoToneMapping ? ShaderChunk.tonemapping_pars_fragment : "", i.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", i.toneMapping) : "", i.dithering ? "#define DITHERING" : "", i.opaque ? "#define OPAQUE" : "", ShaderChunk.colorspace_pars_fragment, getTexelEncodingFunction("linearToOutputTexel", i.outputColorSpace), getLuminanceFunction(), i.useDepthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "", `
`].filter(filterEmptyLine).join(`
`)), l = resolveIncludes(l), l = replaceLightNums(l, i), l = replaceClippingPlaneNums(l, i), c = resolveIncludes(c), c = replaceLightNums(c, i), c = replaceClippingPlaneNums(c, i), l = unrollLoops(l), c = unrollLoops(c), i.isRawShaderMaterial !== !0 && (D = `#version 300 es
`, M = [x, "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
`+ M, w = ["#define varying in", i.glslVersion === GLSL3 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", i.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
`+ w); const R = D + M + l, P = D + w + c, U = WebGLShader(a, a.VERTEX_SHADER, R), O = WebGLShader(a, a.FRAGMENT_SHADER, P); a.attachShader(T, U), a.attachShader(T, O), i.index0AttributeName !== void 0 ? a.bindAttribLocation(T, 0, i.index0AttributeName) : i.morphTargets === !0 && a.bindAttribLocation(T, 0, "position"), a.linkProgram(T); function N(W) {
        if (r.debug.checkShaderErrors) {
            const $ = a.getProgramInfoLog(T) || "", Z = a.getShaderInfoLog(U) || "", J = a.getShaderInfoLog(O) || "", se = $.trim(), re = Z.trim(), ce = J.trim(); let ee = !0, Me = !0; if (a.getProgramParameter(T, a.LINK_STATUS) === !1) if (ee = !1, typeof r.debug.onShaderError == "function") r.debug.onShaderError(a, T, U, O); else {
                const Ee = getShaderErrors(a, U, "vertex"), Ue = getShaderErrors(a, O, "fragment"); console.error("THREE.WebGLProgram: Shader Error " + a.getError() + " - VALIDATE_STATUS " + a.getProgramParameter(T, a.VALIDATE_STATUS) + `

Material Name: `+ W.name + `
Material Type: `+ W.type + `

Program Info Log: `+ se + `
`+ Ee + `
`+ Ue)
            } else se !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", se) : (re === "" || ce === "") && (Me = !1); Me && (W.diagnostics = { runnable: ee, programLog: se, vertexShader: { log: re, prefix: M }, fragmentShader: { log: ce, prefix: w } })
        } a.deleteShader(U), a.deleteShader(O), H = new WebGLUniforms(a, T), F = fetchAttributeLocations(a, T)
    } let H; this.getUniforms = function () { return H === void 0 && N(this), H }; let F; this.getAttributes = function () { return F === void 0 && N(this), F }; let k = i.rendererExtensionParallelShaderCompile === !1; return this.isReady = function () { return k === !1 && (k = a.getProgramParameter(T, COMPLETION_STATUS_KHR)), k }, this.destroy = function () { s.releaseStatesOfProgram(this), a.deleteProgram(T), this.program = void 0 }, this.type = i.shaderType, this.name = i.shaderName, this.id = programIdCount++, this.cacheKey = e, this.usedTimes = 1, this.program = T, this.vertexShader = U, this.fragmentShader = O, this
} let _id = 0; class WebGLShaderCache { constructor() { this.shaderCache = new Map, this.materialCache = new Map } update(e) { const i = e.vertexShader, s = e.fragmentShader, a = this._getShaderStage(i), o = this._getShaderStage(s), l = this._getShaderCacheForMaterial(e); return l.has(a) === !1 && (l.add(a), a.usedTimes++), l.has(o) === !1 && (l.add(o), o.usedTimes++), this } remove(e) { const i = this.materialCache.get(e); for (const s of i) s.usedTimes--, s.usedTimes === 0 && this.shaderCache.delete(s.code); return this.materialCache.delete(e), this } getVertexShaderID(e) { return this._getShaderStage(e.vertexShader).id } getFragmentShaderID(e) { return this._getShaderStage(e.fragmentShader).id } dispose() { this.shaderCache.clear(), this.materialCache.clear() } _getShaderCacheForMaterial(e) { const i = this.materialCache; let s = i.get(e); return s === void 0 && (s = new Set, i.set(e, s)), s } _getShaderStage(e) { const i = this.shaderCache; let s = i.get(e); return s === void 0 && (s = new WebGLShaderStage(e), i.set(e, s)), s } } class WebGLShaderStage { constructor(e) { this.id = _id++, this.code = e, this.usedTimes = 0 } } function WebGLPrograms(r, e, i, s, a, o, l) { const c = new Layers, h = new WebGLShaderCache, d = new Set, p = [], f = a.logarithmicDepthBuffer, _ = a.vertexTextures; let x = a.precision; const b = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" }; function T(F) { return d.add(F), F === 0 ? "uv" : `uv${F}` } function M(F, k, W, $, Z) { const J = $.fog, se = Z.geometry, re = F.isMeshStandardMaterial ? $.environment : null, ce = (F.isMeshStandardMaterial ? i : e).get(F.envMap || re), ee = ce && ce.mapping === CubeUVReflectionMapping ? ce.image.height : null, Me = b[F.type]; F.precision !== null && (x = a.getMaxPrecision(F.precision), x !== F.precision && console.warn("THREE.WebGLProgram.getParameters:", F.precision, "not supported, using", x, "instead.")); const Ee = se.morphAttributes.position || se.morphAttributes.normal || se.morphAttributes.color, Ue = Ee !== void 0 ? Ee.length : 0; let nt = 0; se.morphAttributes.position !== void 0 && (nt = 1), se.morphAttributes.normal !== void 0 && (nt = 2), se.morphAttributes.color !== void 0 && (nt = 3); let mt, ve, ne, z; if (Me) { const It = ShaderLib[Me]; mt = It.vertexShader, ve = It.fragmentShader } else mt = F.vertexShader, ve = F.fragmentShader, h.update(F), ne = h.getVertexShaderID(F), z = h.getFragmentShaderID(F); const V = r.getRenderTarget(), _e = r.state.buffers.depth.getReversed(), Le = Z.isInstancedMesh === !0, fe = Z.isBatchedMesh === !0, Fe = !!F.map, st = !!F.matcap, j = !!ce, Be = !!F.aoMap, Re = !!F.lightMap, Oe = !!F.bumpMap, Ie = !!F.normalMap, oe = !!F.displacementMap, Y = !!F.emissiveMap, $e = !!F.metalnessMap, vt = !!F.roughnessMap, St = F.anisotropy > 0, K = F.clearcoat > 0, G = F.dispersion > 0, he = F.iridescence > 0, De = F.sheen > 0, Ge = F.transmission > 0, Te = St && !!F.anisotropyMap, ot = K && !!F.clearcoatMap, tt = K && !!F.clearcoatNormalMap, ut = K && !!F.clearcoatRoughnessMap, ft = he && !!F.iridescenceMap, ze = he && !!F.iridescenceThicknessMap, le = De && !!F.sheenColorMap, xe = De && !!F.sheenRoughnessMap, be = !!F.specularMap, Ce = !!F.specularColorMap, Ve = !!F.specularIntensityMap, ie = Ge && !!F.transmissionMap, Ne = Ge && !!F.thicknessMap, Ye = !!F.gradientMap, rt = !!F.alphaMap, je = F.alphaTest > 0, ke = !!F.alphaHash, ct = !!F.extensions; let wt = NoToneMapping; F.toneMapped && (V === null || V.isXRRenderTarget === !0) && (wt = r.toneMapping); const Pt = { shaderID: Me, shaderType: F.type, shaderName: F.name, vertexShader: mt, fragmentShader: ve, defines: F.defines, customVertexShaderID: ne, customFragmentShaderID: z, isRawShaderMaterial: F.isRawShaderMaterial === !0, glslVersion: F.glslVersion, precision: x, batching: fe, batchingColor: fe && Z._colorsTexture !== null, instancing: Le, instancingColor: Le && Z.instanceColor !== null, instancingMorph: Le && Z.morphTexture !== null, supportsVertexTextures: _, outputColorSpace: V === null ? r.outputColorSpace : V.isXRRenderTarget === !0 ? V.texture.colorSpace : LinearSRGBColorSpace, alphaToCoverage: !!F.alphaToCoverage, map: Fe, matcap: st, envMap: j, envMapMode: j && ce.mapping, envMapCubeUVHeight: ee, aoMap: Be, lightMap: Re, bumpMap: Oe, normalMap: Ie, displacementMap: _ && oe, emissiveMap: Y, normalMapObjectSpace: Ie && F.normalMapType === ObjectSpaceNormalMap, normalMapTangentSpace: Ie && F.normalMapType === TangentSpaceNormalMap, metalnessMap: $e, roughnessMap: vt, anisotropy: St, anisotropyMap: Te, clearcoat: K, clearcoatMap: ot, clearcoatNormalMap: tt, clearcoatRoughnessMap: ut, dispersion: G, iridescence: he, iridescenceMap: ft, iridescenceThicknessMap: ze, sheen: De, sheenColorMap: le, sheenRoughnessMap: xe, specularMap: be, specularColorMap: Ce, specularIntensityMap: Ve, transmission: Ge, transmissionMap: ie, thicknessMap: Ne, gradientMap: Ye, opaque: F.transparent === !1 && F.blending === NormalBlending && F.alphaToCoverage === !1, alphaMap: rt, alphaTest: je, alphaHash: ke, combine: F.combine, mapUv: Fe && T(F.map.channel), aoMapUv: Be && T(F.aoMap.channel), lightMapUv: Re && T(F.lightMap.channel), bumpMapUv: Oe && T(F.bumpMap.channel), normalMapUv: Ie && T(F.normalMap.channel), displacementMapUv: oe && T(F.displacementMap.channel), emissiveMapUv: Y && T(F.emissiveMap.channel), metalnessMapUv: $e && T(F.metalnessMap.channel), roughnessMapUv: vt && T(F.roughnessMap.channel), anisotropyMapUv: Te && T(F.anisotropyMap.channel), clearcoatMapUv: ot && T(F.clearcoatMap.channel), clearcoatNormalMapUv: tt && T(F.clearcoatNormalMap.channel), clearcoatRoughnessMapUv: ut && T(F.clearcoatRoughnessMap.channel), iridescenceMapUv: ft && T(F.iridescenceMap.channel), iridescenceThicknessMapUv: ze && T(F.iridescenceThicknessMap.channel), sheenColorMapUv: le && T(F.sheenColorMap.channel), sheenRoughnessMapUv: xe && T(F.sheenRoughnessMap.channel), specularMapUv: be && T(F.specularMap.channel), specularColorMapUv: Ce && T(F.specularColorMap.channel), specularIntensityMapUv: Ve && T(F.specularIntensityMap.channel), transmissionMapUv: ie && T(F.transmissionMap.channel), thicknessMapUv: Ne && T(F.thicknessMap.channel), alphaMapUv: rt && T(F.alphaMap.channel), vertexTangents: !!se.attributes.tangent && (Ie || St), vertexColors: F.vertexColors, vertexAlphas: F.vertexColors === !0 && !!se.attributes.color && se.attributes.color.itemSize === 4, pointsUvs: Z.isPoints === !0 && !!se.attributes.uv && (Fe || rt), fog: !!J, useFog: F.fog === !0, fogExp2: !!J && J.isFogExp2, flatShading: F.flatShading === !0 && F.wireframe === !1, sizeAttenuation: F.sizeAttenuation === !0, logarithmicDepthBuffer: f, reversedDepthBuffer: _e, skinning: Z.isSkinnedMesh === !0, morphTargets: se.morphAttributes.position !== void 0, morphNormals: se.morphAttributes.normal !== void 0, morphColors: se.morphAttributes.color !== void 0, morphTargetsCount: Ue, morphTextureStride: nt, numDirLights: k.directional.length, numPointLights: k.point.length, numSpotLights: k.spot.length, numSpotLightMaps: k.spotLightMap.length, numRectAreaLights: k.rectArea.length, numHemiLights: k.hemi.length, numDirLightShadows: k.directionalShadowMap.length, numPointLightShadows: k.pointShadowMap.length, numSpotLightShadows: k.spotShadowMap.length, numSpotLightShadowsWithMaps: k.numSpotLightShadowsWithMaps, numLightProbes: k.numLightProbes, numClippingPlanes: l.numPlanes, numClipIntersection: l.numIntersection, dithering: F.dithering, shadowMapEnabled: r.shadowMap.enabled && W.length > 0, shadowMapType: r.shadowMap.type, toneMapping: wt, decodeVideoTexture: Fe && F.map.isVideoTexture === !0 && ColorManagement.getTransfer(F.map.colorSpace) === SRGBTransfer, decodeVideoTextureEmissive: Y && F.emissiveMap.isVideoTexture === !0 && ColorManagement.getTransfer(F.emissiveMap.colorSpace) === SRGBTransfer, premultipliedAlpha: F.premultipliedAlpha, doubleSided: F.side === DoubleSide, flipSided: F.side === BackSide, useDepthPacking: F.depthPacking >= 0, depthPacking: F.depthPacking || 0, index0AttributeName: F.index0AttributeName, extensionClipCullDistance: ct && F.extensions.clipCullDistance === !0 && s.has("WEBGL_clip_cull_distance"), extensionMultiDraw: (ct && F.extensions.multiDraw === !0 || fe) && s.has("WEBGL_multi_draw"), rendererExtensionParallelShaderCompile: s.has("KHR_parallel_shader_compile"), customProgramCacheKey: F.customProgramCacheKey() }; return Pt.vertexUv1s = d.has(1), Pt.vertexUv2s = d.has(2), Pt.vertexUv3s = d.has(3), d.clear(), Pt } function w(F) { const k = []; if (F.shaderID ? k.push(F.shaderID) : (k.push(F.customVertexShaderID), k.push(F.customFragmentShaderID)), F.defines !== void 0) for (const W in F.defines) k.push(W), k.push(F.defines[W]); return F.isRawShaderMaterial === !1 && (D(k, F), R(k, F), k.push(r.outputColorSpace)), k.push(F.customProgramCacheKey), k.join() } function D(F, k) { F.push(k.precision), F.push(k.outputColorSpace), F.push(k.envMapMode), F.push(k.envMapCubeUVHeight), F.push(k.mapUv), F.push(k.alphaMapUv), F.push(k.lightMapUv), F.push(k.aoMapUv), F.push(k.bumpMapUv), F.push(k.normalMapUv), F.push(k.displacementMapUv), F.push(k.emissiveMapUv), F.push(k.metalnessMapUv), F.push(k.roughnessMapUv), F.push(k.anisotropyMapUv), F.push(k.clearcoatMapUv), F.push(k.clearcoatNormalMapUv), F.push(k.clearcoatRoughnessMapUv), F.push(k.iridescenceMapUv), F.push(k.iridescenceThicknessMapUv), F.push(k.sheenColorMapUv), F.push(k.sheenRoughnessMapUv), F.push(k.specularMapUv), F.push(k.specularColorMapUv), F.push(k.specularIntensityMapUv), F.push(k.transmissionMapUv), F.push(k.thicknessMapUv), F.push(k.combine), F.push(k.fogExp2), F.push(k.sizeAttenuation), F.push(k.morphTargetsCount), F.push(k.morphAttributeCount), F.push(k.numDirLights), F.push(k.numPointLights), F.push(k.numSpotLights), F.push(k.numSpotLightMaps), F.push(k.numHemiLights), F.push(k.numRectAreaLights), F.push(k.numDirLightShadows), F.push(k.numPointLightShadows), F.push(k.numSpotLightShadows), F.push(k.numSpotLightShadowsWithMaps), F.push(k.numLightProbes), F.push(k.shadowMapType), F.push(k.toneMapping), F.push(k.numClippingPlanes), F.push(k.numClipIntersection), F.push(k.depthPacking) } function R(F, k) { c.disableAll(), k.supportsVertexTextures && c.enable(0), k.instancing && c.enable(1), k.instancingColor && c.enable(2), k.instancingMorph && c.enable(3), k.matcap && c.enable(4), k.envMap && c.enable(5), k.normalMapObjectSpace && c.enable(6), k.normalMapTangentSpace && c.enable(7), k.clearcoat && c.enable(8), k.iridescence && c.enable(9), k.alphaTest && c.enable(10), k.vertexColors && c.enable(11), k.vertexAlphas && c.enable(12), k.vertexUv1s && c.enable(13), k.vertexUv2s && c.enable(14), k.vertexUv3s && c.enable(15), k.vertexTangents && c.enable(16), k.anisotropy && c.enable(17), k.alphaHash && c.enable(18), k.batching && c.enable(19), k.dispersion && c.enable(20), k.batchingColor && c.enable(21), k.gradientMap && c.enable(22), F.push(c.mask), c.disableAll(), k.fog && c.enable(0), k.useFog && c.enable(1), k.flatShading && c.enable(2), k.logarithmicDepthBuffer && c.enable(3), k.reversedDepthBuffer && c.enable(4), k.skinning && c.enable(5), k.morphTargets && c.enable(6), k.morphNormals && c.enable(7), k.morphColors && c.enable(8), k.premultipliedAlpha && c.enable(9), k.shadowMapEnabled && c.enable(10), k.doubleSided && c.enable(11), k.flipSided && c.enable(12), k.useDepthPacking && c.enable(13), k.dithering && c.enable(14), k.transmission && c.enable(15), k.sheen && c.enable(16), k.opaque && c.enable(17), k.pointsUvs && c.enable(18), k.decodeVideoTexture && c.enable(19), k.decodeVideoTextureEmissive && c.enable(20), k.alphaToCoverage && c.enable(21), F.push(c.mask) } function P(F) { const k = b[F.type]; let W; if (k) { const $ = ShaderLib[k]; W = UniformsUtils.clone($.uniforms) } else W = F.uniforms; return W } function U(F, k) { let W; for (let $ = 0, Z = p.length; $ < Z; $++) { const J = p[$]; if (J.cacheKey === k) { W = J, ++W.usedTimes; break } } return W === void 0 && (W = new WebGLProgram(r, k, F, o), p.push(W)), W } function O(F) { if (--F.usedTimes === 0) { const k = p.indexOf(F); p[k] = p[p.length - 1], p.pop(), F.destroy() } } function N(F) { h.remove(F) } function H() { h.dispose() } return { getParameters: M, getProgramCacheKey: w, getUniforms: P, acquireProgram: U, releaseProgram: O, releaseShaderCache: N, programs: p, dispose: H } } function WebGLProperties() { let r = new WeakMap; function e(l) { return r.has(l) } function i(l) { let c = r.get(l); return c === void 0 && (c = {}, r.set(l, c)), c } function s(l) { r.delete(l) } function a(l, c, h) { r.get(l)[c] = h } function o() { r = new WeakMap } return { has: e, get: i, remove: s, update: a, dispose: o } } function painterSortStable(r, e) { return r.groupOrder !== e.groupOrder ? r.groupOrder - e.groupOrder : r.renderOrder !== e.renderOrder ? r.renderOrder - e.renderOrder : r.material.id !== e.material.id ? r.material.id - e.material.id : r.z !== e.z ? r.z - e.z : r.id - e.id } function reversePainterSortStable(r, e) { return r.groupOrder !== e.groupOrder ? r.groupOrder - e.groupOrder : r.renderOrder !== e.renderOrder ? r.renderOrder - e.renderOrder : r.z !== e.z ? e.z - r.z : r.id - e.id } function WebGLRenderList() { const r = []; let e = 0; const i = [], s = [], a = []; function o() { e = 0, i.length = 0, s.length = 0, a.length = 0 } function l(f, _, x, b, T, M) { let w = r[e]; return w === void 0 ? (w = { id: f.id, object: f, geometry: _, material: x, groupOrder: b, renderOrder: f.renderOrder, z: T, group: M }, r[e] = w) : (w.id = f.id, w.object = f, w.geometry = _, w.material = x, w.groupOrder = b, w.renderOrder = f.renderOrder, w.z = T, w.group = M), e++, w } function c(f, _, x, b, T, M) { const w = l(f, _, x, b, T, M); x.transmission > 0 ? s.push(w) : x.transparent === !0 ? a.push(w) : i.push(w) } function h(f, _, x, b, T, M) { const w = l(f, _, x, b, T, M); x.transmission > 0 ? s.unshift(w) : x.transparent === !0 ? a.unshift(w) : i.unshift(w) } function d(f, _) { i.length > 1 && i.sort(f || painterSortStable), s.length > 1 && s.sort(_ || reversePainterSortStable), a.length > 1 && a.sort(_ || reversePainterSortStable) } function p() { for (let f = e, _ = r.length; f < _; f++) { const x = r[f]; if (x.id === null) break; x.id = null, x.object = null, x.geometry = null, x.material = null, x.group = null } } return { opaque: i, transmissive: s, transparent: a, init: o, push: c, unshift: h, finish: p, sort: d } } function WebGLRenderLists() { let r = new WeakMap; function e(s, a) { const o = r.get(s); let l; return o === void 0 ? (l = new WebGLRenderList, r.set(s, [l])) : a >= o.length ? (l = new WebGLRenderList, o.push(l)) : l = o[a], l } function i() { r = new WeakMap } return { get: e, dispose: i } } function UniformsCache() { const r = {}; return { get: function (e) { if (r[e.id] !== void 0) return r[e.id]; let i; switch (e.type) { case "DirectionalLight": i = { direction: new Vector3, color: new Color }; break; case "SpotLight": i = { position: new Vector3, direction: new Vector3, color: new Color, distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 }; break; case "PointLight": i = { position: new Vector3, color: new Color, distance: 0, decay: 0 }; break; case "HemisphereLight": i = { direction: new Vector3, skyColor: new Color, groundColor: new Color }; break; case "RectAreaLight": i = { color: new Color, position: new Vector3, halfWidth: new Vector3, halfHeight: new Vector3 }; break }return r[e.id] = i, i } } } function ShadowUniformsCache() { const r = {}; return { get: function (e) { if (r[e.id] !== void 0) return r[e.id]; let i; switch (e.type) { case "DirectionalLight": i = { shadowIntensity: 1, shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Vector2 }; break; case "SpotLight": i = { shadowIntensity: 1, shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Vector2 }; break; case "PointLight": i = { shadowIntensity: 1, shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Vector2, shadowCameraNear: 1, shadowCameraFar: 1e3 }; break }return r[e.id] = i, i } } } let nextVersion = 0; function shadowCastingAndTexturingLightsFirst(r, e) { return (e.castShadow ? 2 : 0) - (r.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (r.map ? 1 : 0) } function WebGLLights(r) { const e = new UniformsCache, i = ShadowUniformsCache(), s = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1, numSpotMaps: -1, numLightProbes: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotLightMap: [], spotShadow: [], spotShadowMap: [], spotLightMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [], numSpotLightShadowsWithMaps: 0, numLightProbes: 0 }; for (let d = 0; d < 9; d++)s.probe.push(new Vector3); const a = new Vector3, o = new Matrix4, l = new Matrix4; function c(d) { let p = 0, f = 0, _ = 0; for (let F = 0; F < 9; F++)s.probe[F].set(0, 0, 0); let x = 0, b = 0, T = 0, M = 0, w = 0, D = 0, R = 0, P = 0, U = 0, O = 0, N = 0; d.sort(shadowCastingAndTexturingLightsFirst); for (let F = 0, k = d.length; F < k; F++) { const W = d[F], $ = W.color, Z = W.intensity, J = W.distance, se = W.shadow && W.shadow.map ? W.shadow.map.texture : null; if (W.isAmbientLight) p += $.r * Z, f += $.g * Z, _ += $.b * Z; else if (W.isLightProbe) { for (let re = 0; re < 9; re++)s.probe[re].addScaledVector(W.sh.coefficients[re], Z); N++ } else if (W.isDirectionalLight) { const re = e.get(W); if (re.color.copy(W.color).multiplyScalar(W.intensity), W.castShadow) { const ce = W.shadow, ee = i.get(W); ee.shadowIntensity = ce.intensity, ee.shadowBias = ce.bias, ee.shadowNormalBias = ce.normalBias, ee.shadowRadius = ce.radius, ee.shadowMapSize = ce.mapSize, s.directionalShadow[x] = ee, s.directionalShadowMap[x] = se, s.directionalShadowMatrix[x] = W.shadow.matrix, D++ } s.directional[x] = re, x++ } else if (W.isSpotLight) { const re = e.get(W); re.position.setFromMatrixPosition(W.matrixWorld), re.color.copy($).multiplyScalar(Z), re.distance = J, re.coneCos = Math.cos(W.angle), re.penumbraCos = Math.cos(W.angle * (1 - W.penumbra)), re.decay = W.decay, s.spot[T] = re; const ce = W.shadow; if (W.map && (s.spotLightMap[U] = W.map, U++, ce.updateMatrices(W), W.castShadow && O++), s.spotLightMatrix[T] = ce.matrix, W.castShadow) { const ee = i.get(W); ee.shadowIntensity = ce.intensity, ee.shadowBias = ce.bias, ee.shadowNormalBias = ce.normalBias, ee.shadowRadius = ce.radius, ee.shadowMapSize = ce.mapSize, s.spotShadow[T] = ee, s.spotShadowMap[T] = se, P++ } T++ } else if (W.isRectAreaLight) { const re = e.get(W); re.color.copy($).multiplyScalar(Z), re.halfWidth.set(W.width * .5, 0, 0), re.halfHeight.set(0, W.height * .5, 0), s.rectArea[M] = re, M++ } else if (W.isPointLight) { const re = e.get(W); if (re.color.copy(W.color).multiplyScalar(W.intensity), re.distance = W.distance, re.decay = W.decay, W.castShadow) { const ce = W.shadow, ee = i.get(W); ee.shadowIntensity = ce.intensity, ee.shadowBias = ce.bias, ee.shadowNormalBias = ce.normalBias, ee.shadowRadius = ce.radius, ee.shadowMapSize = ce.mapSize, ee.shadowCameraNear = ce.camera.near, ee.shadowCameraFar = ce.camera.far, s.pointShadow[b] = ee, s.pointShadowMap[b] = se, s.pointShadowMatrix[b] = W.shadow.matrix, R++ } s.point[b] = re, b++ } else if (W.isHemisphereLight) { const re = e.get(W); re.skyColor.copy(W.color).multiplyScalar(Z), re.groundColor.copy(W.groundColor).multiplyScalar(Z), s.hemi[w] = re, w++ } } M > 0 && (r.has("OES_texture_float_linear") === !0 ? (s.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1, s.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2) : (s.rectAreaLTC1 = UniformsLib.LTC_HALF_1, s.rectAreaLTC2 = UniformsLib.LTC_HALF_2)), s.ambient[0] = p, s.ambient[1] = f, s.ambient[2] = _; const H = s.hash; (H.directionalLength !== x || H.pointLength !== b || H.spotLength !== T || H.rectAreaLength !== M || H.hemiLength !== w || H.numDirectionalShadows !== D || H.numPointShadows !== R || H.numSpotShadows !== P || H.numSpotMaps !== U || H.numLightProbes !== N) && (s.directional.length = x, s.spot.length = T, s.rectArea.length = M, s.point.length = b, s.hemi.length = w, s.directionalShadow.length = D, s.directionalShadowMap.length = D, s.pointShadow.length = R, s.pointShadowMap.length = R, s.spotShadow.length = P, s.spotShadowMap.length = P, s.directionalShadowMatrix.length = D, s.pointShadowMatrix.length = R, s.spotLightMatrix.length = P + U - O, s.spotLightMap.length = U, s.numSpotLightShadowsWithMaps = O, s.numLightProbes = N, H.directionalLength = x, H.pointLength = b, H.spotLength = T, H.rectAreaLength = M, H.hemiLength = w, H.numDirectionalShadows = D, H.numPointShadows = R, H.numSpotShadows = P, H.numSpotMaps = U, H.numLightProbes = N, s.version = nextVersion++) } function h(d, p) { let f = 0, _ = 0, x = 0, b = 0, T = 0; const M = p.matrixWorldInverse; for (let w = 0, D = d.length; w < D; w++) { const R = d[w]; if (R.isDirectionalLight) { const P = s.directional[f]; P.direction.setFromMatrixPosition(R.matrixWorld), a.setFromMatrixPosition(R.target.matrixWorld), P.direction.sub(a), P.direction.transformDirection(M), f++ } else if (R.isSpotLight) { const P = s.spot[x]; P.position.setFromMatrixPosition(R.matrixWorld), P.position.applyMatrix4(M), P.direction.setFromMatrixPosition(R.matrixWorld), a.setFromMatrixPosition(R.target.matrixWorld), P.direction.sub(a), P.direction.transformDirection(M), x++ } else if (R.isRectAreaLight) { const P = s.rectArea[b]; P.position.setFromMatrixPosition(R.matrixWorld), P.position.applyMatrix4(M), l.identity(), o.copy(R.matrixWorld), o.premultiply(M), l.extractRotation(o), P.halfWidth.set(R.width * .5, 0, 0), P.halfHeight.set(0, R.height * .5, 0), P.halfWidth.applyMatrix4(l), P.halfHeight.applyMatrix4(l), b++ } else if (R.isPointLight) { const P = s.point[_]; P.position.setFromMatrixPosition(R.matrixWorld), P.position.applyMatrix4(M), _++ } else if (R.isHemisphereLight) { const P = s.hemi[T]; P.direction.setFromMatrixPosition(R.matrixWorld), P.direction.transformDirection(M), T++ } } } return { setup: c, setupView: h, state: s } } function WebGLRenderState(r) { const e = new WebGLLights(r), i = [], s = []; function a(p) { d.camera = p, i.length = 0, s.length = 0 } function o(p) { i.push(p) } function l(p) { s.push(p) } function c() { e.setup(i) } function h(p) { e.setupView(i, p) } const d = { lightsArray: i, shadowsArray: s, camera: null, lights: e, transmissionRenderTarget: {} }; return { init: a, state: d, setupLights: c, setupLightsView: h, pushLight: o, pushShadow: l } } function WebGLRenderStates(r) { let e = new WeakMap; function i(a, o = 0) { const l = e.get(a); let c; return l === void 0 ? (c = new WebGLRenderState(r), e.set(a, [c])) : o >= l.length ? (c = new WebGLRenderState(r), l.push(c)) : c = l[o], c } function s() { e = new WeakMap } return { get: i, dispose: s } } const vertex$i = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, fragment$i = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`; function WebGLShadowMap(r, e, i) { let s = new Frustum; const a = new Vector2, o = new Vector2, l = new Vector4, c = new MeshDepthMaterial({ depthPacking: RGBADepthPacking }), h = new MeshDistanceMaterial, d = {}, p = i.maxTextureSize, f = { [FrontSide]: BackSide, [BackSide]: FrontSide, [DoubleSide]: DoubleSide }, _ = new ShaderMaterial({ defines: { VSM_SAMPLES: 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new Vector2 }, radius: { value: 4 } }, vertexShader: vertex$i, fragmentShader: fragment$i }), x = _.clone(); x.defines.HORIZONTAL_PASS = 1; const b = new BufferGeometry; b.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3)); const T = new Mesh(b, _), M = this; this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = PCFShadowMap; let w = this.type; this.render = function (O, N, H) { if (M.enabled === !1 || M.autoUpdate === !1 && M.needsUpdate === !1 || O.length === 0) return; const F = r.getRenderTarget(), k = r.getActiveCubeFace(), W = r.getActiveMipmapLevel(), $ = r.state; $.setBlending(NoBlending), $.buffers.depth.getReversed() === !0 ? $.buffers.color.setClear(0, 0, 0, 0) : $.buffers.color.setClear(1, 1, 1, 1), $.buffers.depth.setTest(!0), $.setScissorTest(!1); const Z = w !== VSMShadowMap && this.type === VSMShadowMap, J = w === VSMShadowMap && this.type !== VSMShadowMap; for (let se = 0, re = O.length; se < re; se++) { const ce = O[se], ee = ce.shadow; if (ee === void 0) { console.warn("THREE.WebGLShadowMap:", ce, "has no shadow."); continue } if (ee.autoUpdate === !1 && ee.needsUpdate === !1) continue; a.copy(ee.mapSize); const Me = ee.getFrameExtents(); if (a.multiply(Me), o.copy(ee.mapSize), (a.x > p || a.y > p) && (a.x > p && (o.x = Math.floor(p / Me.x), a.x = o.x * Me.x, ee.mapSize.x = o.x), a.y > p && (o.y = Math.floor(p / Me.y), a.y = o.y * Me.y, ee.mapSize.y = o.y)), ee.map === null || Z === !0 || J === !0) { const Ue = this.type !== VSMShadowMap ? { minFilter: NearestFilter, magFilter: NearestFilter } : {}; ee.map !== null && ee.map.dispose(), ee.map = new WebGLRenderTarget(a.x, a.y, Ue), ee.map.texture.name = ce.name + ".shadowMap", ee.camera.updateProjectionMatrix() } r.setRenderTarget(ee.map), r.clear(); const Ee = ee.getViewportCount(); for (let Ue = 0; Ue < Ee; Ue++) { const nt = ee.getViewport(Ue); l.set(o.x * nt.x, o.y * nt.y, o.x * nt.z, o.y * nt.w), $.viewport(l), ee.updateMatrices(ce, Ue), s = ee.getFrustum(), P(N, H, ee.camera, ce, this.type) } ee.isPointLightShadow !== !0 && this.type === VSMShadowMap && D(ee, H), ee.needsUpdate = !1 } w = this.type, M.needsUpdate = !1, r.setRenderTarget(F, k, W) }; function D(O, N) { const H = e.update(T); _.defines.VSM_SAMPLES !== O.blurSamples && (_.defines.VSM_SAMPLES = O.blurSamples, x.defines.VSM_SAMPLES = O.blurSamples, _.needsUpdate = !0, x.needsUpdate = !0), O.mapPass === null && (O.mapPass = new WebGLRenderTarget(a.x, a.y)), _.uniforms.shadow_pass.value = O.map.texture, _.uniforms.resolution.value = O.mapSize, _.uniforms.radius.value = O.radius, r.setRenderTarget(O.mapPass), r.clear(), r.renderBufferDirect(N, null, H, _, T, null), x.uniforms.shadow_pass.value = O.mapPass.texture, x.uniforms.resolution.value = O.mapSize, x.uniforms.radius.value = O.radius, r.setRenderTarget(O.map), r.clear(), r.renderBufferDirect(N, null, H, x, T, null) } function R(O, N, H, F) { let k = null; const W = H.isPointLight === !0 ? O.customDistanceMaterial : O.customDepthMaterial; if (W !== void 0) k = W; else if (k = H.isPointLight === !0 ? h : c, r.localClippingEnabled && N.clipShadows === !0 && Array.isArray(N.clippingPlanes) && N.clippingPlanes.length !== 0 || N.displacementMap && N.displacementScale !== 0 || N.alphaMap && N.alphaTest > 0 || N.map && N.alphaTest > 0 || N.alphaToCoverage === !0) { const $ = k.uuid, Z = N.uuid; let J = d[$]; J === void 0 && (J = {}, d[$] = J); let se = J[Z]; se === void 0 && (se = k.clone(), J[Z] = se, N.addEventListener("dispose", U)), k = se } if (k.visible = N.visible, k.wireframe = N.wireframe, F === VSMShadowMap ? k.side = N.shadowSide !== null ? N.shadowSide : N.side : k.side = N.shadowSide !== null ? N.shadowSide : f[N.side], k.alphaMap = N.alphaMap, k.alphaTest = N.alphaToCoverage === !0 ? .5 : N.alphaTest, k.map = N.map, k.clipShadows = N.clipShadows, k.clippingPlanes = N.clippingPlanes, k.clipIntersection = N.clipIntersection, k.displacementMap = N.displacementMap, k.displacementScale = N.displacementScale, k.displacementBias = N.displacementBias, k.wireframeLinewidth = N.wireframeLinewidth, k.linewidth = N.linewidth, H.isPointLight === !0 && k.isMeshDistanceMaterial === !0) { const $ = r.properties.get(k); $.light = H } return k } function P(O, N, H, F, k) { if (O.visible === !1) return; if (O.layers.test(N.layers) && (O.isMesh || O.isLine || O.isPoints) && (O.castShadow || O.receiveShadow && k === VSMShadowMap) && (!O.frustumCulled || s.intersectsObject(O))) { O.modelViewMatrix.multiplyMatrices(H.matrixWorldInverse, O.matrixWorld); const Z = e.update(O), J = O.material; if (Array.isArray(J)) { const se = Z.groups; for (let re = 0, ce = se.length; re < ce; re++) { const ee = se[re], Me = J[ee.materialIndex]; if (Me && Me.visible) { const Ee = R(O, Me, F, k); O.onBeforeShadow(r, O, N, H, Z, Ee, ee), r.renderBufferDirect(H, null, Z, Ee, O, ee), O.onAfterShadow(r, O, N, H, Z, Ee, ee) } } } else if (J.visible) { const se = R(O, J, F, k); O.onBeforeShadow(r, O, N, H, Z, se, null), r.renderBufferDirect(H, null, Z, se, O, null), O.onAfterShadow(r, O, N, H, Z, se, null) } } const $ = O.children; for (let Z = 0, J = $.length; Z < J; Z++)P($[Z], N, H, F, k) } function U(O) { O.target.removeEventListener("dispose", U); for (const H in d) { const F = d[H], k = O.target.uuid; k in F && (F[k].dispose(), delete F[k]) } } } const reversedFuncs = { [NeverDepth]: AlwaysDepth, [LessDepth]: GreaterDepth, [EqualDepth]: NotEqualDepth, [LessEqualDepth]: GreaterEqualDepth, [AlwaysDepth]: NeverDepth, [GreaterDepth]: LessDepth, [NotEqualDepth]: EqualDepth, [GreaterEqualDepth]: LessEqualDepth }; function WebGLState(r, e) { function i() { let ie = !1; const Ne = new Vector4; let Ye = null; const rt = new Vector4(0, 0, 0, 0); return { setMask: function (je) { Ye !== je && !ie && (r.colorMask(je, je, je, je), Ye = je) }, setLocked: function (je) { ie = je }, setClear: function (je, ke, ct, wt, Pt) { Pt === !0 && (je *= wt, ke *= wt, ct *= wt), Ne.set(je, ke, ct, wt), rt.equals(Ne) === !1 && (r.clearColor(je, ke, ct, wt), rt.copy(Ne)) }, reset: function () { ie = !1, Ye = null, rt.set(-1, 0, 0, 0) } } } function s() { let ie = !1, Ne = !1, Ye = null, rt = null, je = null; return { setReversed: function (ke) { if (Ne !== ke) { const ct = e.get("EXT_clip_control"); ke ? ct.clipControlEXT(ct.LOWER_LEFT_EXT, ct.ZERO_TO_ONE_EXT) : ct.clipControlEXT(ct.LOWER_LEFT_EXT, ct.NEGATIVE_ONE_TO_ONE_EXT), Ne = ke; const wt = je; je = null, this.setClear(wt) } }, getReversed: function () { return Ne }, setTest: function (ke) { ke ? V(r.DEPTH_TEST) : _e(r.DEPTH_TEST) }, setMask: function (ke) { Ye !== ke && !ie && (r.depthMask(ke), Ye = ke) }, setFunc: function (ke) { if (Ne && (ke = reversedFuncs[ke]), rt !== ke) { switch (ke) { case NeverDepth: r.depthFunc(r.NEVER); break; case AlwaysDepth: r.depthFunc(r.ALWAYS); break; case LessDepth: r.depthFunc(r.LESS); break; case LessEqualDepth: r.depthFunc(r.LEQUAL); break; case EqualDepth: r.depthFunc(r.EQUAL); break; case GreaterEqualDepth: r.depthFunc(r.GEQUAL); break; case GreaterDepth: r.depthFunc(r.GREATER); break; case NotEqualDepth: r.depthFunc(r.NOTEQUAL); break; default: r.depthFunc(r.LEQUAL) }rt = ke } }, setLocked: function (ke) { ie = ke }, setClear: function (ke) { je !== ke && (Ne && (ke = 1 - ke), r.clearDepth(ke), je = ke) }, reset: function () { ie = !1, Ye = null, rt = null, je = null, Ne = !1 } } } function a() { let ie = !1, Ne = null, Ye = null, rt = null, je = null, ke = null, ct = null, wt = null, Pt = null; return { setTest: function (It) { ie || (It ? V(r.STENCIL_TEST) : _e(r.STENCIL_TEST)) }, setMask: function (It) { Ne !== It && !ie && (r.stencilMask(It), Ne = It) }, setFunc: function (It, zi, Ii) { (Ye !== It || rt !== zi || je !== Ii) && (r.stencilFunc(It, zi, Ii), Ye = It, rt = zi, je = Ii) }, setOp: function (It, zi, Ii) { (ke !== It || ct !== zi || wt !== Ii) && (r.stencilOp(It, zi, Ii), ke = It, ct = zi, wt = Ii) }, setLocked: function (It) { ie = It }, setClear: function (It) { Pt !== It && (r.clearStencil(It), Pt = It) }, reset: function () { ie = !1, Ne = null, Ye = null, rt = null, je = null, ke = null, ct = null, wt = null, Pt = null } } } const o = new i, l = new s, c = new a, h = new WeakMap, d = new WeakMap; let p = {}, f = {}, _ = new WeakMap, x = [], b = null, T = !1, M = null, w = null, D = null, R = null, P = null, U = null, O = null, N = new Color(0, 0, 0), H = 0, F = !1, k = null, W = null, $ = null, Z = null, J = null; const se = r.getParameter(r.MAX_COMBINED_TEXTURE_IMAGE_UNITS); let re = !1, ce = 0; const ee = r.getParameter(r.VERSION); ee.indexOf("WebGL") !== -1 ? (ce = parseFloat(/^WebGL (\d)/.exec(ee)[1]), re = ce >= 1) : ee.indexOf("OpenGL ES") !== -1 && (ce = parseFloat(/^OpenGL ES (\d)/.exec(ee)[1]), re = ce >= 2); let Me = null, Ee = {}; const Ue = r.getParameter(r.SCISSOR_BOX), nt = r.getParameter(r.VIEWPORT), mt = new Vector4().fromArray(Ue), ve = new Vector4().fromArray(nt); function ne(ie, Ne, Ye, rt) { const je = new Uint8Array(4), ke = r.createTexture(); r.bindTexture(ie, ke), r.texParameteri(ie, r.TEXTURE_MIN_FILTER, r.NEAREST), r.texParameteri(ie, r.TEXTURE_MAG_FILTER, r.NEAREST); for (let ct = 0; ct < Ye; ct++)ie === r.TEXTURE_3D || ie === r.TEXTURE_2D_ARRAY ? r.texImage3D(Ne, 0, r.RGBA, 1, 1, rt, 0, r.RGBA, r.UNSIGNED_BYTE, je) : r.texImage2D(Ne + ct, 0, r.RGBA, 1, 1, 0, r.RGBA, r.UNSIGNED_BYTE, je); return ke } const z = {}; z[r.TEXTURE_2D] = ne(r.TEXTURE_2D, r.TEXTURE_2D, 1), z[r.TEXTURE_CUBE_MAP] = ne(r.TEXTURE_CUBE_MAP, r.TEXTURE_CUBE_MAP_POSITIVE_X, 6), z[r.TEXTURE_2D_ARRAY] = ne(r.TEXTURE_2D_ARRAY, r.TEXTURE_2D_ARRAY, 1, 1), z[r.TEXTURE_3D] = ne(r.TEXTURE_3D, r.TEXTURE_3D, 1, 1), o.setClear(0, 0, 0, 1), l.setClear(1), c.setClear(0), V(r.DEPTH_TEST), l.setFunc(LessEqualDepth), Oe(!1), Ie(CullFaceBack), V(r.CULL_FACE), Be(NoBlending); function V(ie) { p[ie] !== !0 && (r.enable(ie), p[ie] = !0) } function _e(ie) { p[ie] !== !1 && (r.disable(ie), p[ie] = !1) } function Le(ie, Ne) { return f[ie] !== Ne ? (r.bindFramebuffer(ie, Ne), f[ie] = Ne, ie === r.DRAW_FRAMEBUFFER && (f[r.FRAMEBUFFER] = Ne), ie === r.FRAMEBUFFER && (f[r.DRAW_FRAMEBUFFER] = Ne), !0) : !1 } function fe(ie, Ne) { let Ye = x, rt = !1; if (ie) { Ye = _.get(Ne), Ye === void 0 && (Ye = [], _.set(Ne, Ye)); const je = ie.textures; if (Ye.length !== je.length || Ye[0] !== r.COLOR_ATTACHMENT0) { for (let ke = 0, ct = je.length; ke < ct; ke++)Ye[ke] = r.COLOR_ATTACHMENT0 + ke; Ye.length = je.length, rt = !0 } } else Ye[0] !== r.BACK && (Ye[0] = r.BACK, rt = !0); rt && r.drawBuffers(Ye) } function Fe(ie) { return b !== ie ? (r.useProgram(ie), b = ie, !0) : !1 } const st = { [AddEquation]: r.FUNC_ADD, [SubtractEquation]: r.FUNC_SUBTRACT, [ReverseSubtractEquation]: r.FUNC_REVERSE_SUBTRACT }; st[MinEquation] = r.MIN, st[MaxEquation] = r.MAX; const j = { [ZeroFactor]: r.ZERO, [OneFactor]: r.ONE, [SrcColorFactor]: r.SRC_COLOR, [SrcAlphaFactor]: r.SRC_ALPHA, [SrcAlphaSaturateFactor]: r.SRC_ALPHA_SATURATE, [DstColorFactor]: r.DST_COLOR, [DstAlphaFactor]: r.DST_ALPHA, [OneMinusSrcColorFactor]: r.ONE_MINUS_SRC_COLOR, [OneMinusSrcAlphaFactor]: r.ONE_MINUS_SRC_ALPHA, [OneMinusDstColorFactor]: r.ONE_MINUS_DST_COLOR, [OneMinusDstAlphaFactor]: r.ONE_MINUS_DST_ALPHA, [ConstantColorFactor]: r.CONSTANT_COLOR, [OneMinusConstantColorFactor]: r.ONE_MINUS_CONSTANT_COLOR, [ConstantAlphaFactor]: r.CONSTANT_ALPHA, [OneMinusConstantAlphaFactor]: r.ONE_MINUS_CONSTANT_ALPHA }; function Be(ie, Ne, Ye, rt, je, ke, ct, wt, Pt, It) { if (ie === NoBlending) { T === !0 && (_e(r.BLEND), T = !1); return } if (T === !1 && (V(r.BLEND), T = !0), ie !== CustomBlending) { if (ie !== M || It !== F) { if ((w !== AddEquation || P !== AddEquation) && (r.blendEquation(r.FUNC_ADD), w = AddEquation, P = AddEquation), It) switch (ie) { case NormalBlending: r.blendFuncSeparate(r.ONE, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA); break; case AdditiveBlending: r.blendFunc(r.ONE, r.ONE); break; case SubtractiveBlending: r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE); break; case MultiplyBlending: r.blendFuncSeparate(r.DST_COLOR, r.ONE_MINUS_SRC_ALPHA, r.ZERO, r.ONE); break; default: console.error("THREE.WebGLState: Invalid blending: ", ie); break } else switch (ie) { case NormalBlending: r.blendFuncSeparate(r.SRC_ALPHA, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA); break; case AdditiveBlending: r.blendFuncSeparate(r.SRC_ALPHA, r.ONE, r.ONE, r.ONE); break; case SubtractiveBlending: console.error("THREE.WebGLState: SubtractiveBlending requires material.premultipliedAlpha = true"); break; case MultiplyBlending: console.error("THREE.WebGLState: MultiplyBlending requires material.premultipliedAlpha = true"); break; default: console.error("THREE.WebGLState: Invalid blending: ", ie); break }D = null, R = null, U = null, O = null, N.set(0, 0, 0), H = 0, M = ie, F = It } return } je = je || Ne, ke = ke || Ye, ct = ct || rt, (Ne !== w || je !== P) && (r.blendEquationSeparate(st[Ne], st[je]), w = Ne, P = je), (Ye !== D || rt !== R || ke !== U || ct !== O) && (r.blendFuncSeparate(j[Ye], j[rt], j[ke], j[ct]), D = Ye, R = rt, U = ke, O = ct), (wt.equals(N) === !1 || Pt !== H) && (r.blendColor(wt.r, wt.g, wt.b, Pt), N.copy(wt), H = Pt), M = ie, F = !1 } function Re(ie, Ne) { ie.side === DoubleSide ? _e(r.CULL_FACE) : V(r.CULL_FACE); let Ye = ie.side === BackSide; Ne && (Ye = !Ye), Oe(Ye), ie.blending === NormalBlending && ie.transparent === !1 ? Be(NoBlending) : Be(ie.blending, ie.blendEquation, ie.blendSrc, ie.blendDst, ie.blendEquationAlpha, ie.blendSrcAlpha, ie.blendDstAlpha, ie.blendColor, ie.blendAlpha, ie.premultipliedAlpha), l.setFunc(ie.depthFunc), l.setTest(ie.depthTest), l.setMask(ie.depthWrite), o.setMask(ie.colorWrite); const rt = ie.stencilWrite; c.setTest(rt), rt && (c.setMask(ie.stencilWriteMask), c.setFunc(ie.stencilFunc, ie.stencilRef, ie.stencilFuncMask), c.setOp(ie.stencilFail, ie.stencilZFail, ie.stencilZPass)), Y(ie.polygonOffset, ie.polygonOffsetFactor, ie.polygonOffsetUnits), ie.alphaToCoverage === !0 ? V(r.SAMPLE_ALPHA_TO_COVERAGE) : _e(r.SAMPLE_ALPHA_TO_COVERAGE) } function Oe(ie) { k !== ie && (ie ? r.frontFace(r.CW) : r.frontFace(r.CCW), k = ie) } function Ie(ie) { ie !== CullFaceNone ? (V(r.CULL_FACE), ie !== W && (ie === CullFaceBack ? r.cullFace(r.BACK) : ie === CullFaceFront ? r.cullFace(r.FRONT) : r.cullFace(r.FRONT_AND_BACK))) : _e(r.CULL_FACE), W = ie } function oe(ie) { ie !== $ && (re && r.lineWidth(ie), $ = ie) } function Y(ie, Ne, Ye) { ie ? (V(r.POLYGON_OFFSET_FILL), (Z !== Ne || J !== Ye) && (r.polygonOffset(Ne, Ye), Z = Ne, J = Ye)) : _e(r.POLYGON_OFFSET_FILL) } function $e(ie) { ie ? V(r.SCISSOR_TEST) : _e(r.SCISSOR_TEST) } function vt(ie) { ie === void 0 && (ie = r.TEXTURE0 + se - 1), Me !== ie && (r.activeTexture(ie), Me = ie) } function St(ie, Ne, Ye) { Ye === void 0 && (Me === null ? Ye = r.TEXTURE0 + se - 1 : Ye = Me); let rt = Ee[Ye]; rt === void 0 && (rt = { type: void 0, texture: void 0 }, Ee[Ye] = rt), (rt.type !== ie || rt.texture !== Ne) && (Me !== Ye && (r.activeTexture(Ye), Me = Ye), r.bindTexture(ie, Ne || z[ie]), rt.type = ie, rt.texture = Ne) } function K() { const ie = Ee[Me]; ie !== void 0 && ie.type !== void 0 && (r.bindTexture(ie.type, null), ie.type = void 0, ie.texture = void 0) } function G() { try { r.compressedTexImage2D(...arguments) } catch (ie) { console.error("THREE.WebGLState:", ie) } } function he() { try { r.compressedTexImage3D(...arguments) } catch (ie) { console.error("THREE.WebGLState:", ie) } } function De() { try { r.texSubImage2D(...arguments) } catch (ie) { console.error("THREE.WebGLState:", ie) } } function Ge() { try { r.texSubImage3D(...arguments) } catch (ie) { console.error("THREE.WebGLState:", ie) } } function Te() { try { r.compressedTexSubImage2D(...arguments) } catch (ie) { console.error("THREE.WebGLState:", ie) } } function ot() { try { r.compressedTexSubImage3D(...arguments) } catch (ie) { console.error("THREE.WebGLState:", ie) } } function tt() { try { r.texStorage2D(...arguments) } catch (ie) { console.error("THREE.WebGLState:", ie) } } function ut() { try { r.texStorage3D(...arguments) } catch (ie) { console.error("THREE.WebGLState:", ie) } } function ft() { try { r.texImage2D(...arguments) } catch (ie) { console.error("THREE.WebGLState:", ie) } } function ze() { try { r.texImage3D(...arguments) } catch (ie) { console.error("THREE.WebGLState:", ie) } } function le(ie) { mt.equals(ie) === !1 && (r.scissor(ie.x, ie.y, ie.z, ie.w), mt.copy(ie)) } function xe(ie) { ve.equals(ie) === !1 && (r.viewport(ie.x, ie.y, ie.z, ie.w), ve.copy(ie)) } function be(ie, Ne) { let Ye = d.get(Ne); Ye === void 0 && (Ye = new WeakMap, d.set(Ne, Ye)); let rt = Ye.get(ie); rt === void 0 && (rt = r.getUniformBlockIndex(Ne, ie.name), Ye.set(ie, rt)) } function Ce(ie, Ne) { const rt = d.get(Ne).get(ie); h.get(Ne) !== rt && (r.uniformBlockBinding(Ne, rt, ie.__bindingPointIndex), h.set(Ne, rt)) } function Ve() { r.disable(r.BLEND), r.disable(r.CULL_FACE), r.disable(r.DEPTH_TEST), r.disable(r.POLYGON_OFFSET_FILL), r.disable(r.SCISSOR_TEST), r.disable(r.STENCIL_TEST), r.disable(r.SAMPLE_ALPHA_TO_COVERAGE), r.blendEquation(r.FUNC_ADD), r.blendFunc(r.ONE, r.ZERO), r.blendFuncSeparate(r.ONE, r.ZERO, r.ONE, r.ZERO), r.blendColor(0, 0, 0, 0), r.colorMask(!0, !0, !0, !0), r.clearColor(0, 0, 0, 0), r.depthMask(!0), r.depthFunc(r.LESS), l.setReversed(!1), r.clearDepth(1), r.stencilMask(4294967295), r.stencilFunc(r.ALWAYS, 0, 4294967295), r.stencilOp(r.KEEP, r.KEEP, r.KEEP), r.clearStencil(0), r.cullFace(r.BACK), r.frontFace(r.CCW), r.polygonOffset(0, 0), r.activeTexture(r.TEXTURE0), r.bindFramebuffer(r.FRAMEBUFFER, null), r.bindFramebuffer(r.DRAW_FRAMEBUFFER, null), r.bindFramebuffer(r.READ_FRAMEBUFFER, null), r.useProgram(null), r.lineWidth(1), r.scissor(0, 0, r.canvas.width, r.canvas.height), r.viewport(0, 0, r.canvas.width, r.canvas.height), p = {}, Me = null, Ee = {}, f = {}, _ = new WeakMap, x = [], b = null, T = !1, M = null, w = null, D = null, R = null, P = null, U = null, O = null, N = new Color(0, 0, 0), H = 0, F = !1, k = null, W = null, $ = null, Z = null, J = null, mt.set(0, 0, r.canvas.width, r.canvas.height), ve.set(0, 0, r.canvas.width, r.canvas.height), o.reset(), l.reset(), c.reset() } return { buffers: { color: o, depth: l, stencil: c }, enable: V, disable: _e, bindFramebuffer: Le, drawBuffers: fe, useProgram: Fe, setBlending: Be, setMaterial: Re, setFlipSided: Oe, setCullFace: Ie, setLineWidth: oe, setPolygonOffset: Y, setScissorTest: $e, activeTexture: vt, bindTexture: St, unbindTexture: K, compressedTexImage2D: G, compressedTexImage3D: he, texImage2D: ft, texImage3D: ze, updateUBOMapping: be, uniformBlockBinding: Ce, texStorage2D: tt, texStorage3D: ut, texSubImage2D: De, texSubImage3D: Ge, compressedTexSubImage2D: Te, compressedTexSubImage3D: ot, scissor: le, viewport: xe, reset: Ve } } function WebGLTextures(r, e, i, s, a, o, l) { const c = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, h = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), d = new Vector2, p = new WeakMap; let f; const _ = new WeakMap; let x = !1; try { x = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null } catch { } function b(K, G) { return x ? new OffscreenCanvas(K, G) : createElementNS("canvas") } function T(K, G, he) { let De = 1; const Ge = St(K); if ((Ge.width > he || Ge.height > he) && (De = he / Math.max(Ge.width, Ge.height)), De < 1) if (typeof HTMLImageElement < "u" && K instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && K instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && K instanceof ImageBitmap || typeof VideoFrame < "u" && K instanceof VideoFrame) { const Te = Math.floor(De * Ge.width), ot = Math.floor(De * Ge.height); f === void 0 && (f = b(Te, ot)); const tt = G ? b(Te, ot) : f; return tt.width = Te, tt.height = ot, tt.getContext("2d").drawImage(K, 0, 0, Te, ot), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + Ge.width + "x" + Ge.height + ") to (" + Te + "x" + ot + ")."), tt } else return "data" in K && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + Ge.width + "x" + Ge.height + ")."), K; return K } function M(K) { return K.generateMipmaps } function w(K) { r.generateMipmap(K) } function D(K) { return K.isWebGLCubeRenderTarget ? r.TEXTURE_CUBE_MAP : K.isWebGL3DRenderTarget ? r.TEXTURE_3D : K.isWebGLArrayRenderTarget || K.isCompressedArrayTexture ? r.TEXTURE_2D_ARRAY : r.TEXTURE_2D } function R(K, G, he, De, Ge = !1) { if (K !== null) { if (r[K] !== void 0) return r[K]; console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + K + "'") } let Te = G; if (G === r.RED && (he === r.FLOAT && (Te = r.R32F), he === r.HALF_FLOAT && (Te = r.R16F), he === r.UNSIGNED_BYTE && (Te = r.R8)), G === r.RED_INTEGER && (he === r.UNSIGNED_BYTE && (Te = r.R8UI), he === r.UNSIGNED_SHORT && (Te = r.R16UI), he === r.UNSIGNED_INT && (Te = r.R32UI), he === r.BYTE && (Te = r.R8I), he === r.SHORT && (Te = r.R16I), he === r.INT && (Te = r.R32I)), G === r.RG && (he === r.FLOAT && (Te = r.RG32F), he === r.HALF_FLOAT && (Te = r.RG16F), he === r.UNSIGNED_BYTE && (Te = r.RG8)), G === r.RG_INTEGER && (he === r.UNSIGNED_BYTE && (Te = r.RG8UI), he === r.UNSIGNED_SHORT && (Te = r.RG16UI), he === r.UNSIGNED_INT && (Te = r.RG32UI), he === r.BYTE && (Te = r.RG8I), he === r.SHORT && (Te = r.RG16I), he === r.INT && (Te = r.RG32I)), G === r.RGB_INTEGER && (he === r.UNSIGNED_BYTE && (Te = r.RGB8UI), he === r.UNSIGNED_SHORT && (Te = r.RGB16UI), he === r.UNSIGNED_INT && (Te = r.RGB32UI), he === r.BYTE && (Te = r.RGB8I), he === r.SHORT && (Te = r.RGB16I), he === r.INT && (Te = r.RGB32I)), G === r.RGBA_INTEGER && (he === r.UNSIGNED_BYTE && (Te = r.RGBA8UI), he === r.UNSIGNED_SHORT && (Te = r.RGBA16UI), he === r.UNSIGNED_INT && (Te = r.RGBA32UI), he === r.BYTE && (Te = r.RGBA8I), he === r.SHORT && (Te = r.RGBA16I), he === r.INT && (Te = r.RGBA32I)), G === r.RGB && (he === r.UNSIGNED_INT_5_9_9_9_REV && (Te = r.RGB9_E5), he === r.UNSIGNED_INT_10F_11F_11F_REV && (Te = r.R11F_G11F_B10F)), G === r.RGBA) { const ot = Ge ? LinearTransfer : ColorManagement.getTransfer(De); he === r.FLOAT && (Te = r.RGBA32F), he === r.HALF_FLOAT && (Te = r.RGBA16F), he === r.UNSIGNED_BYTE && (Te = ot === SRGBTransfer ? r.SRGB8_ALPHA8 : r.RGBA8), he === r.UNSIGNED_SHORT_4_4_4_4 && (Te = r.RGBA4), he === r.UNSIGNED_SHORT_5_5_5_1 && (Te = r.RGB5_A1) } return (Te === r.R16F || Te === r.R32F || Te === r.RG16F || Te === r.RG32F || Te === r.RGBA16F || Te === r.RGBA32F) && e.get("EXT_color_buffer_float"), Te } function P(K, G) { let he; return K ? G === null || G === UnsignedIntType || G === UnsignedInt248Type ? he = r.DEPTH24_STENCIL8 : G === FloatType ? he = r.DEPTH32F_STENCIL8 : G === UnsignedShortType && (he = r.DEPTH24_STENCIL8, console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : G === null || G === UnsignedIntType || G === UnsignedInt248Type ? he = r.DEPTH_COMPONENT24 : G === FloatType ? he = r.DEPTH_COMPONENT32F : G === UnsignedShortType && (he = r.DEPTH_COMPONENT16), he } function U(K, G) { return M(K) === !0 || K.isFramebufferTexture && K.minFilter !== NearestFilter && K.minFilter !== LinearFilter ? Math.log2(Math.max(G.width, G.height)) + 1 : K.mipmaps !== void 0 && K.mipmaps.length > 0 ? K.mipmaps.length : K.isCompressedTexture && Array.isArray(K.image) ? G.mipmaps.length : 1 } function O(K) { const G = K.target; G.removeEventListener("dispose", O), H(G), G.isVideoTexture && p.delete(G) } function N(K) { const G = K.target; G.removeEventListener("dispose", N), k(G) } function H(K) { const G = s.get(K); if (G.__webglInit === void 0) return; const he = K.source, De = _.get(he); if (De) { const Ge = De[G.__cacheKey]; Ge.usedTimes--, Ge.usedTimes === 0 && F(K), Object.keys(De).length === 0 && _.delete(he) } s.remove(K) } function F(K) { const G = s.get(K); r.deleteTexture(G.__webglTexture); const he = K.source, De = _.get(he); delete De[G.__cacheKey], l.memory.textures-- } function k(K) { const G = s.get(K); if (K.depthTexture && (K.depthTexture.dispose(), s.remove(K.depthTexture)), K.isWebGLCubeRenderTarget) for (let De = 0; De < 6; De++) { if (Array.isArray(G.__webglFramebuffer[De])) for (let Ge = 0; Ge < G.__webglFramebuffer[De].length; Ge++)r.deleteFramebuffer(G.__webglFramebuffer[De][Ge]); else r.deleteFramebuffer(G.__webglFramebuffer[De]); G.__webglDepthbuffer && r.deleteRenderbuffer(G.__webglDepthbuffer[De]) } else { if (Array.isArray(G.__webglFramebuffer)) for (let De = 0; De < G.__webglFramebuffer.length; De++)r.deleteFramebuffer(G.__webglFramebuffer[De]); else r.deleteFramebuffer(G.__webglFramebuffer); if (G.__webglDepthbuffer && r.deleteRenderbuffer(G.__webglDepthbuffer), G.__webglMultisampledFramebuffer && r.deleteFramebuffer(G.__webglMultisampledFramebuffer), G.__webglColorRenderbuffer) for (let De = 0; De < G.__webglColorRenderbuffer.length; De++)G.__webglColorRenderbuffer[De] && r.deleteRenderbuffer(G.__webglColorRenderbuffer[De]); G.__webglDepthRenderbuffer && r.deleteRenderbuffer(G.__webglDepthRenderbuffer) } const he = K.textures; for (let De = 0, Ge = he.length; De < Ge; De++) { const Te = s.get(he[De]); Te.__webglTexture && (r.deleteTexture(Te.__webglTexture), l.memory.textures--), s.remove(he[De]) } s.remove(K) } let W = 0; function $() { W = 0 } function Z() { const K = W; return K >= a.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + K + " texture units while this GPU supports only " + a.maxTextures), W += 1, K } function J(K) { const G = []; return G.push(K.wrapS), G.push(K.wrapT), G.push(K.wrapR || 0), G.push(K.magFilter), G.push(K.minFilter), G.push(K.anisotropy), G.push(K.internalFormat), G.push(K.format), G.push(K.type), G.push(K.generateMipmaps), G.push(K.premultiplyAlpha), G.push(K.flipY), G.push(K.unpackAlignment), G.push(K.colorSpace), G.join() } function se(K, G) { const he = s.get(K); if (K.isVideoTexture && $e(K), K.isRenderTargetTexture === !1 && K.isExternalTexture !== !0 && K.version > 0 && he.__version !== K.version) { const De = K.image; if (De === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found."); else if (De.complete === !1) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete"); else { z(he, K, G); return } } else K.isExternalTexture && (he.__webglTexture = K.sourceTexture ? K.sourceTexture : null); i.bindTexture(r.TEXTURE_2D, he.__webglTexture, r.TEXTURE0 + G) } function re(K, G) { const he = s.get(K); if (K.isRenderTargetTexture === !1 && K.version > 0 && he.__version !== K.version) { z(he, K, G); return } i.bindTexture(r.TEXTURE_2D_ARRAY, he.__webglTexture, r.TEXTURE0 + G) } function ce(K, G) { const he = s.get(K); if (K.isRenderTargetTexture === !1 && K.version > 0 && he.__version !== K.version) { z(he, K, G); return } i.bindTexture(r.TEXTURE_3D, he.__webglTexture, r.TEXTURE0 + G) } function ee(K, G) { const he = s.get(K); if (K.version > 0 && he.__version !== K.version) { V(he, K, G); return } i.bindTexture(r.TEXTURE_CUBE_MAP, he.__webglTexture, r.TEXTURE0 + G) } const Me = { [RepeatWrapping]: r.REPEAT, [ClampToEdgeWrapping]: r.CLAMP_TO_EDGE, [MirroredRepeatWrapping]: r.MIRRORED_REPEAT }, Ee = { [NearestFilter]: r.NEAREST, [NearestMipmapNearestFilter]: r.NEAREST_MIPMAP_NEAREST, [NearestMipmapLinearFilter]: r.NEAREST_MIPMAP_LINEAR, [LinearFilter]: r.LINEAR, [LinearMipmapNearestFilter]: r.LINEAR_MIPMAP_NEAREST, [LinearMipmapLinearFilter]: r.LINEAR_MIPMAP_LINEAR }, Ue = { [NeverCompare]: r.NEVER, [AlwaysCompare]: r.ALWAYS, [LessCompare]: r.LESS, [LessEqualCompare]: r.LEQUAL, [EqualCompare]: r.EQUAL, [GreaterEqualCompare]: r.GEQUAL, [GreaterCompare]: r.GREATER, [NotEqualCompare]: r.NOTEQUAL }; function nt(K, G) { if (G.type === FloatType && e.has("OES_texture_float_linear") === !1 && (G.magFilter === LinearFilter || G.magFilter === LinearMipmapNearestFilter || G.magFilter === NearestMipmapLinearFilter || G.magFilter === LinearMipmapLinearFilter || G.minFilter === LinearFilter || G.minFilter === LinearMipmapNearestFilter || G.minFilter === NearestMipmapLinearFilter || G.minFilter === LinearMipmapLinearFilter) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), r.texParameteri(K, r.TEXTURE_WRAP_S, Me[G.wrapS]), r.texParameteri(K, r.TEXTURE_WRAP_T, Me[G.wrapT]), (K === r.TEXTURE_3D || K === r.TEXTURE_2D_ARRAY) && r.texParameteri(K, r.TEXTURE_WRAP_R, Me[G.wrapR]), r.texParameteri(K, r.TEXTURE_MAG_FILTER, Ee[G.magFilter]), r.texParameteri(K, r.TEXTURE_MIN_FILTER, Ee[G.minFilter]), G.compareFunction && (r.texParameteri(K, r.TEXTURE_COMPARE_MODE, r.COMPARE_REF_TO_TEXTURE), r.texParameteri(K, r.TEXTURE_COMPARE_FUNC, Ue[G.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) { if (G.magFilter === NearestFilter || G.minFilter !== NearestMipmapLinearFilter && G.minFilter !== LinearMipmapLinearFilter || G.type === FloatType && e.has("OES_texture_float_linear") === !1) return; if (G.anisotropy > 1 || s.get(G).__currentAnisotropy) { const he = e.get("EXT_texture_filter_anisotropic"); r.texParameterf(K, he.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(G.anisotropy, a.getMaxAnisotropy())), s.get(G).__currentAnisotropy = G.anisotropy } } } function mt(K, G) { let he = !1; K.__webglInit === void 0 && (K.__webglInit = !0, G.addEventListener("dispose", O)); const De = G.source; let Ge = _.get(De); Ge === void 0 && (Ge = {}, _.set(De, Ge)); const Te = J(G); if (Te !== K.__cacheKey) { Ge[Te] === void 0 && (Ge[Te] = { texture: r.createTexture(), usedTimes: 0 }, l.memory.textures++, he = !0), Ge[Te].usedTimes++; const ot = Ge[K.__cacheKey]; ot !== void 0 && (Ge[K.__cacheKey].usedTimes--, ot.usedTimes === 0 && F(G)), K.__cacheKey = Te, K.__webglTexture = Ge[Te].texture } return he } function ve(K, G, he) { return Math.floor(Math.floor(K / he) / G) } function ne(K, G, he, De) { const Te = K.updateRanges; if (Te.length === 0) i.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, G.width, G.height, he, De, G.data); else { Te.sort((ze, le) => ze.start - le.start); let ot = 0; for (let ze = 1; ze < Te.length; ze++) { const le = Te[ot], xe = Te[ze], be = le.start + le.count, Ce = ve(xe.start, G.width, 4), Ve = ve(le.start, G.width, 4); xe.start <= be + 1 && Ce === Ve && ve(xe.start + xe.count - 1, G.width, 4) === Ce ? le.count = Math.max(le.count, xe.start + xe.count - le.start) : (++ot, Te[ot] = xe) } Te.length = ot + 1; const tt = r.getParameter(r.UNPACK_ROW_LENGTH), ut = r.getParameter(r.UNPACK_SKIP_PIXELS), ft = r.getParameter(r.UNPACK_SKIP_ROWS); r.pixelStorei(r.UNPACK_ROW_LENGTH, G.width); for (let ze = 0, le = Te.length; ze < le; ze++) { const xe = Te[ze], be = Math.floor(xe.start / 4), Ce = Math.ceil(xe.count / 4), Ve = be % G.width, ie = Math.floor(be / G.width), Ne = Ce, Ye = 1; r.pixelStorei(r.UNPACK_SKIP_PIXELS, Ve), r.pixelStorei(r.UNPACK_SKIP_ROWS, ie), i.texSubImage2D(r.TEXTURE_2D, 0, Ve, ie, Ne, Ye, he, De, G.data) } K.clearUpdateRanges(), r.pixelStorei(r.UNPACK_ROW_LENGTH, tt), r.pixelStorei(r.UNPACK_SKIP_PIXELS, ut), r.pixelStorei(r.UNPACK_SKIP_ROWS, ft) } } function z(K, G, he) { let De = r.TEXTURE_2D; (G.isDataArrayTexture || G.isCompressedArrayTexture) && (De = r.TEXTURE_2D_ARRAY), G.isData3DTexture && (De = r.TEXTURE_3D); const Ge = mt(K, G), Te = G.source; i.bindTexture(De, K.__webglTexture, r.TEXTURE0 + he); const ot = s.get(Te); if (Te.version !== ot.__version || Ge === !0) { i.activeTexture(r.TEXTURE0 + he); const tt = ColorManagement.getPrimaries(ColorManagement.workingColorSpace), ut = G.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries(G.colorSpace), ft = G.colorSpace === NoColorSpace || tt === ut ? r.NONE : r.BROWSER_DEFAULT_WEBGL; r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, G.flipY), r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, G.premultiplyAlpha), r.pixelStorei(r.UNPACK_ALIGNMENT, G.unpackAlignment), r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, ft); let ze = T(G.image, !1, a.maxTextureSize); ze = vt(G, ze); const le = o.convert(G.format, G.colorSpace), xe = o.convert(G.type); let be = R(G.internalFormat, le, xe, G.colorSpace, G.isVideoTexture); nt(De, G); let Ce; const Ve = G.mipmaps, ie = G.isVideoTexture !== !0, Ne = ot.__version === void 0 || Ge === !0, Ye = Te.dataReady, rt = U(G, ze); if (G.isDepthTexture) be = P(G.format === DepthStencilFormat, G.type), Ne && (ie ? i.texStorage2D(r.TEXTURE_2D, 1, be, ze.width, ze.height) : i.texImage2D(r.TEXTURE_2D, 0, be, ze.width, ze.height, 0, le, xe, null)); else if (G.isDataTexture) if (Ve.length > 0) { ie && Ne && i.texStorage2D(r.TEXTURE_2D, rt, be, Ve[0].width, Ve[0].height); for (let je = 0, ke = Ve.length; je < ke; je++)Ce = Ve[je], ie ? Ye && i.texSubImage2D(r.TEXTURE_2D, je, 0, 0, Ce.width, Ce.height, le, xe, Ce.data) : i.texImage2D(r.TEXTURE_2D, je, be, Ce.width, Ce.height, 0, le, xe, Ce.data); G.generateMipmaps = !1 } else ie ? (Ne && i.texStorage2D(r.TEXTURE_2D, rt, be, ze.width, ze.height), Ye && ne(G, ze, le, xe)) : i.texImage2D(r.TEXTURE_2D, 0, be, ze.width, ze.height, 0, le, xe, ze.data); else if (G.isCompressedTexture) if (G.isCompressedArrayTexture) { ie && Ne && i.texStorage3D(r.TEXTURE_2D_ARRAY, rt, be, Ve[0].width, Ve[0].height, ze.depth); for (let je = 0, ke = Ve.length; je < ke; je++)if (Ce = Ve[je], G.format !== RGBAFormat) if (le !== null) if (ie) { if (Ye) if (G.layerUpdates.size > 0) { const ct = getByteLength(Ce.width, Ce.height, G.format, G.type); for (const wt of G.layerUpdates) { const Pt = Ce.data.subarray(wt * ct / Ce.data.BYTES_PER_ELEMENT, (wt + 1) * ct / Ce.data.BYTES_PER_ELEMENT); i.compressedTexSubImage3D(r.TEXTURE_2D_ARRAY, je, 0, 0, wt, Ce.width, Ce.height, 1, le, Pt) } G.clearLayerUpdates() } else i.compressedTexSubImage3D(r.TEXTURE_2D_ARRAY, je, 0, 0, 0, Ce.width, Ce.height, ze.depth, le, Ce.data) } else i.compressedTexImage3D(r.TEXTURE_2D_ARRAY, je, be, Ce.width, Ce.height, ze.depth, 0, Ce.data, 0, 0); else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"); else ie ? Ye && i.texSubImage3D(r.TEXTURE_2D_ARRAY, je, 0, 0, 0, Ce.width, Ce.height, ze.depth, le, xe, Ce.data) : i.texImage3D(r.TEXTURE_2D_ARRAY, je, be, Ce.width, Ce.height, ze.depth, 0, le, xe, Ce.data) } else { ie && Ne && i.texStorage2D(r.TEXTURE_2D, rt, be, Ve[0].width, Ve[0].height); for (let je = 0, ke = Ve.length; je < ke; je++)Ce = Ve[je], G.format !== RGBAFormat ? le !== null ? ie ? Ye && i.compressedTexSubImage2D(r.TEXTURE_2D, je, 0, 0, Ce.width, Ce.height, le, Ce.data) : i.compressedTexImage2D(r.TEXTURE_2D, je, be, Ce.width, Ce.height, 0, Ce.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : ie ? Ye && i.texSubImage2D(r.TEXTURE_2D, je, 0, 0, Ce.width, Ce.height, le, xe, Ce.data) : i.texImage2D(r.TEXTURE_2D, je, be, Ce.width, Ce.height, 0, le, xe, Ce.data) } else if (G.isDataArrayTexture) if (ie) { if (Ne && i.texStorage3D(r.TEXTURE_2D_ARRAY, rt, be, ze.width, ze.height, ze.depth), Ye) if (G.layerUpdates.size > 0) { const je = getByteLength(ze.width, ze.height, G.format, G.type); for (const ke of G.layerUpdates) { const ct = ze.data.subarray(ke * je / ze.data.BYTES_PER_ELEMENT, (ke + 1) * je / ze.data.BYTES_PER_ELEMENT); i.texSubImage3D(r.TEXTURE_2D_ARRAY, 0, 0, 0, ke, ze.width, ze.height, 1, le, xe, ct) } G.clearLayerUpdates() } else i.texSubImage3D(r.TEXTURE_2D_ARRAY, 0, 0, 0, 0, ze.width, ze.height, ze.depth, le, xe, ze.data) } else i.texImage3D(r.TEXTURE_2D_ARRAY, 0, be, ze.width, ze.height, ze.depth, 0, le, xe, ze.data); else if (G.isData3DTexture) ie ? (Ne && i.texStorage3D(r.TEXTURE_3D, rt, be, ze.width, ze.height, ze.depth), Ye && i.texSubImage3D(r.TEXTURE_3D, 0, 0, 0, 0, ze.width, ze.height, ze.depth, le, xe, ze.data)) : i.texImage3D(r.TEXTURE_3D, 0, be, ze.width, ze.height, ze.depth, 0, le, xe, ze.data); else if (G.isFramebufferTexture) { if (Ne) if (ie) i.texStorage2D(r.TEXTURE_2D, rt, be, ze.width, ze.height); else { let je = ze.width, ke = ze.height; for (let ct = 0; ct < rt; ct++)i.texImage2D(r.TEXTURE_2D, ct, be, je, ke, 0, le, xe, null), je >>= 1, ke >>= 1 } } else if (Ve.length > 0) { if (ie && Ne) { const je = St(Ve[0]); i.texStorage2D(r.TEXTURE_2D, rt, be, je.width, je.height) } for (let je = 0, ke = Ve.length; je < ke; je++)Ce = Ve[je], ie ? Ye && i.texSubImage2D(r.TEXTURE_2D, je, 0, 0, le, xe, Ce) : i.texImage2D(r.TEXTURE_2D, je, be, le, xe, Ce); G.generateMipmaps = !1 } else if (ie) { if (Ne) { const je = St(ze); i.texStorage2D(r.TEXTURE_2D, rt, be, je.width, je.height) } Ye && i.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, le, xe, ze) } else i.texImage2D(r.TEXTURE_2D, 0, be, le, xe, ze); M(G) && w(De), ot.__version = Te.version, G.onUpdate && G.onUpdate(G) } K.__version = G.version } function V(K, G, he) { if (G.image.length !== 6) return; const De = mt(K, G), Ge = G.source; i.bindTexture(r.TEXTURE_CUBE_MAP, K.__webglTexture, r.TEXTURE0 + he); const Te = s.get(Ge); if (Ge.version !== Te.__version || De === !0) { i.activeTexture(r.TEXTURE0 + he); const ot = ColorManagement.getPrimaries(ColorManagement.workingColorSpace), tt = G.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries(G.colorSpace), ut = G.colorSpace === NoColorSpace || ot === tt ? r.NONE : r.BROWSER_DEFAULT_WEBGL; r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, G.flipY), r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, G.premultiplyAlpha), r.pixelStorei(r.UNPACK_ALIGNMENT, G.unpackAlignment), r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, ut); const ft = G.isCompressedTexture || G.image[0].isCompressedTexture, ze = G.image[0] && G.image[0].isDataTexture, le = []; for (let ke = 0; ke < 6; ke++)!ft && !ze ? le[ke] = T(G.image[ke], !0, a.maxCubemapSize) : le[ke] = ze ? G.image[ke].image : G.image[ke], le[ke] = vt(G, le[ke]); const xe = le[0], be = o.convert(G.format, G.colorSpace), Ce = o.convert(G.type), Ve = R(G.internalFormat, be, Ce, G.colorSpace), ie = G.isVideoTexture !== !0, Ne = Te.__version === void 0 || De === !0, Ye = Ge.dataReady; let rt = U(G, xe); nt(r.TEXTURE_CUBE_MAP, G); let je; if (ft) { ie && Ne && i.texStorage2D(r.TEXTURE_CUBE_MAP, rt, Ve, xe.width, xe.height); for (let ke = 0; ke < 6; ke++) { je = le[ke].mipmaps; for (let ct = 0; ct < je.length; ct++) { const wt = je[ct]; G.format !== RGBAFormat ? be !== null ? ie ? Ye && i.compressedTexSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ke, ct, 0, 0, wt.width, wt.height, be, wt.data) : i.compressedTexImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ke, ct, Ve, wt.width, wt.height, 0, wt.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : ie ? Ye && i.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ke, ct, 0, 0, wt.width, wt.height, be, Ce, wt.data) : i.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ke, ct, Ve, wt.width, wt.height, 0, be, Ce, wt.data) } } } else { if (je = G.mipmaps, ie && Ne) { je.length > 0 && rt++; const ke = St(le[0]); i.texStorage2D(r.TEXTURE_CUBE_MAP, rt, Ve, ke.width, ke.height) } for (let ke = 0; ke < 6; ke++)if (ze) { ie ? Ye && i.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ke, 0, 0, 0, le[ke].width, le[ke].height, be, Ce, le[ke].data) : i.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ke, 0, Ve, le[ke].width, le[ke].height, 0, be, Ce, le[ke].data); for (let ct = 0; ct < je.length; ct++) { const Pt = je[ct].image[ke].image; ie ? Ye && i.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ke, ct + 1, 0, 0, Pt.width, Pt.height, be, Ce, Pt.data) : i.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ke, ct + 1, Ve, Pt.width, Pt.height, 0, be, Ce, Pt.data) } } else { ie ? Ye && i.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ke, 0, 0, 0, be, Ce, le[ke]) : i.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ke, 0, Ve, be, Ce, le[ke]); for (let ct = 0; ct < je.length; ct++) { const wt = je[ct]; ie ? Ye && i.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ke, ct + 1, 0, 0, be, Ce, wt.image[ke]) : i.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ke, ct + 1, Ve, be, Ce, wt.image[ke]) } } } M(G) && w(r.TEXTURE_CUBE_MAP), Te.__version = Ge.version, G.onUpdate && G.onUpdate(G) } K.__version = G.version } function _e(K, G, he, De, Ge, Te) { const ot = o.convert(he.format, he.colorSpace), tt = o.convert(he.type), ut = R(he.internalFormat, ot, tt, he.colorSpace), ft = s.get(G), ze = s.get(he); if (ze.__renderTarget = G, !ft.__hasExternalTextures) { const le = Math.max(1, G.width >> Te), xe = Math.max(1, G.height >> Te); Ge === r.TEXTURE_3D || Ge === r.TEXTURE_2D_ARRAY ? i.texImage3D(Ge, Te, ut, le, xe, G.depth, 0, ot, tt, null) : i.texImage2D(Ge, Te, ut, le, xe, 0, ot, tt, null) } i.bindFramebuffer(r.FRAMEBUFFER, K), Y(G) ? c.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, De, Ge, ze.__webglTexture, 0, oe(G)) : (Ge === r.TEXTURE_2D || Ge >= r.TEXTURE_CUBE_MAP_POSITIVE_X && Ge <= r.TEXTURE_CUBE_MAP_NEGATIVE_Z) && r.framebufferTexture2D(r.FRAMEBUFFER, De, Ge, ze.__webglTexture, Te), i.bindFramebuffer(r.FRAMEBUFFER, null) } function Le(K, G, he) { if (r.bindRenderbuffer(r.RENDERBUFFER, K), G.depthBuffer) { const De = G.depthTexture, Ge = De && De.isDepthTexture ? De.type : null, Te = P(G.stencilBuffer, Ge), ot = G.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT, tt = oe(G); Y(G) ? c.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, tt, Te, G.width, G.height) : he ? r.renderbufferStorageMultisample(r.RENDERBUFFER, tt, Te, G.width, G.height) : r.renderbufferStorage(r.RENDERBUFFER, Te, G.width, G.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, ot, r.RENDERBUFFER, K) } else { const De = G.textures; for (let Ge = 0; Ge < De.length; Ge++) { const Te = De[Ge], ot = o.convert(Te.format, Te.colorSpace), tt = o.convert(Te.type), ut = R(Te.internalFormat, ot, tt, Te.colorSpace), ft = oe(G); he && Y(G) === !1 ? r.renderbufferStorageMultisample(r.RENDERBUFFER, ft, ut, G.width, G.height) : Y(G) ? c.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, ft, ut, G.width, G.height) : r.renderbufferStorage(r.RENDERBUFFER, ut, G.width, G.height) } } r.bindRenderbuffer(r.RENDERBUFFER, null) } function fe(K, G) { if (G && G.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported"); if (i.bindFramebuffer(r.FRAMEBUFFER, K), !(G.depthTexture && G.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture"); const De = s.get(G.depthTexture); De.__renderTarget = G, (!De.__webglTexture || G.depthTexture.image.width !== G.width || G.depthTexture.image.height !== G.height) && (G.depthTexture.image.width = G.width, G.depthTexture.image.height = G.height, G.depthTexture.needsUpdate = !0), se(G.depthTexture, 0); const Ge = De.__webglTexture, Te = oe(G); if (G.depthTexture.format === DepthFormat) Y(G) ? c.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, Ge, 0, Te) : r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, Ge, 0); else if (G.depthTexture.format === DepthStencilFormat) Y(G) ? c.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, Ge, 0, Te) : r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, Ge, 0); else throw new Error("Unknown depthTexture format") } function Fe(K) { const G = s.get(K), he = K.isWebGLCubeRenderTarget === !0; if (G.__boundDepthTexture !== K.depthTexture) { const De = K.depthTexture; if (G.__depthDisposeCallback && G.__depthDisposeCallback(), De) { const Ge = () => { delete G.__boundDepthTexture, delete G.__depthDisposeCallback, De.removeEventListener("dispose", Ge) }; De.addEventListener("dispose", Ge), G.__depthDisposeCallback = Ge } G.__boundDepthTexture = De } if (K.depthTexture && !G.__autoAllocateDepthBuffer) { if (he) throw new Error("target.depthTexture not supported in Cube render targets"); const De = K.texture.mipmaps; De && De.length > 0 ? fe(G.__webglFramebuffer[0], K) : fe(G.__webglFramebuffer, K) } else if (he) { G.__webglDepthbuffer = []; for (let De = 0; De < 6; De++)if (i.bindFramebuffer(r.FRAMEBUFFER, G.__webglFramebuffer[De]), G.__webglDepthbuffer[De] === void 0) G.__webglDepthbuffer[De] = r.createRenderbuffer(), Le(G.__webglDepthbuffer[De], K, !1); else { const Ge = K.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT, Te = G.__webglDepthbuffer[De]; r.bindRenderbuffer(r.RENDERBUFFER, Te), r.framebufferRenderbuffer(r.FRAMEBUFFER, Ge, r.RENDERBUFFER, Te) } } else { const De = K.texture.mipmaps; if (De && De.length > 0 ? i.bindFramebuffer(r.FRAMEBUFFER, G.__webglFramebuffer[0]) : i.bindFramebuffer(r.FRAMEBUFFER, G.__webglFramebuffer), G.__webglDepthbuffer === void 0) G.__webglDepthbuffer = r.createRenderbuffer(), Le(G.__webglDepthbuffer, K, !1); else { const Ge = K.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT, Te = G.__webglDepthbuffer; r.bindRenderbuffer(r.RENDERBUFFER, Te), r.framebufferRenderbuffer(r.FRAMEBUFFER, Ge, r.RENDERBUFFER, Te) } } i.bindFramebuffer(r.FRAMEBUFFER, null) } function st(K, G, he) { const De = s.get(K); G !== void 0 && _e(De.__webglFramebuffer, K, K.texture, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, 0), he !== void 0 && Fe(K) } function j(K) { const G = K.texture, he = s.get(K), De = s.get(G); K.addEventListener("dispose", N); const Ge = K.textures, Te = K.isWebGLCubeRenderTarget === !0, ot = Ge.length > 1; if (ot || (De.__webglTexture === void 0 && (De.__webglTexture = r.createTexture()), De.__version = G.version, l.memory.textures++), Te) { he.__webglFramebuffer = []; for (let tt = 0; tt < 6; tt++)if (G.mipmaps && G.mipmaps.length > 0) { he.__webglFramebuffer[tt] = []; for (let ut = 0; ut < G.mipmaps.length; ut++)he.__webglFramebuffer[tt][ut] = r.createFramebuffer() } else he.__webglFramebuffer[tt] = r.createFramebuffer() } else { if (G.mipmaps && G.mipmaps.length > 0) { he.__webglFramebuffer = []; for (let tt = 0; tt < G.mipmaps.length; tt++)he.__webglFramebuffer[tt] = r.createFramebuffer() } else he.__webglFramebuffer = r.createFramebuffer(); if (ot) for (let tt = 0, ut = Ge.length; tt < ut; tt++) { const ft = s.get(Ge[tt]); ft.__webglTexture === void 0 && (ft.__webglTexture = r.createTexture(), l.memory.textures++) } if (K.samples > 0 && Y(K) === !1) { he.__webglMultisampledFramebuffer = r.createFramebuffer(), he.__webglColorRenderbuffer = [], i.bindFramebuffer(r.FRAMEBUFFER, he.__webglMultisampledFramebuffer); for (let tt = 0; tt < Ge.length; tt++) { const ut = Ge[tt]; he.__webglColorRenderbuffer[tt] = r.createRenderbuffer(), r.bindRenderbuffer(r.RENDERBUFFER, he.__webglColorRenderbuffer[tt]); const ft = o.convert(ut.format, ut.colorSpace), ze = o.convert(ut.type), le = R(ut.internalFormat, ft, ze, ut.colorSpace, K.isXRRenderTarget === !0), xe = oe(K); r.renderbufferStorageMultisample(r.RENDERBUFFER, xe, le, K.width, K.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + tt, r.RENDERBUFFER, he.__webglColorRenderbuffer[tt]) } r.bindRenderbuffer(r.RENDERBUFFER, null), K.depthBuffer && (he.__webglDepthRenderbuffer = r.createRenderbuffer(), Le(he.__webglDepthRenderbuffer, K, !0)), i.bindFramebuffer(r.FRAMEBUFFER, null) } } if (Te) { i.bindTexture(r.TEXTURE_CUBE_MAP, De.__webglTexture), nt(r.TEXTURE_CUBE_MAP, G); for (let tt = 0; tt < 6; tt++)if (G.mipmaps && G.mipmaps.length > 0) for (let ut = 0; ut < G.mipmaps.length; ut++)_e(he.__webglFramebuffer[tt][ut], K, G, r.COLOR_ATTACHMENT0, r.TEXTURE_CUBE_MAP_POSITIVE_X + tt, ut); else _e(he.__webglFramebuffer[tt], K, G, r.COLOR_ATTACHMENT0, r.TEXTURE_CUBE_MAP_POSITIVE_X + tt, 0); M(G) && w(r.TEXTURE_CUBE_MAP), i.unbindTexture() } else if (ot) { for (let tt = 0, ut = Ge.length; tt < ut; tt++) { const ft = Ge[tt], ze = s.get(ft); let le = r.TEXTURE_2D; (K.isWebGL3DRenderTarget || K.isWebGLArrayRenderTarget) && (le = K.isWebGL3DRenderTarget ? r.TEXTURE_3D : r.TEXTURE_2D_ARRAY), i.bindTexture(le, ze.__webglTexture), nt(le, ft), _e(he.__webglFramebuffer, K, ft, r.COLOR_ATTACHMENT0 + tt, le, 0), M(ft) && w(le) } i.unbindTexture() } else { let tt = r.TEXTURE_2D; if ((K.isWebGL3DRenderTarget || K.isWebGLArrayRenderTarget) && (tt = K.isWebGL3DRenderTarget ? r.TEXTURE_3D : r.TEXTURE_2D_ARRAY), i.bindTexture(tt, De.__webglTexture), nt(tt, G), G.mipmaps && G.mipmaps.length > 0) for (let ut = 0; ut < G.mipmaps.length; ut++)_e(he.__webglFramebuffer[ut], K, G, r.COLOR_ATTACHMENT0, tt, ut); else _e(he.__webglFramebuffer, K, G, r.COLOR_ATTACHMENT0, tt, 0); M(G) && w(tt), i.unbindTexture() } K.depthBuffer && Fe(K) } function Be(K) { const G = K.textures; for (let he = 0, De = G.length; he < De; he++) { const Ge = G[he]; if (M(Ge)) { const Te = D(K), ot = s.get(Ge).__webglTexture; i.bindTexture(Te, ot), w(Te), i.unbindTexture() } } } const Re = [], Oe = []; function Ie(K) { if (K.samples > 0) { if (Y(K) === !1) { const G = K.textures, he = K.width, De = K.height; let Ge = r.COLOR_BUFFER_BIT; const Te = K.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT, ot = s.get(K), tt = G.length > 1; if (tt) for (let ft = 0; ft < G.length; ft++)i.bindFramebuffer(r.FRAMEBUFFER, ot.__webglMultisampledFramebuffer), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + ft, r.RENDERBUFFER, null), i.bindFramebuffer(r.FRAMEBUFFER, ot.__webglFramebuffer), r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0 + ft, r.TEXTURE_2D, null, 0); i.bindFramebuffer(r.READ_FRAMEBUFFER, ot.__webglMultisampledFramebuffer); const ut = K.texture.mipmaps; ut && ut.length > 0 ? i.bindFramebuffer(r.DRAW_FRAMEBUFFER, ot.__webglFramebuffer[0]) : i.bindFramebuffer(r.DRAW_FRAMEBUFFER, ot.__webglFramebuffer); for (let ft = 0; ft < G.length; ft++) { if (K.resolveDepthBuffer && (K.depthBuffer && (Ge |= r.DEPTH_BUFFER_BIT), K.stencilBuffer && K.resolveStencilBuffer && (Ge |= r.STENCIL_BUFFER_BIT)), tt) { r.framebufferRenderbuffer(r.READ_FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.RENDERBUFFER, ot.__webglColorRenderbuffer[ft]); const ze = s.get(G[ft]).__webglTexture; r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, ze, 0) } r.blitFramebuffer(0, 0, he, De, 0, 0, he, De, Ge, r.NEAREST), h === !0 && (Re.length = 0, Oe.length = 0, Re.push(r.COLOR_ATTACHMENT0 + ft), K.depthBuffer && K.resolveDepthBuffer === !1 && (Re.push(Te), Oe.push(Te), r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, Oe)), r.invalidateFramebuffer(r.READ_FRAMEBUFFER, Re)) } if (i.bindFramebuffer(r.READ_FRAMEBUFFER, null), i.bindFramebuffer(r.DRAW_FRAMEBUFFER, null), tt) for (let ft = 0; ft < G.length; ft++) { i.bindFramebuffer(r.FRAMEBUFFER, ot.__webglMultisampledFramebuffer), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + ft, r.RENDERBUFFER, ot.__webglColorRenderbuffer[ft]); const ze = s.get(G[ft]).__webglTexture; i.bindFramebuffer(r.FRAMEBUFFER, ot.__webglFramebuffer), r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0 + ft, r.TEXTURE_2D, ze, 0) } i.bindFramebuffer(r.DRAW_FRAMEBUFFER, ot.__webglMultisampledFramebuffer) } else if (K.depthBuffer && K.resolveDepthBuffer === !1 && h) { const G = K.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT; r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, [G]) } } } function oe(K) { return Math.min(a.maxSamples, K.samples) } function Y(K) { const G = s.get(K); return K.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && G.__useRenderToTexture !== !1 } function $e(K) { const G = l.render.frame; p.get(K) !== G && (p.set(K, G), K.update()) } function vt(K, G) { const he = K.colorSpace, De = K.format, Ge = K.type; return K.isCompressedTexture === !0 || K.isVideoTexture === !0 || he !== LinearSRGBColorSpace && he !== NoColorSpace && (ColorManagement.getTransfer(he) === SRGBTransfer ? (De !== RGBAFormat || Ge !== UnsignedByteType) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", he)), G } function St(K) { return typeof HTMLImageElement < "u" && K instanceof HTMLImageElement ? (d.width = K.naturalWidth || K.width, d.height = K.naturalHeight || K.height) : typeof VideoFrame < "u" && K instanceof VideoFrame ? (d.width = K.displayWidth, d.height = K.displayHeight) : (d.width = K.width, d.height = K.height), d } this.allocateTextureUnit = Z, this.resetTextureUnits = $, this.setTexture2D = se, this.setTexture2DArray = re, this.setTexture3D = ce, this.setTextureCube = ee, this.rebindTextures = st, this.setupRenderTarget = j, this.updateRenderTargetMipmap = Be, this.updateMultisampleRenderTarget = Ie, this.setupDepthRenderbuffer = Fe, this.setupFrameBufferTexture = _e, this.useMultisampledRTT = Y } function WebGLUtils(r, e) { function i(s, a = NoColorSpace) { let o; const l = ColorManagement.getTransfer(a); if (s === UnsignedByteType) return r.UNSIGNED_BYTE; if (s === UnsignedShort4444Type) return r.UNSIGNED_SHORT_4_4_4_4; if (s === UnsignedShort5551Type) return r.UNSIGNED_SHORT_5_5_5_1; if (s === UnsignedInt5999Type) return r.UNSIGNED_INT_5_9_9_9_REV; if (s === UnsignedInt101111Type) return r.UNSIGNED_INT_10F_11F_11F_REV; if (s === ByteType) return r.BYTE; if (s === ShortType) return r.SHORT; if (s === UnsignedShortType) return r.UNSIGNED_SHORT; if (s === IntType) return r.INT; if (s === UnsignedIntType) return r.UNSIGNED_INT; if (s === FloatType) return r.FLOAT; if (s === HalfFloatType) return r.HALF_FLOAT; if (s === AlphaFormat) return r.ALPHA; if (s === RGBFormat) return r.RGB; if (s === RGBAFormat) return r.RGBA; if (s === DepthFormat) return r.DEPTH_COMPONENT; if (s === DepthStencilFormat) return r.DEPTH_STENCIL; if (s === RedFormat) return r.RED; if (s === RedIntegerFormat) return r.RED_INTEGER; if (s === RGFormat) return r.RG; if (s === RGIntegerFormat) return r.RG_INTEGER; if (s === RGBAIntegerFormat) return r.RGBA_INTEGER; if (s === RGB_S3TC_DXT1_Format || s === RGBA_S3TC_DXT1_Format || s === RGBA_S3TC_DXT3_Format || s === RGBA_S3TC_DXT5_Format) if (l === SRGBTransfer) if (o = e.get("WEBGL_compressed_texture_s3tc_srgb"), o !== null) { if (s === RGB_S3TC_DXT1_Format) return o.COMPRESSED_SRGB_S3TC_DXT1_EXT; if (s === RGBA_S3TC_DXT1_Format) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT; if (s === RGBA_S3TC_DXT3_Format) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT; if (s === RGBA_S3TC_DXT5_Format) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT } else return null; else if (o = e.get("WEBGL_compressed_texture_s3tc"), o !== null) { if (s === RGB_S3TC_DXT1_Format) return o.COMPRESSED_RGB_S3TC_DXT1_EXT; if (s === RGBA_S3TC_DXT1_Format) return o.COMPRESSED_RGBA_S3TC_DXT1_EXT; if (s === RGBA_S3TC_DXT3_Format) return o.COMPRESSED_RGBA_S3TC_DXT3_EXT; if (s === RGBA_S3TC_DXT5_Format) return o.COMPRESSED_RGBA_S3TC_DXT5_EXT } else return null; if (s === RGB_PVRTC_4BPPV1_Format || s === RGB_PVRTC_2BPPV1_Format || s === RGBA_PVRTC_4BPPV1_Format || s === RGBA_PVRTC_2BPPV1_Format) if (o = e.get("WEBGL_compressed_texture_pvrtc"), o !== null) { if (s === RGB_PVRTC_4BPPV1_Format) return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if (s === RGB_PVRTC_2BPPV1_Format) return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if (s === RGBA_PVRTC_4BPPV1_Format) return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if (s === RGBA_PVRTC_2BPPV1_Format) return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG } else return null; if (s === RGB_ETC1_Format || s === RGB_ETC2_Format || s === RGBA_ETC2_EAC_Format) if (o = e.get("WEBGL_compressed_texture_etc"), o !== null) { if (s === RGB_ETC1_Format || s === RGB_ETC2_Format) return l === SRGBTransfer ? o.COMPRESSED_SRGB8_ETC2 : o.COMPRESSED_RGB8_ETC2; if (s === RGBA_ETC2_EAC_Format) return l === SRGBTransfer ? o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : o.COMPRESSED_RGBA8_ETC2_EAC } else return null; if (s === RGBA_ASTC_4x4_Format || s === RGBA_ASTC_5x4_Format || s === RGBA_ASTC_5x5_Format || s === RGBA_ASTC_6x5_Format || s === RGBA_ASTC_6x6_Format || s === RGBA_ASTC_8x5_Format || s === RGBA_ASTC_8x6_Format || s === RGBA_ASTC_8x8_Format || s === RGBA_ASTC_10x5_Format || s === RGBA_ASTC_10x6_Format || s === RGBA_ASTC_10x8_Format || s === RGBA_ASTC_10x10_Format || s === RGBA_ASTC_12x10_Format || s === RGBA_ASTC_12x12_Format) if (o = e.get("WEBGL_compressed_texture_astc"), o !== null) { if (s === RGBA_ASTC_4x4_Format) return l === SRGBTransfer ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : o.COMPRESSED_RGBA_ASTC_4x4_KHR; if (s === RGBA_ASTC_5x4_Format) return l === SRGBTransfer ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : o.COMPRESSED_RGBA_ASTC_5x4_KHR; if (s === RGBA_ASTC_5x5_Format) return l === SRGBTransfer ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : o.COMPRESSED_RGBA_ASTC_5x5_KHR; if (s === RGBA_ASTC_6x5_Format) return l === SRGBTransfer ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : o.COMPRESSED_RGBA_ASTC_6x5_KHR; if (s === RGBA_ASTC_6x6_Format) return l === SRGBTransfer ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : o.COMPRESSED_RGBA_ASTC_6x6_KHR; if (s === RGBA_ASTC_8x5_Format) return l === SRGBTransfer ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : o.COMPRESSED_RGBA_ASTC_8x5_KHR; if (s === RGBA_ASTC_8x6_Format) return l === SRGBTransfer ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : o.COMPRESSED_RGBA_ASTC_8x6_KHR; if (s === RGBA_ASTC_8x8_Format) return l === SRGBTransfer ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : o.COMPRESSED_RGBA_ASTC_8x8_KHR; if (s === RGBA_ASTC_10x5_Format) return l === SRGBTransfer ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : o.COMPRESSED_RGBA_ASTC_10x5_KHR; if (s === RGBA_ASTC_10x6_Format) return l === SRGBTransfer ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : o.COMPRESSED_RGBA_ASTC_10x6_KHR; if (s === RGBA_ASTC_10x8_Format) return l === SRGBTransfer ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : o.COMPRESSED_RGBA_ASTC_10x8_KHR; if (s === RGBA_ASTC_10x10_Format) return l === SRGBTransfer ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : o.COMPRESSED_RGBA_ASTC_10x10_KHR; if (s === RGBA_ASTC_12x10_Format) return l === SRGBTransfer ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : o.COMPRESSED_RGBA_ASTC_12x10_KHR; if (s === RGBA_ASTC_12x12_Format) return l === SRGBTransfer ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : o.COMPRESSED_RGBA_ASTC_12x12_KHR } else return null; if (s === RGBA_BPTC_Format || s === RGB_BPTC_SIGNED_Format || s === RGB_BPTC_UNSIGNED_Format) if (o = e.get("EXT_texture_compression_bptc"), o !== null) { if (s === RGBA_BPTC_Format) return l === SRGBTransfer ? o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : o.COMPRESSED_RGBA_BPTC_UNORM_EXT; if (s === RGB_BPTC_SIGNED_Format) return o.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT; if (s === RGB_BPTC_UNSIGNED_Format) return o.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT } else return null; if (s === RED_RGTC1_Format || s === SIGNED_RED_RGTC1_Format || s === RED_GREEN_RGTC2_Format || s === SIGNED_RED_GREEN_RGTC2_Format) if (o = e.get("EXT_texture_compression_rgtc"), o !== null) { if (s === RED_RGTC1_Format) return o.COMPRESSED_RED_RGTC1_EXT; if (s === SIGNED_RED_RGTC1_Format) return o.COMPRESSED_SIGNED_RED_RGTC1_EXT; if (s === RED_GREEN_RGTC2_Format) return o.COMPRESSED_RED_GREEN_RGTC2_EXT; if (s === SIGNED_RED_GREEN_RGTC2_Format) return o.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT } else return null; return s === UnsignedInt248Type ? r.UNSIGNED_INT_24_8 : r[s] !== void 0 ? r[s] : null } return { convert: i } } const _occlusion_vertex = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`, _occlusion_fragment = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`; class WebXRDepthSensing { constructor() { this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0 } init(e, i) { if (this.texture === null) { const s = new ExternalTexture(e.texture); (e.depthNear !== i.depthNear || e.depthFar !== i.depthFar) && (this.depthNear = e.depthNear, this.depthFar = e.depthFar), this.texture = s } } getMesh(e) { if (this.texture !== null && this.mesh === null) { const i = e.cameras[0].viewport, s = new ShaderMaterial({ vertexShader: _occlusion_vertex, fragmentShader: _occlusion_fragment, uniforms: { depthColor: { value: this.texture }, depthWidth: { value: i.z }, depthHeight: { value: i.w } } }); this.mesh = new Mesh(new PlaneGeometry(20, 20), s) } return this.mesh } reset() { this.texture = null, this.mesh = null } getDepthTexture() { return this.texture } } class WebXRManager extends EventDispatcher { constructor(e, i) { super(); const s = this; let a = null, o = 1, l = null, c = "local-floor", h = 1, d = null, p = null, f = null, _ = null, x = null, b = null; const T = typeof XRWebGLBinding < "u", M = new WebXRDepthSensing, w = {}, D = i.getContextAttributes(); let R = null, P = null; const U = [], O = [], N = new Vector2; let H = null; const F = new PerspectiveCamera; F.viewport = new Vector4; const k = new PerspectiveCamera; k.viewport = new Vector4; const W = [F, k], $ = new ArrayCamera; let Z = null, J = null; this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function (z) { let V = U[z]; return V === void 0 && (V = new WebXRController, U[z] = V), V.getTargetRaySpace() }, this.getControllerGrip = function (z) { let V = U[z]; return V === void 0 && (V = new WebXRController, U[z] = V), V.getGripSpace() }, this.getHand = function (z) { let V = U[z]; return V === void 0 && (V = new WebXRController, U[z] = V), V.getHandSpace() }; function se(z) { const V = O.indexOf(z.inputSource); if (V === -1) return; const _e = U[V]; _e !== void 0 && (_e.update(z.inputSource, z.frame, d || l), _e.dispatchEvent({ type: z.type, data: z.inputSource })) } function re() { a.removeEventListener("select", se), a.removeEventListener("selectstart", se), a.removeEventListener("selectend", se), a.removeEventListener("squeeze", se), a.removeEventListener("squeezestart", se), a.removeEventListener("squeezeend", se), a.removeEventListener("end", re), a.removeEventListener("inputsourceschange", ce); for (let z = 0; z < U.length; z++) { const V = O[z]; V !== null && (O[z] = null, U[z].disconnect(V)) } Z = null, J = null, M.reset(); for (const z in w) delete w[z]; e.setRenderTarget(R), x = null, _ = null, f = null, a = null, P = null, ne.stop(), s.isPresenting = !1, e.setPixelRatio(H), e.setSize(N.width, N.height, !1), s.dispatchEvent({ type: "sessionend" }) } this.setFramebufferScaleFactor = function (z) { o = z, s.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.") }, this.setReferenceSpaceType = function (z) { c = z, s.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.") }, this.getReferenceSpace = function () { return d || l }, this.setReferenceSpace = function (z) { d = z }, this.getBaseLayer = function () { return _ !== null ? _ : x }, this.getBinding = function () { return f === null && T && (f = new XRWebGLBinding(a, i)), f }, this.getFrame = function () { return b }, this.getSession = function () { return a }, this.setSession = async function (z) { if (a = z, a !== null) { if (R = e.getRenderTarget(), a.addEventListener("select", se), a.addEventListener("selectstart", se), a.addEventListener("selectend", se), a.addEventListener("squeeze", se), a.addEventListener("squeezestart", se), a.addEventListener("squeezeend", se), a.addEventListener("end", re), a.addEventListener("inputsourceschange", ce), D.xrCompatible !== !0 && await i.makeXRCompatible(), H = e.getPixelRatio(), e.getSize(N), T && "createProjectionLayer" in XRWebGLBinding.prototype) { let _e = null, Le = null, fe = null; D.depth && (fe = D.stencil ? i.DEPTH24_STENCIL8 : i.DEPTH_COMPONENT24, _e = D.stencil ? DepthStencilFormat : DepthFormat, Le = D.stencil ? UnsignedInt248Type : UnsignedIntType); const Fe = { colorFormat: i.RGBA8, depthFormat: fe, scaleFactor: o }; f = this.getBinding(), _ = f.createProjectionLayer(Fe), a.updateRenderState({ layers: [_] }), e.setPixelRatio(1), e.setSize(_.textureWidth, _.textureHeight, !1), P = new WebGLRenderTarget(_.textureWidth, _.textureHeight, { format: RGBAFormat, type: UnsignedByteType, depthTexture: new DepthTexture(_.textureWidth, _.textureHeight, Le, void 0, void 0, void 0, void 0, void 0, void 0, _e), stencilBuffer: D.stencil, colorSpace: e.outputColorSpace, samples: D.antialias ? 4 : 0, resolveDepthBuffer: _.ignoreDepthValues === !1, resolveStencilBuffer: _.ignoreDepthValues === !1 }) } else { const _e = { antialias: D.antialias, alpha: !0, depth: D.depth, stencil: D.stencil, framebufferScaleFactor: o }; x = new XRWebGLLayer(a, i, _e), a.updateRenderState({ baseLayer: x }), e.setPixelRatio(1), e.setSize(x.framebufferWidth, x.framebufferHeight, !1), P = new WebGLRenderTarget(x.framebufferWidth, x.framebufferHeight, { format: RGBAFormat, type: UnsignedByteType, colorSpace: e.outputColorSpace, stencilBuffer: D.stencil, resolveDepthBuffer: x.ignoreDepthValues === !1, resolveStencilBuffer: x.ignoreDepthValues === !1 }) } P.isXRRenderTarget = !0, this.setFoveation(h), d = null, l = await a.requestReferenceSpace(c), ne.setContext(a), ne.start(), s.isPresenting = !0, s.dispatchEvent({ type: "sessionstart" }) } }, this.getEnvironmentBlendMode = function () { if (a !== null) return a.environmentBlendMode }, this.getDepthTexture = function () { return M.getDepthTexture() }; function ce(z) { for (let V = 0; V < z.removed.length; V++) { const _e = z.removed[V], Le = O.indexOf(_e); Le >= 0 && (O[Le] = null, U[Le].disconnect(_e)) } for (let V = 0; V < z.added.length; V++) { const _e = z.added[V]; let Le = O.indexOf(_e); if (Le === -1) { for (let Fe = 0; Fe < U.length; Fe++)if (Fe >= O.length) { O.push(_e), Le = Fe; break } else if (O[Fe] === null) { O[Fe] = _e, Le = Fe; break } if (Le === -1) break } const fe = U[Le]; fe && fe.connect(_e) } } const ee = new Vector3, Me = new Vector3; function Ee(z, V, _e) { ee.setFromMatrixPosition(V.matrixWorld), Me.setFromMatrixPosition(_e.matrixWorld); const Le = ee.distanceTo(Me), fe = V.projectionMatrix.elements, Fe = _e.projectionMatrix.elements, st = fe[14] / (fe[10] - 1), j = fe[14] / (fe[10] + 1), Be = (fe[9] + 1) / fe[5], Re = (fe[9] - 1) / fe[5], Oe = (fe[8] - 1) / fe[0], Ie = (Fe[8] + 1) / Fe[0], oe = st * Oe, Y = st * Ie, $e = Le / (-Oe + Ie), vt = $e * -Oe; if (V.matrixWorld.decompose(z.position, z.quaternion, z.scale), z.translateX(vt), z.translateZ($e), z.matrixWorld.compose(z.position, z.quaternion, z.scale), z.matrixWorldInverse.copy(z.matrixWorld).invert(), fe[10] === -1) z.projectionMatrix.copy(V.projectionMatrix), z.projectionMatrixInverse.copy(V.projectionMatrixInverse); else { const St = st + $e, K = j + $e, G = oe - vt, he = Y + (Le - vt), De = Be * j / K * St, Ge = Re * j / K * St; z.projectionMatrix.makePerspective(G, he, De, Ge, St, K), z.projectionMatrixInverse.copy(z.projectionMatrix).invert() } } function Ue(z, V) { V === null ? z.matrixWorld.copy(z.matrix) : z.matrixWorld.multiplyMatrices(V.matrixWorld, z.matrix), z.matrixWorldInverse.copy(z.matrixWorld).invert() } this.updateCamera = function (z) { if (a === null) return; let V = z.near, _e = z.far; M.texture !== null && (M.depthNear > 0 && (V = M.depthNear), M.depthFar > 0 && (_e = M.depthFar)), $.near = k.near = F.near = V, $.far = k.far = F.far = _e, (Z !== $.near || J !== $.far) && (a.updateRenderState({ depthNear: $.near, depthFar: $.far }), Z = $.near, J = $.far), $.layers.mask = z.layers.mask | 6, F.layers.mask = $.layers.mask & 3, k.layers.mask = $.layers.mask & 5; const Le = z.parent, fe = $.cameras; Ue($, Le); for (let Fe = 0; Fe < fe.length; Fe++)Ue(fe[Fe], Le); fe.length === 2 ? Ee($, F, k) : $.projectionMatrix.copy(F.projectionMatrix), nt(z, $, Le) }; function nt(z, V, _e) { _e === null ? z.matrix.copy(V.matrixWorld) : (z.matrix.copy(_e.matrixWorld), z.matrix.invert(), z.matrix.multiply(V.matrixWorld)), z.matrix.decompose(z.position, z.quaternion, z.scale), z.updateMatrixWorld(!0), z.projectionMatrix.copy(V.projectionMatrix), z.projectionMatrixInverse.copy(V.projectionMatrixInverse), z.isPerspectiveCamera && (z.fov = RAD2DEG * 2 * Math.atan(1 / z.projectionMatrix.elements[5]), z.zoom = 1) } this.getCamera = function () { return $ }, this.getFoveation = function () { if (!(_ === null && x === null)) return h }, this.setFoveation = function (z) { h = z, _ !== null && (_.fixedFoveation = z), x !== null && x.fixedFoveation !== void 0 && (x.fixedFoveation = z) }, this.hasDepthSensing = function () { return M.texture !== null }, this.getDepthSensingMesh = function () { return M.getMesh($) }, this.getCameraTexture = function (z) { return w[z] }; let mt = null; function ve(z, V) { if (p = V.getViewerPose(d || l), b = V, p !== null) { const _e = p.views; x !== null && (e.setRenderTargetFramebuffer(P, x.framebuffer), e.setRenderTarget(P)); let Le = !1; _e.length !== $.cameras.length && ($.cameras.length = 0, Le = !0); for (let j = 0; j < _e.length; j++) { const Be = _e[j]; let Re = null; if (x !== null) Re = x.getViewport(Be); else { const Ie = f.getViewSubImage(_, Be); Re = Ie.viewport, j === 0 && (e.setRenderTargetTextures(P, Ie.colorTexture, Ie.depthStencilTexture), e.setRenderTarget(P)) } let Oe = W[j]; Oe === void 0 && (Oe = new PerspectiveCamera, Oe.layers.enable(j), Oe.viewport = new Vector4, W[j] = Oe), Oe.matrix.fromArray(Be.transform.matrix), Oe.matrix.decompose(Oe.position, Oe.quaternion, Oe.scale), Oe.projectionMatrix.fromArray(Be.projectionMatrix), Oe.projectionMatrixInverse.copy(Oe.projectionMatrix).invert(), Oe.viewport.set(Re.x, Re.y, Re.width, Re.height), j === 0 && ($.matrix.copy(Oe.matrix), $.matrix.decompose($.position, $.quaternion, $.scale)), Le === !0 && $.cameras.push(Oe) } const fe = a.enabledFeatures; if (fe && fe.includes("depth-sensing") && a.depthUsage == "gpu-optimized" && T) { f = s.getBinding(); const j = f.getDepthInformation(_e[0]); j && j.isValid && j.texture && M.init(j, a.renderState) } if (fe && fe.includes("camera-access") && T) { e.state.unbindTexture(), f = s.getBinding(); for (let j = 0; j < _e.length; j++) { const Be = _e[j].camera; if (Be) { let Re = w[Be]; Re || (Re = new ExternalTexture, w[Be] = Re); const Oe = f.getCameraImage(Be); Re.sourceTexture = Oe } } } } for (let _e = 0; _e < U.length; _e++) { const Le = O[_e], fe = U[_e]; Le !== null && fe !== void 0 && fe.update(Le, V, d || l) } mt && mt(z, V), V.detectedPlanes && s.dispatchEvent({ type: "planesdetected", data: V }), b = null } const ne = new WebGLAnimation; ne.setAnimationLoop(ve), this.setAnimationLoop = function (z) { mt = z }, this.dispose = function () { } } } const _e1 = new Euler, _m1 = new Matrix4; function WebGLMaterials(r, e) { function i(M, w) { M.matrixAutoUpdate === !0 && M.updateMatrix(), w.value.copy(M.matrix) } function s(M, w) { w.color.getRGB(M.fogColor.value, getUnlitUniformColorSpace(r)), w.isFog ? (M.fogNear.value = w.near, M.fogFar.value = w.far) : w.isFogExp2 && (M.fogDensity.value = w.density) } function a(M, w, D, R, P) { w.isMeshBasicMaterial || w.isMeshLambertMaterial ? o(M, w) : w.isMeshToonMaterial ? (o(M, w), f(M, w)) : w.isMeshPhongMaterial ? (o(M, w), p(M, w)) : w.isMeshStandardMaterial ? (o(M, w), _(M, w), w.isMeshPhysicalMaterial && x(M, w, P)) : w.isMeshMatcapMaterial ? (o(M, w), b(M, w)) : w.isMeshDepthMaterial ? o(M, w) : w.isMeshDistanceMaterial ? (o(M, w), T(M, w)) : w.isMeshNormalMaterial ? o(M, w) : w.isLineBasicMaterial ? (l(M, w), w.isLineDashedMaterial && c(M, w)) : w.isPointsMaterial ? h(M, w, D, R) : w.isSpriteMaterial ? d(M, w) : w.isShadowMaterial ? (M.color.value.copy(w.color), M.opacity.value = w.opacity) : w.isShaderMaterial && (w.uniformsNeedUpdate = !1) } function o(M, w) { M.opacity.value = w.opacity, w.color && M.diffuse.value.copy(w.color), w.emissive && M.emissive.value.copy(w.emissive).multiplyScalar(w.emissiveIntensity), w.map && (M.map.value = w.map, i(w.map, M.mapTransform)), w.alphaMap && (M.alphaMap.value = w.alphaMap, i(w.alphaMap, M.alphaMapTransform)), w.bumpMap && (M.bumpMap.value = w.bumpMap, i(w.bumpMap, M.bumpMapTransform), M.bumpScale.value = w.bumpScale, w.side === BackSide && (M.bumpScale.value *= -1)), w.normalMap && (M.normalMap.value = w.normalMap, i(w.normalMap, M.normalMapTransform), M.normalScale.value.copy(w.normalScale), w.side === BackSide && M.normalScale.value.negate()), w.displacementMap && (M.displacementMap.value = w.displacementMap, i(w.displacementMap, M.displacementMapTransform), M.displacementScale.value = w.displacementScale, M.displacementBias.value = w.displacementBias), w.emissiveMap && (M.emissiveMap.value = w.emissiveMap, i(w.emissiveMap, M.emissiveMapTransform)), w.specularMap && (M.specularMap.value = w.specularMap, i(w.specularMap, M.specularMapTransform)), w.alphaTest > 0 && (M.alphaTest.value = w.alphaTest); const D = e.get(w), R = D.envMap, P = D.envMapRotation; R && (M.envMap.value = R, _e1.copy(P), _e1.x *= -1, _e1.y *= -1, _e1.z *= -1, R.isCubeTexture && R.isRenderTargetTexture === !1 && (_e1.y *= -1, _e1.z *= -1), M.envMapRotation.value.setFromMatrix4(_m1.makeRotationFromEuler(_e1)), M.flipEnvMap.value = R.isCubeTexture && R.isRenderTargetTexture === !1 ? -1 : 1, M.reflectivity.value = w.reflectivity, M.ior.value = w.ior, M.refractionRatio.value = w.refractionRatio), w.lightMap && (M.lightMap.value = w.lightMap, M.lightMapIntensity.value = w.lightMapIntensity, i(w.lightMap, M.lightMapTransform)), w.aoMap && (M.aoMap.value = w.aoMap, M.aoMapIntensity.value = w.aoMapIntensity, i(w.aoMap, M.aoMapTransform)) } function l(M, w) { M.diffuse.value.copy(w.color), M.opacity.value = w.opacity, w.map && (M.map.value = w.map, i(w.map, M.mapTransform)) } function c(M, w) { M.dashSize.value = w.dashSize, M.totalSize.value = w.dashSize + w.gapSize, M.scale.value = w.scale } function h(M, w, D, R) { M.diffuse.value.copy(w.color), M.opacity.value = w.opacity, M.size.value = w.size * D, M.scale.value = R * .5, w.map && (M.map.value = w.map, i(w.map, M.uvTransform)), w.alphaMap && (M.alphaMap.value = w.alphaMap, i(w.alphaMap, M.alphaMapTransform)), w.alphaTest > 0 && (M.alphaTest.value = w.alphaTest) } function d(M, w) { M.diffuse.value.copy(w.color), M.opacity.value = w.opacity, M.rotation.value = w.rotation, w.map && (M.map.value = w.map, i(w.map, M.mapTransform)), w.alphaMap && (M.alphaMap.value = w.alphaMap, i(w.alphaMap, M.alphaMapTransform)), w.alphaTest > 0 && (M.alphaTest.value = w.alphaTest) } function p(M, w) { M.specular.value.copy(w.specular), M.shininess.value = Math.max(w.shininess, 1e-4) } function f(M, w) { w.gradientMap && (M.gradientMap.value = w.gradientMap) } function _(M, w) { M.metalness.value = w.metalness, w.metalnessMap && (M.metalnessMap.value = w.metalnessMap, i(w.metalnessMap, M.metalnessMapTransform)), M.roughness.value = w.roughness, w.roughnessMap && (M.roughnessMap.value = w.roughnessMap, i(w.roughnessMap, M.roughnessMapTransform)), w.envMap && (M.envMapIntensity.value = w.envMapIntensity) } function x(M, w, D) { M.ior.value = w.ior, w.sheen > 0 && (M.sheenColor.value.copy(w.sheenColor).multiplyScalar(w.sheen), M.sheenRoughness.value = w.sheenRoughness, w.sheenColorMap && (M.sheenColorMap.value = w.sheenColorMap, i(w.sheenColorMap, M.sheenColorMapTransform)), w.sheenRoughnessMap && (M.sheenRoughnessMap.value = w.sheenRoughnessMap, i(w.sheenRoughnessMap, M.sheenRoughnessMapTransform))), w.clearcoat > 0 && (M.clearcoat.value = w.clearcoat, M.clearcoatRoughness.value = w.clearcoatRoughness, w.clearcoatMap && (M.clearcoatMap.value = w.clearcoatMap, i(w.clearcoatMap, M.clearcoatMapTransform)), w.clearcoatRoughnessMap && (M.clearcoatRoughnessMap.value = w.clearcoatRoughnessMap, i(w.clearcoatRoughnessMap, M.clearcoatRoughnessMapTransform)), w.clearcoatNormalMap && (M.clearcoatNormalMap.value = w.clearcoatNormalMap, i(w.clearcoatNormalMap, M.clearcoatNormalMapTransform), M.clearcoatNormalScale.value.copy(w.clearcoatNormalScale), w.side === BackSide && M.clearcoatNormalScale.value.negate())), w.dispersion > 0 && (M.dispersion.value = w.dispersion), w.iridescence > 0 && (M.iridescence.value = w.iridescence, M.iridescenceIOR.value = w.iridescenceIOR, M.iridescenceThicknessMinimum.value = w.iridescenceThicknessRange[0], M.iridescenceThicknessMaximum.value = w.iridescenceThicknessRange[1], w.iridescenceMap && (M.iridescenceMap.value = w.iridescenceMap, i(w.iridescenceMap, M.iridescenceMapTransform)), w.iridescenceThicknessMap && (M.iridescenceThicknessMap.value = w.iridescenceThicknessMap, i(w.iridescenceThicknessMap, M.iridescenceThicknessMapTransform))), w.transmission > 0 && (M.transmission.value = w.transmission, M.transmissionSamplerMap.value = D.texture, M.transmissionSamplerSize.value.set(D.width, D.height), w.transmissionMap && (M.transmissionMap.value = w.transmissionMap, i(w.transmissionMap, M.transmissionMapTransform)), M.thickness.value = w.thickness, w.thicknessMap && (M.thicknessMap.value = w.thicknessMap, i(w.thicknessMap, M.thicknessMapTransform)), M.attenuationDistance.value = w.attenuationDistance, M.attenuationColor.value.copy(w.attenuationColor)), w.anisotropy > 0 && (M.anisotropyVector.value.set(w.anisotropy * Math.cos(w.anisotropyRotation), w.anisotropy * Math.sin(w.anisotropyRotation)), w.anisotropyMap && (M.anisotropyMap.value = w.anisotropyMap, i(w.anisotropyMap, M.anisotropyMapTransform))), M.specularIntensity.value = w.specularIntensity, M.specularColor.value.copy(w.specularColor), w.specularColorMap && (M.specularColorMap.value = w.specularColorMap, i(w.specularColorMap, M.specularColorMapTransform)), w.specularIntensityMap && (M.specularIntensityMap.value = w.specularIntensityMap, i(w.specularIntensityMap, M.specularIntensityMapTransform)) } function b(M, w) { w.matcap && (M.matcap.value = w.matcap) } function T(M, w) { const D = e.get(w).light; M.referencePosition.value.setFromMatrixPosition(D.matrixWorld), M.nearDistance.value = D.shadow.camera.near, M.farDistance.value = D.shadow.camera.far } return { refreshFogUniforms: s, refreshMaterialUniforms: a } } function WebGLUniformsGroups(r, e, i, s) { let a = {}, o = {}, l = []; const c = r.getParameter(r.MAX_UNIFORM_BUFFER_BINDINGS); function h(D, R) { const P = R.program; s.uniformBlockBinding(D, P) } function d(D, R) { let P = a[D.id]; P === void 0 && (b(D), P = p(D), a[D.id] = P, D.addEventListener("dispose", M)); const U = R.program; s.updateUBOMapping(D, U); const O = e.render.frame; o[D.id] !== O && (_(D), o[D.id] = O) } function p(D) { const R = f(); D.__bindingPointIndex = R; const P = r.createBuffer(), U = D.__size, O = D.usage; return r.bindBuffer(r.UNIFORM_BUFFER, P), r.bufferData(r.UNIFORM_BUFFER, U, O), r.bindBuffer(r.UNIFORM_BUFFER, null), r.bindBufferBase(r.UNIFORM_BUFFER, R, P), P } function f() { for (let D = 0; D < c; D++)if (l.indexOf(D) === -1) return l.push(D), D; return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0 } function _(D) { const R = a[D.id], P = D.uniforms, U = D.__cache; r.bindBuffer(r.UNIFORM_BUFFER, R); for (let O = 0, N = P.length; O < N; O++) { const H = Array.isArray(P[O]) ? P[O] : [P[O]]; for (let F = 0, k = H.length; F < k; F++) { const W = H[F]; if (x(W, O, F, U) === !0) { const $ = W.__offset, Z = Array.isArray(W.value) ? W.value : [W.value]; let J = 0; for (let se = 0; se < Z.length; se++) { const re = Z[se], ce = T(re); typeof re == "number" || typeof re == "boolean" ? (W.__data[0] = re, r.bufferSubData(r.UNIFORM_BUFFER, $ + J, W.__data)) : re.isMatrix3 ? (W.__data[0] = re.elements[0], W.__data[1] = re.elements[1], W.__data[2] = re.elements[2], W.__data[3] = 0, W.__data[4] = re.elements[3], W.__data[5] = re.elements[4], W.__data[6] = re.elements[5], W.__data[7] = 0, W.__data[8] = re.elements[6], W.__data[9] = re.elements[7], W.__data[10] = re.elements[8], W.__data[11] = 0) : (re.toArray(W.__data, J), J += ce.storage / Float32Array.BYTES_PER_ELEMENT) } r.bufferSubData(r.UNIFORM_BUFFER, $, W.__data) } } } r.bindBuffer(r.UNIFORM_BUFFER, null) } function x(D, R, P, U) { const O = D.value, N = R + "_" + P; if (U[N] === void 0) return typeof O == "number" || typeof O == "boolean" ? U[N] = O : U[N] = O.clone(), !0; { const H = U[N]; if (typeof O == "number" || typeof O == "boolean") { if (H !== O) return U[N] = O, !0 } else if (H.equals(O) === !1) return H.copy(O), !0 } return !1 } function b(D) { const R = D.uniforms; let P = 0; const U = 16; for (let N = 0, H = R.length; N < H; N++) { const F = Array.isArray(R[N]) ? R[N] : [R[N]]; for (let k = 0, W = F.length; k < W; k++) { const $ = F[k], Z = Array.isArray($.value) ? $.value : [$.value]; for (let J = 0, se = Z.length; J < se; J++) { const re = Z[J], ce = T(re), ee = P % U, Me = ee % ce.boundary, Ee = ee + Me; P += Me, Ee !== 0 && U - Ee < ce.storage && (P += U - Ee), $.__data = new Float32Array(ce.storage / Float32Array.BYTES_PER_ELEMENT), $.__offset = P, P += ce.storage } } } const O = P % U; return O > 0 && (P += U - O), D.__size = P, D.__cache = {}, this } function T(D) { const R = { boundary: 0, storage: 0 }; return typeof D == "number" || typeof D == "boolean" ? (R.boundary = 4, R.storage = 4) : D.isVector2 ? (R.boundary = 8, R.storage = 8) : D.isVector3 || D.isColor ? (R.boundary = 16, R.storage = 12) : D.isVector4 ? (R.boundary = 16, R.storage = 16) : D.isMatrix3 ? (R.boundary = 48, R.storage = 48) : D.isMatrix4 ? (R.boundary = 64, R.storage = 64) : D.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", D), R } function M(D) { const R = D.target; R.removeEventListener("dispose", M); const P = l.indexOf(R.__bindingPointIndex); l.splice(P, 1), r.deleteBuffer(a[R.id]), delete a[R.id], delete o[R.id] } function w() { for (const D in a) r.deleteBuffer(a[D]); l = [], a = {}, o = {} } return { bind: h, update: d, dispose: w } } class WebGLRenderer { constructor(e = {}) { const { canvas: i = createCanvasElement(), context: s = null, depth: a = !0, stencil: o = !1, alpha: l = !1, antialias: c = !1, premultipliedAlpha: h = !0, preserveDrawingBuffer: d = !1, powerPreference: p = "default", failIfMajorPerformanceCaveat: f = !1, reversedDepthBuffer: _ = !1 } = e; this.isWebGLRenderer = !0; let x; if (s !== null) { if (typeof WebGLRenderingContext < "u" && s instanceof WebGLRenderingContext) throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163."); x = s.getContextAttributes().alpha } else x = l; const b = new Uint32Array(4), T = new Int32Array(4); let M = null, w = null; const D = [], R = []; this.domElement = i, this.debug = { checkShaderErrors: !0, onShaderError: null }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.toneMapping = NoToneMapping, this.toneMappingExposure = 1, this.transmissionResolutionScale = 1; const P = this; let U = !1; this._outputColorSpace = SRGBColorSpace; let O = 0, N = 0, H = null, F = -1, k = null; const W = new Vector4, $ = new Vector4; let Z = null; const J = new Color(0); let se = 0, re = i.width, ce = i.height, ee = 1, Me = null, Ee = null; const Ue = new Vector4(0, 0, re, ce), nt = new Vector4(0, 0, re, ce); let mt = !1; const ve = new Frustum; let ne = !1, z = !1; const V = new Matrix4, _e = new Vector3, Le = new Vector4, fe = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 }; let Fe = !1; function st() { return H === null ? ee : 1 } let j = s; function Be(q, me) { return i.getContext(q, me) } try { const q = { alpha: !0, depth: a, stencil: o, antialias: c, premultipliedAlpha: h, preserveDrawingBuffer: d, powerPreference: p, failIfMajorPerformanceCaveat: f }; if ("setAttribute" in i && i.setAttribute("data-engine", `three.js r${REVISION}`), i.addEventListener("webglcontextlost", Ye, !1), i.addEventListener("webglcontextrestored", rt, !1), i.addEventListener("webglcontextcreationerror", je, !1), j === null) { const me = "webgl2"; if (j = Be(me, q), j === null) throw Be(me) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.") } } catch (q) { throw console.error("THREE.WebGLRenderer: " + q.message), q } let Re, Oe, Ie, oe, Y, $e, vt, St, K, G, he, De, Ge, Te, ot, tt, ut, ft, ze, le, xe, be, Ce, Ve; function ie() { Re = new WebGLExtensions(j), Re.init(), be = new WebGLUtils(j, Re), Oe = new WebGLCapabilities(j, Re, e, be), Ie = new WebGLState(j, Re), Oe.reversedDepthBuffer && _ && Ie.buffers.depth.setReversed(!0), oe = new WebGLInfo(j), Y = new WebGLProperties, $e = new WebGLTextures(j, Re, Ie, Y, Oe, be, oe), vt = new WebGLCubeMaps(P), St = new WebGLCubeUVMaps(P), K = new WebGLAttributes(j), Ce = new WebGLBindingStates(j, K), G = new WebGLGeometries(j, K, oe, Ce), he = new WebGLObjects(j, G, K, oe), ze = new WebGLMorphtargets(j, Oe, $e), tt = new WebGLClipping(Y), De = new WebGLPrograms(P, vt, St, Re, Oe, Ce, tt), Ge = new WebGLMaterials(P, Y), Te = new WebGLRenderLists, ot = new WebGLRenderStates(Re), ft = new WebGLBackground(P, vt, St, Ie, he, x, h), ut = new WebGLShadowMap(P, he, Oe), Ve = new WebGLUniformsGroups(j, oe, Oe, Ie), le = new WebGLBufferRenderer(j, Re, oe), xe = new WebGLIndexedBufferRenderer(j, Re, oe), oe.programs = De.programs, P.capabilities = Oe, P.extensions = Re, P.properties = Y, P.renderLists = Te, P.shadowMap = ut, P.state = Ie, P.info = oe } ie(); const Ne = new WebXRManager(P, j); this.xr = Ne, this.getContext = function () { return j }, this.getContextAttributes = function () { return j.getContextAttributes() }, this.forceContextLoss = function () { const q = Re.get("WEBGL_lose_context"); q && q.loseContext() }, this.forceContextRestore = function () { const q = Re.get("WEBGL_lose_context"); q && q.restoreContext() }, this.getPixelRatio = function () { return ee }, this.setPixelRatio = function (q) { q !== void 0 && (ee = q, this.setSize(re, ce, !1)) }, this.getSize = function (q) { return q.set(re, ce) }, this.setSize = function (q, me, we = !0) { if (Ne.isPresenting) { console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."); return } re = q, ce = me, i.width = Math.floor(q * ee), i.height = Math.floor(me * ee), we === !0 && (i.style.width = q + "px", i.style.height = me + "px"), this.setViewport(0, 0, q, me) }, this.getDrawingBufferSize = function (q) { return q.set(re * ee, ce * ee).floor() }, this.setDrawingBufferSize = function (q, me, we) { re = q, ce = me, ee = we, i.width = Math.floor(q * we), i.height = Math.floor(me * we), this.setViewport(0, 0, q, me) }, this.getCurrentViewport = function (q) { return q.copy(W) }, this.getViewport = function (q) { return q.copy(Ue) }, this.setViewport = function (q, me, we, Se) { q.isVector4 ? Ue.set(q.x, q.y, q.z, q.w) : Ue.set(q, me, we, Se), Ie.viewport(W.copy(Ue).multiplyScalar(ee).round()) }, this.getScissor = function (q) { return q.copy(nt) }, this.setScissor = function (q, me, we, Se) { q.isVector4 ? nt.set(q.x, q.y, q.z, q.w) : nt.set(q, me, we, Se), Ie.scissor($.copy(nt).multiplyScalar(ee).round()) }, this.getScissorTest = function () { return mt }, this.setScissorTest = function (q) { Ie.setScissorTest(mt = q) }, this.setOpaqueSort = function (q) { Me = q }, this.setTransparentSort = function (q) { Ee = q }, this.getClearColor = function (q) { return q.copy(ft.getClearColor()) }, this.setClearColor = function () { ft.setClearColor(...arguments) }, this.getClearAlpha = function () { return ft.getClearAlpha() }, this.setClearAlpha = function () { ft.setClearAlpha(...arguments) }, this.clear = function (q = !0, me = !0, we = !0) { let Se = 0; if (q) { let ge = !1; if (H !== null) { const et = H.texture.format; ge = et === RGBAIntegerFormat || et === RGIntegerFormat || et === RedIntegerFormat } if (ge) { const et = H.texture.type, at = et === UnsignedByteType || et === UnsignedIntType || et === UnsignedShortType || et === UnsignedInt248Type || et === UnsignedShort4444Type || et === UnsignedShort5551Type, pt = ft.getClearColor(), lt = ft.getClearAlpha(), yt = pt.r, bt = pt.g, At = pt.b; at ? (b[0] = yt, b[1] = bt, b[2] = At, b[3] = lt, j.clearBufferuiv(j.COLOR, 0, b)) : (T[0] = yt, T[1] = bt, T[2] = At, T[3] = lt, j.clearBufferiv(j.COLOR, 0, T)) } else Se |= j.COLOR_BUFFER_BIT } me && (Se |= j.DEPTH_BUFFER_BIT), we && (Se |= j.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), j.clear(Se) }, this.clearColor = function () { this.clear(!0, !1, !1) }, this.clearDepth = function () { this.clear(!1, !0, !1) }, this.clearStencil = function () { this.clear(!1, !1, !0) }, this.dispose = function () { i.removeEventListener("webglcontextlost", Ye, !1), i.removeEventListener("webglcontextrestored", rt, !1), i.removeEventListener("webglcontextcreationerror", je, !1), ft.dispose(), Te.dispose(), ot.dispose(), Y.dispose(), vt.dispose(), St.dispose(), he.dispose(), Ce.dispose(), Ve.dispose(), De.dispose(), Ne.dispose(), Ne.removeEventListener("sessionstart", Ii), Ne.removeEventListener("sessionend", Da), vn.stop() }; function Ye(q) { q.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), U = !0 } function rt() { console.log("THREE.WebGLRenderer: Context Restored."), U = !1; const q = oe.autoReset, me = ut.enabled, we = ut.autoUpdate, Se = ut.needsUpdate, ge = ut.type; ie(), oe.autoReset = q, ut.enabled = me, ut.autoUpdate = we, ut.needsUpdate = Se, ut.type = ge } function je(q) { console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", q.statusMessage) } function ke(q) { const me = q.target; me.removeEventListener("dispose", ke), ct(me) } function ct(q) { wt(q), Y.remove(q) } function wt(q) { const me = Y.get(q).programs; me !== void 0 && (me.forEach(function (we) { De.releaseProgram(we) }), q.isShaderMaterial && De.releaseShaderCache(q)) } this.renderBufferDirect = function (q, me, we, Se, ge, et) { me === null && (me = fe); const at = ge.isMesh && ge.matrixWorld.determinant() < 0, pt = po(q, me, we, Se, ge); Ie.setMaterial(Se, at); let lt = we.index, yt = 1; if (Se.wireframe === !0) { if (lt = G.getWireframeAttribute(we), lt === void 0) return; yt = 2 } const bt = we.drawRange, At = we.attributes.position; let Ct = bt.start * yt, Bt = (bt.start + bt.count) * yt; et !== null && (Ct = Math.max(Ct, et.start * yt), Bt = Math.min(Bt, (et.start + et.count) * yt)), lt !== null ? (Ct = Math.max(Ct, 0), Bt = Math.min(Bt, lt.count)) : At != null && (Ct = Math.max(Ct, 0), Bt = Math.min(Bt, At.count)); const zt = Bt - Ct; if (zt < 0 || zt === 1 / 0) return; Ce.setup(ge, Se, pt, we, lt); let Ut, Dt = le; if (lt !== null && (Ut = K.get(lt), Dt = xe, Dt.setIndex(Ut)), ge.isMesh) Se.wireframe === !0 ? (Ie.setLineWidth(Se.wireframeLinewidth * st()), Dt.setMode(j.LINES)) : Dt.setMode(j.TRIANGLES); else if (ge.isLine) { let _t = Se.linewidth; _t === void 0 && (_t = 1), Ie.setLineWidth(_t * st()), ge.isLineSegments ? Dt.setMode(j.LINES) : ge.isLineLoop ? Dt.setMode(j.LINE_LOOP) : Dt.setMode(j.LINE_STRIP) } else ge.isPoints ? Dt.setMode(j.POINTS) : ge.isSprite && Dt.setMode(j.TRIANGLES); if (ge.isBatchedMesh) if (ge._multiDrawInstances !== null) warnOnce("THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."), Dt.renderMultiDrawInstances(ge._multiDrawStarts, ge._multiDrawCounts, ge._multiDrawCount, ge._multiDrawInstances); else if (Re.get("WEBGL_multi_draw")) Dt.renderMultiDraw(ge._multiDrawStarts, ge._multiDrawCounts, ge._multiDrawCount); else { const _t = ge._multiDrawStarts, Ot = ge._multiDrawCounts, Tt = ge._multiDrawCount, ni = lt ? K.get(lt).bytesPerElement : 1, Hn = Y.get(Se).currentProgram.getUniforms(); for (let si = 0; si < Tt; si++)Hn.setValue(j, "_gl_DrawID", si), Dt.render(_t[si] / ni, Ot[si]) } else if (ge.isInstancedMesh) Dt.renderInstances(Ct, zt, ge.count); else if (we.isInstancedBufferGeometry) { const _t = we._maxInstanceCount !== void 0 ? we._maxInstanceCount : 1 / 0, Ot = Math.min(we.instanceCount, _t); Dt.renderInstances(Ct, zt, Ot) } else Dt.render(Ct, zt) }; function Pt(q, me, we) { q.transparent === !0 && q.side === DoubleSide && q.forceSinglePass === !1 ? (q.side = BackSide, q.needsUpdate = !0, fr(q, me, we), q.side = FrontSide, q.needsUpdate = !0, fr(q, me, we), q.side = DoubleSide) : fr(q, me, we) } this.compile = function (q, me, we = null) { we === null && (we = q), w = ot.get(we), w.init(me), R.push(w), we.traverseVisible(function (ge) { ge.isLight && ge.layers.test(me.layers) && (w.pushLight(ge), ge.castShadow && w.pushShadow(ge)) }), q !== we && q.traverseVisible(function (ge) { ge.isLight && ge.layers.test(me.layers) && (w.pushLight(ge), ge.castShadow && w.pushShadow(ge)) }), w.setupLights(); const Se = new Set; return q.traverse(function (ge) { if (!(ge.isMesh || ge.isPoints || ge.isLine || ge.isSprite)) return; const et = ge.material; if (et) if (Array.isArray(et)) for (let at = 0; at < et.length; at++) { const pt = et[at]; Pt(pt, we, ge), Se.add(pt) } else Pt(et, we, ge), Se.add(et) }), w = R.pop(), Se }, this.compileAsync = function (q, me, we = null) { const Se = this.compile(q, me, we); return new Promise(ge => { function et() { if (Se.forEach(function (at) { Y.get(at).currentProgram.isReady() && Se.delete(at) }), Se.size === 0) { ge(q); return } setTimeout(et, 10) } Re.get("KHR_parallel_shader_compile") !== null ? et() : setTimeout(et, 10) }) }; let It = null; function zi(q) { It && It(q) } function Ii() { vn.stop() } function Da() { vn.start() } const vn = new WebGLAnimation; vn.setAnimationLoop(zi), typeof self < "u" && vn.setContext(self), this.setAnimationLoop = function (q) { It = q, Ne.setAnimationLoop(q), q === null ? vn.stop() : vn.start() }, Ne.addEventListener("sessionstart", Ii), Ne.addEventListener("sessionend", Da), this.render = function (q, me) { if (me !== void 0 && me.isCamera !== !0) { console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."); return } if (U === !0) return; if (q.matrixWorldAutoUpdate === !0 && q.updateMatrixWorld(), me.parent === null && me.matrixWorldAutoUpdate === !0 && me.updateMatrixWorld(), Ne.enabled === !0 && Ne.isPresenting === !0 && (Ne.cameraAutoUpdate === !0 && Ne.updateCamera(me), me = Ne.getCamera()), q.isScene === !0 && q.onBeforeRender(P, q, me, H), w = ot.get(q, R.length), w.init(me), R.push(w), V.multiplyMatrices(me.projectionMatrix, me.matrixWorldInverse), ve.setFromProjectionMatrix(V, WebGLCoordinateSystem, me.reversedDepth), z = this.localClippingEnabled, ne = tt.init(this.clippingPlanes, z), M = Te.get(q, D.length), M.init(), D.push(M), Ne.enabled === !0 && Ne.isPresenting === !0) { const et = P.xr.getDepthSensingMesh(); et !== null && Jr(et, me, -1 / 0, P.sortObjects) } Jr(q, me, 0, P.sortObjects), M.finish(), P.sortObjects === !0 && M.sort(Me, Ee), Fe = Ne.enabled === !1 || Ne.isPresenting === !1 || Ne.hasDepthSensing() === !1, Fe && ft.addToRenderList(M, q), this.info.render.frame++, ne === !0 && tt.beginShadows(); const we = w.state.shadowsArray; ut.render(we, q, me), ne === !0 && tt.endShadows(), this.info.autoReset === !0 && this.info.reset(); const Se = M.opaque, ge = M.transmissive; if (w.setupLights(), me.isArrayCamera) { const et = me.cameras; if (ge.length > 0) for (let at = 0, pt = et.length; at < pt; at++) { const lt = et[at]; Pa(Se, ge, q, lt) } Fe && ft.render(q); for (let at = 0, pt = et.length; at < pt; at++) { const lt = et[at]; Ra(M, q, lt, lt.viewport) } } else ge.length > 0 && Pa(Se, ge, q, me), Fe && ft.render(q), Ra(M, q, me); H !== null && N === 0 && ($e.updateMultisampleRenderTarget(H), $e.updateRenderTargetMipmap(H)), q.isScene === !0 && q.onAfterRender(P, q, me), Ce.resetDefaultState(), F = -1, k = null, R.pop(), R.length > 0 ? (w = R[R.length - 1], ne === !0 && tt.setGlobalState(P.clippingPlanes, w.state.camera)) : w = null, D.pop(), D.length > 0 ? M = D[D.length - 1] : M = null }; function Jr(q, me, we, Se) { if (q.visible === !1) return; if (q.layers.test(me.layers)) { if (q.isGroup) we = q.renderOrder; else if (q.isLOD) q.autoUpdate === !0 && q.update(me); else if (q.isLight) w.pushLight(q), q.castShadow && w.pushShadow(q); else if (q.isSprite) { if (!q.frustumCulled || ve.intersectsSprite(q)) { Se && Le.setFromMatrixPosition(q.matrixWorld).applyMatrix4(V); const at = he.update(q), pt = q.material; pt.visible && M.push(q, at, pt, we, Le.z, null) } } else if ((q.isMesh || q.isLine || q.isPoints) && (!q.frustumCulled || ve.intersectsObject(q))) { const at = he.update(q), pt = q.material; if (Se && (q.boundingSphere !== void 0 ? (q.boundingSphere === null && q.computeBoundingSphere(), Le.copy(q.boundingSphere.center)) : (at.boundingSphere === null && at.computeBoundingSphere(), Le.copy(at.boundingSphere.center)), Le.applyMatrix4(q.matrixWorld).applyMatrix4(V)), Array.isArray(pt)) { const lt = at.groups; for (let yt = 0, bt = lt.length; yt < bt; yt++) { const At = lt[yt], Ct = pt[At.materialIndex]; Ct && Ct.visible && M.push(q, at, Ct, we, Le.z, At) } } else pt.visible && M.push(q, at, pt, we, Le.z, null) } } const et = q.children; for (let at = 0, pt = et.length; at < pt; at++)Jr(et[at], me, we, Se) } function Ra(q, me, we, Se) { const ge = q.opaque, et = q.transmissive, at = q.transparent; w.setupLightsView(we), ne === !0 && tt.setGlobalState(P.clippingPlanes, we), Se && Ie.viewport(W.copy(Se)), ge.length > 0 && dr(ge, me, we), et.length > 0 && dr(et, me, we), at.length > 0 && dr(at, me, we), Ie.buffers.depth.setTest(!0), Ie.buffers.depth.setMask(!0), Ie.buffers.color.setMask(!0), Ie.setPolygonOffset(!1) } function Pa(q, me, we, Se) { if ((we.isScene === !0 ? we.overrideMaterial : null) !== null) return; w.state.transmissionRenderTarget[Se.id] === void 0 && (w.state.transmissionRenderTarget[Se.id] = new WebGLRenderTarget(1, 1, { generateMipmaps: !0, type: Re.has("EXT_color_buffer_half_float") || Re.has("EXT_color_buffer_float") ? HalfFloatType : UnsignedByteType, minFilter: LinearMipmapLinearFilter, samples: 4, stencilBuffer: o, resolveDepthBuffer: !1, resolveStencilBuffer: !1, colorSpace: ColorManagement.workingColorSpace })); const et = w.state.transmissionRenderTarget[Se.id], at = Se.viewport || W; et.setSize(at.z * P.transmissionResolutionScale, at.w * P.transmissionResolutionScale); const pt = P.getRenderTarget(), lt = P.getActiveCubeFace(), yt = P.getActiveMipmapLevel(); P.setRenderTarget(et), P.getClearColor(J), se = P.getClearAlpha(), se < 1 && P.setClearColor(16777215, .5), P.clear(), Fe && ft.render(we); const bt = P.toneMapping; P.toneMapping = NoToneMapping; const At = Se.viewport; if (Se.viewport !== void 0 && (Se.viewport = void 0), w.setupLightsView(Se), ne === !0 && tt.setGlobalState(P.clippingPlanes, Se), dr(q, we, Se), $e.updateMultisampleRenderTarget(et), $e.updateRenderTargetMipmap(et), Re.has("WEBGL_multisampled_render_to_texture") === !1) { let Ct = !1; for (let Bt = 0, zt = me.length; Bt < zt; Bt++) { const Ut = me[Bt], Dt = Ut.object, _t = Ut.geometry, Ot = Ut.material, Tt = Ut.group; if (Ot.side === DoubleSide && Dt.layers.test(Se.layers)) { const ni = Ot.side; Ot.side = BackSide, Ot.needsUpdate = !0, La(Dt, we, Se, _t, Ot, Tt), Ot.side = ni, Ot.needsUpdate = !0, Ct = !0 } } Ct === !0 && ($e.updateMultisampleRenderTarget(et), $e.updateRenderTargetMipmap(et)) } P.setRenderTarget(pt, lt, yt), P.setClearColor(J, se), At !== void 0 && (Se.viewport = At), P.toneMapping = bt } function dr(q, me, we) { const Se = me.isScene === !0 ? me.overrideMaterial : null; for (let ge = 0, et = q.length; ge < et; ge++) { const at = q[ge], pt = at.object, lt = at.geometry, yt = at.group; let bt = at.material; bt.allowOverride === !0 && Se !== null && (bt = Se), pt.layers.test(we.layers) && La(pt, me, we, lt, bt, yt) } } function La(q, me, we, Se, ge, et) { q.onBeforeRender(P, me, we, Se, ge, et), q.modelViewMatrix.multiplyMatrices(we.matrixWorldInverse, q.matrixWorld), q.normalMatrix.getNormalMatrix(q.modelViewMatrix), ge.onBeforeRender(P, me, we, Se, q, et), ge.transparent === !0 && ge.side === DoubleSide && ge.forceSinglePass === !1 ? (ge.side = BackSide, ge.needsUpdate = !0, P.renderBufferDirect(we, me, Se, ge, q, et), ge.side = FrontSide, ge.needsUpdate = !0, P.renderBufferDirect(we, me, Se, ge, q, et), ge.side = DoubleSide) : P.renderBufferDirect(we, me, Se, ge, q, et), q.onAfterRender(P, me, we, Se, ge, et) } function fr(q, me, we) { me.isScene !== !0 && (me = fe); const Se = Y.get(q), ge = w.state.lights, et = w.state.shadowsArray, at = ge.state.version, pt = De.getParameters(q, ge.state, et, me, we), lt = De.getProgramCacheKey(pt); let yt = Se.programs; Se.environment = q.isMeshStandardMaterial ? me.environment : null, Se.fog = me.fog, Se.envMap = (q.isMeshStandardMaterial ? St : vt).get(q.envMap || Se.environment), Se.envMapRotation = Se.environment !== null && q.envMap === null ? me.environmentRotation : q.envMapRotation, yt === void 0 && (q.addEventListener("dispose", ke), yt = new Map, Se.programs = yt); let bt = yt.get(lt); if (bt !== void 0) { if (Se.currentProgram === bt && Se.lightsStateVersion === at) return Fa(q, pt), bt } else pt.uniforms = De.getUniforms(q), q.onBeforeCompile(pt, P), bt = De.acquireProgram(pt, lt), yt.set(lt, bt), Se.uniforms = pt.uniforms; const At = Se.uniforms; return (!q.isShaderMaterial && !q.isRawShaderMaterial || q.clipping === !0) && (At.clippingPlanes = tt.uniform), Fa(q, pt), Se.needsLights = go(q), Se.lightsStateVersion = at, Se.needsLights && (At.ambientLightColor.value = ge.state.ambient, At.lightProbe.value = ge.state.probe, At.directionalLights.value = ge.state.directional, At.directionalLightShadows.value = ge.state.directionalShadow, At.spotLights.value = ge.state.spot, At.spotLightShadows.value = ge.state.spotShadow, At.rectAreaLights.value = ge.state.rectArea, At.ltc_1.value = ge.state.rectAreaLTC1, At.ltc_2.value = ge.state.rectAreaLTC2, At.pointLights.value = ge.state.point, At.pointLightShadows.value = ge.state.pointShadow, At.hemisphereLights.value = ge.state.hemi, At.directionalShadowMap.value = ge.state.directionalShadowMap, At.directionalShadowMatrix.value = ge.state.directionalShadowMatrix, At.spotShadowMap.value = ge.state.spotShadowMap, At.spotLightMatrix.value = ge.state.spotLightMatrix, At.spotLightMap.value = ge.state.spotLightMap, At.pointShadowMap.value = ge.state.pointShadowMap, At.pointShadowMatrix.value = ge.state.pointShadowMatrix), Se.currentProgram = bt, Se.uniformsList = null, bt } function Ua(q) { if (q.uniformsList === null) { const me = q.currentProgram.getUniforms(); q.uniformsList = WebGLUniforms.seqWithValue(me.seq, q.uniforms) } return q.uniformsList } function Fa(q, me) { const we = Y.get(q); we.outputColorSpace = me.outputColorSpace, we.batching = me.batching, we.batchingColor = me.batchingColor, we.instancing = me.instancing, we.instancingColor = me.instancingColor, we.instancingMorph = me.instancingMorph, we.skinning = me.skinning, we.morphTargets = me.morphTargets, we.morphNormals = me.morphNormals, we.morphColors = me.morphColors, we.morphTargetsCount = me.morphTargetsCount, we.numClippingPlanes = me.numClippingPlanes, we.numIntersection = me.numClipIntersection, we.vertexAlphas = me.vertexAlphas, we.vertexTangents = me.vertexTangents, we.toneMapping = me.toneMapping } function po(q, me, we, Se, ge) { me.isScene !== !0 && (me = fe), $e.resetTextureUnits(); const et = me.fog, at = Se.isMeshStandardMaterial ? me.environment : null, pt = H === null ? P.outputColorSpace : H.isXRRenderTarget === !0 ? H.texture.colorSpace : LinearSRGBColorSpace, lt = (Se.isMeshStandardMaterial ? St : vt).get(Se.envMap || at), yt = Se.vertexColors === !0 && !!we.attributes.color && we.attributes.color.itemSize === 4, bt = !!we.attributes.tangent && (!!Se.normalMap || Se.anisotropy > 0), At = !!we.morphAttributes.position, Ct = !!we.morphAttributes.normal, Bt = !!we.morphAttributes.color; let zt = NoToneMapping; Se.toneMapped && (H === null || H.isXRRenderTarget === !0) && (zt = P.toneMapping); const Ut = we.morphAttributes.position || we.morphAttributes.normal || we.morphAttributes.color, Dt = Ut !== void 0 ? Ut.length : 0, _t = Y.get(Se), Ot = w.state.lights; if (ne === !0 && (z === !0 || q !== k)) { const Jt = q === k && Se.id === F; tt.setState(Se, q, Jt) } let Tt = !1; Se.version === _t.__version ? (_t.needsLights && _t.lightsStateVersion !== Ot.state.version || _t.outputColorSpace !== pt || ge.isBatchedMesh && _t.batching === !1 || !ge.isBatchedMesh && _t.batching === !0 || ge.isBatchedMesh && _t.batchingColor === !0 && ge.colorTexture === null || ge.isBatchedMesh && _t.batchingColor === !1 && ge.colorTexture !== null || ge.isInstancedMesh && _t.instancing === !1 || !ge.isInstancedMesh && _t.instancing === !0 || ge.isSkinnedMesh && _t.skinning === !1 || !ge.isSkinnedMesh && _t.skinning === !0 || ge.isInstancedMesh && _t.instancingColor === !0 && ge.instanceColor === null || ge.isInstancedMesh && _t.instancingColor === !1 && ge.instanceColor !== null || ge.isInstancedMesh && _t.instancingMorph === !0 && ge.morphTexture === null || ge.isInstancedMesh && _t.instancingMorph === !1 && ge.morphTexture !== null || _t.envMap !== lt || Se.fog === !0 && _t.fog !== et || _t.numClippingPlanes !== void 0 && (_t.numClippingPlanes !== tt.numPlanes || _t.numIntersection !== tt.numIntersection) || _t.vertexAlphas !== yt || _t.vertexTangents !== bt || _t.morphTargets !== At || _t.morphNormals !== Ct || _t.morphColors !== Bt || _t.toneMapping !== zt || _t.morphTargetsCount !== Dt) && (Tt = !0) : (Tt = !0, _t.__version = Se.version); let ni = _t.currentProgram; Tt === !0 && (ni = fr(Se, me, ge)); let Hn = !1, si = !1, us = !1; const kt = ni.getUniforms(), pi = _t.uniforms; if (Ie.useProgram(ni.program) && (Hn = !0, si = !0, us = !0), Se.id !== F && (F = Se.id, si = !0), Hn || k !== q) { Ie.buffers.depth.getReversed() && q.reversedDepth !== !0 && (q._reversedDepth = !0, q.updateProjectionMatrix()), kt.setValue(j, "projectionMatrix", q.projectionMatrix), kt.setValue(j, "viewMatrix", q.matrixWorldInverse); const ti = kt.map.cameraPosition; ti !== void 0 && ti.setValue(j, _e.setFromMatrixPosition(q.matrixWorld)), Oe.logarithmicDepthBuffer && kt.setValue(j, "logDepthBufFC", 2 / (Math.log(q.far + 1) / Math.LN2)), (Se.isMeshPhongMaterial || Se.isMeshToonMaterial || Se.isMeshLambertMaterial || Se.isMeshBasicMaterial || Se.isMeshStandardMaterial || Se.isShaderMaterial) && kt.setValue(j, "isOrthographic", q.isOrthographicCamera === !0), k !== q && (k = q, si = !0, us = !0) } if (ge.isSkinnedMesh) { kt.setOptional(j, ge, "bindMatrix"), kt.setOptional(j, ge, "bindMatrixInverse"); const Jt = ge.skeleton; Jt && (Jt.boneTexture === null && Jt.computeBoneTexture(), kt.setValue(j, "boneTexture", Jt.boneTexture, $e)) } ge.isBatchedMesh && (kt.setOptional(j, ge, "batchingTexture"), kt.setValue(j, "batchingTexture", ge._matricesTexture, $e), kt.setOptional(j, ge, "batchingIdTexture"), kt.setValue(j, "batchingIdTexture", ge._indirectTexture, $e), kt.setOptional(j, ge, "batchingColorTexture"), ge._colorsTexture !== null && kt.setValue(j, "batchingColorTexture", ge._colorsTexture, $e)); const mi = we.morphAttributes; if ((mi.position !== void 0 || mi.normal !== void 0 || mi.color !== void 0) && ze.update(ge, we, ni), (si || _t.receiveShadow !== ge.receiveShadow) && (_t.receiveShadow = ge.receiveShadow, kt.setValue(j, "receiveShadow", ge.receiveShadow)), Se.isMeshGouraudMaterial && Se.envMap !== null && (pi.envMap.value = lt, pi.flipEnvMap.value = lt.isCubeTexture && lt.isRenderTargetTexture === !1 ? -1 : 1), Se.isMeshStandardMaterial && Se.envMap === null && me.environment !== null && (pi.envMapIntensity.value = me.environmentIntensity), si && (kt.setValue(j, "toneMappingExposure", P.toneMappingExposure), _t.needsLights && mo(pi, us), et && Se.fog === !0 && Ge.refreshFogUniforms(pi, et), Ge.refreshMaterialUniforms(pi, Se, ee, ce, w.state.transmissionRenderTarget[q.id]), WebGLUniforms.upload(j, Ua(_t), pi, $e)), Se.isShaderMaterial && Se.uniformsNeedUpdate === !0 && (WebGLUniforms.upload(j, Ua(_t), pi, $e), Se.uniformsNeedUpdate = !1), Se.isSpriteMaterial && kt.setValue(j, "center", ge.center), kt.setValue(j, "modelViewMatrix", ge.modelViewMatrix), kt.setValue(j, "normalMatrix", ge.normalMatrix), kt.setValue(j, "modelMatrix", ge.matrixWorld), Se.isShaderMaterial || Se.isRawShaderMaterial) { const Jt = Se.uniformsGroups; for (let ti = 0, Zr = Jt.length; ti < Zr; ti++) { const An = Jt[ti]; Ve.update(An, ni), Ve.bind(An, ni) } } return ni } function mo(q, me) { q.ambientLightColor.needsUpdate = me, q.lightProbe.needsUpdate = me, q.directionalLights.needsUpdate = me, q.directionalLightShadows.needsUpdate = me, q.pointLights.needsUpdate = me, q.pointLightShadows.needsUpdate = me, q.spotLights.needsUpdate = me, q.spotLightShadows.needsUpdate = me, q.rectAreaLights.needsUpdate = me, q.hemisphereLights.needsUpdate = me } function go(q) { return q.isMeshLambertMaterial || q.isMeshToonMaterial || q.isMeshPhongMaterial || q.isMeshStandardMaterial || q.isShadowMaterial || q.isShaderMaterial && q.lights === !0 } this.getActiveCubeFace = function () { return O }, this.getActiveMipmapLevel = function () { return N }, this.getRenderTarget = function () { return H }, this.setRenderTargetTextures = function (q, me, we) { const Se = Y.get(q); Se.__autoAllocateDepthBuffer = q.resolveDepthBuffer === !1, Se.__autoAllocateDepthBuffer === !1 && (Se.__useRenderToTexture = !1), Y.get(q.texture).__webglTexture = me, Y.get(q.depthTexture).__webglTexture = Se.__autoAllocateDepthBuffer ? void 0 : we, Se.__hasExternalTextures = !0 }, this.setRenderTargetFramebuffer = function (q, me) { const we = Y.get(q); we.__webglFramebuffer = me, we.__useDefaultFramebuffer = me === void 0 }; const vo = j.createFramebuffer(); this.setRenderTarget = function (q, me = 0, we = 0) { H = q, O = me, N = we; let Se = !0, ge = null, et = !1, at = !1; if (q) { const lt = Y.get(q); if (lt.__useDefaultFramebuffer !== void 0) Ie.bindFramebuffer(j.FRAMEBUFFER, null), Se = !1; else if (lt.__webglFramebuffer === void 0) $e.setupRenderTarget(q); else if (lt.__hasExternalTextures) $e.rebindTextures(q, Y.get(q.texture).__webglTexture, Y.get(q.depthTexture).__webglTexture); else if (q.depthBuffer) { const At = q.depthTexture; if (lt.__boundDepthTexture !== At) { if (At !== null && Y.has(At) && (q.width !== At.image.width || q.height !== At.image.height)) throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size."); $e.setupDepthRenderbuffer(q) } } const yt = q.texture; (yt.isData3DTexture || yt.isDataArrayTexture || yt.isCompressedArrayTexture) && (at = !0); const bt = Y.get(q).__webglFramebuffer; q.isWebGLCubeRenderTarget ? (Array.isArray(bt[me]) ? ge = bt[me][we] : ge = bt[me], et = !0) : q.samples > 0 && $e.useMultisampledRTT(q) === !1 ? ge = Y.get(q).__webglMultisampledFramebuffer : Array.isArray(bt) ? ge = bt[we] : ge = bt, W.copy(q.viewport), $.copy(q.scissor), Z = q.scissorTest } else W.copy(Ue).multiplyScalar(ee).floor(), $.copy(nt).multiplyScalar(ee).floor(), Z = mt; if (we !== 0 && (ge = vo), Ie.bindFramebuffer(j.FRAMEBUFFER, ge) && Se && Ie.drawBuffers(q, ge), Ie.viewport(W), Ie.scissor($), Ie.setScissorTest(Z), et) { const lt = Y.get(q.texture); j.framebufferTexture2D(j.FRAMEBUFFER, j.COLOR_ATTACHMENT0, j.TEXTURE_CUBE_MAP_POSITIVE_X + me, lt.__webglTexture, we) } else if (at) { const lt = me; for (let yt = 0; yt < q.textures.length; yt++) { const bt = Y.get(q.textures[yt]); j.framebufferTextureLayer(j.FRAMEBUFFER, j.COLOR_ATTACHMENT0 + yt, bt.__webglTexture, we, lt) } } else if (q !== null && we !== 0) { const lt = Y.get(q.texture); j.framebufferTexture2D(j.FRAMEBUFFER, j.COLOR_ATTACHMENT0, j.TEXTURE_2D, lt.__webglTexture, we) } F = -1 }, this.readRenderTargetPixels = function (q, me, we, Se, ge, et, at, pt = 0) { if (!(q && q.isWebGLRenderTarget)) { console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."); return } let lt = Y.get(q).__webglFramebuffer; if (q.isWebGLCubeRenderTarget && at !== void 0 && (lt = lt[at]), lt) { Ie.bindFramebuffer(j.FRAMEBUFFER, lt); try { const yt = q.textures[pt], bt = yt.format, At = yt.type; if (!Oe.textureFormatReadable(bt)) { console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."); return } if (!Oe.textureTypeReadable(At)) { console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."); return } me >= 0 && me <= q.width - Se && we >= 0 && we <= q.height - ge && (q.textures.length > 1 && j.readBuffer(j.COLOR_ATTACHMENT0 + pt), j.readPixels(me, we, Se, ge, be.convert(bt), be.convert(At), et)) } finally { const yt = H !== null ? Y.get(H).__webglFramebuffer : null; Ie.bindFramebuffer(j.FRAMEBUFFER, yt) } } }, this.readRenderTargetPixelsAsync = async function (q, me, we, Se, ge, et, at, pt = 0) { if (!(q && q.isWebGLRenderTarget)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."); let lt = Y.get(q).__webglFramebuffer; if (q.isWebGLCubeRenderTarget && at !== void 0 && (lt = lt[at]), lt) if (me >= 0 && me <= q.width - Se && we >= 0 && we <= q.height - ge) { Ie.bindFramebuffer(j.FRAMEBUFFER, lt); const yt = q.textures[pt], bt = yt.format, At = yt.type; if (!Oe.textureFormatReadable(bt)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format."); if (!Oe.textureTypeReadable(At)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type."); const Ct = j.createBuffer(); j.bindBuffer(j.PIXEL_PACK_BUFFER, Ct), j.bufferData(j.PIXEL_PACK_BUFFER, et.byteLength, j.STREAM_READ), q.textures.length > 1 && j.readBuffer(j.COLOR_ATTACHMENT0 + pt), j.readPixels(me, we, Se, ge, be.convert(bt), be.convert(At), 0); const Bt = H !== null ? Y.get(H).__webglFramebuffer : null; Ie.bindFramebuffer(j.FRAMEBUFFER, Bt); const zt = j.fenceSync(j.SYNC_GPU_COMMANDS_COMPLETE, 0); return j.flush(), await probeAsync(j, zt, 4), j.bindBuffer(j.PIXEL_PACK_BUFFER, Ct), j.getBufferSubData(j.PIXEL_PACK_BUFFER, 0, et), j.deleteBuffer(Ct), j.deleteSync(zt), et } else throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.") }, this.copyFramebufferToTexture = function (q, me = null, we = 0) { const Se = Math.pow(2, -we), ge = Math.floor(q.image.width * Se), et = Math.floor(q.image.height * Se), at = me !== null ? me.x : 0, pt = me !== null ? me.y : 0; $e.setTexture2D(q, 0), j.copyTexSubImage2D(j.TEXTURE_2D, we, 0, 0, at, pt, ge, et), Ie.unbindTexture() }; const Ao = j.createFramebuffer(), _o = j.createFramebuffer(); this.copyTextureToTexture = function (q, me, we = null, Se = null, ge = 0, et = null) { et === null && (ge !== 0 ? (warnOnce("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."), et = ge, ge = 0) : et = 0); let at, pt, lt, yt, bt, At, Ct, Bt, zt; const Ut = q.isCompressedTexture ? q.mipmaps[et] : q.image; if (we !== null) at = we.max.x - we.min.x, pt = we.max.y - we.min.y, lt = we.isBox3 ? we.max.z - we.min.z : 1, yt = we.min.x, bt = we.min.y, At = we.isBox3 ? we.min.z : 0; else { const mi = Math.pow(2, -ge); at = Math.floor(Ut.width * mi), pt = Math.floor(Ut.height * mi), q.isDataArrayTexture ? lt = Ut.depth : q.isData3DTexture ? lt = Math.floor(Ut.depth * mi) : lt = 1, yt = 0, bt = 0, At = 0 } Se !== null ? (Ct = Se.x, Bt = Se.y, zt = Se.z) : (Ct = 0, Bt = 0, zt = 0); const Dt = be.convert(me.format), _t = be.convert(me.type); let Ot; me.isData3DTexture ? ($e.setTexture3D(me, 0), Ot = j.TEXTURE_3D) : me.isDataArrayTexture || me.isCompressedArrayTexture ? ($e.setTexture2DArray(me, 0), Ot = j.TEXTURE_2D_ARRAY) : ($e.setTexture2D(me, 0), Ot = j.TEXTURE_2D), j.pixelStorei(j.UNPACK_FLIP_Y_WEBGL, me.flipY), j.pixelStorei(j.UNPACK_PREMULTIPLY_ALPHA_WEBGL, me.premultiplyAlpha), j.pixelStorei(j.UNPACK_ALIGNMENT, me.unpackAlignment); const Tt = j.getParameter(j.UNPACK_ROW_LENGTH), ni = j.getParameter(j.UNPACK_IMAGE_HEIGHT), Hn = j.getParameter(j.UNPACK_SKIP_PIXELS), si = j.getParameter(j.UNPACK_SKIP_ROWS), us = j.getParameter(j.UNPACK_SKIP_IMAGES); j.pixelStorei(j.UNPACK_ROW_LENGTH, Ut.width), j.pixelStorei(j.UNPACK_IMAGE_HEIGHT, Ut.height), j.pixelStorei(j.UNPACK_SKIP_PIXELS, yt), j.pixelStorei(j.UNPACK_SKIP_ROWS, bt), j.pixelStorei(j.UNPACK_SKIP_IMAGES, At); const kt = q.isDataArrayTexture || q.isData3DTexture, pi = me.isDataArrayTexture || me.isData3DTexture; if (q.isDepthTexture) { const mi = Y.get(q), Jt = Y.get(me), ti = Y.get(mi.__renderTarget), Zr = Y.get(Jt.__renderTarget); Ie.bindFramebuffer(j.READ_FRAMEBUFFER, ti.__webglFramebuffer), Ie.bindFramebuffer(j.DRAW_FRAMEBUFFER, Zr.__webglFramebuffer); for (let An = 0; An < lt; An++)kt && (j.framebufferTextureLayer(j.READ_FRAMEBUFFER, j.COLOR_ATTACHMENT0, Y.get(q).__webglTexture, ge, At + An), j.framebufferTextureLayer(j.DRAW_FRAMEBUFFER, j.COLOR_ATTACHMENT0, Y.get(me).__webglTexture, et, zt + An)), j.blitFramebuffer(yt, bt, at, pt, Ct, Bt, at, pt, j.DEPTH_BUFFER_BIT, j.NEAREST); Ie.bindFramebuffer(j.READ_FRAMEBUFFER, null), Ie.bindFramebuffer(j.DRAW_FRAMEBUFFER, null) } else if (ge !== 0 || q.isRenderTargetTexture || Y.has(q)) { const mi = Y.get(q), Jt = Y.get(me); Ie.bindFramebuffer(j.READ_FRAMEBUFFER, Ao), Ie.bindFramebuffer(j.DRAW_FRAMEBUFFER, _o); for (let ti = 0; ti < lt; ti++)kt ? j.framebufferTextureLayer(j.READ_FRAMEBUFFER, j.COLOR_ATTACHMENT0, mi.__webglTexture, ge, At + ti) : j.framebufferTexture2D(j.READ_FRAMEBUFFER, j.COLOR_ATTACHMENT0, j.TEXTURE_2D, mi.__webglTexture, ge), pi ? j.framebufferTextureLayer(j.DRAW_FRAMEBUFFER, j.COLOR_ATTACHMENT0, Jt.__webglTexture, et, zt + ti) : j.framebufferTexture2D(j.DRAW_FRAMEBUFFER, j.COLOR_ATTACHMENT0, j.TEXTURE_2D, Jt.__webglTexture, et), ge !== 0 ? j.blitFramebuffer(yt, bt, at, pt, Ct, Bt, at, pt, j.COLOR_BUFFER_BIT, j.NEAREST) : pi ? j.copyTexSubImage3D(Ot, et, Ct, Bt, zt + ti, yt, bt, at, pt) : j.copyTexSubImage2D(Ot, et, Ct, Bt, yt, bt, at, pt); Ie.bindFramebuffer(j.READ_FRAMEBUFFER, null), Ie.bindFramebuffer(j.DRAW_FRAMEBUFFER, null) } else pi ? q.isDataTexture || q.isData3DTexture ? j.texSubImage3D(Ot, et, Ct, Bt, zt, at, pt, lt, Dt, _t, Ut.data) : me.isCompressedArrayTexture ? j.compressedTexSubImage3D(Ot, et, Ct, Bt, zt, at, pt, lt, Dt, Ut.data) : j.texSubImage3D(Ot, et, Ct, Bt, zt, at, pt, lt, Dt, _t, Ut) : q.isDataTexture ? j.texSubImage2D(j.TEXTURE_2D, et, Ct, Bt, at, pt, Dt, _t, Ut.data) : q.isCompressedTexture ? j.compressedTexSubImage2D(j.TEXTURE_2D, et, Ct, Bt, Ut.width, Ut.height, Dt, Ut.data) : j.texSubImage2D(j.TEXTURE_2D, et, Ct, Bt, at, pt, Dt, _t, Ut); j.pixelStorei(j.UNPACK_ROW_LENGTH, Tt), j.pixelStorei(j.UNPACK_IMAGE_HEIGHT, ni), j.pixelStorei(j.UNPACK_SKIP_PIXELS, Hn), j.pixelStorei(j.UNPACK_SKIP_ROWS, si), j.pixelStorei(j.UNPACK_SKIP_IMAGES, us), et === 0 && me.generateMipmaps && j.generateMipmap(Ot), Ie.unbindTexture() }, this.initRenderTarget = function (q) { Y.get(q).__webglFramebuffer === void 0 && $e.setupRenderTarget(q) }, this.initTexture = function (q) { q.isCubeTexture ? $e.setTextureCube(q, 0) : q.isData3DTexture ? $e.setTexture3D(q, 0) : q.isDataArrayTexture || q.isCompressedArrayTexture ? $e.setTexture2DArray(q, 0) : $e.setTexture2D(q, 0), Ie.unbindTexture() }, this.resetState = function () { O = 0, N = 0, H = null, Ie.reset(), Ce.reset() }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } get coordinateSystem() { return WebGLCoordinateSystem } get outputColorSpace() { return this._outputColorSpace } set outputColorSpace(e) { this._outputColorSpace = e; const i = this.getContext(); i.drawingBufferColorSpace = ColorManagement._getDrawingBufferColorSpace(e), i.unpackColorSpace = ColorManagement._getUnpackColorSpace() } } var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}; function getDefaultExportFromCjs(r) { return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r } var eventemitter3 = { exports: {} }, hasRequiredEventemitter3; function requireEventemitter3() { return hasRequiredEventemitter3 || (hasRequiredEventemitter3 = 1, function (r) { var e = Object.prototype.hasOwnProperty, i = "~"; function s() { } Object.create && (s.prototype = Object.create(null), new s().__proto__ || (i = !1)); function a(h, d, p) { this.fn = h, this.context = d, this.once = p || !1 } function o(h, d, p, f, _) { if (typeof p != "function") throw new TypeError("The listener must be a function"); var x = new a(p, f || h, _), b = i ? i + d : d; return h._events[b] ? h._events[b].fn ? h._events[b] = [h._events[b], x] : h._events[b].push(x) : (h._events[b] = x, h._eventsCount++), h } function l(h, d) { --h._eventsCount === 0 ? h._events = new s : delete h._events[d] } function c() { this._events = new s, this._eventsCount = 0 } c.prototype.eventNames = function () { var d = [], p, f; if (this._eventsCount === 0) return d; for (f in p = this._events) e.call(p, f) && d.push(i ? f.slice(1) : f); return Object.getOwnPropertySymbols ? d.concat(Object.getOwnPropertySymbols(p)) : d }, c.prototype.listeners = function (d) { var p = i ? i + d : d, f = this._events[p]; if (!f) return []; if (f.fn) return [f.fn]; for (var _ = 0, x = f.length, b = new Array(x); _ < x; _++)b[_] = f[_].fn; return b }, c.prototype.listenerCount = function (d) { var p = i ? i + d : d, f = this._events[p]; return f ? f.fn ? 1 : f.length : 0 }, c.prototype.emit = function (d, p, f, _, x, b) { var T = i ? i + d : d; if (!this._events[T]) return !1; var M = this._events[T], w = arguments.length, D, R; if (M.fn) { switch (M.once && this.removeListener(d, M.fn, void 0, !0), w) { case 1: return M.fn.call(M.context), !0; case 2: return M.fn.call(M.context, p), !0; case 3: return M.fn.call(M.context, p, f), !0; case 4: return M.fn.call(M.context, p, f, _), !0; case 5: return M.fn.call(M.context, p, f, _, x), !0; case 6: return M.fn.call(M.context, p, f, _, x, b), !0 }for (R = 1, D = new Array(w - 1); R < w; R++)D[R - 1] = arguments[R]; M.fn.apply(M.context, D) } else { var P = M.length, U; for (R = 0; R < P; R++)switch (M[R].once && this.removeListener(d, M[R].fn, void 0, !0), w) { case 1: M[R].fn.call(M[R].context); break; case 2: M[R].fn.call(M[R].context, p); break; case 3: M[R].fn.call(M[R].context, p, f); break; case 4: M[R].fn.call(M[R].context, p, f, _); break; default: if (!D) for (U = 1, D = new Array(w - 1); U < w; U++)D[U - 1] = arguments[U]; M[R].fn.apply(M[R].context, D) } } return !0 }, c.prototype.on = function (d, p, f) { return o(this, d, p, f, !1) }, c.prototype.once = function (d, p, f) { return o(this, d, p, f, !0) }, c.prototype.removeListener = function (d, p, f, _) { var x = i ? i + d : d; if (!this._events[x]) return this; if (!p) return l(this, x), this; var b = this._events[x]; if (b.fn) b.fn === p && (!_ || b.once) && (!f || b.context === f) && l(this, x); else { for (var T = 0, M = [], w = b.length; T < w; T++)(b[T].fn !== p || _ && !b[T].once || f && b[T].context !== f) && M.push(b[T]); M.length ? this._events[x] = M.length === 1 ? M[0] : M : l(this, x) } return this }, c.prototype.removeAllListeners = function (d) { var p; return d ? (p = i ? i + d : d, this._events[p] && l(this, p)) : (this._events = new s, this._eventsCount = 0), this }, c.prototype.off = c.prototype.removeListener, c.prototype.addListener = c.prototype.on, c.prefixed = i, c.EventEmitter = c, r.exports = c }(eventemitter3)), eventemitter3.exports } var eventemitter3Exports = requireEventemitter3(); const EventEmitter = getDefaultExportFromCjs(eventemitter3Exports); let events = null; window.__webgl && window.__webgl.events ? events = window.__webgl.events : events = new EventEmitter; const math = { TWO_PI: Math.PI * 2, HALF_PI: Math.PI * .5, DEG2RAD: Math.PI / 180, RAD2DEG: 180 / Math.PI, degrees(r) { return r * this.RAD2DEG }, radians(r) { return r * this.DEG2RAD }, clamp(r, e = 0, i = 1) { return Math.max(e, Math.min(i, r)) }, lerp(r, e, i) { return (1 - i) * r + i * e }, mix(r, e, i) { return this.lerp(r, e, i) }, deltaRatio() { return renderInfo.ratio }, lerpCoefFPS(r) { return this.damp(r, renderInfo.ratio) }, lerpFPS(r, e, i) { return this.lerp(r, e, this.lerpCoefFPS(i)) }, lerpFPSLimited(r, e, i, s = 1 / 0) { const a = this.lerpFPS(r, e, i), o = s * renderInfo.ratio, l = this.clamp(a - r, -o, o); return r + l }, damp(r, e) { return 1 - Math.exp(Math.log(1 - r) * e) }, frictionFPS(r) { return this.friction(r, renderInfo.ratio) }, friction(r, e) { return Math.exp(Math.log(r) * e) }, efit(r, e, i, s, a) { return s + (r - e) * (a - s) / (i - e) }, fit(r, e, i, s, a) { return this.efit(this.clamp(r, Math.min(e, i), Math.max(e, i)), e, i, s, a) }, fit01(r, e, i) { return this.fit(r, 0, 1, e, i) }, fit10(r, e, i) { return this.fit(r, 1, 0, e, i) }, fit11(r, e, i) { return this.fit(r, -1, 1, e, i) }, step(r, e) { return e < r ? 0 : 1 }, linearstep(r, e, i) { return this.clamp((i - r) / (e - r), 0, 1) }, smoothstep(r, e, i) { const s = this.linearstep(r, e, i); return s * s * (3 - 2 * s) }, smootherstep(r, e, i) { const s = this.linearstep(r, e, i); return s * s * s * (s * (s * 6 - 15) + 10) }, parabola(r, e) { return Math.pow(4 * r * (1 - r), e) }, pcurve(r, e, i) { return Math.pow(e + i, e + i) / (Math.pow(e, e) * Math.pow(i, i)) * Math.pow(r, e) * Math.pow(1 - r, i) }, falloff(r, e, i, s, a) { const o = s * Math.sign(i - e), l = this.mix(e - o, i, a); return this.linearstep(l + o, l, r) }, falloffsmooth(r, e, i, s, a) { const o = s * Math.sign(i - e), l = this.mix(e - o, i, a); return this.smoothstep(l + o, l, r) }, round(r, e = 0) { const i = Math.pow(10, e); return Math.round(r * i) / i }, isPowerOfTwo(r) { return (r & r - 1) === 0 && r !== 0 }, ceilPowerOfTwo(r) { return Math.pow(2, Math.ceil(Math.log(r) / Math.LN2)) }, floorPowerOfTwo(r) { return Math.pow(2, Math.floor(Math.log(r) / Math.LN2)) }, makeAnglePositive(r) { const e = r % this.TWO_PI; return e < 0 ? this.TWO_PI + e : e }, getShortestRotationAngle(r, e) { const i = this.makeAnglePositive(r); let s = this.makeAnglePositive(e); return Math.abs(s - i) > Math.PI && (s > i ? s -= this.TWO_PI : s += this.TWO_PI), r + s - i }, latLonTo3D(r, e, i) { const s = this.HALF_PI - this.radians(r), a = this.radians(e); return { x: i * Math.sin(s) * Math.sin(a), y: i * Math.cos(s), z: i * Math.sin(s) * Math.cos(a) } }, getTextureSizeParticles(r = 4, e = 1) { return Math.max(Math.ceil(Math.sqrt(r * e) / e) * e, e) }, uidAlphabet: "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", uid(r = 21) { let e = "", i = r | 0; for (; i--;)e += this.uidAlphabet[Math.random() * 64 | 0]; return e } }; window.requestIdleCallback || (window.requestIdleCallback = function (r) { return setTimeout(() => { const e = performance.now(); r({ didTimeout: !1, timeRemaining: () => Math.max(0, 5 - (performance.now() - e)) }) }, 16) }, window.cancelIdleCallback = function (r) { clearTimeout(r) }); let _idle = null; const idleCbs = [], idleTick = r => { idleCbs.length > 0 ? _idle = requestIdleCallback(idleTick) : _idle = null; for (let e = idleCbs.length - 1; e > -1 && r.timeRemaining() > 0; e--)idleCbs[e](r) }; function addToIdle(r) { idleCbs.push(r), _idle === null && (_idle = requestIdleCallback(idleTick)) } function removeFromIdle(r) { const e = idleCbs.indexOf(r); e > -1 && idleCbs.splice(e, 1) } const miscutils = { debounce(r, e) { let i = null; return (...s) => { clearTimeout(i), i = setTimeout(() => r(...s), e) } }, deferred() { let r = null, e = null; const i = new Promise((s, a) => { r = s, e = a }); return i.resolve = r, i.reject = e, i }, wait(r, e = !1) { return new Promise(i => { const s = "prerender"; if (typeof r == "number") if (e === !0) { const a = renderInfo.frame, o = () => { renderInfo.frame - a >= r && (events.off(s, o), i()) }; events.on(s, o) } else createDelayedCall(r, i); else if (r && typeof e == "string") { const a = () => { r[e] !== void 0 && (events.off(s, a), i()) }; events.on(s, a) } else console.warn("invalid wait"), i() }) }, nextFrame(r) { return new Promise(e => { createDelayedCall(0, () => { e(r == null ? void 0 : r()) }) }) }, nextIdle(r) { return new Promise(e => { const i = () => { removeFromIdle(i), e(r == null ? void 0 : r()) }; addToIdle(i) }) }, taskIdle(r, e = 2, i = 10) { return new Promise(s => { const a = performance.now(); let o = !1; const l = () => { removeFromIdle(c), o = !0, s() }, c = h => { const d = performance.now(); let p = d, f = -1; for (; !o && f < e && h.timeRemaining() > 0;)r == null || r(l), p = performance.now(), f = p - d; !o && p - a > i * 1e3 && (console.warn("An idle task took too long to complete, aborting."), l()) }; addToIdle(c) }) }, hasRunThisFrame(r) { if (!r) throw new Error("hasRunThisFrame requires an object"); const e = r.___lastTimeFired; return r.___lastTimeFired = renderInfo.time, e ? e === renderInfo.time : !1 }, loadJson(r) { return fetch(r).then(e => e.json()).catch(() => console.log(`Load of ${r} failed.`)) }, preload(r = [], e) { if (!(r && r.length)) return e == null || e(1), Promise.resolve(); const i = [...new Set(r)], s = i.length; let a = 0; const o = async l => { try { const h = await fetch(l); h.ok && await h.blob() } catch (h) { console.warn(`${h} ${l}`) } const c = ++a / s; e == null || e(c) }; return Promise.all(i.map(l => o(l))) } }; var _n, ai, Vi, qn, br, wr, $n, ms, Sr, Cr, hn, Xn, gs, ta, Yn; const Er = class Er { constructor() { pe(this, gs); pe(this, _n, 0); pe(this, ai, []); pe(this, Vi, 0); pe(this, qn, 0); pe(this, br, 100); pe(this, wr, 1e3 / 60); pe(this, $n, () => { }); pe(this, ms, 0); pe(this, Sr, .5); pe(this, Cr, 5); pe(this, hn, []); pe(this, Xn, 1 / 0); Ke(this, "_timeScale", 1); Ke(this, "_time", 0); Ke(this, "_delta", 0); Ke(this, "_ratio", 1); Ke(this, "_averageFPS", 60); Ke(this, "_maxFPS", 0); Ke(this, "_frame", 0); Ke(this, "_ticking", !1); pe(this, Yn, () => { L(this, ai).length > 0 ? Xe(this, _n, requestAnimationFrame(L(this, Yn))) : Xe(this, _n, 0); const e = Er.getTime(); if (L(this, Xn) < 1 / 0 && e - L(this, Vi) < 1e3 / L(this, Xn)) return; if (this._ticking = !0, Xe(this, qn, L(this, Vi)), Xe(this, Vi, e), this._delta = Math.min(L(this, br), L(this, Vi) - L(this, qn)) * this._timeScale, this._time += this._delta / 1e3, this._ratio = this._delta / L(this, wr), this._frame++, L(this, hn).push(this._delta), this._time - L(this, ms) >= L(this, Sr) && L(this, hn).length >= L(this, Cr)) { const s = Math.round(1e3 / (L(this, hn).reduce((a, o) => a + o, 0) / L(this, hn).length)); this._maxFPS = Math.max(this._maxFPS, s), this._averageFPS = s, L(this, $n).call(this, s), L(this, hn).length = 0, Xe(this, ms, this._time) } const i = L(this, ai).slice(); for (; i.length > 0;)i.shift().tick(this._time, this._delta, this._frame); this._ticking = !1 }); Xe(this, Vi, Er.getTime()), Xe(this, qn, L(this, Vi)), L(this, Yn).call(this) } static getTime() { return performance.now() } set onAverageFPS(e) { Xe(this, $n, e) } get onAverageFPS() { return L(this, $n) } add(e, i = !1) { if (!e.tick) throw new Error('Elements added to the ticker must have a "tick()" method'); i && Pe(this, gs, ta).call(this, e), L(this, ai).push(e), L(this, _n) === 0 && Xe(this, _n, requestAnimationFrame(L(this, Yn))) } remove(e) { Xe(this, ai, L(this, ai).filter(i => i !== e)) } removeCb(e) { Xe(this, ai, L(this, ai).filter(i => i.tick !== e)) } removeAll() { Xe(this, ai, []) } limitFPS(e = 1 / 0) { Xe(this, Xn, e) } }; _n = new WeakMap, ai = new WeakMap, Vi = new WeakMap, qn = new WeakMap, br = new WeakMap, wr = new WeakMap, $n = new WeakMap, ms = new WeakMap, Sr = new WeakMap, Cr = new WeakMap, hn = new WeakMap, Xn = new WeakMap, gs = new WeakSet, ta = function (e) { e.isTween ? Xe(this, ai, L(this, ai).filter(i => !i.isTween && !i.isTimeline ? !0 : (i.isTween ? [i] : i._tweens.slice()).every(s => s._obj !== e._obj ? !0 : (Object.keys(s._from).forEach(a => { a in e._from && s._removeProp(a) }), !(Object.keys(s._from).length === 0 && (i.isTween || (i._tweens = i._tweens.filter(a => a !== s), i._tweens.length === 0))))))) : e.isTimeline && e._tweens.forEach(i => Pe(this, gs, ta).call(this, i)) }, Yn = new WeakMap; let ticker = Er; const t$1 = new ticker, renderInfo = Object.defineProperties({}, { time: { get: () => t$1._time }, delta: { get: () => t$1._delta }, frame: { get: () => t$1._frame }, averageFPS: { get: () => t$1._averageFPS }, maxFPS: { get: () => t$1._maxFPS }, ratio: { get: () => t$1._ratio } }), noop$2 = () => { }; var yn, un, vs, As, xs, bn, dn, Di, ys, Sn; class animation { constructor({ delay: e = 0, onStart: i = noop$2, onUpdate: s = noop$2, onComplete: a = noop$2, paused: o = !1, overwrite: l = !0 } = {}) { pe(this, yn, !1); pe(this, un, !1); pe(this, vs, noop$2); pe(this, As, noop$2); pe(this, xs, noop$2); pe(this, bn, null); pe(this, dn, 0); pe(this, Di, !1); pe(this, ys, !0); pe(this, Sn, null); Ke(this, "_duration", 0); Ke(this, "_delay", 0); this._delay = Math.max(0, e), Xe(this, vs, i), Xe(this, As, s), Xe(this, xs, a), Xe(this, Di, o), Xe(this, ys, l) } _animationAutoPlay() { L(this, Di) || (Xe(this, Di, !0), this.play()) } _animationUpdate(e = 0) { var c; const i = e - this._delay; let s = 0; this._duration > 0 ? (s = i / this._duration, Xe(this, dn, math.fit(i, -this._delay, this._duration, 0, 1))) : (i < 0 ? s = -1 : i === 0 || !L(this, un) ? s = 1 : s = 2, Xe(this, dn, s < 0 ? 0 : 1)); let a = !1, o = !1, l = !1; (s <= 0 || this._duration === 0 && s === 1) && Xe(this, yn, !1), !L(this, yn) && s >= 0 && (Xe(this, yn, !0), a = !0, o = !0), s >= 0 && s <= 1 && (o = !0), s <= 1 && Xe(this, un, !1), !L(this, un) && s >= 1 && (Xe(this, un, !0), l = !0, o = !0), this._animationPerformUpdate(i, s, o), a && L(this, vs).call(this), o && L(this, As).call(this), l && (L(this, xs).call(this), (c = L(this, Sn)) == null || c.resolve()), this._animationAfterUpdate(i, s, o) } _animationPerformUpdate(e, i, s) { } _animationAfterUpdate(e, i, s) { } then(e, i) { return L(this, Sn) || Xe(this, Sn, miscutils.deferred()), L(this, Sn).then(e, i) } play() { return L(this, Di) ? (Xe(this, Di, !1), Xe(this, bn, null), t$1.add(this, L(this, ys)), this) : this } pause() { return L(this, Di) ? this : (Xe(this, Di, !0), t$1.remove(this), this) } stop() { return Xe(this, dn, 0), Xe(this, yn, !1), Xe(this, un, !1), this.pause() } seek(e = 0) { return this.pause(), this._animationUpdate((this._duration + this._delay) * math.clamp(e, 0, 1)), this } tick(e) { return L(this, bn) === null && Xe(this, bn, e - (this._duration + this._delay) * L(this, dn)), this._animationUpdate(e - L(this, bn)), L(this, dn) === 1 && t$1.remove(this), this } } yn = new WeakMap, un = new WeakMap, vs = new WeakMap, As = new WeakMap, xs = new WeakMap, bn = new WeakMap, dn = new WeakMap, Di = new WeakMap, ys = new WeakMap, Sn = new WeakMap; const COLOR_SPACE_SVG = SRGBColorSpace; class SVGLoader extends Loader$1 { constructor(e) { super(e), this.defaultDPI = 90, this.defaultUnit = "px" } load(e, i, s, a) { const o = this, l = new FileLoader(o.manager); l.setPath(o.path), l.setRequestHeader(o.requestHeader), l.setWithCredentials(o.withCredentials), l.load(e, function (c) { try { i(o.parse(c)) } catch (h) { a ? a(h) : console.error(h), o.manager.itemError(e) } }, s, a) } parse(e) { const i = this; function s(ve, ne) { if (ve.nodeType !== 1) return; const z = P(ve); let V = !1, _e = null; switch (ve.nodeName) { case "svg": ne = b(ve, ne); break; case "style": o(ve); break; case "g": ne = b(ve, ne); break; case "path": ne = b(ve, ne), ve.hasAttribute("d") && (_e = a(ve)); break; case "rect": ne = b(ve, ne), _e = h(ve); break; case "polygon": ne = b(ve, ne), _e = d(ve); break; case "polyline": ne = b(ve, ne), _e = p(ve); break; case "circle": ne = b(ve, ne), _e = f(ve); break; case "ellipse": ne = b(ve, ne), _e = _(ve); break; case "line": ne = b(ve, ne), _e = x(ve); break; case "defs": V = !0; break; case "use": ne = b(ve, ne); const Fe = (ve.getAttributeNS("http://www.w3.org/1999/xlink", "href") || "").substring(1), st = ve.viewportElement.getElementById(Fe); st ? s(st, ne) : console.warn("SVGLoader: 'use node' references non-existent node id: " + Fe); break }_e && (ne.fill !== void 0 && ne.fill !== "none" && _e.color.setStyle(ne.fill, COLOR_SPACE_SVG), O(_e, Ue), $.push(_e), _e.userData = { node: ve, style: ne }); const Le = ve.childNodes; for (let fe = 0; fe < Le.length; fe++) { const Fe = Le[fe]; V && Fe.nodeName !== "style" && Fe.nodeName !== "defs" || s(Fe, ne) } z && (J.pop(), J.length > 0 ? Ue.copy(J[J.length - 1]) : Ue.identity()) } function a(ve) { const ne = new ShapePath, z = new Vector2, V = new Vector2, _e = new Vector2; let Le = !0, fe = !1; const Fe = ve.getAttribute("d"); if (Fe === "" || Fe === "none") return null; const st = Fe.match(/[a-df-z][^a-df-z]*/ig); for (let j = 0, Be = st.length; j < Be; j++) { const Re = st[j], Oe = Re.charAt(0), Ie = Re.slice(1).trim(); Le === !0 && (fe = !0, Le = !1); let oe; switch (Oe) { case "M": oe = M(Ie); for (let Y = 0, $e = oe.length; Y < $e; Y += 2)z.x = oe[Y + 0], z.y = oe[Y + 1], V.x = z.x, V.y = z.y, Y === 0 ? ne.moveTo(z.x, z.y) : ne.lineTo(z.x, z.y), Y === 0 && _e.copy(z); break; case "H": oe = M(Ie); for (let Y = 0, $e = oe.length; Y < $e; Y++)z.x = oe[Y], V.x = z.x, V.y = z.y, ne.lineTo(z.x, z.y), Y === 0 && fe === !0 && _e.copy(z); break; case "V": oe = M(Ie); for (let Y = 0, $e = oe.length; Y < $e; Y++)z.y = oe[Y], V.x = z.x, V.y = z.y, ne.lineTo(z.x, z.y), Y === 0 && fe === !0 && _e.copy(z); break; case "L": oe = M(Ie); for (let Y = 0, $e = oe.length; Y < $e; Y += 2)z.x = oe[Y + 0], z.y = oe[Y + 1], V.x = z.x, V.y = z.y, ne.lineTo(z.x, z.y), Y === 0 && fe === !0 && _e.copy(z); break; case "C": oe = M(Ie); for (let Y = 0, $e = oe.length; Y < $e; Y += 6)ne.bezierCurveTo(oe[Y + 0], oe[Y + 1], oe[Y + 2], oe[Y + 3], oe[Y + 4], oe[Y + 5]), V.x = oe[Y + 2], V.y = oe[Y + 3], z.x = oe[Y + 4], z.y = oe[Y + 5], Y === 0 && fe === !0 && _e.copy(z); break; case "S": oe = M(Ie); for (let Y = 0, $e = oe.length; Y < $e; Y += 4)ne.bezierCurveTo(T(z.x, V.x), T(z.y, V.y), oe[Y + 0], oe[Y + 1], oe[Y + 2], oe[Y + 3]), V.x = oe[Y + 0], V.y = oe[Y + 1], z.x = oe[Y + 2], z.y = oe[Y + 3], Y === 0 && fe === !0 && _e.copy(z); break; case "Q": oe = M(Ie); for (let Y = 0, $e = oe.length; Y < $e; Y += 4)ne.quadraticCurveTo(oe[Y + 0], oe[Y + 1], oe[Y + 2], oe[Y + 3]), V.x = oe[Y + 0], V.y = oe[Y + 1], z.x = oe[Y + 2], z.y = oe[Y + 3], Y === 0 && fe === !0 && _e.copy(z); break; case "T": oe = M(Ie); for (let Y = 0, $e = oe.length; Y < $e; Y += 2) { const vt = T(z.x, V.x), St = T(z.y, V.y); ne.quadraticCurveTo(vt, St, oe[Y + 0], oe[Y + 1]), V.x = vt, V.y = St, z.x = oe[Y + 0], z.y = oe[Y + 1], Y === 0 && fe === !0 && _e.copy(z) } break; case "A": oe = M(Ie, [3, 4], 7); for (let Y = 0, $e = oe.length; Y < $e; Y += 7) { if (oe[Y + 5] == z.x && oe[Y + 6] == z.y) continue; const vt = z.clone(); z.x = oe[Y + 5], z.y = oe[Y + 6], V.x = z.x, V.y = z.y, l(ne, oe[Y], oe[Y + 1], oe[Y + 2], oe[Y + 3], oe[Y + 4], vt, z), Y === 0 && fe === !0 && _e.copy(z) } break; case "m": oe = M(Ie); for (let Y = 0, $e = oe.length; Y < $e; Y += 2)z.x += oe[Y + 0], z.y += oe[Y + 1], V.x = z.x, V.y = z.y, Y === 0 ? ne.moveTo(z.x, z.y) : ne.lineTo(z.x, z.y), Y === 0 && _e.copy(z); break; case "h": oe = M(Ie); for (let Y = 0, $e = oe.length; Y < $e; Y++)z.x += oe[Y], V.x = z.x, V.y = z.y, ne.lineTo(z.x, z.y), Y === 0 && fe === !0 && _e.copy(z); break; case "v": oe = M(Ie); for (let Y = 0, $e = oe.length; Y < $e; Y++)z.y += oe[Y], V.x = z.x, V.y = z.y, ne.lineTo(z.x, z.y), Y === 0 && fe === !0 && _e.copy(z); break; case "l": oe = M(Ie); for (let Y = 0, $e = oe.length; Y < $e; Y += 2)z.x += oe[Y + 0], z.y += oe[Y + 1], V.x = z.x, V.y = z.y, ne.lineTo(z.x, z.y), Y === 0 && fe === !0 && _e.copy(z); break; case "c": oe = M(Ie); for (let Y = 0, $e = oe.length; Y < $e; Y += 6)ne.bezierCurveTo(z.x + oe[Y + 0], z.y + oe[Y + 1], z.x + oe[Y + 2], z.y + oe[Y + 3], z.x + oe[Y + 4], z.y + oe[Y + 5]), V.x = z.x + oe[Y + 2], V.y = z.y + oe[Y + 3], z.x += oe[Y + 4], z.y += oe[Y + 5], Y === 0 && fe === !0 && _e.copy(z); break; case "s": oe = M(Ie); for (let Y = 0, $e = oe.length; Y < $e; Y += 4)ne.bezierCurveTo(T(z.x, V.x), T(z.y, V.y), z.x + oe[Y + 0], z.y + oe[Y + 1], z.x + oe[Y + 2], z.y + oe[Y + 3]), V.x = z.x + oe[Y + 0], V.y = z.y + oe[Y + 1], z.x += oe[Y + 2], z.y += oe[Y + 3], Y === 0 && fe === !0 && _e.copy(z); break; case "q": oe = M(Ie); for (let Y = 0, $e = oe.length; Y < $e; Y += 4)ne.quadraticCurveTo(z.x + oe[Y + 0], z.y + oe[Y + 1], z.x + oe[Y + 2], z.y + oe[Y + 3]), V.x = z.x + oe[Y + 0], V.y = z.y + oe[Y + 1], z.x += oe[Y + 2], z.y += oe[Y + 3], Y === 0 && fe === !0 && _e.copy(z); break; case "t": oe = M(Ie); for (let Y = 0, $e = oe.length; Y < $e; Y += 2) { const vt = T(z.x, V.x), St = T(z.y, V.y); ne.quadraticCurveTo(vt, St, z.x + oe[Y + 0], z.y + oe[Y + 1]), V.x = vt, V.y = St, z.x = z.x + oe[Y + 0], z.y = z.y + oe[Y + 1], Y === 0 && fe === !0 && _e.copy(z) } break; case "a": oe = M(Ie, [3, 4], 7); for (let Y = 0, $e = oe.length; Y < $e; Y += 7) { if (oe[Y + 5] == 0 && oe[Y + 6] == 0) continue; const vt = z.clone(); z.x += oe[Y + 5], z.y += oe[Y + 6], V.x = z.x, V.y = z.y, l(ne, oe[Y], oe[Y + 1], oe[Y + 2], oe[Y + 3], oe[Y + 4], vt, z), Y === 0 && fe === !0 && _e.copy(z) } break; case "Z": case "z": ne.currentPath.autoClose = !0, ne.currentPath.curves.length > 0 && (z.copy(_e), ne.currentPath.currentPoint.copy(z), Le = !0); break; default: console.warn(Re) }fe = !1 } return ne } function o(ve) { if (!(!ve.sheet || !ve.sheet.cssRules || !ve.sheet.cssRules.length)) for (let ne = 0; ne < ve.sheet.cssRules.length; ne++) { const z = ve.sheet.cssRules[ne]; if (z.type !== 1) continue; const V = z.selectorText.split(/,/gm).filter(Boolean).map(_e => _e.trim()); for (let _e = 0; _e < V.length; _e++) { const Le = Object.fromEntries(Object.entries(z.style).filter(([, fe]) => fe !== "")); Z[V[_e]] = Object.assign(Z[V[_e]] || {}, Le) } } } function l(ve, ne, z, V, _e, Le, fe, Fe) { if (ne == 0 || z == 0) { ve.lineTo(Fe.x, Fe.y); return } V = V * Math.PI / 180, ne = Math.abs(ne), z = Math.abs(z); const st = (fe.x - Fe.x) / 2, j = (fe.y - Fe.y) / 2, Be = Math.cos(V) * st + Math.sin(V) * j, Re = -Math.sin(V) * st + Math.cos(V) * j; let Oe = ne * ne, Ie = z * z; const oe = Be * Be, Y = Re * Re, $e = oe / Oe + Y / Ie; if ($e > 1) { const tt = Math.sqrt($e); ne = tt * ne, z = tt * z, Oe = ne * ne, Ie = z * z } const vt = Oe * Y + Ie * oe, St = (Oe * Ie - vt) / vt; let K = Math.sqrt(Math.max(0, St)); _e === Le && (K = -K); const G = K * ne * Re / z, he = -K * z * Be / ne, De = Math.cos(V) * G - Math.sin(V) * he + (fe.x + Fe.x) / 2, Ge = Math.sin(V) * G + Math.cos(V) * he + (fe.y + Fe.y) / 2, Te = c(1, 0, (Be - G) / ne, (Re - he) / z), ot = c((Be - G) / ne, (Re - he) / z, (-Be - G) / ne, (-Re - he) / z) % (Math.PI * 2); ve.currentPath.absellipse(De, Ge, ne, z, Te, Te + ot, Le === 0, V) } function c(ve, ne, z, V) { const _e = ve * z + ne * V, Le = Math.sqrt(ve * ve + ne * ne) * Math.sqrt(z * z + V * V); let fe = Math.acos(Math.max(-1, Math.min(1, _e / Le))); return ve * V - ne * z < 0 && (fe = -fe), fe } function h(ve) { const ne = R(ve.getAttribute("x") || 0), z = R(ve.getAttribute("y") || 0), V = R(ve.getAttribute("rx") || ve.getAttribute("ry") || 0), _e = R(ve.getAttribute("ry") || ve.getAttribute("rx") || 0), Le = R(ve.getAttribute("width")), fe = R(ve.getAttribute("height")), Fe = 1 - .551915024494, st = new ShapePath; return st.moveTo(ne + V, z), st.lineTo(ne + Le - V, z), (V !== 0 || _e !== 0) && st.bezierCurveTo(ne + Le - V * Fe, z, ne + Le, z + _e * Fe, ne + Le, z + _e), st.lineTo(ne + Le, z + fe - _e), (V !== 0 || _e !== 0) && st.bezierCurveTo(ne + Le, z + fe - _e * Fe, ne + Le - V * Fe, z + fe, ne + Le - V, z + fe), st.lineTo(ne + V, z + fe), (V !== 0 || _e !== 0) && st.bezierCurveTo(ne + V * Fe, z + fe, ne, z + fe - _e * Fe, ne, z + fe - _e), st.lineTo(ne, z + _e), (V !== 0 || _e !== 0) && st.bezierCurveTo(ne, z + _e * Fe, ne + V * Fe, z, ne + V, z), st } function d(ve) { function ne(Le, fe, Fe) { const st = R(fe), j = R(Fe); _e === 0 ? V.moveTo(st, j) : V.lineTo(st, j), _e++ } const z = /([+-]?\d*\.?\d+(?:e[+-]?\d+)?)(?:,|\s)([+-]?\d*\.?\d+(?:e[+-]?\d+)?)/g, V = new ShapePath; let _e = 0; return ve.getAttribute("points").replace(z, ne), V.currentPath.autoClose = !0, V } function p(ve) { function ne(Le, fe, Fe) { const st = R(fe), j = R(Fe); _e === 0 ? V.moveTo(st, j) : V.lineTo(st, j), _e++ } const z = /([+-]?\d*\.?\d+(?:e[+-]?\d+)?)(?:,|\s)([+-]?\d*\.?\d+(?:e[+-]?\d+)?)/g, V = new ShapePath; let _e = 0; return ve.getAttribute("points").replace(z, ne), V.currentPath.autoClose = !1, V } function f(ve) { const ne = R(ve.getAttribute("cx") || 0), z = R(ve.getAttribute("cy") || 0), V = R(ve.getAttribute("r") || 0), _e = new Path; _e.absarc(ne, z, V, 0, Math.PI * 2); const Le = new ShapePath; return Le.subPaths.push(_e), Le } function _(ve) { const ne = R(ve.getAttribute("cx") || 0), z = R(ve.getAttribute("cy") || 0), V = R(ve.getAttribute("rx") || 0), _e = R(ve.getAttribute("ry") || 0), Le = new Path; Le.absellipse(ne, z, V, _e, 0, Math.PI * 2); const fe = new ShapePath; return fe.subPaths.push(Le), fe } function x(ve) { const ne = R(ve.getAttribute("x1") || 0), z = R(ve.getAttribute("y1") || 0), V = R(ve.getAttribute("x2") || 0), _e = R(ve.getAttribute("y2") || 0), Le = new ShapePath; return Le.moveTo(ne, z), Le.lineTo(V, _e), Le.currentPath.autoClose = !1, Le } function b(ve, ne) { ne = Object.assign({}, ne); let z = {}; if (ve.hasAttribute("class")) { const fe = ve.getAttribute("class").split(/\s/).filter(Boolean).map(Fe => Fe.trim()); for (let Fe = 0; Fe < fe.length; Fe++)z = Object.assign(z, Z["." + fe[Fe]]) } ve.hasAttribute("id") && (z = Object.assign(z, Z["#" + ve.getAttribute("id")])); function V(fe, Fe, st) { st === void 0 && (st = function (Be) { return Be.startsWith("url") && console.warn("SVGLoader: url access in attributes is not implemented."), Be }), ve.hasAttribute(fe) && (ne[Fe] = st(ve.getAttribute(fe))), z[fe] && (ne[Fe] = st(z[fe])), ve.style && ve.style[fe] !== "" && (ne[Fe] = st(ve.style[fe])) } function _e(fe) { return Math.max(0, Math.min(1, R(fe))) } function Le(fe) { return Math.max(0, R(fe)) } return V("fill", "fill"), V("fill-opacity", "fillOpacity", _e), V("fill-rule", "fillRule"), V("opacity", "opacity", _e), V("stroke", "stroke"), V("stroke-opacity", "strokeOpacity", _e), V("stroke-width", "strokeWidth", Le), V("stroke-linejoin", "strokeLineJoin"), V("stroke-linecap", "strokeLineCap"), V("stroke-miterlimit", "strokeMiterLimit", Le), V("visibility", "visibility"), ne } function T(ve, ne) { return ve - (ne - ve) } function M(ve, ne, z) { if (typeof ve != "string") throw new TypeError("Invalid input: " + typeof ve); const V = { WHITESPACE: /[ \t\r\n]/, DIGIT: /[\d]/, SIGN: /[-+]/, POINT: /\./, COMMA: /,/, EXP: /e/i, FLAGS: /[01]/ }, _e = 0, Le = 1, fe = 2, Fe = 3; let st = _e, j = !0, Be = "", Re = ""; const Oe = []; function Ie(vt, St, K) { const G = new SyntaxError('Unexpected character "' + vt + '" at index ' + St + "."); throw G.partial = K, G } function oe() { Be !== "" && (Re === "" ? Oe.push(Number(Be)) : Oe.push(Number(Be) * Math.pow(10, Number(Re)))), Be = "", Re = "" } let Y; const $e = ve.length; for (let vt = 0; vt < $e; vt++) { if (Y = ve[vt], Array.isArray(ne) && ne.includes(Oe.length % z) && V.FLAGS.test(Y)) { st = Le, Be = Y, oe(); continue } if (st === _e) { if (V.WHITESPACE.test(Y)) continue; if (V.DIGIT.test(Y) || V.SIGN.test(Y)) { st = Le, Be = Y; continue } if (V.POINT.test(Y)) { st = fe, Be = Y; continue } V.COMMA.test(Y) && (j && Ie(Y, vt, Oe), j = !0) } if (st === Le) { if (V.DIGIT.test(Y)) { Be += Y; continue } if (V.POINT.test(Y)) { Be += Y, st = fe; continue } if (V.EXP.test(Y)) { st = Fe; continue } V.SIGN.test(Y) && Be.length === 1 && V.SIGN.test(Be[0]) && Ie(Y, vt, Oe) } if (st === fe) { if (V.DIGIT.test(Y)) { Be += Y; continue } if (V.EXP.test(Y)) { st = Fe; continue } V.POINT.test(Y) && Be[Be.length - 1] === "." && Ie(Y, vt, Oe) } if (st === Fe) { if (V.DIGIT.test(Y)) { Re += Y; continue } if (V.SIGN.test(Y)) { if (Re === "") { Re += Y; continue } Re.length === 1 && V.SIGN.test(Re) && Ie(Y, vt, Oe) } } V.WHITESPACE.test(Y) ? (oe(), st = _e, j = !1) : V.COMMA.test(Y) ? (oe(), st = _e, j = !0) : V.SIGN.test(Y) ? (oe(), st = Le, Be = Y) : V.POINT.test(Y) ? (oe(), st = fe, Be = Y) : Ie(Y, vt, Oe) } return oe(), Oe } const w = ["mm", "cm", "in", "pt", "pc", "px"], D = { mm: { mm: 1, cm: .1, in: 1 / 25.4, pt: 72 / 25.4, pc: 6 / 25.4, px: -1 }, cm: { mm: 10, cm: 1, in: 1 / 2.54, pt: 72 / 2.54, pc: 6 / 2.54, px: -1 }, in: { mm: 25.4, cm: 2.54, in: 1, pt: 72, pc: 6, px: -1 }, pt: { mm: 25.4 / 72, cm: 2.54 / 72, in: 1 / 72, pt: 1, pc: 6 / 72, px: -1 }, pc: { mm: 25.4 / 6, cm: 2.54 / 6, in: 1 / 6, pt: 72 / 6, pc: 1, px: -1 }, px: { px: 1 } }; function R(ve) { let ne = "px"; if (typeof ve == "string" || ve instanceof String) for (let V = 0, _e = w.length; V < _e; V++) { const Le = w[V]; if (ve.endsWith(Le)) { ne = Le, ve = ve.substring(0, ve.length - Le.length); break } } let z; return ne === "px" && i.defaultUnit !== "px" ? z = D.in[i.defaultUnit] / i.defaultDPI : (z = D[ne][i.defaultUnit], z < 0 && (z = D[ne].in * i.defaultDPI)), z * parseFloat(ve) } function P(ve) { if (!(ve.hasAttribute("transform") || ve.nodeName === "use" && (ve.hasAttribute("x") || ve.hasAttribute("y")))) return null; const ne = U(ve); return J.length > 0 && ne.premultiply(J[J.length - 1]), Ue.copy(ne), J.push(ne), ne } function U(ve) { const ne = new Matrix3, z = se; if (ve.nodeName === "use" && (ve.hasAttribute("x") || ve.hasAttribute("y"))) { const V = R(ve.getAttribute("x")), _e = R(ve.getAttribute("y")); ne.translate(V, _e) } if (ve.hasAttribute("transform")) { const V = ve.getAttribute("transform").split(")"); for (let _e = V.length - 1; _e >= 0; _e--) { const Le = V[_e].trim(); if (Le === "") continue; const fe = Le.indexOf("("), Fe = Le.length; if (fe > 0 && fe < Fe) { const st = Le.slice(0, fe), j = M(Le.slice(fe + 1)); switch (z.identity(), st) { case "translate": if (j.length >= 1) { const Be = j[0]; let Re = 0; j.length >= 2 && (Re = j[1]), z.translate(Be, Re) } break; case "rotate": if (j.length >= 1) { let Be = 0, Re = 0, Oe = 0; Be = j[0] * Math.PI / 180, j.length >= 3 && (Re = j[1], Oe = j[2]), re.makeTranslation(-Re, -Oe), ce.makeRotation(Be), ee.multiplyMatrices(ce, re), re.makeTranslation(Re, Oe), z.multiplyMatrices(re, ee) } break; case "scale": if (j.length >= 1) { const Be = j[0]; let Re = Be; j.length >= 2 && (Re = j[1]), z.scale(Be, Re) } break; case "skewX": j.length === 1 && z.set(1, Math.tan(j[0] * Math.PI / 180), 0, 0, 1, 0, 0, 0, 1); break; case "skewY": j.length === 1 && z.set(1, 0, 0, Math.tan(j[0] * Math.PI / 180), 1, 0, 0, 0, 1); break; case "matrix": j.length === 6 && z.set(j[0], j[2], j[4], j[1], j[3], j[5], 0, 0, 1); break } } ne.premultiply(z) } } return ne } function O(ve, ne) { function z(fe) { Ee.set(fe.x, fe.y, 1).applyMatrix3(ne), fe.set(Ee.x, Ee.y) } function V(fe) { const Fe = fe.xRadius, st = fe.yRadius, j = Math.cos(fe.aRotation), Be = Math.sin(fe.aRotation), Re = new Vector3(Fe * j, Fe * Be, 0), Oe = new Vector3(-st * Be, st * j, 0), Ie = Re.applyMatrix3(ne), oe = Oe.applyMatrix3(ne), Y = se.set(Ie.x, oe.x, 0, Ie.y, oe.y, 0, 0, 0, 1), $e = re.copy(Y).invert(), K = ce.copy($e).transpose().multiply($e).elements, G = W(K[0], K[1], K[4]), he = Math.sqrt(G.rt1), De = Math.sqrt(G.rt2); if (fe.xRadius = 1 / he, fe.yRadius = 1 / De, fe.aRotation = Math.atan2(G.sn, G.cs), !((fe.aEndAngle - fe.aStartAngle) % (2 * Math.PI) < Number.EPSILON)) { const Te = re.set(he, 0, 0, 0, De, 0, 0, 0, 1), ot = ce.set(G.cs, G.sn, 0, -G.sn, G.cs, 0, 0, 0, 1), tt = Te.multiply(ot).multiply(Y), ut = ft => { const { x: ze, y: le } = new Vector3(Math.cos(ft), Math.sin(ft), 0).applyMatrix3(tt); return Math.atan2(le, ze) }; fe.aStartAngle = ut(fe.aStartAngle), fe.aEndAngle = ut(fe.aEndAngle), N(ne) && (fe.aClockwise = !fe.aClockwise) } } function _e(fe) { const Fe = F(ne), st = k(ne); fe.xRadius *= Fe, fe.yRadius *= st; const j = Fe > Number.EPSILON ? Math.atan2(ne.elements[1], ne.elements[0]) : Math.atan2(-ne.elements[3], ne.elements[4]); fe.aRotation += j, N(ne) && (fe.aStartAngle *= -1, fe.aEndAngle *= -1, fe.aClockwise = !fe.aClockwise) } const Le = ve.subPaths; for (let fe = 0, Fe = Le.length; fe < Fe; fe++) { const j = Le[fe].curves; for (let Be = 0; Be < j.length; Be++) { const Re = j[Be]; Re.isLineCurve ? (z(Re.v1), z(Re.v2)) : Re.isCubicBezierCurve ? (z(Re.v0), z(Re.v1), z(Re.v2), z(Re.v3)) : Re.isQuadraticBezierCurve ? (z(Re.v0), z(Re.v1), z(Re.v2)) : Re.isEllipseCurve && (Me.set(Re.aX, Re.aY), z(Me), Re.aX = Me.x, Re.aY = Me.y, H(ne) ? V(Re) : _e(Re)) } } } function N(ve) { const ne = ve.elements; return ne[0] * ne[4] - ne[1] * ne[3] < 0 } function H(ve) { const ne = ve.elements, z = ne[0] * ne[3] + ne[1] * ne[4]; if (z === 0) return !1; const V = F(ve), _e = k(ve); return Math.abs(z / (V * _e)) > Number.EPSILON } function F(ve) { const ne = ve.elements; return Math.sqrt(ne[0] * ne[0] + ne[1] * ne[1]) } function k(ve) { const ne = ve.elements; return Math.sqrt(ne[3] * ne[3] + ne[4] * ne[4]) } function W(ve, ne, z) { let V, _e, Le, fe, Fe; const st = ve + z, j = ve - z, Be = Math.sqrt(j * j + 4 * ne * ne); return st > 0 ? (V = .5 * (st + Be), Fe = 1 / V, _e = ve * Fe * z - ne * Fe * ne) : st < 0 ? _e = .5 * (st - Be) : (V = .5 * Be, _e = -.5 * Be), j > 0 ? Le = j + Be : Le = j - Be, Math.abs(Le) > 2 * Math.abs(ne) ? (Fe = -2 * ne / Le, fe = 1 / Math.sqrt(1 + Fe * Fe), Le = Fe * fe) : Math.abs(ne) === 0 ? (Le = 1, fe = 0) : (Fe = -.5 * Le / ne, Le = 1 / Math.sqrt(1 + Fe * Fe), fe = Fe * Le), j > 0 && (Fe = Le, Le = -fe, fe = Fe), { rt1: V, rt2: _e, cs: Le, sn: fe } } const $ = [], Z = {}, J = [], se = new Matrix3, re = new Matrix3, ce = new Matrix3, ee = new Matrix3, Me = new Vector2, Ee = new Vector3, Ue = new Matrix3, nt = new DOMParser().parseFromString(e, "image/svg+xml"); return s(nt.documentElement, { fill: "#000", fillOpacity: 1, strokeOpacity: 1, strokeWidth: 1, strokeLineJoin: "miter", strokeLineCap: "butt", strokeMiterLimit: 4 }), { paths: $, xml: nt.documentElement } } static createShapes(e) { const s = { ORIGIN: 0, DESTINATION: 1, BETWEEN: 2, LEFT: 3, RIGHT: 4, BEHIND: 5, BEYOND: 6 }, a = { loc: s.ORIGIN, t: 0 }; function o(T, M, w, D) { const R = T.x, P = M.x, U = w.x, O = D.x, N = T.y, H = M.y, F = w.y, k = D.y, W = (O - U) * (N - F) - (k - F) * (R - U), $ = (P - R) * (N - F) - (H - N) * (R - U), Z = (k - F) * (P - R) - (O - U) * (H - N), J = W / Z, se = $ / Z; if (Z === 0 && W !== 0 || J <= 0 || J >= 1 || se < 0 || se > 1) return null; if (W === 0 && Z === 0) { for (let re = 0; re < 2; re++)if (l(re === 0 ? w : D, T, M), a.loc == s.ORIGIN) { const ce = re === 0 ? w : D; return { x: ce.x, y: ce.y, t: a.t } } else if (a.loc == s.BETWEEN) { const ce = +(R + a.t * (P - R)).toPrecision(10), ee = +(N + a.t * (H - N)).toPrecision(10); return { x: ce, y: ee, t: a.t } } return null } else { for (let ee = 0; ee < 2; ee++)if (l(ee === 0 ? w : D, T, M), a.loc == s.ORIGIN) { const Me = ee === 0 ? w : D; return { x: Me.x, y: Me.y, t: a.t } } const re = +(R + J * (P - R)).toPrecision(10), ce = +(N + J * (H - N)).toPrecision(10); return { x: re, y: ce, t: J } } } function l(T, M, w) { const D = w.x - M.x, R = w.y - M.y, P = T.x - M.x, U = T.y - M.y, O = D * U - P * R; if (T.x === M.x && T.y === M.y) { a.loc = s.ORIGIN, a.t = 0; return } if (T.x === w.x && T.y === w.y) { a.loc = s.DESTINATION, a.t = 1; return } if (O < -Number.EPSILON) { a.loc = s.LEFT; return } if (O > Number.EPSILON) { a.loc = s.RIGHT; return } if (D * P < 0 || R * U < 0) { a.loc = s.BEHIND; return } if (Math.sqrt(D * D + R * R) < Math.sqrt(P * P + U * U)) { a.loc = s.BEYOND; return } let N; D !== 0 ? N = P / D : N = U / R, a.loc = s.BETWEEN, a.t = N } function c(T, M) { const w = [], D = []; for (let R = 1; R < T.length; R++) { const P = T[R - 1], U = T[R]; for (let O = 1; O < M.length; O++) { const N = M[O - 1], H = M[O], F = o(P, U, N, H); F !== null && w.find(k => k.t <= F.t + Number.EPSILON && k.t >= F.t - Number.EPSILON) === void 0 && (w.push(F), D.push(new Vector2(F.x, F.y))) } } return D } function h(T, M, w) { const D = new Vector2; M.getCenter(D); const R = []; return w.forEach(P => { P.boundingBox.containsPoint(D) && c(T, P.points).forEach(O => { R.push({ identifier: P.identifier, isCW: P.isCW, point: O }) }) }), R.sort((P, U) => P.point.x - U.point.x), R } function d(T, M, w, D, R) { (R == null || R === "") && (R = "nonzero"); const P = new Vector2; T.boundingBox.getCenter(P); const U = [new Vector2(w, P.y), new Vector2(D, P.y)], O = h(U, T.boundingBox, M); O.sort(($, Z) => $.point.x - Z.point.x); const N = [], H = []; O.forEach($ => { $.identifier === T.identifier ? N.push($) : H.push($) }); const F = N[0].point.x, k = []; let W = 0; for (; W < H.length && H[W].point.x < F;)k.length > 0 && k[k.length - 1] === H[W].identifier ? k.pop() : k.push(H[W].identifier), W++; if (k.push(T.identifier), R === "evenodd") { const $ = k.length % 2 === 0, Z = k[k.length - 2]; return { identifier: T.identifier, isHole: $, for: Z } } else if (R === "nonzero") { let $ = !0, Z = null, J = null; for (let se = 0; se < k.length; se++) { const re = k[se]; $ ? (J = M[re].isCW, $ = !1, Z = re) : J !== M[re].isCW && (J = M[re].isCW, $ = !0) } return { identifier: T.identifier, isHole: $, for: Z } } else console.warn('fill-rule: "' + R + '" is currently not implemented.') } let p = 999999999, f = -999999999, _ = e.subPaths.map(T => { const M = T.getPoints(); let w = -999999999, D = 999999999, R = -999999999, P = 999999999; for (let U = 0; U < M.length; U++) { const O = M[U]; O.y > w && (w = O.y), O.y < D && (D = O.y), O.x > R && (R = O.x), O.x < P && (P = O.x) } return f <= R && (f = R + 1), p >= P && (p = P - 1), { curves: T.curves, points: M, isCW: ShapeUtils.isClockWise(M), identifier: -1, boundingBox: new Box2(new Vector2(P, D), new Vector2(R, w)) } }); _ = _.filter(T => T.points.length > 1); for (let T = 0; T < _.length; T++)_[T].identifier = T; const x = _.map(T => d(T, _, p, f, e.userData ? e.userData.style.fillRule : void 0)), b = []; return _.forEach(T => { if (!x[T.identifier].isHole) { const w = new Shape; w.curves = T.curves, x.filter(R => R.isHole && R.for === T.identifier).forEach(R => { const P = _[R.identifier], U = new Path; U.curves = P.curves, w.holes.push(U) }), b.push(w) } }), b } static getStrokeStyle(e, i, s, a, o) { return e = e !== void 0 ? e : 1, i = i !== void 0 ? i : "#000", s = s !== void 0 ? s : "miter", a = a !== void 0 ? a : "butt", o = o !== void 0 ? o : 4, { strokeColor: i, strokeWidth: e, strokeLineJoin: s, strokeLineCap: a, strokeMiterLimit: o } } static pointsToStroke(e, i, s, a) { const o = [], l = [], c = []; if (SVGLoader.pointsToStrokeWithBuffers(e, i, s, a, o, l, c) === 0) return null; const h = new BufferGeometry; return h.setAttribute("position", new Float32BufferAttribute(o, 3)), h.setAttribute("normal", new Float32BufferAttribute(l, 3)), h.setAttribute("uv", new Float32BufferAttribute(c, 2)), h } static pointsToStrokeWithBuffers(e, i, s, a, o, l, c, h) { const d = new Vector2, p = new Vector2, f = new Vector2, _ = new Vector2, x = new Vector2, b = new Vector2, T = new Vector2, M = new Vector2, w = new Vector2, D = new Vector2, R = new Vector2, P = new Vector2, U = new Vector2, O = new Vector2, N = new Vector2, H = new Vector2, F = new Vector2; s = s !== void 0 ? s : 12, a = a !== void 0 ? a : .001, h = h !== void 0 ? h : 0, e = j(e); const k = e.length; if (k < 2) return 0; const W = e[0].equals(e[k - 1]); let $, Z = e[0], J; const se = i.strokeWidth / 2, re = 1 / (k - 1); let ce = 0, ee, Me, Ee, Ue, nt = !1, mt = 0, ve = h * 3, ne = h * 2; z(e[0], e[1], d).multiplyScalar(se), M.copy(e[0]).sub(d), w.copy(e[0]).add(d), D.copy(M), R.copy(w); for (let Be = 1; Be < k; Be++) { $ = e[Be], Be === k - 1 ? W ? J = e[1] : J = void 0 : J = e[Be + 1]; const Re = d; if (z(Z, $, Re), f.copy(Re).multiplyScalar(se), P.copy($).sub(f), U.copy($).add(f), ee = ce + re, Me = !1, J !== void 0) { z($, J, p), f.copy(p).multiplyScalar(se), O.copy($).sub(f), N.copy($).add(f), Ee = !0, f.subVectors(J, Z), Re.dot(f) < 0 && (Ee = !1), Be === 1 && (nt = Ee), f.subVectors(J, $), f.normalize(); const Oe = Math.abs(Re.dot(f)); if (Oe > Number.EPSILON) { const Ie = se / Oe; f.multiplyScalar(-Ie), _.subVectors($, Z), x.copy(_).setLength(Ie).add(f), H.copy(x).negate(); const oe = x.length(), Y = _.length(); _.divideScalar(Y), b.subVectors(J, $); const $e = b.length(); switch (b.divideScalar($e), _.dot(H) < Y && b.dot(H) < $e && (Me = !0), F.copy(x).add($), H.add($), Ue = !1, Me ? Ee ? (N.copy(H), U.copy(H)) : (O.copy(H), P.copy(H)) : Le(), i.strokeLineJoin) { case "bevel": fe(Ee, Me, ee); break; case "round": Fe(Ee, Me), Ee ? _e($, P, O, ee, 0) : _e($, N, U, ee, 1); break; case "miter": case "miter-clip": default: const vt = se * i.strokeMiterLimit / oe; if (vt < 1) if (i.strokeLineJoin !== "miter-clip") { fe(Ee, Me, ee); break } else Fe(Ee, Me), Ee ? (b.subVectors(F, P).multiplyScalar(vt).add(P), T.subVectors(F, O).multiplyScalar(vt).add(O), V(P, ee, 0), V(b, ee, 0), V($, ee, .5), V($, ee, .5), V(b, ee, 0), V(T, ee, 0), V($, ee, .5), V(T, ee, 0), V(O, ee, 0)) : (b.subVectors(F, U).multiplyScalar(vt).add(U), T.subVectors(F, N).multiplyScalar(vt).add(N), V(U, ee, 1), V(b, ee, 1), V($, ee, .5), V($, ee, .5), V(b, ee, 1), V(T, ee, 1), V($, ee, .5), V(T, ee, 1), V(N, ee, 1)); else Me ? (Ee ? (V(w, ce, 1), V(M, ce, 0), V(F, ee, 0), V(w, ce, 1), V(F, ee, 0), V(H, ee, 1)) : (V(w, ce, 1), V(M, ce, 0), V(F, ee, 1), V(M, ce, 0), V(H, ee, 0), V(F, ee, 1)), Ee ? O.copy(F) : N.copy(F)) : Ee ? (V(P, ee, 0), V(F, ee, 0), V($, ee, .5), V($, ee, .5), V(F, ee, 0), V(O, ee, 0)) : (V(U, ee, 1), V(F, ee, 1), V($, ee, .5), V($, ee, .5), V(F, ee, 1), V(N, ee, 1)), Ue = !0; break } } else Le() } else Le(); !W && Be === k - 1 && st(e[0], D, R, Ee, !0, ce), ce = ee, Z = $, M.copy(O), w.copy(N) } if (!W) st($, P, U, Ee, !1, ee); else if (Me && o) { let Be = F, Re = H; nt !== Ee && (Be = H, Re = F), Ee ? (Ue || nt) && (Re.toArray(o, 0 * 3), Re.toArray(o, 3 * 3), Ue && Be.toArray(o, 1 * 3)) : (Ue || !nt) && (Re.toArray(o, 1 * 3), Re.toArray(o, 3 * 3), Ue && Be.toArray(o, 0 * 3)) } return mt; function z(Be, Re, Oe) { return Oe.subVectors(Re, Be), Oe.set(-Oe.y, Oe.x).normalize() } function V(Be, Re, Oe) { o && (o[ve] = Be.x, o[ve + 1] = Be.y, o[ve + 2] = 0, l && (l[ve] = 0, l[ve + 1] = 0, l[ve + 2] = 1), ve += 3, c && (c[ne] = Re, c[ne + 1] = Oe, ne += 2)), mt += 3 } function _e(Be, Re, Oe, Ie, oe) { d.copy(Re).sub(Be).normalize(), p.copy(Oe).sub(Be).normalize(); let Y = Math.PI; const $e = d.dot(p); Math.abs($e) < 1 && (Y = Math.abs(Math.acos($e))), Y /= s, f.copy(Re); for (let vt = 0, St = s - 1; vt < St; vt++)_.copy(f).rotateAround(Be, Y), V(f, Ie, oe), V(_, Ie, oe), V(Be, Ie, .5), f.copy(_); V(_, Ie, oe), V(Oe, Ie, oe), V(Be, Ie, .5) } function Le() { V(w, ce, 1), V(M, ce, 0), V(P, ee, 0), V(w, ce, 1), V(P, ee, 0), V(U, ee, 1) } function fe(Be, Re, Oe) { Re ? Be ? (V(w, ce, 1), V(M, ce, 0), V(P, ee, 0), V(w, ce, 1), V(P, ee, 0), V(H, ee, 1), V(P, Oe, 0), V(O, Oe, 0), V(H, Oe, .5)) : (V(w, ce, 1), V(M, ce, 0), V(U, ee, 1), V(M, ce, 0), V(H, ee, 0), V(U, ee, 1), V(U, Oe, 1), V(H, Oe, 0), V(N, Oe, 1)) : Be ? (V(P, Oe, 0), V(O, Oe, 0), V($, Oe, .5)) : (V(U, Oe, 1), V(N, Oe, 0), V($, Oe, .5)) } function Fe(Be, Re) { Re && (Be ? (V(w, ce, 1), V(M, ce, 0), V(P, ee, 0), V(w, ce, 1), V(P, ee, 0), V(H, ee, 1), V(P, ce, 0), V($, ee, .5), V(H, ee, 1), V($, ee, .5), V(O, ce, 0), V(H, ee, 1)) : (V(w, ce, 1), V(M, ce, 0), V(U, ee, 1), V(M, ce, 0), V(H, ee, 0), V(U, ee, 1), V(U, ce, 1), V(H, ee, 0), V($, ee, .5), V($, ee, .5), V(H, ee, 0), V(N, ce, 1))) } function st(Be, Re, Oe, Ie, oe, Y) { switch (i.strokeLineCap) { case "round": oe ? _e(Be, Oe, Re, Y, .5) : _e(Be, Re, Oe, Y, .5); break; case "square": if (oe) d.subVectors(Re, Be), p.set(d.y, -d.x), f.addVectors(d, p).add(Be), _.subVectors(p, d).add(Be), Ie ? (f.toArray(o, 1 * 3), _.toArray(o, 0 * 3), _.toArray(o, 3 * 3)) : (f.toArray(o, 1 * 3), c[3 * 2 + 1] === 1 ? _.toArray(o, 3 * 3) : f.toArray(o, 3 * 3), _.toArray(o, 0 * 3)); else { d.subVectors(Oe, Be), p.set(d.y, -d.x), f.addVectors(d, p).add(Be), _.subVectors(p, d).add(Be); const $e = o.length; Ie ? (f.toArray(o, $e - 1 * 3), _.toArray(o, $e - 2 * 3), _.toArray(o, $e - 4 * 3)) : (_.toArray(o, $e - 2 * 3), f.toArray(o, $e - 1 * 3), _.toArray(o, $e - 4 * 3)) } break } } function j(Be) { let Re = !1; for (let Ie = 1, oe = Be.length - 1; Ie < oe; Ie++)if (Be[Ie].distanceTo(Be[Ie + 1]) < a) { Re = !0; break } if (!Re) return Be; const Oe = []; Oe.push(Be[0]); for (let Ie = 1, oe = Be.length - 1; Ie < oe; Ie++)Be[Ie].distanceTo(Be[Ie + 1]) >= a && Oe.push(Be[Ie]); return Oe.push(Be[Be.length - 1]), Oe } } } const parser = new SVGLoader, customEasesCache = new Map; function customEase(r, e, i = 1) { let s = r, a = e; if (!a) { if (customEasesCache.has(r)) return customEasesCache.get(r); a = r, s = math.uid() } let o = null; try { const _ = `<svg xmlns="http://www.w3.org/2000/svg"><path d="${a.trim()}"/></svg>`; o = parser.parse(_).paths[0].subPaths[0] } catch { return console.warn(`customEase: invalid curve path: ${a}`), customEasesCache.set(s, x => x), customEasesCache.get(s) } const l = o.getPoints(Math.round(75 * o.getLength() * i)); if (l[0].x !== 0 || l[l.length - 1].x !== 1) return console.warn(`customEase: curve points must start at 0 and end at 1: ${a}`), customEasesCache.set(s, _ => _), customEasesCache.get(s); const c = [], h = l.length * 2, d = h - 1, p = 1 / d; for (let _ = 0; _ < h; _++) { const x = _ * p; let b = 0; for (let D = 0; D < l.length; D++) { if (x < l[0].x) { b = 0; break } if (x > l[l.length - 1].x) { b = l.length - 1; break } const R = l[D - 1] || l[D], P = l[D]; if (R.x <= x && P.x >= x) { b = D; break } } const T = l[b], M = l[b - 1] || T, w = T.x === M.x ? 0 : math.fit(x, M.x, T.x, 0, 1); c.push(math.lerp(M.y, T.y, w)) } const f = _ => { const x = math.clamp(_, 0, 1) * d, b = Math.ceil(x), T = Math.max(0, b - 1), M = x - T; return math.lerp(c[T], c[b], M) }; return customEasesCache.set(s, f), f } customEase("inOut1", "M0,0 C0.5,0 0.1,1 1,1"); customEase("inOut2", "M0,0 C0.56,0 0,1 1,1"); customEase("inOut3", "M0,0 C0.6,0 0,1 1,1"); const easeInPower = r => e => Math.pow(e, r), easeIns = { power1: easeInPower(2), power2: easeInPower(3), power3: easeInPower(4), power4: easeInPower(5), sine: r => 1 - Math.cos(r * math.HALF_PI), circ: r => 1 - Math.sqrt(1 - r * r), expo: r => r ? Math.pow(2, 10 * r - 10) : 0, bounce: r => { let e = 0, i = 4; for (; r < ((e = Math.pow(2, --i)) - 1) / 11;); return 1 / Math.pow(4, 3 - i) - 7.5625 * Math.pow((e * 3 - 2) / 22 - r, 2) }, back: (r = 1.70158) => e => (r + 1) * e * e * e - r * e * e, elastic: (r = 1, e = .3) => { const i = math.clamp(r, 1, 10), s = math.clamp(e, 1e-11, 2), a = s / math.TWO_PI * Math.asin(1 / i), o = math.TWO_PI / s; return l => l === 0 || l === 1 ? l : -i * Math.pow(2, -10 * (1 - l)) * Math.sin((1 - l - a) * o) } }, easeTypes = { in: r => e => r(e), out: r => e => 1 - r(1 - e), inout: r => e => e < .5 ? r(e * 2) / 2 : 1 - r(e * -2 + 2) / 2, outin: r => e => e < .5 ? (1 - r(1 - e * 2)) / 2 : (r(e * 2 - 1) + 1) / 2 }, easeMap = { linear: r => r, none: r => r }; for (const r in easeTypes) for (const e in easeIns) { const i = e === "back" || e === "elastic", s = easeIns[e], a = easeTypes[r], o = a(i ? s() : s), l = `${e}.${r}`, c = `${e}${r}`; if (easeMap[l] = o, easeMap[c] = o, i) { const h = (d, p) => a(s(d, p)); easeMap[`${l}_fn`] = h, easeMap[`${c}_fn`] = h } } const functionStrRegexp = /([\w.]+)(\(([\d., ]+)\))?/; function getEase(r = "linear") { if (typeof r == "function") return r; if (typeof r != "string") return easeMap.linear; const e = r.toLowerCase(); if (easeMap[e]) return easeMap[e]; if (customEasesCache.has(r)) return customEasesCache.get(r); if (customEasesCache.has(e)) return customEasesCache.get(e); const i = functionStrRegexp.exec(e), s = i[1], a = i[3]; return s && easeMap[`${s}_fn`] && a ? easeMap[`${s}_fn`](...a.split(",").map(Number)) : (console.warn(`Invalid ease "${r}". Using linear instead.`), easeMap.linear) } const noop$1 = () => { }, numberUnitRegexp = /([\d.]+)([\d\D]*)$/; var Hi, En, Zt, li, Tn, Mn, bs, Tr, Ga; const Bi = class Bi extends animation { constructor(i, { from: s = {}, to: a = {}, duration: o = 0, delay: l = 0, ease: c = "power2.inOut", onStart: h = noop$1, onUpdate: d = noop$1, onComplete: p = noop$1, paused: f = !1, overwrite: _ = !0 } = {}) { super({ delay: l, onStart: h, onUpdate: d, onComplete: p, paused: f, overwrite: _ }); pe(this, Tr); pe(this, Hi, null); pe(this, En, !1); pe(this, Zt, {}); pe(this, li, {}); pe(this, Tn, {}); pe(this, Mn, {}); pe(this, bs, i => i); Ke(this, "isTween", !0); Ke(this, "_isTimelineInitializer", !1); this._duration = Math.max(0, o), Xe(this, Hi, i), Xe(this, Zt, s), Xe(this, li, a), Xe(this, En, i instanceof HTMLElement), Xe(this, bs, getEase(c)), Pe(this, Tr, Ga).call(this), super._animationAutoPlay() } get _obj() { return L(this, Hi) } get _from() { return L(this, Zt) } _removeProp(i) { delete L(this, Zt)[i], delete L(this, li)[i], delete L(this, Tn)[i], delete L(this, Mn)[i] } _animationPerformUpdate(i, s, a) { const o = s >= 1; if (a || o) { const l = L(this, bs).call(this, math.clamp(s, 0, 1)); for (const c in L(this, Zt)) { const h = L(this, Zt)[c], d = L(this, li)[c]; let p = L(this, Tn)[c] === Bi.TYPES.number ? math.lerp(h, d, l) : l < .5 ? h : d; L(this, Mn)[c] && (p = `${p}${L(this, Mn)[c]}`), L(this, En) ? L(this, Hi).style[c] = p : L(this, Hi)[c] = p } } } _animationAfterUpdate(i, s, a) { L(this, En) && !t$1._ticking && console.warn("tween updating the DOM outside a rAF loop. This may cause performance issues.") } }; Hi = new WeakMap, En = new WeakMap, Zt = new WeakMap, li = new WeakMap, Tn = new WeakMap, Mn = new WeakMap, bs = new WeakMap, Tr = new WeakSet, Ga = function () { for (const i in L(this, li)) L(this, Zt)[i] === void 0 && (L(this, En) ? L(this, Zt)[i] = L(this, Hi).style[i] : L(this, Zt)[i] = L(this, Hi)[i]); for (const i in L(this, Zt)) { L(this, li)[i] === void 0 && (L(this, li)[i] = L(this, Zt)[i]); const s = L(this, Zt)[i], a = typeof s; if (!Bi.TYPES_STR.includes(a)) throw new Error(`tween: invalid type "${a}" for property "${i}".`); if (a !== typeof L(this, li)[i] && (console.warn(`tween: "from" and "to" values for "${i}" must be of the same type. This property won't animate.`), L(this, li)[i] = s), a !== "string") { L(this, Tn)[i] = Bi.TYPES[a]; continue } let o = numberUnitRegexp.exec(s); const l = o && !isNaN(o[1]); l && (L(this, Zt)[i] = Number(o[1])), L(this, Tn)[i] = l ? Bi.TYPES.number : Bi.TYPES.string, l && o[2] !== "" && (L(this, Mn)[i] = o[2]), l && (o = numberUnitRegexp.exec(L(this, li)[i]), L(this, li)[i] = Number(o[1])) } }, Ke(Bi, "TYPES", { number: 0, boolean: 1, string: 2 }), Ke(Bi, "TYPES_STR", Object.keys(Bi.TYPES)); let tween = Bi; function ease(r, e) { return getEase(r)(Math.max(0, Math.min(1, e))) } function addToTicker(r) { t$1.add({ tick: r }) } function createTween(r, e) { return new tween(r, e) } function createDelayedCall(r = 0, e) { return new tween({}, { delay: r, duration: 0, onComplete: e }) } t$1.onAverageFPS = r => events.emit("average_fps_update", r); const renderEvents = ["internal_prerender", "prerender", "render", "postrender", "internal_postrender"]; addToTicker((r, e, i) => { renderEvents.forEach(s => events.emit(s, r, e)) }); class WebGL { static isWebGL2Available() { try { const e = document.createElement("canvas"); return !!(window.WebGL2RenderingContext && e.getContext("webgl2")) } catch { return !1 } } static isColorSpaceAvailable(e) { try { const i = document.createElement("canvas"), s = window.WebGL2RenderingContext && i.getContext("webgl2"); return s.drawingBufferColorSpace = e, s.drawingBufferColorSpace === e } catch { return !1 } } static getWebGL2ErrorMessage() { return this._getErrorMessage(2) } static _getErrorMessage(e) { const i = { 1: "WebGL", 2: "WebGL 2" }, s = { 1: window.WebGLRenderingContext, 2: window.WebGL2RenderingContext }; let a = 'Your $0 does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">$1</a>'; const o = document.createElement("div"); return o.id = "webglmessage", o.style.fontFamily = "monospace", o.style.fontSize = "13px", o.style.fontWeight = "normal", o.style.textAlign = "center", o.style.background = "#fff", o.style.color = "#000", o.style.padding = "1.5em", o.style.width = "400px", o.style.margin = "5em auto 0", s[e] ? a = a.replace("$0", "graphics card") : a = a.replace("$0", "browser"), a = a.replace("$1", i[e]), o.innerHTML = a, o } } const key = "App3D_data"; let dataObject = null; try { dataObject = JSON.parse(localStorage.getItem(key) || "{}") } catch (r) { console.warn("Failed to parse localStorage data, resetting to empty object", r), dataObject = {} } const update = r => localStorage.setItem(key, JSON.stringify(r)), storage = new Proxy(dataObject, { set: (r, e, i) => (r[e] = i, update(r), !0), deleteProperty: (r, e) => e in r ? (delete r[e], Object.keys(r).length > 0 ? update(r) : localStorage.removeItem(key), !0) : !1 }); var ka, Zi, ds, Va, Mr, Qi, di, ia, na, sa, Ha; const ln = class ln { constructor() { pe(this, di); pe(this, Mr, document.querySelector("html")); Ke(this, "capabilities", { webgpu: navigator.gpu !== void 0, webgl2: WebGL.isWebGL2Available(), touch: "ontouchstart" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0, offscreenCanvas: !!HTMLCanvasElement.prototype.transferControlToOffscreen, userMedia: !!(navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia), matchMedia: !!window.matchMedia, colorScheme: !!((ka = window.matchMedia) != null && ka.call(window, "(prefers-color-scheme: dark)")), fullScreen: document.fullscreenEnabled || document.mozFullscreenEnabled || document.webkitFullscreenEnabled || document.msFullscreenEnabled, geo: typeof navigator.geolocation < "u", gamepad: !!navigator.getGamepads, opus: !0, imageBitmap: !0 }); Ke(this, "relativePath", ""); Ke(this, "absolutePath", window.location.origin + (window.location.hostname.includes("github.io") ? "/test3d" : "")); Ke(this, "https", window.location.protocol === "https:"); Ke(this, "crossOriginIsolated", !!window.crossOriginIsolated); Ke(this, "userAgent", navigator.userAgent); Ke(this, "language", (navigator.language || navigator.userLanguage).substr(0, 2)); Ke(this, "darkMode", this.capabilities.colorScheme ? window.matchMedia("(prefers-color-scheme: dark)").matches : !1); Ke(this, "visible", !0); Ke(this, "focused", !0); Ke(this, "localStorage", storage); Ke(this, "electron", this.userAgent.toLowerCase().indexOf(" electron/") > -1); Ke(this, "iOS", !1); Ke(this, "iOSVersion", 0); Ke(this, "oldIphone", !1); Ke(this, "iphone", !1); Ke(this, "lowMemoryDevice", !1); Ke(this, "browser", { name: "", version: 0 }); Ke(this, "screen", { dpr: window.devicePixelRatio || 1, aspectRatio: 1, width: 0, height: 0, w: 0, h: 0 }); pe(this, Qi, null); Ke(this, "boundVisibilityChange", Pe(this, di, na).bind(this)); Ke(this, "boundFocusChange", Pe(this, di, sa).bind(this)); Ke(this, "boundDarkModeChange", Pe(this, di, Ha).bind(this)); Ke(this, "query", new Proxy(new URLSearchParams(window.location.search), { get: (e, i) => e.get(i) })); Ke(this, "devScene", !1); var e, i, s, a; if (/firefox|iceweasel|fxios/i.test(this.userAgent) === !0) { this.browser.name = "firefox"; const o = this.userAgent.match(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i); this.browser.version = o ? Pe(e = ln, Zi, ds).call(e, o[1]) : 0 } if (/(ipod|iphone|ipad)/i.test(this.userAgent) === !0) { this.iOS = !0; const o = this.userAgent.match(/os (\d+([_\s]\d+)*) like mac os x/i); this.iOSVersion = o ? Pe(i = ln, Zi, ds).call(i, o[1].replace(/[_\s]/g, ".")) : 0 } if (!this.browser.name && /^((?!chrome|android).)*safari/i.test(this.userAgent) === !0) { this.browser.name = "safari"; const o = this.userAgent.match(/version\/(\d+(\.?_?\d+)+)/i); this.browser.version = o ? Pe(s = ln, Zi, ds).call(s, o[1]) : 0, this.browser.version === 0 && this.iOS && (this.browser.version = this.iOSVersion) } if (!this.browser.name && /chrome|crios|crmo/i.test(this.userAgent) === !0) { this.browser.name = "chrome"; const o = this.userAgent.match(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i); this.browser.version = o ? Pe(a = ln, Zi, ds).call(a, o[1]) : 0 } !this.iOS && this.browser.name === "safari" && this.capabilities.touch && (this.iOS = !0, this.iOSVersion = this.browser.version), this.iOS && Math.min(window.screen.width, window.screen.height) / Math.max(window.screen.width, window.screen.height) < .65 && (this.iphone = !0, this.oldIphone = window.devicePixelRatio < 3), this.capabilities.opus = this.browser.name !== "safari", (this.browser.name === "safari" || this.browser.name === "firefox" && this.browser.version < 100 || this.iOS && this.browser.name !== "safari") && (this.capabilities.imageBitmap = !1), this.lowMemoryDevice = this.iphone, Xe(this, Qi, miscutils.debounce(Pe(this, di, ia).bind(this), this.iOS ? 500 : 50)), this.init() } init() { window.addEventListener("resize", L(this, Qi)), window.addEventListener("orientationchange", L(this, Qi)), Pe(this, di, ia).call(this), L(this, Qi).call(this), document.addEventListener("visibilitychange", this.boundVisibilityChange), window.addEventListener("focus", this.boundFocusChange), window.addEventListener("blur", this.boundFocusChange), this.capabilities.colorScheme && window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", this.boundDarkModeChange), Pe(this, di, na).call(this), Pe(this, di, sa).call(this) } setRelativePath(e) { var i; this.relativePath = Pe(i = ln, Zi, Va).call(i, e), this.absolutePath = window.location.origin + (window.location.hostname.includes("github.io")?"/test3d":"") } dispose() { window.removeEventListener("resize", L(this, Qi)), window.removeEventListener("orientationchange", L(this, Qi)), document.removeEventListener("visibilitychange", this.boundVisibilityChange), window.removeEventListener("focus", this.boundFocusChange), window.removeEventListener("blur", this.boundFocusChange), this.capabilities.colorScheme && window.matchMedia("(prefers-color-scheme: dark)").removeEventListener("change", this.boundDarkModeChange) } }; Zi = new WeakSet, ds = function (e) { return Number(e.match(/\d+.?\d*/)[0]) }, Va = function (e) { return e.replace(/^\/+|\/+$/g, "") }, Mr = new WeakMap, Qi = new WeakMap, di = new WeakSet, ia = function () { const e = Math.max(2, window.innerWidth), i = Math.max(2, window.innerHeight); this.screen.width = e, this.screen.height = i, this.screen.w = e, this.screen.h = i, this.screen.aspectRatio = e / i, this.iOS && Math.min(window.screen.width, window.screen.height) !== i && (L(this, Mr).scrollTop = -1), events.emit("resize", e, i) }, na = function () { this.visible = document.visibilityState === "visible", events.emit("visibility_change", this.visible) }, sa = function () { this.focused = document.hasFocus(), events.emit("focus_change", this.focused) }, Ha = function (e) { this.darkMode = e.matches, events.emit("dark_mode_change", this.darkMode) }, pe(ln, Zi); let client = ln; const client$1 = new client; var Ir, Br, jn, Kn, Jn, Zn, ws, Gt, ra, mr, aa, gr, Qa, vr; const Wn = class Wn { constructor(e = 0) { pe(this, Gt); pe(this, jn, new Vector2); pe(this, Kn, new Vector2); pe(this, Jn, new Vector2); pe(this, Zn, new Vector2); pe(this, ws, 0); this.finger = e, this.touchID = !1, this.eventID = this.finger === 0 ? "touch" : `touch${this.finger + 1}`, this.input = this.finger === 0 ? "mouse" : "touch", this.button = 0, this.position = new Vector2(client$1.screen.w * .5, client$1.screen.h * .5), this.position01 = new Vector2(.5, .5), this.position11 = new Vector2, this.delta = new Vector2, this.delta11 = new Vector2, this.dragged = new Vector2, this.dragged11 = new Vector2, this.swipeVelocity = new Vector2, L(this, jn).copy(this.position), L(this, Kn).copy(this.position01), L(this, Jn).copy(this.position), L(this, Zn).copy(this.position01) } onTouchStart(e) { Xe(this, ws, renderInfo.time), Pe(this, Gt, ra).call(this, e), Pe(this, Gt, mr).call(this, e), Pe(this, Gt, aa).call(this), Pe(this, Gt, gr).call(this), Pe(this, Gt, Qa).call(this), Pe(this, Gt, vr).call(this), events.emit(`${this.eventID}_start`, this) } onTouchMove(e) { this.touchID === !1 && Pe(this, Gt, ra).call(this, e), Pe(this, Gt, mr).call(this, e), Pe(this, Gt, gr).call(this), events.emit(`${this.eventID}_move`, this), this.touchID !== !1 && (Pe(this, Gt, vr).call(this), events.emit(`${this.eventID}_drag`, this)) } onTouchEnd(e) { Pe(this, Gt, mr).call(this, e), Pe(this, Gt, gr).call(this), Pe(this, Gt, vr).call(this); const i = Math.max(.001, renderInfo.time - L(this, ws)); this.swipeVelocity.copy(this.dragged).divideScalar(i), events.emit(`${this.eventID}_end`, this), !(this.dragged.length() >= L(Wn, Ir) || i >= L(Wn, Br)) && (this.input === "mouse" && this.button !== 0 || e.type !== "pointerout" && events.emit(`${this.eventID}_click`, this)) } dispose() { } }; Ir = new WeakMap, Br = new WeakMap, jn = new WeakMap, Kn = new WeakMap, Jn = new WeakMap, Zn = new WeakMap, ws = new WeakMap, Gt = new WeakSet, ra = function (e) { this.input = e.pointerType === "mouse" ? "mouse" : "touch", this.button = e.button }, mr = function (e) { const i = e, s = i.clientX, a = i.clientY; this.position.set(s, a), this.position01.set(s / client$1.screen.w, 1 - a / client$1.screen.h), this.position11.copy(this.position01).multiplyScalar(2).subScalar(1) }, aa = function () { L(this, Jn).copy(this.position), L(this, Zn).copy(this.position01) }, gr = function () { this.delta.copy(this.position).sub(L(this, Jn)), this.delta11.copy(this.position01).sub(L(this, Zn)), Pe(this, Gt, aa).call(this) }, Qa = function () { L(this, jn).copy(this.position), L(this, Kn).copy(this.position01) }, vr = function () { this.dragged.copy(this.position).sub(L(this, jn)), this.dragged11.copy(this.position01).sub(L(this, Kn)) }, pe(Wn, Ir, 25), pe(Wn, Br, .5); let touch = Wn; var Ai, Ht, fn, Wt, oa, la, Wa, qa, $a, Xa, Ya; class touches { constructor() { pe(this, Wt); pe(this, Ai, []); pe(this, Ht, null); pe(this, fn, !0); Ke(this, "allowTouchStart", !1); Ke(this, "boundTouchesStart", Pe(this, Wt, Wa).bind(this)); Ke(this, "boundTouchesMove", Pe(this, Wt, qa).bind(this)); Ke(this, "boundTouchesEnd", Pe(this, Wt, $a).bind(this)); Ke(this, "boundPreventTouchesStart", Pe(this, Wt, Xa).bind(this)); Ke(this, "boundPreventDefault", Pe(this, Wt, Ya).bind(this)) } get(e) { return L(this, Ai)[e] } getActive() { return L(this, Ai).filter(e => e.touchID !== !1) } init({ element: e = window, fingers: i = 2, contextMenu: s = !1 } = {}) { Xe(this, Ht, e), Xe(this, fn, L(this, Ht) instanceof HTMLCanvasElement); for (let a = 0; a < i; a++)L(this, Ai).push(new touch(a, L(this, Ai))); e !== window && (e.style.touchAction = "none", L(this, fn) && (e.style.userSelect = "none")), L(this, Ht).addEventListener("pointerdown", this.boundTouchesStart), L(this, Ht).addEventListener("pointermove", this.boundTouchesMove), L(this, Ht).addEventListener("pointerup", this.boundTouchesEnd), L(this, Ht).addEventListener("pointerout", this.boundTouchesEnd), L(this, Ht).addEventListener("pointercancel", this.boundTouchesEnd), s || L(this, Ht).addEventListener("contextmenu", this.boundPreventDefault), e.addEventListener("touchstart", this.boundPreventTouchesStart, { passive: !1 }), document.addEventListener("dblclick", this.boundPreventDefault) } dispose() { L(this, Ht).removeEventListener("pointerdown", this.boundTouchesStart), L(this, Ht).removeEventListener("pointermove", this.boundTouchesMove), L(this, Ht).removeEventListener("pointerup", this.boundTouchesEnd), L(this, Ht).removeEventListener("pointerout", this.boundTouchesEnd), L(this, Ht).removeEventListener("pointercancel", this.boundTouchesEnd), L(this, Ht).removeEventListener("contextmenu", this.boundPreventDefault), L(this, Ht).removeEventListener("touchstart", this.boundPreventTouchStart), document.removeEventListener("dblclick", this.boundPreventDefault), L(this, Ai).forEach(e => e.dispose()), L(this, Ai).length = 0, Xe(this, Ht, null), Xe(this, fn, !0) } } Ai = new WeakMap, Ht = new WeakMap, fn = new WeakMap, Wt = new WeakSet, oa = function () { return L(this, Ai).find(e => e.touchID === !1) }, la = function (e) { return L(this, Ai).find(i => i.touchID === e.pointerId) }, Wa = function (e) { const i = Pe(this, Wt, oa).call(this); i && (L(this, fn) && this.getActive().length === 0 && L(this, Ht).setPointerCapture(e.pointerId), i.touchID = e.pointerId, i.onTouchStart(e)) }, qa = function (e) { var i; (i = Pe(this, Wt, la).call(this, e) || Pe(this, Wt, oa).call(this)) == null || i.onTouchMove(e) }, $a = function (e) { const i = Pe(this, Wt, la).call(this, e); i && (i.onTouchEnd(e), i.touchID = !1, L(this, fn) && this.getActive().length === 0 && L(this, Ht).releasePointerCapture(e.pointerId)) }, Xa = function (e) { this.allowTouchStart || e.preventDefault() }, Ya = function (e) { e.preventDefault() }; const touches$1 = new touches, STATES = { RUNNING: "running" }; var es, Wi, fi, ja, ca, ha, ua; class audioContext { constructor() { pe(this, fi); pe(this, es, null); pe(this, Wi, Pe(this, fi, ha).bind(this)); Ke(this, "context", AudioContext.getContext()); Ke(this, "contextReady", miscutils.deferred()); Ke(this, "contextStarted", !1) } get isRunning() { return this.context.state === STATES.RUNNING } init() { this.isRunning ? Pe(this, fi, ha).call(this) : Pe(this, fi, ja).call(this), events.on("visibility_change", Pe(this, fi, ua), this) } dispose() { Pe(this, fi, ca).call(this), clearTimeout(L(this, es)), events.off("visibility_change", Pe(this, fi, ua), this), this.contextReady.reject(), this.contextReady = miscutils.deferred(), this.context.close(), this.contextStarted = !1, AudioContext.setContext(void 0), this.context = AudioContext.getContext() } } es = new WeakMap, Wi = new WeakMap, fi = new WeakSet, ja = function () { touches$1.allowTouchStart = !0, document.body.addEventListener("click", L(this, Wi)), events.on("touch_end", L(this, Wi)), events.on("keydown", L(this, Wi)) }, ca = function () { touches$1.allowTouchStart = !1, document.body.removeEventListener("click", L(this, Wi)), events.off("touch_end", L(this, Wi)), events.off("keydown", L(this, Wi)) }, ha = async function () { try { if (await this.context.resume(), this.contextStarted) return; this.contextStarted = !0, Pe(this, fi, ca).call(this), this.contextReady.resolve() } catch (e) { console.log("audio context error:", e) } }, ua = function (e) { this.contextStarted && (clearTimeout(L(this, es)), e && !this.isRunning && (client$1.iOS ? Xe(this, es, setTimeout(() => this.context.resume(), 500)) : this.context.resume())) }; const audiocontext = new audioContext, bufferLoader$1 = new FileLoader; bufferLoader$1.setResponseType("arraybuffer"); const offlineAudioContext = new OfflineAudioContext(2, 1, AudioContext.getContext().sampleRate), audiobufferLoader = { _audiobuffersCache: new Map, _initLoad(r, e) { return this._audiobuffersCache.has(r) || this._audiobuffersCache.set(r, new Promise(e)), this._audiobuffersCache.get(r) }, load(r, e = !1) { return this._initLoad(r, async i => { try { const s = r.endsWith(".ogg") && !client$1.capabilities.opus ? `${r.slice(0, -3)}mp3` : r, a = await bufferLoader$1.loadAsync(s); offlineAudioContext.decodeAudioData(a, o => { i(o) }, () => { throw new Error(`audio could not be decoded: ${r}`) }) } catch (s) { console.log(`audio ${r} load error: ${s}`), i(!1) } e || deleteFromCache$3(r) }) } }; function deleteFromCache$3() { for (const r of arguments) audiobufferLoader._audiobuffersCache.delete(r) } function disposeAudioBuffers() { audiobufferLoader._audiobuffersCache.clear() } function setAudioBuffersPath() { bufferLoader$1.setPath(`${client$1.absolutePath}/assets/audio/`) } var qi, xi, $i, bi, Xi, Yt, ei, Dr, Ss, Cs, In, Nt, tn, da, fa, pa, ma, ga, ts; let audioController$1 = (ts = class { constructor({ camera: e = null, volume: i = 1, muted: s = !0 } = {}) { pe(this, Nt); pe(this, qi, null); pe(this, xi, 1); pe(this, $i, 0); pe(this, bi, !0); pe(this, Xi, client$1.visible); pe(this, Yt, new AudioListener); pe(this, ei, new Map); pe(this, Dr, .1); pe(this, Ss, 0); pe(this, Cs, !0); pe(this, In, !1); Xe(this, qi, e), L(this, qi) && L(this, qi).add(L(this, Yt)), Xe(this, xi, Math.max(0, i)), Xe(this, bi, s), L(this, Yt).setMasterVolume(L(this, $i)), events.on("visibility_change", Pe(this, Nt, da), this), events.on("audio_mute_toggle", Pe(this, Nt, fa), this), events.on("audio_global_volume", Pe(this, Nt, pa), this), events.on("prerender", Pe(this, Nt, ma), this), audiocontext.contextReady.then(() => { L(this, bi) && events.emit("audio_mute_toggle"), Pe(this, Nt, tn).call(this, L(this, xi), 3) }).catch(() => { console.warn("audio failed to set volume") }) } static constantToTime(e = 0, i = 1, s = .01, a = .001) { const o = i !== 0 ? s * Math.log(Math.abs(i - e) / a / i) : s * Math.log(e / a); return Math.max(a, o) } static timeToConstant(e = 0, i = 1, s = 1, a = .001) { const o = i !== 0 ? s / Math.log(Math.abs(i - e) / a / i) : s / Math.log(e / a); return Math.max(a, o) } get listener() { return L(this, Yt) } get muted() { return L(this, bi) } addAudio({ name: e = "default", url: i, volume: s = 1, autoPlay: a = !1, loop: o = !1, playbackRate: l = 1, offset: c = 0, sync: h = !1, syncOffset: d = 0, minTimeBetweenPlays: p = 0 } = {}) { return Pe(this, Nt, ga).call(this, { name: e, url: i, volume: s, autoPlay: a, loop: o, playbackRate: l, offset: c, sync: h, syncOffset: d, minTimeBetweenPlays: p }) } addPositionalAudio({ name: e = "default", url: i, volume: s = 1, autoPlay: a = !0, loop: o = !0, playbackRate: l = 1, offset: c = 0, sync: h = !1, syncOffset: d = 0, minTimeBetweenPlays: p = 0, refDistance: f = 1, rolloffFactor: _ = 1, distanceModel: x = "inverse", maxDistance: b = 1e4, directionalCone: T = [360, 0, 0] } = {}) { return Pe(this, Nt, ga).call(this, { name: e, url: i, volume: s, autoPlay: a, loop: o, playbackRate: l, offset: c, sync: h, syncOffset: d, minTimeBetweenPlays: p, positional: { refDistance: f, rolloffFactor: _, distanceModel: x, maxDistance: b, directionalCone: T } }) } playAudio(e = "default", i = 0) { const s = L(this, ei).get(e); !s || !audiocontext.isRunning || renderInfo.time - s._timeLastPlayed > s._minTimeBetweenPlays && (s._timeLastPlayed = renderInfo.time, s.stop().play(i)) } pauseAudio(e = "default") { const i = L(this, ei).get(e); !i || !audiocontext.isRunning || i.pause() } stopAudio(e = "default") { const i = L(this, ei).get(e); !i || !audiocontext.isRunning || i.stop() } setAudioVolume(e = "default", i = 1) { const s = L(this, ei).get(e); s && (s.individualVolume = Math.max(0, i), s.setVolume(s.individualVolume)) } setFilter(e) { L(this, Yt).setFilter(e) } getFilter() { return L(this, Yt).getFilter() } removeFilter() { L(this, Yt).removeFilter() } async dispose({ delay: e = 0, duration: i = .35 } = {}) { events.off("audio_global_volume", Pe(this, Nt, pa), this), e > 0 && await miscutils.wait(e), Xe(this, xi, 0), Pe(this, Nt, tn).call(this, L(this, xi), i), i > 0 && await miscutils.wait(i), events.off("visibility_change", Pe(this, Nt, da), this), events.off("audio_mute_toggle", Pe(this, Nt, fa), this), events.off("prerender", Pe(this, Nt, ma), this), L(this, ei) && (L(this, ei).forEach(s => { s.stop(), s.disconnect(), s.source = null, s.buffer = null }), L(this, ei).clear(), Xe(this, ei, null)), L(this, Yt) && (L(this, qi) && L(this, qi).remove(L(this, Yt)), L(this, Yt).gain.disconnect(audiocontext.context.destination)), Xe(this, qi, null), Xe(this, Yt, null), Xe(this, In, !0) } }, qi = new WeakMap, xi = new WeakMap, $i = new WeakMap, bi = new WeakMap, Xi = new WeakMap, Yt = new WeakMap, ei = new WeakMap, Dr = new WeakMap, Ss = new WeakMap, Cs = new WeakMap, In = new WeakMap, Nt = new WeakSet, tn = function (e = 1, i = 1.5) { if (L(this, In)) return; let s = e; if ((!audiocontext.contextStarted || !L(this, Xi) || L(this, bi)) && (s = 0), s === L(this, $i)) return; Xe(this, $i, Math.max(0, s)); const a = Math.max(.1, audiocontext.context.currentTime), o = L(this, Cs) && L(this, $i) > 0; o && Xe(this, Cs, !1); const l = Math.max(.01, o ? 3 : i), c = ts.timeToConstant(L(this, Yt).gain.gain.value, L(this, $i), l); L(this, Yt).gain.gain.setTargetAtTime(L(this, $i), a, c) }, da = function (e) { e ? L(this, Xi) || (Xe(this, Xi, !0), Pe(this, Nt, tn).call(this, L(this, xi), 2)) : L(this, Xi) && (Xe(this, Xi, !1), Pe(this, Nt, tn).call(this, 0, 1.5)) }, fa = function () { Xe(this, bi, !L(this, bi)), L(this, bi) ? Pe(this, Nt, tn).call(this, 0, 1) : Pe(this, Nt, tn).call(this, L(this, xi), 1), events.emit("audio_update_mute", L(this, bi)) }, pa = function (e = {}) { let i = 1, s = .2; typeof e == "number" ? i = e : typeof e == "object" && (i = typeof e.volume == "number" ? e.volume : 1, s = typeof e.time == "number" ? e.time : .2), Xe(this, xi, Math.max(0, i)), Pe(this, Nt, tn).call(this, L(this, xi), s) }, ma = function () { if (!L(this, Xi) || !audiocontext.isRunning) return; const e = renderInfo.time - audiocontext.context.currentTime, i = Math.abs(e - L(this, Ss)) > L(this, Dr); L(this, ei).forEach(s => { s && i && s._animationSync && (s.pause(), s._progress = (renderInfo.time + s._animationSyncOffset) * s.playbackRate % (s.duration || s.buffer.duration), s.play()) }), i && Xe(this, Ss, e) }, ga = async function ({ name: e, url: i, volume: s, autoPlay: a, loop: o, playbackRate: l, offset: c, sync: h, syncOffset: d, minTimeBetweenPlays: p, positional: f = null } = {}) { if (L(this, ei).has(e)) throw new Error(`audio ${e} already exists`); L(this, ei).set(e, null); try { const _ = await audiobufferLoader.load(i); if (!_ || L(this, In)) return; const x = new (f ? PositionalAudio : Audio)(L(this, Yt)); if (x.setBuffer(_), x.setLoop(o), x.setPlaybackRate(l), x.offset = c, x._animationSync = h, x._animationSyncOffset = d, x._minTimeBetweenPlays = p, x._timeLastPlayed = 0, f && (x.setRefDistance(f.refDistance), x.setRolloffFactor(f.rolloffFactor), x.setDistanceModel(f.distanceModel), x.setMaxDistance(f.maxDistance), x.setDirectionalCone(...f.directionalCone)), x.individualVolume = Math.max(0, s), x.setVolume(x.individualVolume), await audiocontext.contextReady.then(() => miscutils.wait(.5)), L(this, In)) throw new Error(`audio controller disposed during audio "${e}" creation.`); return a && audiocontext.isRunning && !x.isPlaying && x.play(), L(this, ei).set(e, x), x } catch (_) { console.log(_) } }, ts); const _v20 = new Vector2; var zn, va, Ka; const Gi = class Gi { constructor() { pe(this, zn); Ke(this, "stick1", new Vector2); Ke(this, "stick2", new Vector2); Ke(this, "buttons", Array(4).fill(!1)); Ke(this, "boundUpdate", Pe(this, zn, Ka).bind(this)) } static controlDeadZone(e = 0) { return e * math.smoothstep(Gi.DEADZONE[0], Gi.DEADZONE[1], Math.abs(e)) } init() { client$1.capabilities.gamepad && events.on("prerender", this.boundUpdate) } dispose() { events.off("prerender", this.boundUpdate), Pe(this, zn, va).call(this) } }; zn = new WeakSet, va = function () { this.stick1.set(0, 0), this.stick2.set(0, 0), this.buttons.fill(!1) }, Ka = function () { const e = this.stick1.toArray(), i = this.stick2.toArray(), s = this.buttons.slice(); Pe(this, zn, va).call(this); const o = navigator.getGamepads().find(l => l == null ? void 0 : l.connected); if (o && (o.axes.length >= 2 && (this.stick1.x = Gi.controlDeadZone(o.axes[0]), this.stick1.y = Gi.controlDeadZone(o.axes[1]), this.stick1.multiplyScalar(-1), o.axes.length >= 4 && (this.stick2.x = Gi.controlDeadZone(o.axes[2]), this.stick2.y = Gi.controlDeadZone(o.axes[3]), this.stick1.multiplyScalar(-1))), o.buttons.length > 0)) { const l = Math.min(this.buttons.length, o.buttons.length); for (let c = 0; c < l; c++)this.buttons[c] = o.buttons[c].pressed } (!this.stick1.equals(_v20.fromArray(e)) || !this.stick2.equals(_v20.fromArray(i)) || !this.buttons.every((l, c) => l === s[c])) && events.emit("gamepad_update", this) }, Ke(Gi, "DEADZONE", [.15, .25]); let gamepad = Gi; const gamepad$1 = new gamepad; var Rr, is, mn, Es, Ts, Ms, Pr, Ja; const Lr = class Lr { constructor() { pe(this, Pr); pe(this, is, new Vector2); pe(this, mn, null); pe(this, Es, !0); pe(this, Ts, !1); pe(this, Ms, new Vector2); Ke(this, "boundWheel", Pe(this, Pr, Ja).bind(this)); Ke(this, "position", new Vector2); Ke(this, "delta", new Vector2); Ke(this, "isPinching", !1) } init({ element: e = window } = {}) { Xe(this, mn, e), Xe(this, Es, L(this, mn) instanceof HTMLCanvasElement), Xe(this, Ts, client$1.browser.name === "firefox"), L(this, mn).addEventListener("wheel", this.boundWheel, { passive: !1 }) } dispose() { L(this, mn).removeEventListener("wheel", this.boundWheel), Xe(this, mn, null) } }; Rr = new WeakMap, is = new WeakMap, mn = new WeakMap, Es = new WeakMap, Ts = new WeakMap, Ms = new WeakMap, Pr = new WeakSet, Ja = function (e) { L(this, Es) && (e.preventDefault(), e.stopPropagation()), this.isPinching = e.ctrlKey, L(this, is).set(e.deltaX, e.deltaY), L(this, Ts) && e.deltaMode === 1 && L(this, is).multiplyScalar(L(Lr, Rr)), this.position.add(L(this, is)), this.delta.copy(this.position).sub(L(this, Ms)), L(this, Ms).copy(this.position), events.emit("wheel", this) }, pe(Lr, Rr, 33); let wheel = Lr; const wheel$1 = new wheel; var gi, Ur, Fr, Is; const Xt = class Xt { constructor({ nodes: e = [], onHover: i = null, onTouch: s = null, onMove: a = null, onDrag: o = null, onClick: l = null, ctx: c = null, disablePointerEvents: h = !0, hoverCursor: d = !1, grabCursor: p = !1 } = {}) { pe(this, Is, e => !touches$1.allowTouchStart && e.preventDefault()); this._enabled = !1, this._nodes = Array.isArray(e) ? e : [e], this._onHover = i, this._onTouch = s, this._onMove = a, this._onDrag = o, this._onClick = l, this._ctx = c, this._touchStartCbs = this._nodes.map((f, _) => x => this._handleEvent(x, L(Xt, gi).TOUCH_START, f, _)), this._touchMoveCbs = this._nodes.map((f, _) => x => this._handleEvent(x, L(Xt, gi).TOUCH_MOVE, f, _)), this._touchEndCbs = this._nodes.map((f, _) => x => this._handleEvent(x, L(Xt, gi).TOUCH_END, f, _)), this._disablePointerEvents = h, this._disablePointerEvents && this._nodes.forEach(f => f.style.pointerEvents = "none"), this._hoverCursor = d, this._grabCursor = p && !d, this.starts = this._nodes.map(() => ({ position: { x: 0, y: 0 }, time: 0 })), this.hovering = this._nodes.map(() => !1), this.touching = this._nodes.map(() => !1), this.dragging = this._nodes.map(() => !1) } _performHover(e, i, s, a) { this.hovering[a] = i === "hover_in", this._callBack(this._onHover, i, s, a, e), this._hoverCursor && (s.style.cursor = this.hovering[a] ? "pointer" : ""), this._grabCursor && !this.dragging[a] && (s.style.cursor = this.hovering[a] ? "grab" : "") } _performTouch(e, i, s, a) { const o = i === "touch_start"; if (this.touching[a] = o, this._callBack(this._onTouch, i, s, a, e), this._grabCursor && (s.style.cursor = this.touching[a] ? "grabbing" : this.hovering[a] ? "grab" : ""), o) this.starts[a].position.x = (e == null ? void 0 : e.clientX) || 0, this.starts[a].position.y = (e == null ? void 0 : e.clientY) || 0, this.starts[a].time = renderInfo.time; else { const l = (e == null ? void 0 : e.clientX) || 0, c = (e == null ? void 0 : e.clientY) || 0, h = Math.sqrt(Math.pow(l - this.starts[a].position.x, 2) + Math.pow(c - this.starts[a].position.y, 2)), d = renderInfo.time - this.starts[a].time; if (h >= L(Xt, Ur) || d >= L(Xt, Fr) || e.pointerType === "mouse" && e.button !== 0 || e.type === "pointerout") return; this._callBack(this._onClick, "click", s, a, e) } } _handleEvent(e, i, s, a) { i === L(Xt, gi).TOUCH_START || i === L(Xt, gi).TOUCH_MOVE ? (this.hovering[a] || this._performHover(e, "hover_in", s, a), i === L(Xt, gi).TOUCH_START ? this.touching[a] || (this._performTouch(e, "touch_start", s, a), this.dragging[a] = !0) : this._callBack(this._onMove, "move", s, a, e)) : i === L(Xt, gi).TOUCH_END && (this.hovering[a] && (e.type !== "pointerup" || e.pointerType !== "mouse") && this._performHover(e, "hover_out", s, a), this.touching[a] && this._performTouch(e, "touch_end", s, a), this.dragging[a] = !1), i === L(Xt, gi).TOUCH_MOVE && this.dragging[a] && this._callBack(this._onDrag, "drag", s, a, e) } _callBack(e, i, s, a, o) { e && e.call(this._ctx, { action: i, node: s, nodeIndex: a, event: o }) } enable() { this._enabled || (this._enabled = !0, (this._onTouch || this._onHover || this._onDrag || this._onClick) && this._nodes.forEach((e, i) => e.addEventListener("pointerdown", this._touchStartCbs[i])), (this._onHover || this._onMove || this._onDrag) && (this._nodes.forEach((e, i) => e.addEventListener("pointerover", this._touchMoveCbs[i])), this._nodes.forEach((e, i) => e.addEventListener("pointermove", this._touchMoveCbs[i]))), (this._onTouch || this._onHover || this._onDrag || this._onClick) && this._nodes.forEach((e, i) => { e.addEventListener("pointerup", this._touchEndCbs[i]), e.addEventListener("pointerout", this._touchEndCbs[i]), e.addEventListener("pointercancel", this._touchEndCbs[i]) }), this._nodes.forEach((e, i) => e.addEventListener("touchstart", L(this, Is), { passive: !1 })), this._disablePointerEvents && this._nodes.forEach(e => e.style.pointerEvents = "")) } disable() { this._enabled && (this._enabled = !1, this._nodes.forEach((e, i) => e.removeEventListener("pointerdown", this._touchStartCbs[i])), this._nodes.forEach((e, i) => e.removeEventListener("pointerover", this._touchMoveCbs[i])), this._nodes.forEach((e, i) => e.removeEventListener("pointermove", this._touchMoveCbs[i])), this._nodes.forEach((e, i) => { e.removeEventListener("pointerup", this._touchEndCbs[i]), e.removeEventListener("pointerout", this._touchEndCbs[i]), e.removeEventListener("pointercancel", this._touchEndCbs[i]) }), this._nodes.forEach((e, i) => e.removeEventListener("touchstart", L(this, Is))), this._nodes.forEach((e, i) => this._handleEvent({}, L(Xt, gi).TOUCH_END, e, i)), this._disablePointerEvents && this._nodes.forEach(e => e.style.pointerEvents = "none")) } }; gi = new WeakMap, Ur = new WeakMap, Fr = new WeakMap, Is = new WeakMap, pe(Xt, gi, { TOUCH_START: 1, TOUCH_MOVE: 2, TOUCH_END: 3, CLICK: 4 }), pe(Xt, Ur, 25), pe(Xt, Fr, .5); let domInteraction = Xt; const _sphere = new Sphere, _box = new Box3; var ii, Bs; const qt = class qt { constructor({ meshes: e = [], camera: i = null, onHover: s = null, onTouch: a = null, onMove: o = null, onDrag: l = null, onClick: c = null, ctx: h = null, performant: d = !1, performantMode: p = "bounding_sphere", finger: f = 0, interactWhileTouching: _ = !1, domNodeCursor: x = document.body, hoverCursor: b = !1, grabCursor: T = !1 } = {}) { if (!i) throw new Error("mesh interaction needs a camera"); this._meshes = Array.isArray(e) ? e : [e], this._camera = i, this._onHover = s, this._onTouch = a, this._onMove = o, this._onDrag = l, this._onClick = c, this._ctx = h, this._performant = d, this._performantMode = L(qt, Bs)[p.toUpperCase()], this._finger = f, this._eventsID = this._finger === 0 ? "touch" : `touch${this._finger + 1}`, this._interactWhileTouching = _, this._touchPressed = !1, this._hoverCursor = b, this._grabCursor = T && !b, this._domNodeCursor = x, this._raycaster = new Raycaster, this._enabled = !1, this.hovering = !1, this.hoveringElement = -1, this.hoveringSubelement = -1, this.touching = !1, this.touchingElement = -1, this.touchingSubelement = -1, this.dragging = !1 } _castRay(e, i) { if (this._raycaster.setFromCamera(e.position11, this._camera), !this._performant) return this._checkIntersections(i, this._raycaster.intersectObjects(this._meshes, !1)); const s = [], a = this._performantMode === L(qt, Bs).BOUNDING_SPHERE, o = a ? _sphere : _box, l = a ? "Sphere" : "Box", c = `bounding${l}`, h = `computeBounding${l}`, d = `intersects${l}`; this._meshes.forEach(p => { if (!p.isMesh && !p.isSpecialCaseemptyMesh || !p.layers.test(this._raycaster.layers)) return; const f = p[c] !== void 0 ? p : p.geometry; f[c] === null && f[h](), this._raycaster.ray[d](o.copy(f[c]).applyMatrix4(p.matrixWorld)) && s.push({ object: p }) }), this._checkIntersections(i, s) } _performHover(e = [], i = "hover_out", s = null, a = -1) { this.hovering = i === "hover_in", this.hoveringElement = s, this.hoveringSubelement = a, this._callBack(this._onHover, i, e), this._hoverCursor && (this._domNodeCursor.style.cursor = this.hovering ? "pointer" : ""), this._grabCursor && !this.dragging && (this._domNodeCursor.style.cursor = this.hovering ? "grab" : "") } _performTouch(e = [], i = "touch_end", s = null, a = -1) { this.touching = i === "touch_start", this.touchingElement = s, this.touchingSubelement = a, this._callBack(this._onTouch, i, e), this._grabCursor && (this._domNodeCursor.style.cursor = this.touching ? "grabbing" : this.hovering ? "grab" : "") } _checkIntersections(e, i) { if (i.length > 0) if (e === L(qt, ii).TOUCH_START || e === L(qt, ii).TOUCH_MOVE) { const s = this._meshes.indexOf(i[0].object); let a = -1; typeof i[0].instanceId == "number" ? a = i[0].instanceId : typeof i[0].batchId == "number" && (a = i[0].batchId), this.hovering && (this.hoveringElement !== s || this.hoveringSubelement !== a) && this._performHover(), !this.hovering && (this._interactWhileTouching || !this._touchPressed) && this._performHover(i, "hover_in", s, a), e === L(qt, ii).TOUCH_START ? (this.touching && (this.touchingElement !== s || this.touchingSubelement !== a) && this._performTouch(), !this.touching && (this._interactWhileTouching || !this._touchPressed) && (this._performTouch(i, "touch_start", s, a), this.dragging = !0)) : this._callBack(this._onMove, "move", i) } else e === L(qt, ii).CLICK && this._callBack(this._onClick, "click", i); else this.hovering && this._performHover(); e === L(qt, ii).TOUCH_END && (this.hovering && touches$1.get(this._finger).input === "touch" && this._performHover(), this.touching && this._performTouch(), this.dragging = !1), e === L(qt, ii).TOUCH_MOVE && this.dragging && this._callBack(this._onDrag, "drag", i) } _callBack(e, i, s) { e && e.call(this._ctx, { action: i, finger: this._finger, interactions: s, event: touches$1.get(this._finger) }) } _onTouchStart(e) { this._castRay(e, L(qt, ii).TOUCH_START), this._touchPressed = !0 } _onTouchMove(e) { this._castRay(e, L(qt, ii).TOUCH_MOVE) } _onTouchEnd(e) { this._touchPressed = !1, this._castRay(e, L(qt, ii).TOUCH_END) } _onTouchClick(e) { this._castRay(e, L(qt, ii).CLICK) } enable() { this._enabled || (this._enabled = !0, (this._onTouch || this._onHover || this._onDrag) && events.on(`${this._eventsID}_start`, this._onTouchStart, this), (this._onHover || this._onMove || this._onDrag) && events.on(`${this._eventsID}_move`, this._onTouchMove, this), (this._onTouch || this._onHover || this._onDrag) && events.on(`${this._eventsID}_end`, this._onTouchEnd, this), this._onClick && events.on(`${this._eventsID}_click`, this._onTouchClick, this), this._onTouchMove(touches$1.get(this._finger))) } disable() { this._enabled && (this._enabled = !1, this._touchPressed = !1, events.off(`${this._eventsID}_start`, this._onTouchStart, this), events.off(`${this._eventsID}_move`, this._onTouchMove, this), events.off(`${this._eventsID}_end`, this._onTouchEnd, this), events.off(`${this._eventsID}_click`, this._onTouchClick, this), this._checkIntersections(L(qt, ii).TOUCH_END, [])) } dispose() { this.disable() } }; ii = new WeakMap, Bs = new WeakMap, pe(qt, ii, { TOUCH_START: 1, TOUCH_MOVE: 2, TOUCH_END: 3, CLICK: 4 }), pe(qt, Bs, { BOUNDING_SPHERE: 1, BOUNDING_BOX: 2 }); let meshInteraction = qt; const DEFAULT_CONSTANT = 0, _raycaster = new Raycaster, _v1$f = new Vector3, _v2$4 = new Vector3; class planeInteraction { constructor({ camera: e = null, normal: i = new Vector3(0, 0, -1), constant: s = DEFAULT_CONSTANT } = {}) { this._camera = e, this._plane = new Plane(i, s) } _unproject(e) { return _raycaster.setFromCamera(e, this._camera), _raycaster.ray.intersectPlane(this._plane, _v1$f), _v1$f } getTouchPositionOnPlane(e = 0) { return this._unproject(touches$1.get(e).position11) } getPointPositionOnPlane(e) { return this._unproject(e) } getPointPositionOnScreen(e) { return _v1$f.copy(e), _v1$f.project(this._camera), _v1$f.set((_v1$f.x + 1) / 2 * client$1.screen.w, -(_v1$f.y - 1) / 2 * client$1.screen.h, _v1$f.z), _v1$f } setPlaneFromPoint(e) { return _v1$f.copy(this._camera.position).sub(e).normalize(), this._plane.setFromNormalAndCoplanarPoint(_v1$f, e), this } setPlaneFromCameraTarget() { return this.setPlaneFromPoint(this._camera.target) } setPlaneFromCameraTargetAndDistance(e) { return _v1$f.copy(this._camera.position).sub(this._camera.target).normalize(), _v2$4.copy(_v1$f).negate().multiplyScalar(e).add(this._camera.position), this._plane.setFromNormalAndCoplanarPoint(_v1$f, _v2$4), this } setPlaneFromDirectionAndPoint(e, i) { return _v1$f.copy(e).normalize(), this._plane.setFromNormalAndCoplanarPoint(_v1$f, i), this } setDefaultPlane() { return this._plane.normal.set(0, 0, -1), this._plane.constant = DEFAULT_CONSTANT, this } setCamera(e) { return this._camera = e, this } unprojectFinger(e = 0) { return this.setPlaneFromCameraTarget().getTouchPositionOnPlane(e) } unprojectPoint(e) { return this.setPlaneFromCameraTarget().getPointPositionOnPlane(e) } unprojectDistance(e, i = 0) { return this.setPlaneFromCameraTargetAndDistance(e).getTouchPositionOnPlane(i) } project(e) { return this.getPointPositionOnScreen(e) } } const _v0$l = new Vector3, _v1$e = new Vector3; function sineNoise1(r, e, i) { _v0$l.set(r, e, i); let s = 0; return s += Math.sin(_v0$l.dot(_v1$e.set(1.5, 3.4598, 1.234))), s += Math.sin(_v0$l.dot(_v1$e.set(3.12, -3.234, 4.221))), s += Math.sin(_v0$l.dot(_v1$e.set(.355, 2.3, -1.375))), s += Math.sin(_v0$l.dot(_v1$e.set(-.156, -3.34, -.4566))), s += Math.sin(_v0$l.dot(_v1$e.set(-4.1235, -.485, -1.45))), s += Math.sin(_v0$l.dot(_v1$e.set(2.54, -.879, -2.123))), s / 6 } const noises = { sineNoise1 }; var Ri, Ds, Pi, Nr, Rs, ns, Bn, Ti, Za, Ar, Aa; class workerTask { constructor() { pe(this, Ti); pe(this, Ri, null); pe(this, Ds, null); pe(this, Pi, new Map); pe(this, Nr, 0); pe(this, Rs, null); pe(this, ns, 1 / 0); pe(this, Bn, null) } get pendingTasks() { return L(this, Pi).size } setWorkerCreator(e) { return Xe(this, Ds, e), this } setCallback(e) { return Xe(this, Rs, e), this } setDisposeTimeout(e = 1 / 0) { return Xe(this, ns, e), Pe(this, Ti, Aa).call(this), this } postMessage(e, i) { if (typeof e != "object") throw new Error("workerTask: message must be an object"); return Pe(this, Ti, Ar).call(this), new Promise(s => { const a = pr(this, Nr)._++; L(this, Pi).set(a, s), L(this, Ri) || (Xe(this, Ri, L(this, Ds).call(this)), L(this, Ri).addEventListener("message", Pe(this, Ti, Za).bind(this))), e.id = a, L(this, Ri).postMessage(e, i) }) } dispose() { var e; return Pe(this, Ti, Ar).call(this), (e = L(this, Ri)) == null || e.terminate(), Xe(this, Ri, null), L(this, Pi).clear(), this } } Ri = new WeakMap, Ds = new WeakMap, Pi = new WeakMap, Nr = new WeakMap, Rs = new WeakMap, ns = new WeakMap, Bn = new WeakMap, Ti = new WeakSet, Za = function (e) { var s; const i = e.data.id; if (typeof i > "u") { console.warn("workerTask: message without id, skipping", e.data); return }; if (delete e.data.id, L(this, Pi).has(i)) { const a = L(this, Pi).get(i); L(this, Pi).delete(i), a == null || a(e.data) } (s = L(this, Rs)) == null || s.call(this, e.data), Pe(this, Ti, Aa).call(this) }, Ar = function () { L(this, Bn) !== null && (clearTimeout(L(this, Bn)), Xe(this, Bn, null)) }, Aa = function () { L(this, Ri) && L(this, ns) < 1 / 0 && L(this, Pi).size === 0 && (Pe(this, Ti, Ar).call(this), Xe(this, Bn, setTimeout(() => { this.dispose() }, L(this, ns) * 1e3))) }; function WorkerWrapper$7(r) { return new Worker("./assets/glyphworker-DoaYwstb.js", { name: r == null ? void 0 : r.name }) } const bufferLoader = new FileLoader; bufferLoader.setResponseType("arraybuffer"); const worker = new workerTask().setWorkerCreator(() => new WorkerWrapper$7); let pathFonts = "", pathIcons = ""; function getFilePath(r) { return `${r.endsWith(".font") ? pathFonts : pathIcons}${r}` } const glyphLoader = { _glyphsBufferCache: new Map, _glyphsTextureCache: new Map, _loadBuffer(r) { if (this._glyphsBufferCache.has(r)) return this._glyphsBufferCache.get(r); const e = bufferLoader.loadAsync(r).then(i => new Uint8Array(i)).catch(i => (console.error("Glyph buffer loader", i), new Uint8Array(0))); return this._glyphsBufferCache.set(r, e), e }, loadTexture(r, e, i = !0) { if (e !== "curve" && e !== "band") throw new Error('Invalid type for glyph texture. Must be either "curve" or "band".'); const s = `${r}_<>_curve`, a = `${r}_<>_band`, o = e === "curve" ? s : a; if (this._glyphsTextureCache.has(o)) return this._glyphsTextureCache.get(o); const l = miscutils.deferred(), c = miscutils.deferred(); return this._glyphsTextureCache.set(s, l), this._glyphsTextureCache.set(a, c), (async () => { const h = getFilePath(r), d = await this._loadBuffer(h), p = await worker.postMessage({ action: "generateTextures", url: h, buffer: d }); let f = null, _ = null; p.error ? (console.warn(p.error), f = new DataTexture(null, 1, 1, RGBAFormat, HalfFloatType), _ = new DataTexture(null, 1, 1, RGIntegerFormat, UnsignedShortType)) : (f = new DataTexture(p.curveTextureData, p.curveTextureSize.width, p.curveTextureSize.height, RGBAFormat, p.curveTextureData.constructor.name === "Uint16Array" ? HalfFloatType : FloatType), _ = new DataTexture(p.bandTextureData, p.bandTextureSize.width, p.bandTextureSize.height, RGIntegerFormat, UnsignedShortType), f.needsUpdate = !0, _.needsUpdate = !0), f._loaded = Promise.resolve(), _._loaded = Promise.resolve(), l.resolve(f), c.resolve(_), i || deleteFromCache$2(h, s, a) })(), e === "curve" ? l : c }, loadGeometry(r, e = {}) { return new Promise(async i => { const s = getFilePath(r), a = await this._loadBuffer(s), o = r.endsWith(".font") ? "generateText" : "generatePicture", l = await worker.postMessage({ action: o, url: s, buffer: a, options: e }), c = new BufferGeometry; l.error ? console.warn(l.error) : (c.setIndex(new BufferAttribute(l.index, 1)), c.setAttribute("position", new BufferAttribute(l.position, 3)), c.setAttribute("posnorm", new BufferAttribute(l.posnorm, 2)), c.setAttribute("texcoord", new BufferAttribute(l.texcoord, 4)), c.setAttribute("jacobian", new BufferAttribute(l.jacobian, 4)), c.setAttribute("banding", new BufferAttribute(l.banding, 4)), c.setAttribute("color", new BufferAttribute(l.color, 4)), c.setAttribute("uv", new BufferAttribute(l.uv, 2)), l.fontMetrics && (c._fontMetrics = l.fontMetrics), l.centr && c.setAttribute("centr", new BufferAttribute(l.centr, 3)), l.textWeights && c.setAttribute("textWeights", new BufferAttribute(l.textWeights, 2)), l.lineWeights && c.setAttribute("lineWeights", new BufferAttribute(l.lineWeights, 3)), c.boundingBox = new Box3, c.boundingBox.min.fromArray(l.boundingBox.min), c.boundingBox.max.fromArray(l.boundingBox.max), c.boundingSphere = new Sphere, c.boundingSphere.center.fromArray(l.boundingSphere.center), c.boundingSphere.radius = l.boundingSphere.radius), i(c) }) } }; function deleteFromCache$2(r, e, i) { glyphLoader._glyphsBufferCache.delete(r), glyphLoader._glyphsTextureCache.delete(e), glyphLoader._glyphsTextureCache.delete(i) } function disposeGlyphs() { worker.dispose(), glyphLoader._glyphsBufferCache.clear(), glyphLoader._glyphsTextureCache.clear() } function setGlyphsPath() { pathFonts = `${client$1.absolutePath}/assets/fonts/`, pathIcons = `${client$1.absolutePath}/assets/images/` } function WorkerWrapper$6(r) { return new Worker("./assets/dracoworker-9mmlh0V-.js", { name: r == null ? void 0 : r.name }) } var Yi, Ps, Ls, ss, Or, eo; class CustomDRACOLoader { constructor() { pe(this, Or); pe(this, Yi, new Map); pe(this, Ps, new FileLoader().setResponseType("arraybuffer")); pe(this, Ls, new workerTask().setWorkerCreator(() => new WorkerWrapper$6)); pe(this, ss, "") } setPath(e) { Xe(this, ss, e), L(this, Ps).setPath(L(this, ss)) } loadAsync(e) { if (L(this, Yi).has(e)) return L(this, Yi).get(e); const i = new Promise((s, a) => { L(this, Ps).loadAsync(e).then(o => L(this, Ls).postMessage({ url: `${L(this, ss)}${e}`, buffer: o }, [o])).then(o => { o.error ? a(new Error(`buffer "${e}" could not be decoded.`)) : s(Pe(this, Or, eo).call(this, o.geometry)) }).catch(o => { a(new Error(o)) }) }); return L(this, Yi).set(e, i), i } deleteFromCache(e) { L(this, Yi).delete(e) } dispose() { L(this, Ls).dispose(), L(this, Yi).forEach(e => e.then(i => i.dispose())), L(this, Yi).clear() } } Yi = new WeakMap, Ps = new WeakMap, Ls = new WeakMap, ss = new WeakMap, Or = new WeakSet, eo = function (e) { const i = new BufferGeometry; e.userData && (i.userData = e.userData), e.index && i.setIndex(new BufferAttribute(e.index.array, 1)); for (let s = 0; s < e.attributes.length; s++) { const a = e.attributes[s], o = a.name, l = a.array, c = a.itemSize; i.setAttribute(o, new BufferAttribute(l, c)) } return i }; function WorkerWrapper$5(r) { return new Worker("./assets/geometryworker-WyEueJn9.js", { name: r == null ? void 0 : r.name }) } var Rn, Kt, Qn, to, _a, xa, za; let geometryProcessor$1 = (za = class { constructor() { pe(this, Kt); pe(this, Rn, new workerTask().setWorkerCreator(() => new WorkerWrapper$5)) } batched(e) { if (!e.isBufferGeometry) throw new Error("geometryProcessor.batched: geometry is not a BufferGeometry"); const { attribs: i, transfers: s } = Pe(this, Kt, Qn).call(this, e); return L(this, Rn).postMessage({ action: "batched", attributes: i }, s).then(a => { const o = []; for (let l = 0; l < a.result.length; l++) { const c = a.result[l]; o.push(Pe(this, Kt, to).call(this, c)) } return o }) } instanced(e, i) { if (!e.isBufferGeometry || !i.isBufferGeometry) throw new Error("geometryProcessor.instanced: geometries are not a BufferGeometry"); const s = Pe(this, Kt, Qn).call(this, e), a = Pe(this, Kt, Qn).call(this, i); return L(this, Rn).postMessage({ action: "instanced", attributes: s.attribs, attributesInstanced: a.attribs }, [...s.transfers, ...a.transfers]).then(o => { const l = o.result, c = Pe(this, Kt, _a).call(this, l); return Pe(this, Kt, xa).call(this, e, c), c }) } instancedPatches(e, i) { if (!e.isBufferGeometry || !i.isBufferGeometry) throw new Error("geometryProcessor.instanced: geometries are not a BufferGeometry"); const s = Pe(this, Kt, Qn).call(this, e), a = Pe(this, Kt, Qn).call(this, i); return L(this, Rn).postMessage({ action: "instancedPatches", attributes: s.attribs, attributesInstanced: a.attribs }, [...s.transfers, ...a.transfers]).then(o => { const l = []; for (let c = 0; c < o.result.length; c++) { const h = o.result[c], d = Pe(this, Kt, _a).call(this, h); Pe(this, Kt, xa).call(this, e, d), l.push(d) } return l }) } dispose() { L(this, Rn).dispose() } }, Rn = new WeakMap, Kt = new WeakSet, Qn = function (e) { const i = {}, s = []; if (e.getIndex()) { const a = e.getIndex(); i.index = { array: a.array, itemSize: a.itemSize, normalized: a.normalized }, s.push(a.array.buffer) } for (const a in e.attributes) { const o = e.getAttribute(a); i[a] = { array: o.array, itemSize: o.itemSize, normalized: o.normalized }, s.push(i[a].array.buffer) } return { attribs: i, transfers: s, userData: e.userData } }, to = function (e) { const i = new BufferGeometry; for (const s in e) if (s === "userData") i.userData = e.userData; else { const a = e[s]; s === "index" ? i.setIndex(new BufferAttribute(a.array, a.itemSize, a.normalized)) : i.setAttribute(s, new BufferAttribute(a.array, a.itemSize, a.normalized)) } return i }, _a = function (e) { const i = new InstancedBufferGeometry; for (const s in e) if (s === "userData") i.userData = e.userData; else if (s === "instanceCount") i.instanceCount = e.instanceCount; else if (s === "matrixArray") i._matrixArray = e[s]; else { const a = e[s]; s === "index" ? i.setIndex(new BufferAttribute(a.array, a.itemSize, a.normalized)) : i.setAttribute(s, new (a.isInstanced ? InstancedBufferAttribute : BufferAttribute)(a.array, a.itemSize, a.normalized)) } return i }, xa = function (e, i) { e.__vertexAnimationUniforms && (i.__vertexAnimationUniforms = e.__vertexAnimationUniforms) }, za); function capitalizeFirstLetter(r) { return r.charAt(0).toUpperCase() + r.slice(1) } function createVertexAnimation(r) { const e = r.userData, i = Object.keys(r.attributes), s = i.filter(c => c.slice(-2) === "_1").map(c => c.substring(0, c.length - 2)), a = i.filter(c => c.slice(-2) === "_2").map(c => c.substring(0, c.length - 2)), o = new BufferGeometry; r.index && o.setIndex(r.index.clone()), s.forEach(c => { o.setAttribute(c, r.attributes[`${c}_1`].clone()) }); const l = {}; if (a.length > 0) { const c = r.attributes[`${a[0]}_1`].count, h = c * e.frames, d = math.getTextureSizeParticles(h), p = d * d; l.uAnimInfo = { value: new Vector3(e.fps, e.frames, c), ignore: !0 }; const f = new Float32Array(c); for (let _ = 0; _ < f.length; _++)f[_] = _; o.setAttribute("vposition", new BufferAttribute(f, 1)), a.forEach(_ => { const x = new Float32Array(p * 4); for (let T = 0; T < e.frames; T++) { const M = r.attributes[`${_}_${T + 1}`].array; for (let w = 0; w < c; w++) { const D = T * c * 4 + w * 4, R = w * 3; x[D + 0] = M[R + 0], x[D + 1] = M[R + 1], x[D + 2] = M[R + 2], x[D + 3] = 1 } } const b = new DataTexture(x, d, d, RGBAFormat, FloatType); b.needsUpdate = !0, l[`t${capitalizeFirstLetter(_)}`] = { value: b } }) } return o.__vertexAnimationUniforms = l, o } function createCurves(r, e, i) { const s = []; return Object.values(r.attributes).forEach(o => { const l = o.count, c = o.array, h = []; for (let f = 0; f < l; f++)h.push(new Vector3(c[f * 3 + 0], c[f * 3 + 1], c[f * 3 + 2])); const d = new CurvePath; for (let f = 0; f < h.length - 1; f++)d.add(new LineCurve3(h[f], h[f + 1])); i && (d.autoClose = !0); const p = d.getPoints(Math.round(d.getLength() * 10 * e)); s.push({ curve: d, geometry: new BufferGeometry().setFromPoints(p) }) }), s } const defaultMaterial = new MeshNormalMaterial; function createSkin(r, e) { const i = []; for (let l = 0; l < e.attributes.position.count; l++) { const c = new Bone; c.name = `bone_${l}`, c.position.fromArray(e.attributes.position.array, l * 3), c.quaternion.fromArray(e.attributes.quaternion.array, l * 4).normalize(), c.scale.fromArray(e.attributes.scale.array, l * 3), i.push(c) } const s = []; for (let l = 0; l < e.attributes.hierarchy.count; l++) { const c = e.attributes.hierarchy.array[l] - 1; c === -1 ? s.push(l) : i[c].add(i[l]) } const a = new Skeleton(i), o = new SkinnedMesh(r, defaultMaterial); return s.forEach(l => o.add(a.bones[l])), o.bind(a), o.normalizeSkinWeights(), o } function WorkerWrapper$4(r) { return new Worker("./assets/msdfworker-DGxypdow.js", { name: r == null ? void 0 : r.name }) } class MSDFLoader { constructor() { this.jsonLoader = new FileLoader, this.jsonCache = new Map, this.workerTask = new workerTask().setWorkerCreator(() => new WorkerWrapper$4) } loadAsync(e) { return new Promise(async i => { if (!e.font) throw new Error("You must specify a MSDF font."); const s = e.font; this.jsonCache.has(s) || this.jsonCache.set(s, new Promise(async l => { try { const c = JSON.parse(await this.jsonLoader.loadAsync(`${e.font}.json`)), h = c.glyphs; c.glyphs = {}, h.forEach(d => { const p = String.fromCharCode(d.unicode); d.isWhitespace = /\s/.test(p), c.glyphs[p] = d }), c.placeholderChar = Object.keys(c.glyphs).sort()[0], l(c) } catch (c) { console.log("Error loading msdf json:", c), l(!1) } })); const a = new BufferGeometry, o = await this.jsonCache.get(s); if (o) { const l = (await this.workerTask.postMessage({ font: o, options: e })).buffers; a.setIndex(new BufferAttribute(l.index, 1)), a.setAttribute("position", new BufferAttribute(l.position, 3)), a.setAttribute("uv", new BufferAttribute(l.uv, 2)), a.setAttribute("uvMask", new BufferAttribute(l.uvMask, 4)), a.setAttribute("textWeights", new BufferAttribute(l.textWeights, 2)), a.setAttribute("lineWeights", new BufferAttribute(l.lineWeights, 3)), a.setAttribute("centr", new BufferAttribute(l.centr, 3)), a._maxLineHeight = l.maxLineHeight, a._maxUVDisp = l.maxUVDisp, a._sizes = l.sizes } else a._maxLineHeight = 0, a._maxUVDisp = 0, a._sizes = { width: 0, height: 0 }; i(a) }) } setPath(e) { this.jsonLoader.setPath(e) } dispose() { this.workerTask.dispose(), this.jsonCache.clear() } } const animationAttributes = ["scale", "quaternion", "position"], _v1$d = new Vector3, _q1$1 = new Quaternion, _q2 = new Quaternion, _qCam = new Quaternion, _qIdentity = new Quaternion; class pointAnimation { constructor(e) { const i = e.userData; this._frames = i.frames, this._fps = i.fps, this._duration = this._frames / this._fps, this._attribs = e.attributes, this._camTargetDistance = 1, this._object = null, this._animationVar = 0, this._animation = createTween(this, { to: { _animationVar: 1 }, duration: this._duration, ease: "none", paused: !0, onUpdate: this._onUpdate.bind(this) }) } _onUpdate() { if (!this._object) return; const e = this._frames - 1, i = math.clamp(e * this._animationVar, 0, e), s = Math.floor(i), a = Math.ceil(i), o = Math.abs(i - s); this._object.isCamera && _qCam.identity(), animationAttributes.forEach(l => { const c = this._attribs[l]; if (!(!c || !this._object[l]) && !(this._object.isCamera && l === "scale")) switch (l) { case "scale": c.itemSize === 1 ? this._object.scale.setScalar(math.lerp(c.array[s], c.array[a], o)) : this._object.scale.fromArray(c.array, s * 3).lerp(_v1$d.fromArray(c.array, a * 3), o); break; case "quaternion": _q1$1.fromArray(c.array, s * 4).normalize(), _q2.fromArray(c.array, a * 4).normalize(), _q1$1.slerp(_q2, o), this._object.isCamera ? _qCam.copy(_q1$1) : this._object.quaternion.copy(_q1$1); break; case "position": this._object[this._object.isCamera ? "basePosition" : "position"].fromArray(c.array, s * 3).lerp(_v1$d.fromArray(c.array, a * 3), o); break } }), this._object.isCamera && !_qCam.equals(_qIdentity) && (this._object.baseTarget.set(0, 0, -this._camTargetDistance).applyQuaternion(_qCam).add(this._object.basePosition), this._object.baseUp.set(0, 1, 0).applyQuaternion(_qCam)) } use(e, i = !0) { return this._object = e, this._object.isCamera && i && (this._camTargetDistance = _v1$d.copy(this._object.baseTarget).sub(this._object.basePosition).length()), this.progress(0) } play() { return this._animation.play() } pause() { return this._animation.pause() } progress(e = 0) { return this._animation.progress(e) } restart() { return this._animation.restart() } dispose() { this._animation.kill(), this._object = null } } const _v0$k = new Vector3, _q0$4 = new Quaternion; function createSkinAnimation(r, e) { if (!Object.hasOwn(e.userData, "frames") || !Object.hasOwn(e.userData, "fps")) return new AnimationClip(r, 0, []); const i = e.userData, s = i.frames, a = e.attributes.position.count / s, o = s / i.fps, l = o / (s - 1), c = new Array(s).fill(0).map((f, _) => _ * l), h = {};["position", "quaternion", "scale"].forEach(f => { const _ = e.attributes[f].array, x = e.attributes[f].itemSize, b = x === 4 ? _q0$4 : _v0$k; for (let T = 0; T < a; T++) { const M = `bone_${T}.${f}`; h[M] = { size: x, arr: [] }; const w = T * x; for (let D = 0; D < s; D++)b.fromArray(_, D * a * x + w), x === 4 && b.normalize(), h[M].arr.push(...b.toArray()) } }); const d = []; return Object.keys(h).forEach(f => { const _ = h[f].size === 4 ? QuaternionKeyframeTrack : VectorKeyframeTrack; d.push(new _(f, c, h[f].arr, InterpolateLinear)) }), new AnimationClip(r, o, d) } const bufferGeometryLoader = new BufferGeometryLoader, customDracoLoader = new CustomDRACOLoader, msdfLoader = new MSDFLoader, geometryProcessor = new geometryProcessor$1, fallbackGeometry = new BoxGeometry(.5, .5, .5), geometryLoader = { _geometryCache: new Map, _initLoad(r, e) { return this._geometryCache.has(r) || this._geometryCache.set(r, new Promise(e)), this._geometryCache.get(r) }, load(r, e = !1) { return this._initLoad(r, async i => { const s = r.split(".").pop(); let a = null; try { s.startsWith("drc") || s.startsWith("bin") ? a = await customDracoLoader.loadAsync(r) : a = await bufferGeometryLoader.loadAsync(r), i(a) } catch (o) { console.log("Geometry loader", o), i(fallbackGeometry) } e || (customDracoLoader.deleteFromCache(r), deleteFromCache$1(r)) }) }, instanced(r, e, i = "load", s = !1) { const a = `instanced_<>_${r}-${e}`; return this._initLoad(a, async o => { const [l, c] = await Promise.all([this[i](r, !1), this.load(e, !1)]), h = await geometryProcessor.instanced(l, c); o(h), s || deleteFromCache$1(a) }) }, instancedPatches(r, e, i = "load", s = !1) { const a = `instancedPatches_<>_${r}-${e}`; return this._initLoad(a, async o => { const [l, c] = await Promise.all([this[i](r, !1), this.load(e, !1)]), h = await geometryProcessor.instancedPatches(l, c); o(h), s || deleteFromCache$1(a) }) }, batched(r, e = !1) { const i = `batched_<>_${r}`; return this._initLoad(i, async s => { const a = await this.load(r, !1), o = await geometryProcessor.batched(a); s(o), e || deleteFromCache$1(i) }) }, vertexAnimation(r, e = !1) { const i = `vertexanimation_<>_${r}`; return this._initLoad(i, async s => { const a = await this.load(r, !1); s(createVertexAnimation(a)), e || deleteFromCache$1(i) }) }, curves(r, e = !1, i = 1, s = !1) { const a = `curves_<>_${r}_${e}_${i}`; return this._initLoad(a, async o => { const l = await this.load(r, !1); o(createCurves(l, i, e)), s || deleteFromCache$1(a) }) }, pointAnimation(r, e = !1) { const i = `pointanimation_<>_${r}`; return this._initLoad(i, async s => { const a = await this.load(r, !1); s(new pointAnimation(a)), e || deleteFromCache$1(i) }) }, skin(r, e, i = !1) { const s = `skin_<>_${r}-${e}`; return this._initLoad(`skin_<>_${r}-${e}`, async a => { const [o, l] = await Promise.all([this.load(r, !1), this.load(e, !1)]); a(createSkin(o, l)), i || deleteFromCache$1(s) }) }, skinAnimation(r, e = !1) { const i = `skinanimation_<>_${r}`; return this._initLoad(i, async s => { const a = await this.load(r, !1); s(createSkinAnimation(r, a)), e || deleteFromCache$1(i) }) }, msdf(r) { return msdfLoader.loadAsync(r) } }; function deleteFromCache$1() { for (const r of arguments) geometryLoader._geometryCache.delete(r) } function createInstancedGeometryPatches(r, e) { return geometryProcessor.instancedPatches(r, e) } function setGeometryPath() { bufferGeometryLoader.setPath(`${client$1.absolutePath}/assets/geometries/`), customDracoLoader.setPath(`${client$1.absolutePath}/assets/geometries/`), msdfLoader.setPath(`${client$1.absolutePath}/assets/fonts/`) } function disposeGeometries() { customDracoLoader.dispose(), msdfLoader.dispose(), geometryProcessor.dispose(), geometryLoader._geometryCache.clear() } class WorkerPool { constructor(e = 4) { this.pool = e, this.queue = [], this.workers = [], this.workersResolve = [], this.workerStatus = 0, this.workerCreator = null } _initWorker(e) { if (!this.workers[e]) { const i = this.workerCreator(); i.addEventListener("message", this._onMessage.bind(this, e)), this.workers[e] = i } } _getIdleWorker() { for (let e = 0; e < this.pool; e++)if (!(this.workerStatus & 1 << e)) return e; return -1 } _onMessage(e, i) { const s = this.workersResolve[e]; if (s && s(i), this.queue.length) { const { resolve: a, msg: o, transfer: l } = this.queue.shift(); this.workersResolve[e] = a, this.workers[e].postMessage(o, l) } else this.workerStatus ^= 1 << e } setWorkerCreator(e) { this.workerCreator = e } setWorkerLimit(e) { this.pool = e } postMessage(e, i) { return new Promise(s => { const a = this._getIdleWorker(); a !== -1 ? (this._initWorker(a), this.workerStatus |= 1 << a, this.workersResolve[a] = s, this.workers[a].postMessage(e, i)) : this.queue.push({ resolve: s, msg: e, transfer: i }) }) } dispose() { this.workers.forEach(e => e.terminate()), this.workersResolve.length = 0, this.workers.length = 0, this.queue.length = 0, this.workerStatus = 0 } } const t = 0, n = 2, u = 1, y = 2, S = 0, E = 1, X = 10, it = 0, ht = 9, gt = 15, xt = 16, dt = 22, Ft = 37, Et = 43, te = 76, ae = 83, ue = 97, ye = 100, de = 103, Ae = 109, We = 122, He = 123, qe = 131, Je = 132, Qe = 133, Ze = 134, en = 137, nn = 138, sn = 139, an = 140, rn = 141, on = 142, cn = 145, Un = 146, pn = 148, xn = 152, Dn = 157, wn = 158, Vn = 165, Cn = 166, ri = 1000054e3, oi = 1000054001, ci = 1000054004, Ui = 1000054005, _i = 1000066e3, yi = 1000066004; class Ci { constructor(e, i, s, a) { this._dataView = void 0, this._littleEndian = void 0, this._offset = void 0, this._dataView = new DataView(e.buffer, e.byteOffset + i, s), this._littleEndian = a, this._offset = 0 } _nextUint8() { const e = this._dataView.getUint8(this._offset); return this._offset += 1, e } _nextUint16() { const e = this._dataView.getUint16(this._offset, this._littleEndian); return this._offset += 2, e } _nextUint32() { const e = this._dataView.getUint32(this._offset, this._littleEndian); return this._offset += 4, e } _nextUint64() { const e = this._dataView.getUint32(this._offset, this._littleEndian) + 4294967296 * this._dataView.getUint32(this._offset + 4, this._littleEndian); return this._offset += 8, e } _nextInt32() { const e = this._dataView.getInt32(this._offset, this._littleEndian); return this._offset += 4, e } _nextUint8Array(e) { const i = new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + this._offset, e); return this._offset += e, i } _skip(e) { return this._offset += e, this } _scan(e, i = 0) { const s = this._offset; let a = 0; for (; this._dataView.getUint8(this._offset) !== i && a < e;)a++, this._offset++; return a < e && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + s, a) } } const Oi = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10]; function Si(r) { return new TextDecoder().decode(r) } function Mi(r) { const e = new Uint8Array(r.buffer, r.byteOffset, Oi.length); if (e[0] !== Oi[0] || e[1] !== Oi[1] || e[2] !== Oi[2] || e[3] !== Oi[3] || e[4] !== Oi[4] || e[5] !== Oi[5] || e[6] !== Oi[6] || e[7] !== Oi[7] || e[8] !== Oi[8] || e[9] !== Oi[9] || e[10] !== Oi[10] || e[11] !== Oi[11]) throw new Error("Missing KTX 2.0 identifier."); const i = { vkFormat: 0, typeSize: 1, pixelWidth: 0, pixelHeight: 0, pixelDepth: 0, layerCount: 0, faceCount: 1, levelCount: 0, supercompressionScheme: 0, levels: [], dataFormatDescriptor: [{ vendorId: 0, descriptorType: 0, versionNumber: 2, colorModel: 0, colorPrimaries: 1, transferFunction: 2, flags: 0, texelBlockDimension: [0, 0, 0, 0], bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0], samples: [] }], keyValue: {}, globalData: null }, s = 17 * Uint32Array.BYTES_PER_ELEMENT, a = new Ci(r, Oi.length, s, !0); i.vkFormat = a._nextUint32(), i.typeSize = a._nextUint32(), i.pixelWidth = a._nextUint32(), i.pixelHeight = a._nextUint32(), i.pixelDepth = a._nextUint32(), i.layerCount = a._nextUint32(), i.faceCount = a._nextUint32(), i.levelCount = a._nextUint32(), i.supercompressionScheme = a._nextUint32(); const o = a._nextUint32(), l = a._nextUint32(), c = a._nextUint32(), h = a._nextUint32(), d = a._nextUint64(), p = a._nextUint64(), f = 3 * Math.max(i.levelCount, 1) * 8, _ = new Ci(r, Oi.length + s, f, !0); for (let Ue = 0, nt = Math.max(i.levelCount, 1); Ue < nt; Ue++)i.levels.push({ levelData: new Uint8Array(r.buffer, r.byteOffset + _._nextUint64(), _._nextUint64()), uncompressedByteLength: _._nextUint64() }); const x = new Ci(r, o, l, !0); x._skip(4); const b = x._nextUint16(), T = x._nextUint16(), M = x._nextUint16(), w = x._nextUint16(), D = { vendorId: b, descriptorType: T, versionNumber: M, colorModel: x._nextUint8(), colorPrimaries: x._nextUint8(), transferFunction: x._nextUint8(), flags: x._nextUint8(), texelBlockDimension: [x._nextUint8(), x._nextUint8(), x._nextUint8(), x._nextUint8()], bytesPlane: [x._nextUint8(), x._nextUint8(), x._nextUint8(), x._nextUint8(), x._nextUint8(), x._nextUint8(), x._nextUint8(), x._nextUint8()], samples: [] }, R = (w / 4 - 6) / 4; for (let Ue = 0; Ue < R; Ue++) { const nt = { bitOffset: x._nextUint16(), bitLength: x._nextUint8(), channelType: x._nextUint8(), samplePosition: [x._nextUint8(), x._nextUint8(), x._nextUint8(), x._nextUint8()], sampleLower: Number.NEGATIVE_INFINITY, sampleUpper: Number.POSITIVE_INFINITY }; 64 & nt.channelType ? (nt.sampleLower = x._nextInt32(), nt.sampleUpper = x._nextInt32()) : (nt.sampleLower = x._nextUint32(), nt.sampleUpper = x._nextUint32()), D.samples[Ue] = nt } i.dataFormatDescriptor.length = 0, i.dataFormatDescriptor.push(D); const P = new Ci(r, c, h, !0); for (; P._offset < h;) { const Ue = P._nextUint32(), nt = P._scan(Ue), mt = Si(nt); if (i.keyValue[mt] = P._nextUint8Array(Ue - nt.byteLength - 1), mt.match(/^ktx/i)) { const ve = Si(i.keyValue[mt]); i.keyValue[mt] = ve.substring(0, ve.lastIndexOf("\0")) } P._skip(Ue % 4 ? 4 - Ue % 4 : 0) } if (p <= 0) return i; const U = new Ci(r, d, p, !0), O = U._nextUint16(), N = U._nextUint16(), H = U._nextUint32(), F = U._nextUint32(), k = U._nextUint32(), W = U._nextUint32(), $ = []; for (let Ue = 0, nt = Math.max(i.levelCount, 1); Ue < nt; Ue++)$.push({ imageFlags: U._nextUint32(), rgbSliceByteOffset: U._nextUint32(), rgbSliceByteLength: U._nextUint32(), alphaSliceByteOffset: U._nextUint32(), alphaSliceByteLength: U._nextUint32() }); const Z = d + U._offset, J = Z + H, se = J + F, re = se + k, ce = new Uint8Array(r.buffer, r.byteOffset + Z, H), ee = new Uint8Array(r.buffer, r.byteOffset + J, F), Me = new Uint8Array(r.buffer, r.byteOffset + se, k), Ee = new Uint8Array(r.buffer, r.byteOffset + re, W); return i.globalData = { endpointCount: O, selectorCount: N, imageDescs: $, endpointsData: ce, selectorsData: ee, tablesData: Me, extendedData: Ee }, i } let A, I, B; const g = { env: { emscripten_notify_memory_growth: function (r) { B = new Uint8Array(I.exports.memory.buffer) } } }; class Q { init() { return A || (A = typeof fetch < "u" ? fetch("data:application/wasm;base64," + C).then(e => e.arrayBuffer()).then(e => WebAssembly.instantiate(e, g)).then(this._init) : WebAssembly.instantiate(Buffer.from(C, "base64"), g).then(this._init), A) } _init(e) { I = e.instance, g.env.emscripten_notify_memory_growth(0) } decode(e, i = 0) { if (!I) throw new Error("ZSTDDecoder: Await .init() before decoding."); const s = e.byteLength, a = I.exports.malloc(s); B.set(e, a), i = i || Number(I.exports.ZSTD_findDecompressedSize(a, s)); const o = I.exports.malloc(i), l = I.exports.ZSTD_decompress(o, i, a, s), c = B.slice(o, o + l); return I.exports.free(a), I.exports.free(o), c } } const C = "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IAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQh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ASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdB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IAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY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wOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEE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", DisplayP3ColorSpace = "display-p3", LinearDisplayP3ColorSpace = "display-p3-linear"; ({ ...ColorManagement.spaces[SRGBColorSpace] }); const _taskCache = new WeakMap; let _activeLoaders = 0, _zstd; class KTX2Loader extends Loader$1 {
    constructor(e) { super(e), this.transcoderPath = "", this.transcoderBinary = null, this.transcoderPending = null, this.workerPool = new WorkerPool, this.workerSourceURL = "", this.workerConfig = null, typeof MSC_TRANSCODER < "u" && console.warn('THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.') } setTranscoderPath(e) { return this.transcoderPath = e, this } setWorkerLimit(e) { return this.workerPool.setWorkerLimit(e), this } async detectSupportAsync(e) { return this.workerConfig = { astcSupported: await e.hasFeatureAsync("texture-compression-astc"), astcHDRSupported: !1, etc1Supported: await e.hasFeatureAsync("texture-compression-etc2"), etc2Supported: await e.hasFeatureAsync("texture-compression-etc2"), dxtSupported: await e.hasFeatureAsync("texture-compression-bc"), bptcSupported: await e.hasFeatureAsync("texture-compression-bc"), pvrtcSupported: await e.hasFeatureAsync("texture-compression-pvrtc") }, this } detectSupport(e) { return e.isWebGPURenderer === !0 ? this.workerConfig = { astcSupported: e.hasFeature("texture-compression-astc"), astcHDRSupported: !1, etc1Supported: e.hasFeature("texture-compression-etc2"), etc2Supported: e.hasFeature("texture-compression-etc2"), dxtSupported: e.hasFeature("texture-compression-bc"), bptcSupported: e.hasFeature("texture-compression-bc"), pvrtcSupported: e.hasFeature("texture-compression-pvrtc") } : this.workerConfig = { astcSupported: e.extensions.has("WEBGL_compressed_texture_astc"), astcHDRSupported: e.extensions.has("WEBGL_compressed_texture_astc") && e.extensions.get("WEBGL_compressed_texture_astc").getSupportedProfiles().includes("hdr"), etc1Supported: e.extensions.has("WEBGL_compressed_texture_etc1"), etc2Supported: e.extensions.has("WEBGL_compressed_texture_etc"), dxtSupported: e.extensions.has("WEBGL_compressed_texture_s3tc"), bptcSupported: e.extensions.has("EXT_texture_compression_bptc"), pvrtcSupported: e.extensions.has("WEBGL_compressed_texture_pvrtc") || e.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc") }, this } init() {
        if (!this.transcoderPending) {
            const e = new FileLoader(this.manager); e.setPath(this.transcoderPath), e.setWithCredentials(this.withCredentials); const i = e.loadAsync("basis_transcoder.js"), s = new FileLoader(this.manager); s.setPath(this.transcoderPath), s.setResponseType("arraybuffer"), s.setWithCredentials(this.withCredentials); const a = s.loadAsync("basis_transcoder.wasm"); this.transcoderPending = Promise.all([i, a]).then(([o, l]) => {
                const c = KTX2Loader.BasisWorker.toString(), h = ["/* constants */", "let _EngineFormat = " + JSON.stringify(KTX2Loader.EngineFormat), "let _EngineType = " + JSON.stringify(KTX2Loader.EngineType), "let _TranscoderFormat = " + JSON.stringify(KTX2Loader.TranscoderFormat), "let _BasisFormat = " + JSON.stringify(KTX2Loader.BasisFormat), "/* basis_transcoder.js */", o, "/* worker */", c.substring(c.indexOf("{") + 1, c.lastIndexOf("}"))].join(`
`); this.workerSourceURL = URL.createObjectURL(new Blob([h])), this.transcoderBinary = l, this.workerPool.setWorkerCreator(() => { const d = new Worker(this.workerSourceURL), p = this.transcoderBinary.slice(0); return d.postMessage({ type: "init", config: this.workerConfig, transcoderBinary: p }, [p]), d })
            }), _activeLoaders > 0 && console.warn("THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."), _activeLoaders++
        } return this.transcoderPending
    } load(e, i, s, a) { if (this.workerConfig === null) throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`."); const o = new FileLoader(this.manager); o.setPath(this.path), o.setCrossOrigin(this.crossOrigin), o.setWithCredentials(this.withCredentials), o.setResponseType("arraybuffer"), o.load(e, l => { this.parse(l, i, a) }, s, a) } parse(e, i, s) { if (this.workerConfig === null) throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`."); if (_taskCache.has(e)) return _taskCache.get(e).promise.then(i).catch(s); this._createTexture(e).then(a => i ? i(a) : null).catch(s) } _createTextureFrom(e, i) { const { type: s, error: a, data: { faces: o, width: l, height: c, format: h, type: d, dfdFlags: p } } = e; if (s === "error") return Promise.reject(a); let f; if (i.faceCount === 6) f = new CompressedCubeTexture(o, h, d); else { const _ = o[0].mipmaps; f = i.layerCount > 1 ? new CompressedArrayTexture(_, l, c, i.layerCount, h, d) : new CompressedTexture(_, l, c, h, d) } return f.minFilter = o[0].mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter, f.magFilter = LinearFilter, f.generateMipmaps = !1, f.needsUpdate = !0, f.colorSpace = parseColorSpace(i), f.premultiplyAlpha = !!(p & u), f } async _createTexture(e, i = {}) { const s = Mi(new Uint8Array(e)), a = s.vkFormat === _i && s.dataFormatDescriptor[0].colorModel === 167; if (!(s.vkFormat === it || a && !this.workerConfig.astcHDRSupported)) return createRawTexture(s); const l = i, c = this.init().then(() => this.workerPool.postMessage({ type: "transcode", buffer: e, taskConfig: l }, [e])).then(h => this._createTextureFrom(h.data, s)); return _taskCache.set(e, { promise: c }), c } dispose() { this.workerPool.dispose(), this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL), _activeLoaders-- }
} KTX2Loader.BasisFormat = { ETC1S: 0, UASTC: 1, UASTC_HDR: 2 }; KTX2Loader.TranscoderFormat = { ETC1: 0, ETC2: 1, BC1: 2, BC3: 3, BC4: 4, BC5: 5, BC7_M6_OPAQUE_ONLY: 6, BC7_M5: 7, PVRTC1_4_RGB: 8, PVRTC1_4_RGBA: 9, ASTC_4x4: 10, ATC_RGB: 11, ATC_RGBA_INTERPOLATED_ALPHA: 12, RGBA32: 13, RGB565: 14, BGR565: 15, RGBA4444: 16, BC6H: 22, RGB_HALF: 24, RGBA_HALF: 25 }; KTX2Loader.EngineFormat = { RGBAFormat, RGBA_ASTC_4x4_Format, RGB_BPTC_UNSIGNED_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT5_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT1_Format }; KTX2Loader.EngineType = { UnsignedByteType, HalfFloatType, FloatType }; KTX2Loader.BasisWorker = function () { let r, e, i; const s = _EngineFormat, a = _EngineType, o = _TranscoderFormat, l = _BasisFormat; self.addEventListener("message", function (b) { const T = b.data; switch (T.type) { case "init": r = T.config, c(T.transcoderBinary); break; case "transcode": e.then(() => { try { const { faces: M, buffers: w, width: D, height: R, hasAlpha: P, format: U, type: O, dfdFlags: N } = h(T.buffer); self.postMessage({ type: "transcode", id: T.id, data: { faces: M, width: D, height: R, hasAlpha: P, format: U, type: O, dfdFlags: N } }, w) } catch (M) { console.error(M), self.postMessage({ type: "error", id: T.id, error: M.message }) } }); break } }); function c(b) { e = new Promise(T => { i = { wasmBinary: b, onRuntimeInitialized: T }, BASIS(i) }).then(() => { i.initializeBasis(), i.KTX2File === void 0 && console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.") }) } function h(b) { const T = new i.KTX2File(new Uint8Array(b)); function M() { T.close(), T.delete() } if (!T.isValid()) throw M(), new Error("THREE.KTX2Loader:	Invalid or unsupported .ktx2 file"); let w; if (T.isUASTC()) w = l.UASTC; else if (T.isETC1S()) w = l.ETC1S; else if (T.isHDR()) w = l.UASTC_HDR; else throw new Error("THREE.KTX2Loader: Unknown Basis encoding"); const D = T.getWidth(), R = T.getHeight(), P = T.getLayers() || 1, U = T.getLevels(), O = T.getFaces(), N = T.getHasAlpha(), H = T.getDFDFlags(), { transcoderFormat: F, engineFormat: k, engineType: W } = f(w, D, R, N); if (!D || !R || !U) throw M(), new Error("THREE.KTX2Loader:	Invalid texture"); if (!T.startTranscoding()) throw M(), new Error("THREE.KTX2Loader: .startTranscoding failed"); const $ = [], Z = []; for (let J = 0; J < O; J++) { const se = []; for (let re = 0; re < U; re++) { const ce = []; let ee, Me; for (let Ue = 0; Ue < P; Ue++) { const nt = T.getImageLevelInfo(re, Ue, J); J === 0 && re === 0 && Ue === 0 && (nt.origWidth % 4 !== 0 || nt.origHeight % 4 !== 0) && console.warn("THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions."), U > 1 ? (ee = nt.origWidth, Me = nt.origHeight) : (ee = nt.width, Me = nt.height); let mt = new Uint8Array(T.getImageTranscodedSizeInBytes(re, Ue, 0, F)); const ve = T.transcodeImage(mt, re, Ue, J, F, 0, -1, -1); if (W === a.HalfFloatType && (mt = new Uint16Array(mt.buffer, mt.byteOffset, mt.byteLength / Uint16Array.BYTES_PER_ELEMENT)), !ve) throw M(), new Error("THREE.KTX2Loader: .transcodeImage failed."); ce.push(mt) } const Ee = x(ce); se.push({ data: Ee, width: ee, height: Me }), Z.push(Ee.buffer) } $.push({ mipmaps: se, width: D, height: R, format: k, type: W }) } return M(), { faces: $, buffers: Z, width: D, height: R, hasAlpha: N, dfdFlags: H, format: k, type: W } } const d = [{ if: "astcSupported", basisFormat: [l.UASTC], transcoderFormat: [o.ASTC_4x4, o.ASTC_4x4], engineFormat: [s.RGBA_ASTC_4x4_Format, s.RGBA_ASTC_4x4_Format], engineType: [a.UnsignedByteType], priorityETC1S: 1 / 0, priorityUASTC: 1, needsPowerOfTwo: !1 }, { if: "bptcSupported", basisFormat: [l.ETC1S, l.UASTC], transcoderFormat: [o.BC7_M5, o.BC7_M5], engineFormat: [s.RGBA_BPTC_Format, s.RGBA_BPTC_Format], engineType: [a.UnsignedByteType], priorityETC1S: 3, priorityUASTC: 2, needsPowerOfTwo: !1 }, { if: "dxtSupported", basisFormat: [l.ETC1S, l.UASTC], transcoderFormat: [o.BC1, o.BC3], engineFormat: [s.RGBA_S3TC_DXT1_Format, s.RGBA_S3TC_DXT5_Format], engineType: [a.UnsignedByteType], priorityETC1S: 4, priorityUASTC: 5, needsPowerOfTwo: !1 }, { if: "etc2Supported", basisFormat: [l.ETC1S, l.UASTC], transcoderFormat: [o.ETC1, o.ETC2], engineFormat: [s.RGB_ETC2_Format, s.RGBA_ETC2_EAC_Format], engineType: [a.UnsignedByteType], priorityETC1S: 1, priorityUASTC: 3, needsPowerOfTwo: !1 }, { if: "etc1Supported", basisFormat: [l.ETC1S, l.UASTC], transcoderFormat: [o.ETC1], engineFormat: [s.RGB_ETC1_Format], engineType: [a.UnsignedByteType], priorityETC1S: 2, priorityUASTC: 4, needsPowerOfTwo: !1 }, { if: "pvrtcSupported", basisFormat: [l.ETC1S, l.UASTC], transcoderFormat: [o.PVRTC1_4_RGB, o.PVRTC1_4_RGBA], engineFormat: [s.RGB_PVRTC_4BPPV1_Format, s.RGBA_PVRTC_4BPPV1_Format], engineType: [a.UnsignedByteType], priorityETC1S: 5, priorityUASTC: 6, needsPowerOfTwo: !0 }, { if: "bptcSupported", basisFormat: [l.UASTC_HDR], transcoderFormat: [o.BC6H], engineFormat: [s.RGB_BPTC_UNSIGNED_Format], engineType: [a.HalfFloatType], priorityHDR: 1, needsPowerOfTwo: !1 }, { basisFormat: [l.ETC1S, l.UASTC], transcoderFormat: [o.RGBA32, o.RGBA32], engineFormat: [s.RGBAFormat, s.RGBAFormat], engineType: [a.UnsignedByteType, a.UnsignedByteType], priorityETC1S: 100, priorityUASTC: 100, needsPowerOfTwo: !1 }, { basisFormat: [l.UASTC_HDR], transcoderFormat: [o.RGBA_HALF], engineFormat: [s.RGBAFormat], engineType: [a.HalfFloatType], priorityHDR: 100, needsPowerOfTwo: !1 }], p = { [l.ETC1S]: d.filter(b => b.basisFormat.includes(l.ETC1S)).sort((b, T) => b.priorityUASTC - T.priorityUASTC), [l.UASTC]: d.filter(b => b.basisFormat.includes(l.UASTC)).sort((b, T) => b.priorityUASTC - T.priorityUASTC), [l.UASTC_HDR]: d.filter(b => b.basisFormat.includes(l.UASTC_HDR)).sort((b, T) => b.priorityHDR - T.priorityHDR) }; function f(b, T, M, w) { const D = p[b]; for (let R = 0; R < D.length; R++) { const P = D[R]; if (P.if && !r[P.if] || !P.basisFormat.includes(b) || w && P.transcoderFormat.length < 2 || P.needsPowerOfTwo && !(_(T) && _(M))) continue; const U = P.transcoderFormat[w ? 1 : 0], O = P.engineFormat[w ? 1 : 0], N = P.engineType[0]; return { transcoderFormat: U, engineFormat: O, engineType: N } } throw new Error("THREE.KTX2Loader: Failed to identify transcoding target.") } function _(b) { return b <= 2 ? !0 : (b & b - 1) === 0 && b !== 0 } function x(b) { if (b.length === 1) return b[0]; let T = 0; for (let D = 0; D < b.length; D++) { const R = b[D]; T += R.byteLength } const M = new Uint8Array(T); let w = 0; for (let D = 0; D < b.length; D++) { const R = b[D]; M.set(R, w), w += R.byteLength } return M } }; const UNCOMPRESSED_FORMATS = new Set([RGBAFormat, RGBFormat, RGFormat, RedFormat]), FORMAT_MAP = { [Ae]: RGBAFormat, [de]: RGFormat, [ye]: RedFormat, [ue]: RGBAFormat, [ae]: RGFormat, [te]: RedFormat, [Et]: RGBAFormat, [Ft]: RGBAFormat, [dt]: RGFormat, [xt]: RGFormat, [gt]: RedFormat, [ht]: RedFormat, [He]: RGBFormat, [We]: RGBFormat, [xn]: RGBA_ETC2_EAC_Format, [pn]: RGB_ETC2_Format, [_i]: RGBA_ASTC_4x4_Format, [wn]: RGBA_ASTC_4x4_Format, [Dn]: RGBA_ASTC_4x4_Format, [yi]: RGBA_ASTC_6x6_Format, [Cn]: RGBA_ASTC_6x6_Format, [Vn]: RGBA_ASTC_6x6_Format, [Ze]: RGBA_S3TC_DXT1_Format, [Qe]: RGBA_S3TC_DXT1_Format, [Je]: RGB_S3TC_DXT1_Format, [qe]: RGB_S3TC_DXT1_Format, [nn]: RGBA_S3TC_DXT3_Format, [en]: RGBA_S3TC_DXT3_Format, [an]: SIGNED_RED_RGTC1_Format, [sn]: RED_RGTC1_Format, [on]: SIGNED_RED_GREEN_RGTC2_Format, [rn]: RED_GREEN_RGTC2_Format, [Un]: RGBA_BPTC_Format, [cn]: RGBA_BPTC_Format, [Ui]: RGBA_PVRTC_4BPPV1_Format, [oi]: RGBA_PVRTC_4BPPV1_Format, [ci]: RGBA_PVRTC_2BPPV1_Format, [ri]: RGBA_PVRTC_2BPPV1_Format }, TYPE_MAP = { [Ae]: FloatType, [de]: FloatType, [ye]: FloatType, [ue]: HalfFloatType, [ae]: HalfFloatType, [te]: HalfFloatType, [Et]: UnsignedByteType, [Ft]: UnsignedByteType, [dt]: UnsignedByteType, [xt]: UnsignedByteType, [gt]: UnsignedByteType, [ht]: UnsignedByteType, [He]: UnsignedInt5999Type, [We]: UnsignedInt101111Type, [xn]: UnsignedByteType, [pn]: UnsignedByteType, [_i]: HalfFloatType, [wn]: UnsignedByteType, [Dn]: UnsignedByteType, [yi]: HalfFloatType, [Cn]: UnsignedByteType, [Vn]: UnsignedByteType, [Ze]: UnsignedByteType, [Qe]: UnsignedByteType, [Je]: UnsignedByteType, [qe]: UnsignedByteType, [nn]: UnsignedByteType, [en]: UnsignedByteType, [an]: UnsignedByteType, [sn]: UnsignedByteType, [on]: UnsignedByteType, [rn]: UnsignedByteType, [Un]: UnsignedByteType, [cn]: UnsignedByteType, [Ui]: UnsignedByteType, [oi]: UnsignedByteType, [ci]: UnsignedByteType, [ri]: UnsignedByteType }; async function createRawTexture(r) { const { vkFormat: e } = r; if (FORMAT_MAP[e] === void 0) throw new Error("THREE.KTX2Loader: Unsupported vkFormat: " + e); TYPE_MAP[e] === void 0 && console.warn('THREE.KTX2Loader: Missing ".type" for vkFormat: ' + e); let i; r.supercompressionScheme === n && (_zstd || (_zstd = new Promise(async l => { const c = new Q; await c.init(), l(c) })), i = await _zstd); const s = []; for (let l = 0; l < r.levels.length; l++) { const c = Math.max(1, r.pixelWidth >> l), h = Math.max(1, r.pixelHeight >> l), d = r.pixelDepth ? Math.max(1, r.pixelDepth >> l) : 0, p = r.levels[l]; let f; if (r.supercompressionScheme === t) f = p.levelData; else if (r.supercompressionScheme === n) f = i.decode(p.levelData, p.uncompressedByteLength); else throw new Error("THREE.KTX2Loader: Unsupported supercompressionScheme."); let _; TYPE_MAP[e] === FloatType ? _ = new Float32Array(f.buffer, f.byteOffset, f.byteLength / Float32Array.BYTES_PER_ELEMENT) : TYPE_MAP[e] === HalfFloatType ? _ = new Uint16Array(f.buffer, f.byteOffset, f.byteLength / Uint16Array.BYTES_PER_ELEMENT) : TYPE_MAP[e] === UnsignedInt5999Type || TYPE_MAP[e] === UnsignedInt101111Type ? _ = new Uint32Array(f.buffer, f.byteOffset, f.byteLength / Uint32Array.BYTES_PER_ELEMENT) : _ = f, s.push({ data: _, width: c, height: h, depth: d }) } const a = r.levelCount === 0 || s.length > 1; let o; if (UNCOMPRESSED_FORMATS.has(FORMAT_MAP[e])) o = r.pixelDepth === 0 ? new DataTexture(s[0].data, r.pixelWidth, r.pixelHeight) : new Data3DTexture(s[0].data, r.pixelWidth, r.pixelHeight, r.pixelDepth), o.minFilter = a ? NearestMipmapNearestFilter : NearestFilter, o.magFilter = NearestFilter, o.generateMipmaps = r.levelCount === 0; else { if (r.pixelDepth > 0) throw new Error("THREE.KTX2Loader: Unsupported pixelDepth."); o = new CompressedTexture(s, r.pixelWidth, r.pixelHeight), o.minFilter = a ? LinearMipmapLinearFilter : LinearFilter, o.magFilter = LinearFilter } return o.mipmaps = s, o.type = TYPE_MAP[e], o.format = FORMAT_MAP[e], o.colorSpace = parseColorSpace(r), o.needsUpdate = !0, Promise.resolve(o) } function parseColorSpace(r) { const e = r.dataFormatDescriptor[0]; return e.colorPrimaries === E ? e.transferFunction === y ? SRGBColorSpace : LinearSRGBColorSpace : e.colorPrimaries === X ? e.transferFunction === y ? DisplayP3ColorSpace : LinearDisplayP3ColorSpace : (e.colorPrimaries === S || console.warn(`THREE.KTX2Loader: Unsupported color primaries, "${e.colorPrimaries}"`), NoColorSpace) } function WorkerWrapper$3(r) { return new Worker("./assets/bitmapworker-DtCLhbWB.js", { name: r == null ? void 0 : r.name }) } var gn, Us, Fs; class BitmapLoader { constructor() { pe(this, gn, new Map); pe(this, Us, ""); pe(this, Fs, new workerTask().setWorkerCreator(() => new WorkerWrapper$3)) } loadAsync(e, i = !0) { const s = `${e}-${i}`; if (L(this, gn).has(s)) return L(this, gn).get(s); const a = new Promise(async (o, l) => { const c = await L(this, Fs).postMessage({ url: L(this, Us) + e, flipY: i }); c.error ? l(new Error(`fetch for "${e}" responded with 404: Not Found.`)) : o(new Texture(c.bitmap)) }); return L(this, gn).set(s, a), a } setPath(e) { Xe(this, Us, e) } deleteFromCache(e, i = !0) { const s = `${e}-${i}`; L(this, gn).delete(s) } dispose() { L(this, Fs).dispose(), L(this, gn).clear() } } gn = new WeakMap, Us = new WeakMap, Fs = new WeakMap; function createCurvesTexture(r, e, i) { const s = new DataTexture(new Float32Array(16), 2, 2, RGBAFormat, FloatType); return s._curves = [], s._url = r, s._closed = e, s._pointDensity = i, makeTextureAwaitable(s), setTimeout(async () => { const a = await geometryLoader.curves(r, e, i); s._curves = a; const o = math.ceilPowerOfTwo(Math.max(2, a.length)); let l = 2, c = 0; a.forEach(d => { l = Math.max(l, d.geometry.attributes.position.count), c = Math.max(c, d.curve.getLength()) }), l > 2048 && console.warn(`Curves texture will be clamped to 2048 from ${l}`), l = math.clamp(l, 2, 2048); const h = new Float32Array(o * l * 4); a.forEach((d, p) => { const f = d.curve.getSpacedPoints(l), _ = l * p * 4, x = 1 / (f.length - 1); f.forEach((b, T) => { const M = T * 4; h[_ + M + 0] = b.x, h[_ + M + 1] = b.y, h[_ + M + 2] = b.z, h[_ + M + 3] = x * T }) }), s.image = { data: h, width: l, height: o }, s.needsUpdate = !0, s._loaded.resolve(s) }, 0), s } function WorkerWrapper$2(r) { return new Worker("./assets/exrworker-Dm3Bkfzh.js", { name: r == null ? void 0 : r.name }) } class ExrLoader { constructor() { this.exrTextureCache = new Map, this.path = "", this.workerTask = new workerTask().setWorkerCreator(() => new WorkerWrapper$2) } loadAsync(e) { if (this.exrTextureCache.has(e)) return this.exrTextureCache.get(e); const i = new Promise(async (s, a) => { const o = await this.workerTask.postMessage({ url: this.path + e }); if (o.error) a(new Error(`fetch for "${e}" responded with 404: Not Found.`)); else { const { texData: l } = o, c = new DataTexture; c.image.width = l.width, c.image.height = l.height, c.image.data = l.data, c.colorSpace = l.colorSpace, c.format = l.format, c.type = l.type, c.needsUpdate = !0, c.minFilter = LinearFilter, c.magFilter = LinearFilter, c.generateMipmaps = !1, c.flipY = !1, s(c) } }); return this.exrTextureCache.set(e, i), i } setPath(e) { this.path = e } deleteFromCache(e) { this.exrTextureCache.delete(e) } dispose() { this.workerTask.dispose(), this.exrTextureCache.clear() } } class CustomVideoTexture extends VideoTexture { constructor(e, i = !1) { const s = document.createElement("video"); super(s), s.loop = !0, s.muted = !0, s.preload = "auto", s.crossOrigin = "anonymous", s.playsInline = !0; const a = document.createElement("source"); a.src = e, a.type = `video/${e.split(".").pop().startsWith("mp4") ? "mp4" : "webm"}`, s.appendChild(a), s.load(), this._autoplay = i, this._videoLoadAsync = new Promise((o, l) => { const c = () => { s.removeEventListener("canplaythrough", h), s.removeEventListener("error", d) }, h = () => { c(), o() }, d = () => { c(), l(new Error(`fetch for "${e}" responded with 404: Not Found.`)) }; s.addEventListener("canplaythrough", h), s.addEventListener("error", d), s.readyState > 3 && h() }) } update() { this._autoplay && this.image.paused && this.image.play().catch(() => { }), super.update() } dispose() { this.image.pause(), this.image.currentTime = 0, super.dispose() } } const ktx2Loader = new KTX2Loader().setWorkerLimit(1), bitmapLoader = new BitmapLoader, exrLoader = new ExrLoader, basicLoader = new TextureLoader, TEXTURE_FORMATS = { KTX2: 1, BITMAP: 2, IMAGE: 3, EXR: 4, VIDEO: 5 }, BITMAP_EXTENSIONS = ["png", "jpg", "jpeg", "avif"], DEFAULT_TEXTURE = "uv/uvchecker-srgb.png", DEFAULT_TEXTURE_KTX2 = "uv/uvchecker-srgb.ktx2", textureLoader = { _texturesCache: new Map, load(r = DEFAULT_TEXTURE, e = "default", i = !0) { const s = `${r}_<>_${e}`; if (this._texturesCache.has(s)) return this._texturesCache.get(s); const a = r.split(".").pop(), o = e.toLowerCase(); let l = null, c = null; a.startsWith("ktx2") ? (l = TEXTURE_FORMATS.KTX2, o.includes("cubemap") ? c = new CompressedCubeTexture : o.includes("3d") || o.includes("lut") ? c = new Data3DTexture : o.includes("data") ? c = new DataTexture : c = new CompressedTexture) : a.startsWith("exr") ? (l = TEXTURE_FORMATS.EXR, c = new DataTexture) : a.startsWith("mp4") || a.startsWith("webm") ? (l = TEXTURE_FORMATS.VIDEO, c = new CustomVideoTexture(`${client$1.absolutePath}/assets/${r}`, o.includes("autoplay"))) : (client$1.capabilities.imageBitmap && BITMAP_EXTENSIONS.some(f => a.startsWith(f)) ? l = TEXTURE_FORMATS.BITMAP : l = TEXTURE_FORMATS.IMAGE, c = new Texture), c._url = r, c._loadMode = e, makeTextureAwaitable(c); const d = o.includes("srgb") || r === DEFAULT_TEXTURE ? SRGBColorSpace : c.colorSpace; c.colorSpace = d; const p = !o.includes("noflip"); return this._texturesCache.set(s, c), setTimeout(async () => { let f = null; try { l === TEXTURE_FORMATS.KTX2 ? f = await ktx2Loader.loadAsync(r) : l === TEXTURE_FORMATS.EXR ? f = await exrLoader.loadAsync(r) : l === TEXTURE_FORMATS.VIDEO ? (f = c) && await c._videoLoadAsync : l === TEXTURE_FORMATS.BITMAP ? f = await bitmapLoader.loadAsync(r, p) : f = await basicLoader.loadAsync(r) } catch (_) { console.warn("Texture load:", _, r), l !== TEXTURE_FORMATS.EXR && l !== TEXTURE_FORMATS.VIDEO && !c.isData3DTexture && (c.colorSpace = SRGBColorSpace, l === TEXTURE_FORMATS.KTX2 ? f = await ktx2Loader.loadAsync(DEFAULT_TEXTURE_KTX2) : l === TEXTURE_FORMATS.BITMAP ? f = await bitmapLoader.loadAsync(DEFAULT_TEXTURE) : (l = TEXTURE_FORMATS.IMAGE, f = await basicLoader.loadAsync(DEFAULT_TEXTURE_KTX2))) } c !== f && (c.dispose(), c.copy(f)), o.includes("repeat") && (o.includes("mirror") ? (c.wrapS = MirroredRepeatWrapping, c.wrapT = MirroredRepeatWrapping) : (c.wrapS = RepeatWrapping, c.wrapT = RepeatWrapping)), o.includes("lut") ? o.includes("luttetrahedral") ? (c.magFilter = NearestFilter, c.minFilter = NearestFilter) : (c.magFilter = LinearFilter, c.minFilter = LinearFilter) : o.includes("data") || o.includes("linearfilter") ? (c.magFilter = LinearFilter, c.minFilter = LinearFilter) : o.includes("nearest") && (c.magFilter = NearestFilter, c.minFilter = NearestFilter), (o.includes("nearest") || o.includes("data") || o.includes("nomipmaps")) && (c.generateMipmaps = !1), o.includes("pmrem") && (o.includes("refraction") ? c.mapping = EquirectangularRefractionMapping : c.mapping = EquirectangularReflectionMapping), c.colorSpace = d, c.needsUpdate = !0, c._loaded.resolve(c), i || deleteFromCache(r, p, s) }, 0), c }, loadCurves(r, e = !1, i = 1, s = !0) { const a = `curves_${r}_<>_${e}_<>_${i}`; if (this._texturesCache.has(a)) return this._texturesCache.get(a); const o = createCurvesTexture(r, e, i); return this._texturesCache.set(a, o), o._loaded.then(() => { s || this._texturesCache.delete(a) }), o } }; function makeTextureAwaitable(r) { const e = miscutils.deferred(), i = e.resolve; e.resolve = s => { delete r.then, i(s) }, r._loaded = e, r.then = (s, a) => r._loaded.then(s, a) } function deleteFromCache(r, e, i) { bitmapLoader.deleteFromCache(r, e), exrLoader.deleteFromCache(r), textureLoader._texturesCache.delete(i) } function setTexturesPath() { ktx2Loader.setTranscoderPath(`${client$1.absolutePath}/assets/libs/basis/`), ktx2Loader.setPath(`${client$1.absolutePath}/assets/images/`), bitmapLoader.setPath(`${client$1.absolutePath}/assets/images/`), exrLoader.setPath(`${client$1.absolutePath}/assets/images/`), basicLoader.setPath(`${client$1.absolutePath}/assets/images/`) } function disposeTextures() { const r = ktx2Loader.workerSourceURL; ktx2Loader.workerSourceURL = "", ktx2Loader.dispose(), ktx2Loader.workerSourceURL = r, bitmapLoader.dispose(), exrLoader.dispose(), textureLoader._texturesCache.clear() } function mergeGeometries(r, e = !1) { const i = r[0].index !== null, s = new Set(Object.keys(r[0].attributes)), a = new Set(Object.keys(r[0].morphAttributes)), o = {}, l = {}, c = r[0].morphTargetsRelative, h = new BufferGeometry; let d = 0; for (let p = 0; p < r.length; ++p) { const f = r[p]; let _ = 0; if (i !== (f.index !== null)) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + p + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."), null; for (const x in f.attributes) { if (!s.has(x)) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + p + '. All geometries must have compatible attributes; make sure "' + x + '" attribute exists among all geometries, or in none of them.'), null; o[x] === void 0 && (o[x] = []), o[x].push(f.attributes[x]), _++ } if (_ !== s.size) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + p + ". Make sure all geometries have the same number of attributes."), null; if (c !== f.morphTargetsRelative) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + p + ". .morphTargetsRelative must be consistent throughout all geometries."), null; for (const x in f.morphAttributes) { if (!a.has(x)) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + p + ".  .morphAttributes must be consistent throughout all geometries."), null; l[x] === void 0 && (l[x] = []), l[x].push(f.morphAttributes[x]) } if (e) { let x; if (i) x = f.index.count; else if (f.attributes.position !== void 0) x = f.attributes.position.count; else return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + p + ". The geometry must have either an index or a position attribute"), null; h.addGroup(d, x, p), d += x } } if (i) { let p = 0; const f = []; for (let _ = 0; _ < r.length; ++_) { const x = r[_].index; for (let b = 0; b < x.count; ++b)f.push(x.getX(b) + p); p += r[_].attributes.position.count } h.setIndex(f) } for (const p in o) { const f = mergeAttributes(o[p]); if (!f) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + p + " attribute."), null; h.setAttribute(p, f) } for (const p in l) { const f = l[p][0].length; if (f === 0) break; h.morphAttributes = h.morphAttributes || {}, h.morphAttributes[p] = []; for (let _ = 0; _ < f; ++_) { const x = []; for (let T = 0; T < l[p].length; ++T)x.push(l[p][T][_]); const b = mergeAttributes(x); if (!b) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + p + " morphAttribute."), null; h.morphAttributes[p].push(b) } } return h } function mergeAttributes(r) { let e, i, s, a = -1, o = 0; for (let d = 0; d < r.length; ++d) { const p = r[d]; if (e === void 0 && (e = p.array.constructor), e !== p.array.constructor) return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."), null; if (i === void 0 && (i = p.itemSize), i !== p.itemSize) return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."), null; if (s === void 0 && (s = p.normalized), s !== p.normalized) return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."), null; if (a === -1 && (a = p.gpuType), a !== p.gpuType) return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."), null; o += p.count * i } const l = new e(o), c = new BufferAttribute(l, i, s); let h = 0; for (let d = 0; d < r.length; ++d) { const p = r[d]; if (p.isInterleavedBufferAttribute) { const f = h / i; for (let _ = 0, x = p.count; _ < x; _++)for (let b = 0; b < i; b++) { const T = p.getComponent(_, b); c.setComponent(_ + f, b, T) } } else l.set(p.array, h); h += p.count * i } return a !== void 0 && (c.gpuType = a), c } function toTrianglesDrawMode(r, e) { if (e === TrianglesDrawMode) return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), r; if (e === TriangleFanDrawMode || e === TriangleStripDrawMode) { let i = r.getIndex(); if (i === null) { const l = [], c = r.getAttribute("position"); if (c !== void 0) { for (let h = 0; h < c.count; h++)l.push(h); r.setIndex(l), i = r.getIndex() } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), r } const s = i.count - 2, a = []; if (e === TriangleFanDrawMode) for (let l = 1; l <= s; l++)a.push(i.getX(0)), a.push(i.getX(l)), a.push(i.getX(l + 1)); else for (let l = 0; l < s; l++)l % 2 === 0 ? (a.push(i.getX(l)), a.push(i.getX(l + 1)), a.push(i.getX(l + 2))) : (a.push(i.getX(l + 2)), a.push(i.getX(l + 1)), a.push(i.getX(l))); a.length / 3 !== s && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles."); const o = r.clone(); return o.setIndex(a), o.clearGroups(), o } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), r } class GLTFLoader extends Loader$1 { constructor(e) { super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function (i) { return new GLTFMaterialsClearcoatExtension(i) }), this.register(function (i) { return new GLTFMaterialsDispersionExtension(i) }), this.register(function (i) { return new GLTFTextureBasisUExtension(i) }), this.register(function (i) { return new GLTFTextureWebPExtension(i) }), this.register(function (i) { return new GLTFTextureAVIFExtension(i) }), this.register(function (i) { return new GLTFMaterialsSheenExtension(i) }), this.register(function (i) { return new GLTFMaterialsTransmissionExtension(i) }), this.register(function (i) { return new GLTFMaterialsVolumeExtension(i) }), this.register(function (i) { return new GLTFMaterialsIorExtension(i) }), this.register(function (i) { return new GLTFMaterialsEmissiveStrengthExtension(i) }), this.register(function (i) { return new GLTFMaterialsSpecularExtension(i) }), this.register(function (i) { return new GLTFMaterialsIridescenceExtension(i) }), this.register(function (i) { return new GLTFMaterialsAnisotropyExtension(i) }), this.register(function (i) { return new GLTFMaterialsBumpExtension(i) }), this.register(function (i) { return new GLTFLightsExtension(i) }), this.register(function (i) { return new GLTFMeshoptCompression(i) }), this.register(function (i) { return new GLTFMeshGpuInstancing(i) }) } load(e, i, s, a) { const o = this; let l; if (this.resourcePath !== "") l = this.resourcePath; else if (this.path !== "") { const d = LoaderUtils.extractUrlBase(e); l = LoaderUtils.resolveURL(d, this.path) } else l = LoaderUtils.extractUrlBase(e); this.manager.itemStart(e); const c = function (d) { a ? a(d) : console.error(d), o.manager.itemError(e), o.manager.itemEnd(e) }, h = new FileLoader(this.manager); h.setPath(this.path), h.setResponseType("arraybuffer"), h.setRequestHeader(this.requestHeader), h.setWithCredentials(this.withCredentials), h.load(e, function (d) { try { o.parse(d, l, function (p) { i(p), o.manager.itemEnd(e) }, c) } catch (p) { c(p) } }, s, c) } setDRACOLoader(e) { return this.dracoLoader = e, this } setKTX2Loader(e) { return this.ktx2Loader = e, this } setMeshoptDecoder(e) { return this.meshoptDecoder = e, this } register(e) { return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this } unregister(e) { return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this } parse(e, i, s, a) { let o; const l = {}, c = {}, h = new TextDecoder; if (typeof e == "string") o = JSON.parse(e); else if (e instanceof ArrayBuffer) if (h.decode(new Uint8Array(e, 0, 4)) === BINARY_EXTENSION_HEADER_MAGIC) { try { l[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(e) } catch (f) { a && a(f); return } o = JSON.parse(l[EXTENSIONS.KHR_BINARY_GLTF].content) } else o = JSON.parse(h.decode(e)); else o = e; if (o.asset === void 0 || o.asset.version[0] < 2) { a && a(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")); return } const d = new GLTFParser(o, { path: i || this.resourcePath || "", crossOrigin: this.crossOrigin, requestHeader: this.requestHeader, manager: this.manager, ktx2Loader: this.ktx2Loader, meshoptDecoder: this.meshoptDecoder }); d.fileLoader.setRequestHeader(this.requestHeader); for (let p = 0; p < this.pluginCallbacks.length; p++) { const f = this.pluginCallbacks[p](d); f.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), c[f.name] = f, l[f.name] = !0 } if (o.extensionsUsed) for (let p = 0; p < o.extensionsUsed.length; ++p) { const f = o.extensionsUsed[p], _ = o.extensionsRequired || []; switch (f) { case EXTENSIONS.KHR_MATERIALS_UNLIT: l[f] = new GLTFMaterialsUnlitExtension; break; case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION: l[f] = new GLTFDracoMeshCompressionExtension(o, this.dracoLoader); break; case EXTENSIONS.KHR_TEXTURE_TRANSFORM: l[f] = new GLTFTextureTransformExtension; break; case EXTENSIONS.KHR_MESH_QUANTIZATION: l[f] = new GLTFMeshQuantizationExtension; break; default: _.indexOf(f) >= 0 && c[f] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + f + '".') } } d.setExtensions(l), d.setPlugins(c), d.parse(s, a) } parseAsync(e, i) { const s = this; return new Promise(function (a, o) { s.parse(e, i, a, o) }) } } function GLTFRegistry() { let r = {}; return { get: function (e) { return r[e] }, add: function (e, i) { r[e] = i }, remove: function (e) { delete r[e] }, removeAll: function () { r = {} } } } const EXTENSIONS = { KHR_BINARY_GLTF: "KHR_binary_glTF", KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression", KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual", KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat", KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion", KHR_MATERIALS_IOR: "KHR_materials_ior", KHR_MATERIALS_SHEEN: "KHR_materials_sheen", KHR_MATERIALS_SPECULAR: "KHR_materials_specular", KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission", KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence", KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy", KHR_MATERIALS_UNLIT: "KHR_materials_unlit", KHR_MATERIALS_VOLUME: "KHR_materials_volume", KHR_TEXTURE_BASISU: "KHR_texture_basisu", KHR_TEXTURE_TRANSFORM: "KHR_texture_transform", KHR_MESH_QUANTIZATION: "KHR_mesh_quantization", KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength", EXT_MATERIALS_BUMP: "EXT_materials_bump", EXT_TEXTURE_WEBP: "EXT_texture_webp", EXT_TEXTURE_AVIF: "EXT_texture_avif", EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression", EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing" }; class GLTFLightsExtension { constructor(e) { this.parser = e, this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} } } _markDefs() { const e = this.parser, i = this.parser.json.nodes || []; for (let s = 0, a = i.length; s < a; s++) { const o = i[s]; o.extensions && o.extensions[this.name] && o.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, o.extensions[this.name].light) } } _loadLight(e) { const i = this.parser, s = "light:" + e; let a = i.cache.get(s); if (a) return a; const o = i.json, h = ((o.extensions && o.extensions[this.name] || {}).lights || [])[e]; let d; const p = new Color(16777215); h.color !== void 0 && p.setRGB(h.color[0], h.color[1], h.color[2], LinearSRGBColorSpace); const f = h.range !== void 0 ? h.range : 0; switch (h.type) { case "directional": d = new DirectionalLight(p), d.target.position.set(0, 0, -1), d.add(d.target); break; case "point": d = new PointLight(p), d.distance = f; break; case "spot": d = new SpotLight(p), d.distance = f, h.spot = h.spot || {}, h.spot.innerConeAngle = h.spot.innerConeAngle !== void 0 ? h.spot.innerConeAngle : 0, h.spot.outerConeAngle = h.spot.outerConeAngle !== void 0 ? h.spot.outerConeAngle : Math.PI / 4, d.angle = h.spot.outerConeAngle, d.penumbra = 1 - h.spot.innerConeAngle / h.spot.outerConeAngle, d.target.position.set(0, 0, -1), d.add(d.target); break; default: throw new Error("THREE.GLTFLoader: Unexpected light type: " + h.type) }return d.position.set(0, 0, 0), assignExtrasToUserData(d, h), h.intensity !== void 0 && (d.intensity = h.intensity), d.name = i.createUniqueName(h.name || "light_" + e), a = Promise.resolve(d), i.cache.add(s, a), a } getDependency(e, i) { if (e === "light") return this._loadLight(i) } createNodeAttachment(e) { const i = this, s = this.parser, o = s.json.nodes[e], c = (o.extensions && o.extensions[this.name] || {}).light; return c === void 0 ? null : this._loadLight(c).then(function (h) { return s._getNodeRef(i.cache, c, h) }) } } class GLTFMaterialsUnlitExtension { constructor() { this.name = EXTENSIONS.KHR_MATERIALS_UNLIT } getMaterialType() { return MeshBasicMaterial } extendParams(e, i, s) { const a = []; e.color = new Color(1, 1, 1), e.opacity = 1; const o = i.pbrMetallicRoughness; if (o) { if (Array.isArray(o.baseColorFactor)) { const l = o.baseColorFactor; e.color.setRGB(l[0], l[1], l[2], LinearSRGBColorSpace), e.opacity = l[3] } o.baseColorTexture !== void 0 && a.push(s.assignTexture(e, "map", o.baseColorTexture, SRGBColorSpace)) } return Promise.all(a) } } class GLTFMaterialsEmissiveStrengthExtension { constructor(e) { this.parser = e, this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH } extendMaterialParams(e, i) { const a = this.parser.json.materials[e]; if (!a.extensions || !a.extensions[this.name]) return Promise.resolve(); const o = a.extensions[this.name].emissiveStrength; return o !== void 0 && (i.emissiveIntensity = o), Promise.resolve() } } class GLTFMaterialsClearcoatExtension { constructor(e) { this.parser = e, this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT } getMaterialType(e) { const s = this.parser.json.materials[e]; return !s.extensions || !s.extensions[this.name] ? null : MeshPhysicalMaterial } extendMaterialParams(e, i) { const s = this.parser, a = s.json.materials[e]; if (!a.extensions || !a.extensions[this.name]) return Promise.resolve(); const o = [], l = a.extensions[this.name]; if (l.clearcoatFactor !== void 0 && (i.clearcoat = l.clearcoatFactor), l.clearcoatTexture !== void 0 && o.push(s.assignTexture(i, "clearcoatMap", l.clearcoatTexture)), l.clearcoatRoughnessFactor !== void 0 && (i.clearcoatRoughness = l.clearcoatRoughnessFactor), l.clearcoatRoughnessTexture !== void 0 && o.push(s.assignTexture(i, "clearcoatRoughnessMap", l.clearcoatRoughnessTexture)), l.clearcoatNormalTexture !== void 0 && (o.push(s.assignTexture(i, "clearcoatNormalMap", l.clearcoatNormalTexture)), l.clearcoatNormalTexture.scale !== void 0)) { const c = l.clearcoatNormalTexture.scale; i.clearcoatNormalScale = new Vector2(c, c) } return Promise.all(o) } } class GLTFMaterialsDispersionExtension { constructor(e) { this.parser = e, this.name = EXTENSIONS.KHR_MATERIALS_DISPERSION } getMaterialType(e) { const s = this.parser.json.materials[e]; return !s.extensions || !s.extensions[this.name] ? null : MeshPhysicalMaterial } extendMaterialParams(e, i) { const a = this.parser.json.materials[e]; if (!a.extensions || !a.extensions[this.name]) return Promise.resolve(); const o = a.extensions[this.name]; return i.dispersion = o.dispersion !== void 0 ? o.dispersion : 0, Promise.resolve() } } class GLTFMaterialsIridescenceExtension { constructor(e) { this.parser = e, this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE } getMaterialType(e) { const s = this.parser.json.materials[e]; return !s.extensions || !s.extensions[this.name] ? null : MeshPhysicalMaterial } extendMaterialParams(e, i) { const s = this.parser, a = s.json.materials[e]; if (!a.extensions || !a.extensions[this.name]) return Promise.resolve(); const o = [], l = a.extensions[this.name]; return l.iridescenceFactor !== void 0 && (i.iridescence = l.iridescenceFactor), l.iridescenceTexture !== void 0 && o.push(s.assignTexture(i, "iridescenceMap", l.iridescenceTexture)), l.iridescenceIor !== void 0 && (i.iridescenceIOR = l.iridescenceIor), i.iridescenceThicknessRange === void 0 && (i.iridescenceThicknessRange = [100, 400]), l.iridescenceThicknessMinimum !== void 0 && (i.iridescenceThicknessRange[0] = l.iridescenceThicknessMinimum), l.iridescenceThicknessMaximum !== void 0 && (i.iridescenceThicknessRange[1] = l.iridescenceThicknessMaximum), l.iridescenceThicknessTexture !== void 0 && o.push(s.assignTexture(i, "iridescenceThicknessMap", l.iridescenceThicknessTexture)), Promise.all(o) } } class GLTFMaterialsSheenExtension { constructor(e) { this.parser = e, this.name = EXTENSIONS.KHR_MATERIALS_SHEEN } getMaterialType(e) { const s = this.parser.json.materials[e]; return !s.extensions || !s.extensions[this.name] ? null : MeshPhysicalMaterial } extendMaterialParams(e, i) { const s = this.parser, a = s.json.materials[e]; if (!a.extensions || !a.extensions[this.name]) return Promise.resolve(); const o = []; i.sheenColor = new Color(0, 0, 0), i.sheenRoughness = 0, i.sheen = 1; const l = a.extensions[this.name]; if (l.sheenColorFactor !== void 0) { const c = l.sheenColorFactor; i.sheenColor.setRGB(c[0], c[1], c[2], LinearSRGBColorSpace) } return l.sheenRoughnessFactor !== void 0 && (i.sheenRoughness = l.sheenRoughnessFactor), l.sheenColorTexture !== void 0 && o.push(s.assignTexture(i, "sheenColorMap", l.sheenColorTexture, SRGBColorSpace)), l.sheenRoughnessTexture !== void 0 && o.push(s.assignTexture(i, "sheenRoughnessMap", l.sheenRoughnessTexture)), Promise.all(o) } } class GLTFMaterialsTransmissionExtension { constructor(e) { this.parser = e, this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION } getMaterialType(e) { const s = this.parser.json.materials[e]; return !s.extensions || !s.extensions[this.name] ? null : MeshPhysicalMaterial } extendMaterialParams(e, i) { const s = this.parser, a = s.json.materials[e]; if (!a.extensions || !a.extensions[this.name]) return Promise.resolve(); const o = [], l = a.extensions[this.name]; return l.transmissionFactor !== void 0 && (i.transmission = l.transmissionFactor), l.transmissionTexture !== void 0 && o.push(s.assignTexture(i, "transmissionMap", l.transmissionTexture)), Promise.all(o) } } class GLTFMaterialsVolumeExtension { constructor(e) { this.parser = e, this.name = EXTENSIONS.KHR_MATERIALS_VOLUME } getMaterialType(e) { const s = this.parser.json.materials[e]; return !s.extensions || !s.extensions[this.name] ? null : MeshPhysicalMaterial } extendMaterialParams(e, i) { const s = this.parser, a = s.json.materials[e]; if (!a.extensions || !a.extensions[this.name]) return Promise.resolve(); const o = [], l = a.extensions[this.name]; i.thickness = l.thicknessFactor !== void 0 ? l.thicknessFactor : 0, l.thicknessTexture !== void 0 && o.push(s.assignTexture(i, "thicknessMap", l.thicknessTexture)), i.attenuationDistance = l.attenuationDistance || 1 / 0; const c = l.attenuationColor || [1, 1, 1]; return i.attenuationColor = new Color().setRGB(c[0], c[1], c[2], LinearSRGBColorSpace), Promise.all(o) } } class GLTFMaterialsIorExtension { constructor(e) { this.parser = e, this.name = EXTENSIONS.KHR_MATERIALS_IOR } getMaterialType(e) { const s = this.parser.json.materials[e]; return !s.extensions || !s.extensions[this.name] ? null : MeshPhysicalMaterial } extendMaterialParams(e, i) { const a = this.parser.json.materials[e]; if (!a.extensions || !a.extensions[this.name]) return Promise.resolve(); const o = a.extensions[this.name]; return i.ior = o.ior !== void 0 ? o.ior : 1.5, Promise.resolve() } } class GLTFMaterialsSpecularExtension { constructor(e) { this.parser = e, this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR } getMaterialType(e) { const s = this.parser.json.materials[e]; return !s.extensions || !s.extensions[this.name] ? null : MeshPhysicalMaterial } extendMaterialParams(e, i) { const s = this.parser, a = s.json.materials[e]; if (!a.extensions || !a.extensions[this.name]) return Promise.resolve(); const o = [], l = a.extensions[this.name]; i.specularIntensity = l.specularFactor !== void 0 ? l.specularFactor : 1, l.specularTexture !== void 0 && o.push(s.assignTexture(i, "specularIntensityMap", l.specularTexture)); const c = l.specularColorFactor || [1, 1, 1]; return i.specularColor = new Color().setRGB(c[0], c[1], c[2], LinearSRGBColorSpace), l.specularColorTexture !== void 0 && o.push(s.assignTexture(i, "specularColorMap", l.specularColorTexture, SRGBColorSpace)), Promise.all(o) } } class GLTFMaterialsBumpExtension { constructor(e) { this.parser = e, this.name = EXTENSIONS.EXT_MATERIALS_BUMP } getMaterialType(e) { const s = this.parser.json.materials[e]; return !s.extensions || !s.extensions[this.name] ? null : MeshPhysicalMaterial } extendMaterialParams(e, i) { const s = this.parser, a = s.json.materials[e]; if (!a.extensions || !a.extensions[this.name]) return Promise.resolve(); const o = [], l = a.extensions[this.name]; return i.bumpScale = l.bumpFactor !== void 0 ? l.bumpFactor : 1, l.bumpTexture !== void 0 && o.push(s.assignTexture(i, "bumpMap", l.bumpTexture)), Promise.all(o) } } class GLTFMaterialsAnisotropyExtension { constructor(e) { this.parser = e, this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY } getMaterialType(e) { const s = this.parser.json.materials[e]; return !s.extensions || !s.extensions[this.name] ? null : MeshPhysicalMaterial } extendMaterialParams(e, i) { const s = this.parser, a = s.json.materials[e]; if (!a.extensions || !a.extensions[this.name]) return Promise.resolve(); const o = [], l = a.extensions[this.name]; return l.anisotropyStrength !== void 0 && (i.anisotropy = l.anisotropyStrength), l.anisotropyRotation !== void 0 && (i.anisotropyRotation = l.anisotropyRotation), l.anisotropyTexture !== void 0 && o.push(s.assignTexture(i, "anisotropyMap", l.anisotropyTexture)), Promise.all(o) } } class GLTFTextureBasisUExtension { constructor(e) { this.parser = e, this.name = EXTENSIONS.KHR_TEXTURE_BASISU } loadTexture(e) { const i = this.parser, s = i.json, a = s.textures[e]; if (!a.extensions || !a.extensions[this.name]) return null; const o = a.extensions[this.name], l = i.options.ktx2Loader; if (!l) { if (s.extensionsRequired && s.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"); return null } return i.loadTextureImage(e, o.source, l) } } class GLTFTextureWebPExtension { constructor(e) { this.parser = e, this.name = EXTENSIONS.EXT_TEXTURE_WEBP } loadTexture(e) { const i = this.name, s = this.parser, a = s.json, o = a.textures[e]; if (!o.extensions || !o.extensions[i]) return null; const l = o.extensions[i], c = a.images[l.source]; let h = s.textureLoader; if (c.uri) { const d = s.options.manager.getHandler(c.uri); d !== null && (h = d) } return s.loadTextureImage(e, l.source, h) } } class GLTFTextureAVIFExtension { constructor(e) { this.parser = e, this.name = EXTENSIONS.EXT_TEXTURE_AVIF } loadTexture(e) { const i = this.name, s = this.parser, a = s.json, o = a.textures[e]; if (!o.extensions || !o.extensions[i]) return null; const l = o.extensions[i], c = a.images[l.source]; let h = s.textureLoader; if (c.uri) { const d = s.options.manager.getHandler(c.uri); d !== null && (h = d) } return s.loadTextureImage(e, l.source, h) } } class GLTFMeshoptCompression { constructor(e) { this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION, this.parser = e } loadBufferView(e) { const i = this.parser.json, s = i.bufferViews[e]; if (s.extensions && s.extensions[this.name]) { const a = s.extensions[this.name], o = this.parser.getDependency("buffer", a.buffer), l = this.parser.options.meshoptDecoder; if (!l || !l.supported) { if (i.extensionsRequired && i.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"); return null } return o.then(function (c) { const h = a.byteOffset || 0, d = a.byteLength || 0, p = a.count, f = a.byteStride, _ = new Uint8Array(c, h, d); return l.decodeGltfBufferAsync ? l.decodeGltfBufferAsync(p, f, _, a.mode, a.filter).then(function (x) { return x.buffer }) : l.ready.then(function () { const x = new ArrayBuffer(p * f); return l.decodeGltfBuffer(new Uint8Array(x), p, f, _, a.mode, a.filter), x }) }) } else return null } } class GLTFMeshGpuInstancing { constructor(e) { this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING, this.parser = e } createNodeMesh(e) { const i = this.parser.json, s = i.nodes[e]; if (!s.extensions || !s.extensions[this.name] || s.mesh === void 0) return null; const a = i.meshes[s.mesh]; for (const d of a.primitives) if (d.mode !== WEBGL_CONSTANTS.TRIANGLES && d.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP && d.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN && d.mode !== void 0) return null; const l = s.extensions[this.name].attributes, c = [], h = {}; for (const d in l) c.push(this.parser.getDependency("accessor", l[d]).then(p => (h[d] = p, h[d]))); return c.length < 1 ? null : (c.push(this.parser.createNodeMesh(e)), Promise.all(c).then(d => { const p = d.pop(), f = p.isGroup ? p.children : [p], _ = d[0].count, x = []; for (const b of f) { const T = new Matrix4, M = new Vector3, w = new Quaternion, D = new Vector3(1, 1, 1), R = new InstancedMesh(b.geometry, b.material, _); for (let P = 0; P < _; P++)h.TRANSLATION && M.fromBufferAttribute(h.TRANSLATION, P), h.ROTATION && w.fromBufferAttribute(h.ROTATION, P), h.SCALE && D.fromBufferAttribute(h.SCALE, P), R.setMatrixAt(P, T.compose(M, w, D)); for (const P in h) if (P === "_COLOR_0") { const U = h[P]; R.instanceColor = new InstancedBufferAttribute(U.array, U.itemSize, U.normalized) } else P !== "TRANSLATION" && P !== "ROTATION" && P !== "SCALE" && b.geometry.setAttribute(P, h[P]); Object3D.prototype.copy.call(R, b), this.parser.assignFinalMaterial(R), x.push(R) } return p.isGroup ? (p.clear(), p.add(...x), p) : x[0] })) } } const BINARY_EXTENSION_HEADER_MAGIC = "glTF", BINARY_EXTENSION_HEADER_LENGTH = 12, BINARY_EXTENSION_CHUNK_TYPES = { JSON: 1313821514, BIN: 5130562 }; class GLTFBinaryExtension { constructor(e) { this.name = EXTENSIONS.KHR_BINARY_GLTF, this.content = null, this.body = null; const i = new DataView(e, 0, BINARY_EXTENSION_HEADER_LENGTH), s = new TextDecoder; if (this.header = { magic: s.decode(new Uint8Array(e.slice(0, 4))), version: i.getUint32(4, !0), length: i.getUint32(8, !0) }, this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header."); if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected."); const a = this.header.length - BINARY_EXTENSION_HEADER_LENGTH, o = new DataView(e, BINARY_EXTENSION_HEADER_LENGTH); let l = 0; for (; l < a;) { const c = o.getUint32(l, !0); l += 4; const h = o.getUint32(l, !0); if (l += 4, h === BINARY_EXTENSION_CHUNK_TYPES.JSON) { const d = new Uint8Array(e, BINARY_EXTENSION_HEADER_LENGTH + l, c); this.content = s.decode(d) } else if (h === BINARY_EXTENSION_CHUNK_TYPES.BIN) { const d = BINARY_EXTENSION_HEADER_LENGTH + l; this.body = e.slice(d, d + c) } l += c } if (this.content === null) throw new Error("THREE.GLTFLoader: JSON content not found.") } } class GLTFDracoMeshCompressionExtension { constructor(e, i) { if (!i) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided."); this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = i, this.dracoLoader.preload() } decodePrimitive(e, i) { const s = this.json, a = this.dracoLoader, o = e.extensions[this.name].bufferView, l = e.extensions[this.name].attributes, c = {}, h = {}, d = {}; for (const p in l) { const f = ATTRIBUTES[p] || p.toLowerCase(); c[f] = l[p] } for (const p in e.attributes) { const f = ATTRIBUTES[p] || p.toLowerCase(); if (l[p] !== void 0) { const _ = s.accessors[e.attributes[p]], x = WEBGL_COMPONENT_TYPES[_.componentType]; d[f] = x.name, h[f] = _.normalized === !0 } } return i.getDependency("bufferView", o).then(function (p) { return new Promise(function (f, _) { a.decodeDracoFile(p, function (x) { for (const b in x.attributes) { const T = x.attributes[b], M = h[b]; M !== void 0 && (T.normalized = M) } f(x) }, c, d, LinearSRGBColorSpace, _) }) }) } } class GLTFTextureTransformExtension { constructor() { this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM } extendTexture(e, i) { return (i.texCoord === void 0 || i.texCoord === e.channel) && i.offset === void 0 && i.rotation === void 0 && i.scale === void 0 || (e = e.clone(), i.texCoord !== void 0 && (e.channel = i.texCoord), i.offset !== void 0 && e.offset.fromArray(i.offset), i.rotation !== void 0 && (e.rotation = i.rotation), i.scale !== void 0 && e.repeat.fromArray(i.scale), e.needsUpdate = !0), e } } class GLTFMeshQuantizationExtension { constructor() { this.name = EXTENSIONS.KHR_MESH_QUANTIZATION } } class GLTFCubicSplineInterpolant extends Interpolant { constructor(e, i, s, a) { super(e, i, s, a) } copySampleValue_(e) { const i = this.resultBuffer, s = this.sampleValues, a = this.valueSize, o = e * a * 3 + a; for (let l = 0; l !== a; l++)i[l] = s[o + l]; return i } interpolate_(e, i, s, a) { const o = this.resultBuffer, l = this.sampleValues, c = this.valueSize, h = c * 2, d = c * 3, p = a - i, f = (s - i) / p, _ = f * f, x = _ * f, b = e * d, T = b - d, M = -2 * x + 3 * _, w = x - _, D = 1 - M, R = w - _ + f; for (let P = 0; P !== c; P++) { const U = l[T + P + c], O = l[T + P + h] * p, N = l[b + P + c], H = l[b + P] * p; o[P] = D * U + R * O + M * N + w * H } return o } } const _quaternion = new Quaternion; class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant { interpolate_(e, i, s, a) { const o = super.interpolate_(e, i, s, a); return _quaternion.fromArray(o).normalize().toArray(o), o } } const WEBGL_CONSTANTS = { POINTS: 0, LINES: 1, LINE_LOOP: 2, LINE_STRIP: 3, TRIANGLES: 4, TRIANGLE_STRIP: 5, TRIANGLE_FAN: 6 }, WEBGL_COMPONENT_TYPES = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }, WEBGL_FILTERS = { 9728: NearestFilter, 9729: LinearFilter, 9984: NearestMipmapNearestFilter, 9985: LinearMipmapNearestFilter, 9986: NearestMipmapLinearFilter, 9987: LinearMipmapLinearFilter }, WEBGL_WRAPPINGS = { 33071: ClampToEdgeWrapping, 33648: MirroredRepeatWrapping, 10497: RepeatWrapping }, WEBGL_TYPE_SIZES = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 }, ATTRIBUTES = { POSITION: "position", NORMAL: "normal", TANGENT: "tangent", TEXCOORD_0: "uv", TEXCOORD_1: "uv1", TEXCOORD_2: "uv2", TEXCOORD_3: "uv3", COLOR_0: "color", WEIGHTS_0: "skinWeight", JOINTS_0: "skinIndex" }, PATH_PROPERTIES = { scale: "scale", translation: "position", rotation: "quaternion", weights: "morphTargetInfluences" }, INTERPOLATION = { CUBICSPLINE: void 0, LINEAR: InterpolateLinear, STEP: InterpolateDiscrete }, ALPHA_MODES = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" }; function createDefaultMaterial(r) { return r.DefaultMaterial === void 0 && (r.DefaultMaterial = new MeshStandardMaterial({ color: 16777215, emissive: 0, metalness: 1, roughness: 1, transparent: !1, depthTest: !0, side: FrontSide })), r.DefaultMaterial } function addUnknownExtensionsToUserData(r, e, i) { for (const s in i.extensions) r[s] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[s] = i.extensions[s]) } function assignExtrasToUserData(r, e) { e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(r.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras)) } function addMorphTargets(r, e, i) { let s = !1, a = !1, o = !1; for (let d = 0, p = e.length; d < p; d++) { const f = e[d]; if (f.POSITION !== void 0 && (s = !0), f.NORMAL !== void 0 && (a = !0), f.COLOR_0 !== void 0 && (o = !0), s && a && o) break } if (!s && !a && !o) return Promise.resolve(r); const l = [], c = [], h = []; for (let d = 0, p = e.length; d < p; d++) { const f = e[d]; if (s) { const _ = f.POSITION !== void 0 ? i.getDependency("accessor", f.POSITION) : r.attributes.position; l.push(_) } if (a) { const _ = f.NORMAL !== void 0 ? i.getDependency("accessor", f.NORMAL) : r.attributes.normal; c.push(_) } if (o) { const _ = f.COLOR_0 !== void 0 ? i.getDependency("accessor", f.COLOR_0) : r.attributes.color; h.push(_) } } return Promise.all([Promise.all(l), Promise.all(c), Promise.all(h)]).then(function (d) { const p = d[0], f = d[1], _ = d[2]; return s && (r.morphAttributes.position = p), a && (r.morphAttributes.normal = f), o && (r.morphAttributes.color = _), r.morphTargetsRelative = !0, r }) } function updateMorphTargets(r, e) { if (r.updateMorphTargets(), e.weights !== void 0) for (let i = 0, s = e.weights.length; i < s; i++)r.morphTargetInfluences[i] = e.weights[i]; if (e.extras && Array.isArray(e.extras.targetNames)) { const i = e.extras.targetNames; if (r.morphTargetInfluences.length === i.length) { r.morphTargetDictionary = {}; for (let s = 0, a = i.length; s < a; s++)r.morphTargetDictionary[i[s]] = s } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.") } } function createPrimitiveKey(r) { let e; const i = r.extensions && r.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]; if (i ? e = "draco:" + i.bufferView + ":" + i.indices + ":" + createAttributesKey(i.attributes) : e = r.indices + ":" + createAttributesKey(r.attributes) + ":" + r.mode, r.targets !== void 0) for (let s = 0, a = r.targets.length; s < a; s++)e += ":" + createAttributesKey(r.targets[s]); return e } function createAttributesKey(r) { let e = ""; const i = Object.keys(r).sort(); for (let s = 0, a = i.length; s < a; s++)e += i[s] + ":" + r[i[s]] + ";"; return e } function getNormalizedComponentScale(r) { switch (r) { case Int8Array: return 1 / 127; case Uint8Array: return 1 / 255; case Int16Array: return 1 / 32767; case Uint16Array: return 1 / 65535; default: throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.") } } function getImageURIMimeType(r) { return r.search(/\.jpe?g($|\?)/i) > 0 || r.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : r.search(/\.webp($|\?)/i) > 0 || r.search(/^data\:image\/webp/) === 0 ? "image/webp" : r.search(/\.ktx2($|\?)/i) > 0 || r.search(/^data\:image\/ktx2/) === 0 ? "image/ktx2" : "image/png" } const _identityMatrix = new Matrix4; class GLTFParser { constructor(e = {}, i = {}) { this.json = e, this.extensions = {}, this.plugins = {}, this.options = i, this.cache = new GLTFRegistry, this.associations = new Map, this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {}; let s = !1, a = -1, o = !1, l = -1; if (typeof navigator < "u") { const c = navigator.userAgent; s = /^((?!chrome|android).)*safari/i.test(c) === !0; const h = c.match(/Version\/(\d+)/); a = s && h ? parseInt(h[1], 10) : -1, o = c.indexOf("Firefox") > -1, l = o ? c.match(/Firefox\/([0-9]+)\./)[1] : -1 } typeof createImageBitmap > "u" || s && a < 17 || o && l < 98 ? this.textureLoader = new TextureLoader(this.options.manager) : this.textureLoader = new ImageBitmapLoader(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new FileLoader(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0) } setExtensions(e) { this.extensions = e } setPlugins(e) { this.plugins = e } parse(e, i) { const s = this, a = this.json, o = this.extensions; this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function (l) { return l._markDefs && l._markDefs() }), Promise.all(this._invokeAll(function (l) { return l.beforeRoot && l.beforeRoot() })).then(function () { return Promise.all([s.getDependencies("scene"), s.getDependencies("animation"), s.getDependencies("camera")]) }).then(function (l) { const c = { scene: l[0][a.scene || 0], scenes: l[0], animations: l[1], cameras: l[2], asset: a.asset, parser: s, userData: {} }; return addUnknownExtensionsToUserData(o, c, a), assignExtrasToUserData(c, a), Promise.all(s._invokeAll(function (h) { return h.afterRoot && h.afterRoot(c) })).then(function () { for (const h of c.scenes) h.updateMatrixWorld(); e(c) }) }).catch(i) } _markDefs() { const e = this.json.nodes || [], i = this.json.skins || [], s = this.json.meshes || []; for (let a = 0, o = i.length; a < o; a++) { const l = i[a].joints; for (let c = 0, h = l.length; c < h; c++)e[l[c]].isBone = !0 } for (let a = 0, o = e.length; a < o; a++) { const l = e[a]; l.mesh !== void 0 && (this._addNodeRef(this.meshCache, l.mesh), l.skin !== void 0 && (s[l.mesh].isSkinnedMesh = !0)), l.camera !== void 0 && this._addNodeRef(this.cameraCache, l.camera) } } _addNodeRef(e, i) { i !== void 0 && (e.refs[i] === void 0 && (e.refs[i] = e.uses[i] = 0), e.refs[i]++) } _getNodeRef(e, i, s) { if (e.refs[i] <= 1) return s; const a = s.clone(), o = (l, c) => { const h = this.associations.get(l); h != null && this.associations.set(c, h); for (const [d, p] of l.children.entries()) o(p, c.children[d]) }; return o(s, a), a.name += "_instance_" + e.uses[i]++, a } _invokeOne(e) { const i = Object.values(this.plugins); i.push(this); for (let s = 0; s < i.length; s++) { const a = e(i[s]); if (a) return a } return null } _invokeAll(e) { const i = Object.values(this.plugins); i.unshift(this); const s = []; for (let a = 0; a < i.length; a++) { const o = e(i[a]); o && s.push(o) } return s } getDependency(e, i) { const s = e + ":" + i; let a = this.cache.get(s); if (!a) { switch (e) { case "scene": a = this.loadScene(i); break; case "node": a = this._invokeOne(function (o) { return o.loadNode && o.loadNode(i) }); break; case "mesh": a = this._invokeOne(function (o) { return o.loadMesh && o.loadMesh(i) }); break; case "accessor": a = this.loadAccessor(i); break; case "bufferView": a = this._invokeOne(function (o) { return o.loadBufferView && o.loadBufferView(i) }); break; case "buffer": a = this.loadBuffer(i); break; case "material": a = this._invokeOne(function (o) { return o.loadMaterial && o.loadMaterial(i) }); break; case "texture": a = this._invokeOne(function (o) { return o.loadTexture && o.loadTexture(i) }); break; case "skin": a = this.loadSkin(i); break; case "animation": a = this._invokeOne(function (o) { return o.loadAnimation && o.loadAnimation(i) }); break; case "camera": a = this.loadCamera(i); break; default: if (a = this._invokeOne(function (o) { return o != this && o.getDependency && o.getDependency(e, i) }), !a) throw new Error("Unknown type: " + e); break }this.cache.add(s, a) } return a } getDependencies(e) { let i = this.cache.get(e); if (!i) { const s = this, a = this.json[e + (e === "mesh" ? "es" : "s")] || []; i = Promise.all(a.map(function (o, l) { return s.getDependency(e, l) })), this.cache.add(e, i) } return i } loadBuffer(e) { const i = this.json.buffers[e], s = this.fileLoader; if (i.type && i.type !== "arraybuffer") throw new Error("THREE.GLTFLoader: " + i.type + " buffer type is not supported."); if (i.uri === void 0 && e === 0) return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body); const a = this.options; return new Promise(function (o, l) { s.load(LoaderUtils.resolveURL(i.uri, a.path), o, void 0, function () { l(new Error('THREE.GLTFLoader: Failed to load buffer "' + i.uri + '".')) }) }) } loadBufferView(e) { const i = this.json.bufferViews[e]; return this.getDependency("buffer", i.buffer).then(function (s) { const a = i.byteLength || 0, o = i.byteOffset || 0; return s.slice(o, o + a) }) } loadAccessor(e) { const i = this, s = this.json, a = this.json.accessors[e]; if (a.bufferView === void 0 && a.sparse === void 0) { const l = WEBGL_TYPE_SIZES[a.type], c = WEBGL_COMPONENT_TYPES[a.componentType], h = a.normalized === !0, d = new c(a.count * l); return Promise.resolve(new BufferAttribute(d, l, h)) } const o = []; return a.bufferView !== void 0 ? o.push(this.getDependency("bufferView", a.bufferView)) : o.push(null), a.sparse !== void 0 && (o.push(this.getDependency("bufferView", a.sparse.indices.bufferView)), o.push(this.getDependency("bufferView", a.sparse.values.bufferView))), Promise.all(o).then(function (l) { const c = l[0], h = WEBGL_TYPE_SIZES[a.type], d = WEBGL_COMPONENT_TYPES[a.componentType], p = d.BYTES_PER_ELEMENT, f = p * h, _ = a.byteOffset || 0, x = a.bufferView !== void 0 ? s.bufferViews[a.bufferView].byteStride : void 0, b = a.normalized === !0; let T, M; if (x && x !== f) { const w = Math.floor(_ / x), D = "InterleavedBuffer:" + a.bufferView + ":" + a.componentType + ":" + w + ":" + a.count; let R = i.cache.get(D); R || (T = new d(c, w * x, a.count * x / p), R = new InterleavedBuffer(T, x / p), i.cache.add(D, R)), M = new InterleavedBufferAttribute(R, h, _ % x / p, b) } else c === null ? T = new d(a.count * h) : T = new d(c, _, a.count * h), M = new BufferAttribute(T, h, b); if (a.sparse !== void 0) { const w = WEBGL_TYPE_SIZES.SCALAR, D = WEBGL_COMPONENT_TYPES[a.sparse.indices.componentType], R = a.sparse.indices.byteOffset || 0, P = a.sparse.values.byteOffset || 0, U = new D(l[1], R, a.sparse.count * w), O = new d(l[2], P, a.sparse.count * h); c !== null && (M = new BufferAttribute(M.array.slice(), M.itemSize, M.normalized)), M.normalized = !1; for (let N = 0, H = U.length; N < H; N++) { const F = U[N]; if (M.setX(F, O[N * h]), h >= 2 && M.setY(F, O[N * h + 1]), h >= 3 && M.setZ(F, O[N * h + 2]), h >= 4 && M.setW(F, O[N * h + 3]), h >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.") } M.normalized = b } return M }) } loadTexture(e) { const i = this.json, s = this.options, o = i.textures[e].source, l = i.images[o]; let c = this.textureLoader; if (l.uri) { const h = s.manager.getHandler(l.uri); h !== null && (c = h) } return this.loadTextureImage(e, o, c) } loadTextureImage(e, i, s) { const a = this, o = this.json, l = o.textures[e], c = o.images[i], h = (c.uri || c.bufferView) + ":" + l.sampler; if (this.textureCache[h]) return this.textureCache[h]; const d = this.loadImageSource(i, s).then(function (p) { p.flipY = !1, p.name = l.name || c.name || "", p.name === "" && typeof c.uri == "string" && c.uri.startsWith("data:image/") === !1 && (p.name = c.uri); const _ = (o.samplers || {})[l.sampler] || {}; return p.magFilter = WEBGL_FILTERS[_.magFilter] || LinearFilter, p.minFilter = WEBGL_FILTERS[_.minFilter] || LinearMipmapLinearFilter, p.wrapS = WEBGL_WRAPPINGS[_.wrapS] || RepeatWrapping, p.wrapT = WEBGL_WRAPPINGS[_.wrapT] || RepeatWrapping, p.generateMipmaps = !p.isCompressedTexture && p.minFilter !== NearestFilter && p.minFilter !== LinearFilter, a.associations.set(p, { textures: e }), p }).catch(function () { return null }); return this.textureCache[h] = d, d } loadImageSource(e, i) { const s = this, a = this.json, o = this.options; if (this.sourceCache[e] !== void 0) return this.sourceCache[e].then(f => f.clone()); const l = a.images[e], c = self.URL || self.webkitURL; let h = l.uri || "", d = !1; if (l.bufferView !== void 0) h = s.getDependency("bufferView", l.bufferView).then(function (f) { d = !0; const _ = new Blob([f], { type: l.mimeType }); return h = c.createObjectURL(_), h }); else if (l.uri === void 0) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"); const p = Promise.resolve(h).then(function (f) { return new Promise(function (_, x) { let b = _; i.isImageBitmapLoader === !0 && (b = function (T) { const M = new Texture(T); M.needsUpdate = !0, _(M) }), i.load(LoaderUtils.resolveURL(f, o.path), b, void 0, x) }) }).then(function (f) { return d === !0 && c.revokeObjectURL(h), assignExtrasToUserData(f, l), f.userData.mimeType = l.mimeType || getImageURIMimeType(l.uri), f }).catch(function (f) { throw console.error("THREE.GLTFLoader: Couldn't load texture", h), f }); return this.sourceCache[e] = p, p } assignTexture(e, i, s, a) { const o = this; return this.getDependency("texture", s.index).then(function (l) { if (!l) return null; if (s.texCoord !== void 0 && s.texCoord > 0 && (l = l.clone(), l.channel = s.texCoord), o.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) { const c = s.extensions !== void 0 ? s.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0; if (c) { const h = o.associations.get(l); l = o.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(l, c), o.associations.set(l, h) } } return a !== void 0 && (l.colorSpace = a), e[i] = l, l }) } assignFinalMaterial(e) { const i = e.geometry; let s = e.material; const a = i.attributes.tangent === void 0, o = i.attributes.color !== void 0, l = i.attributes.normal === void 0; if (e.isPoints) { const c = "PointsMaterial:" + s.uuid; let h = this.cache.get(c); h || (h = new PointsMaterial, Material.prototype.copy.call(h, s), h.color.copy(s.color), h.map = s.map, h.sizeAttenuation = !1, this.cache.add(c, h)), s = h } else if (e.isLine) { const c = "LineBasicMaterial:" + s.uuid; let h = this.cache.get(c); h || (h = new LineBasicMaterial, Material.prototype.copy.call(h, s), h.color.copy(s.color), h.map = s.map, this.cache.add(c, h)), s = h } if (a || o || l) { let c = "ClonedMaterial:" + s.uuid + ":"; a && (c += "derivative-tangents:"), o && (c += "vertex-colors:"), l && (c += "flat-shading:"); let h = this.cache.get(c); h || (h = s.clone(), o && (h.vertexColors = !0), l && (h.flatShading = !0), a && (h.normalScale && (h.normalScale.y *= -1), h.clearcoatNormalScale && (h.clearcoatNormalScale.y *= -1)), this.cache.add(c, h), this.associations.set(h, this.associations.get(s))), s = h } e.material = s } getMaterialType() { return MeshStandardMaterial } loadMaterial(e) { const i = this, s = this.json, a = this.extensions, o = s.materials[e]; let l; const c = {}, h = o.extensions || {}, d = []; if (h[EXTENSIONS.KHR_MATERIALS_UNLIT]) { const f = a[EXTENSIONS.KHR_MATERIALS_UNLIT]; l = f.getMaterialType(), d.push(f.extendParams(c, o, i)) } else { const f = o.pbrMetallicRoughness || {}; if (c.color = new Color(1, 1, 1), c.opacity = 1, Array.isArray(f.baseColorFactor)) { const _ = f.baseColorFactor; c.color.setRGB(_[0], _[1], _[2], LinearSRGBColorSpace), c.opacity = _[3] } f.baseColorTexture !== void 0 && d.push(i.assignTexture(c, "map", f.baseColorTexture, SRGBColorSpace)), c.metalness = f.metallicFactor !== void 0 ? f.metallicFactor : 1, c.roughness = f.roughnessFactor !== void 0 ? f.roughnessFactor : 1, f.metallicRoughnessTexture !== void 0 && (d.push(i.assignTexture(c, "metalnessMap", f.metallicRoughnessTexture)), d.push(i.assignTexture(c, "roughnessMap", f.metallicRoughnessTexture))), l = this._invokeOne(function (_) { return _.getMaterialType && _.getMaterialType(e) }), d.push(Promise.all(this._invokeAll(function (_) { return _.extendMaterialParams && _.extendMaterialParams(e, c) }))) } o.doubleSided === !0 && (c.side = DoubleSide); const p = o.alphaMode || ALPHA_MODES.OPAQUE; if (p === ALPHA_MODES.BLEND ? (c.transparent = !0, c.depthWrite = !1) : (c.transparent = !1, p === ALPHA_MODES.MASK && (c.alphaTest = o.alphaCutoff !== void 0 ? o.alphaCutoff : .5)), o.normalTexture !== void 0 && l !== MeshBasicMaterial && (d.push(i.assignTexture(c, "normalMap", o.normalTexture)), c.normalScale = new Vector2(1, 1), o.normalTexture.scale !== void 0)) { const f = o.normalTexture.scale; c.normalScale.set(f, f) } if (o.occlusionTexture !== void 0 && l !== MeshBasicMaterial && (d.push(i.assignTexture(c, "aoMap", o.occlusionTexture)), o.occlusionTexture.strength !== void 0 && (c.aoMapIntensity = o.occlusionTexture.strength)), o.emissiveFactor !== void 0 && l !== MeshBasicMaterial) { const f = o.emissiveFactor; c.emissive = new Color().setRGB(f[0], f[1], f[2], LinearSRGBColorSpace) } return o.emissiveTexture !== void 0 && l !== MeshBasicMaterial && d.push(i.assignTexture(c, "emissiveMap", o.emissiveTexture, SRGBColorSpace)), Promise.all(d).then(function () { const f = new l(c); return o.name && (f.name = o.name), assignExtrasToUserData(f, o), i.associations.set(f, { materials: e }), o.extensions && addUnknownExtensionsToUserData(a, f, o), f }) } createUniqueName(e) { const i = PropertyBinding.sanitizeNodeName(e || ""); return i in this.nodeNamesUsed ? i + "_" + ++this.nodeNamesUsed[i] : (this.nodeNamesUsed[i] = 0, i) } loadGeometries(e) { const i = this, s = this.extensions, a = this.primitiveCache; function o(c) { return s[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(c, i).then(function (h) { return addPrimitiveAttributes(h, c, i) }) } const l = []; for (let c = 0, h = e.length; c < h; c++) { const d = e[c], p = createPrimitiveKey(d), f = a[p]; if (f) l.push(f.promise); else { let _; d.extensions && d.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION] ? _ = o(d) : _ = addPrimitiveAttributes(new BufferGeometry, d, i), a[p] = { primitive: d, promise: _ }, l.push(_) } } return Promise.all(l) } loadMesh(e) { const i = this, s = this.json, a = this.extensions, o = s.meshes[e], l = o.primitives, c = []; for (let h = 0, d = l.length; h < d; h++) { const p = l[h].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency("material", l[h].material); c.push(p) } return c.push(i.loadGeometries(l)), Promise.all(c).then(function (h) { const d = h.slice(0, h.length - 1), p = h[h.length - 1], f = []; for (let x = 0, b = p.length; x < b; x++) { const T = p[x], M = l[x]; let w; const D = d[x]; if (M.mode === WEBGL_CONSTANTS.TRIANGLES || M.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || M.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || M.mode === void 0) w = o.isSkinnedMesh === !0 ? new SkinnedMesh(T, D) : new Mesh(T, D), w.isSkinnedMesh === !0 && w.normalizeSkinWeights(), M.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ? w.geometry = toTrianglesDrawMode(w.geometry, TriangleStripDrawMode) : M.mode === WEBGL_CONSTANTS.TRIANGLE_FAN && (w.geometry = toTrianglesDrawMode(w.geometry, TriangleFanDrawMode)); else if (M.mode === WEBGL_CONSTANTS.LINES) w = new LineSegments(T, D); else if (M.mode === WEBGL_CONSTANTS.LINE_STRIP) w = new Line(T, D); else if (M.mode === WEBGL_CONSTANTS.LINE_LOOP) w = new LineLoop(T, D); else if (M.mode === WEBGL_CONSTANTS.POINTS) w = new Points(T, D); else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + M.mode); Object.keys(w.geometry.morphAttributes).length > 0 && updateMorphTargets(w, o), w.name = i.createUniqueName(o.name || "mesh_" + e), assignExtrasToUserData(w, o), M.extensions && addUnknownExtensionsToUserData(a, w, M), i.assignFinalMaterial(w), f.push(w) } for (let x = 0, b = f.length; x < b; x++)i.associations.set(f[x], { meshes: e, primitives: x }); if (f.length === 1) return o.extensions && addUnknownExtensionsToUserData(a, f[0], o), f[0]; const _ = new Group; o.extensions && addUnknownExtensionsToUserData(a, _, o), i.associations.set(_, { meshes: e }); for (let x = 0, b = f.length; x < b; x++)_.add(f[x]); return _ }) } loadCamera(e) { let i; const s = this.json.cameras[e], a = s[s.type]; if (!a) { console.warn("THREE.GLTFLoader: Missing camera parameters."); return } return s.type === "perspective" ? i = new PerspectiveCamera(MathUtils.radToDeg(a.yfov), a.aspectRatio || 1, a.znear || 1, a.zfar || 2e6) : s.type === "orthographic" && (i = new OrthographicCamera(-a.xmag, a.xmag, a.ymag, -a.ymag, a.znear, a.zfar)), s.name && (i.name = this.createUniqueName(s.name)), assignExtrasToUserData(i, s), Promise.resolve(i) } loadSkin(e) { const i = this.json.skins[e], s = []; for (let a = 0, o = i.joints.length; a < o; a++)s.push(this._loadNodeShallow(i.joints[a])); return i.inverseBindMatrices !== void 0 ? s.push(this.getDependency("accessor", i.inverseBindMatrices)) : s.push(null), Promise.all(s).then(function (a) { const o = a.pop(), l = a, c = [], h = []; for (let d = 0, p = l.length; d < p; d++) { const f = l[d]; if (f) { c.push(f); const _ = new Matrix4; o !== null && _.fromArray(o.array, d * 16), h.push(_) } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', i.joints[d]) } return new Skeleton(c, h) }) } loadAnimation(e) { const i = this.json, s = this, a = i.animations[e], o = a.name ? a.name : "animation_" + e, l = [], c = [], h = [], d = [], p = []; for (let f = 0, _ = a.channels.length; f < _; f++) { const x = a.channels[f], b = a.samplers[x.sampler], T = x.target, M = T.node, w = a.parameters !== void 0 ? a.parameters[b.input] : b.input, D = a.parameters !== void 0 ? a.parameters[b.output] : b.output; T.node !== void 0 && (l.push(this.getDependency("node", M)), c.push(this.getDependency("accessor", w)), h.push(this.getDependency("accessor", D)), d.push(b), p.push(T)) } return Promise.all([Promise.all(l), Promise.all(c), Promise.all(h), Promise.all(d), Promise.all(p)]).then(function (f) { const _ = f[0], x = f[1], b = f[2], T = f[3], M = f[4], w = []; for (let R = 0, P = _.length; R < P; R++) { const U = _[R], O = x[R], N = b[R], H = T[R], F = M[R]; if (U === void 0) continue; U.updateMatrix && U.updateMatrix(); const k = s._createAnimationTracks(U, O, N, H, F); if (k) for (let W = 0; W < k.length; W++)w.push(k[W]) } const D = new AnimationClip(o, void 0, w); return assignExtrasToUserData(D, a), D }) } createNodeMesh(e) { const i = this.json, s = this, a = i.nodes[e]; return a.mesh === void 0 ? null : s.getDependency("mesh", a.mesh).then(function (o) { const l = s._getNodeRef(s.meshCache, a.mesh, o); return a.weights !== void 0 && l.traverse(function (c) { if (c.isMesh) for (let h = 0, d = a.weights.length; h < d; h++)c.morphTargetInfluences[h] = a.weights[h] }), l }) } loadNode(e) { const i = this.json, s = this, a = i.nodes[e], o = s._loadNodeShallow(e), l = [], c = a.children || []; for (let d = 0, p = c.length; d < p; d++)l.push(s.getDependency("node", c[d])); const h = a.skin === void 0 ? Promise.resolve(null) : s.getDependency("skin", a.skin); return Promise.all([o, Promise.all(l), h]).then(function (d) { const p = d[0], f = d[1], _ = d[2]; _ !== null && p.traverse(function (x) { x.isSkinnedMesh && x.bind(_, _identityMatrix) }); for (let x = 0, b = f.length; x < b; x++)p.add(f[x]); return p }) } _loadNodeShallow(e) { const i = this.json, s = this.extensions, a = this; if (this.nodeCache[e] !== void 0) return this.nodeCache[e]; const o = i.nodes[e], l = o.name ? a.createUniqueName(o.name) : "", c = [], h = a._invokeOne(function (d) { return d.createNodeMesh && d.createNodeMesh(e) }); return h && c.push(h), o.camera !== void 0 && c.push(a.getDependency("camera", o.camera).then(function (d) { return a._getNodeRef(a.cameraCache, o.camera, d) })), a._invokeAll(function (d) { return d.createNodeAttachment && d.createNodeAttachment(e) }).forEach(function (d) { c.push(d) }), this.nodeCache[e] = Promise.all(c).then(function (d) { let p; if (o.isBone === !0 ? p = new Bone : d.length > 1 ? p = new Group : d.length === 1 ? p = d[0] : p = new Object3D, p !== d[0]) for (let f = 0, _ = d.length; f < _; f++)p.add(d[f]); if (o.name && (p.userData.name = o.name, p.name = l), assignExtrasToUserData(p, o), o.extensions && addUnknownExtensionsToUserData(s, p, o), o.matrix !== void 0) { const f = new Matrix4; f.fromArray(o.matrix), p.applyMatrix4(f) } else o.translation !== void 0 && p.position.fromArray(o.translation), o.rotation !== void 0 && p.quaternion.fromArray(o.rotation), o.scale !== void 0 && p.scale.fromArray(o.scale); if (!a.associations.has(p)) a.associations.set(p, {}); else if (o.mesh !== void 0 && a.meshCache.refs[o.mesh] > 1) { const f = a.associations.get(p); a.associations.set(p, { ...f }) } return a.associations.get(p).nodes = e, p }), this.nodeCache[e] } loadScene(e) { const i = this.extensions, s = this.json.scenes[e], a = this, o = new Group; s.name && (o.name = a.createUniqueName(s.name)), assignExtrasToUserData(o, s), s.extensions && addUnknownExtensionsToUserData(i, o, s); const l = s.nodes || [], c = []; for (let h = 0, d = l.length; h < d; h++)c.push(a.getDependency("node", l[h])); return Promise.all(c).then(function (h) { for (let p = 0, f = h.length; p < f; p++)o.add(h[p]); const d = p => { const f = new Map; for (const [_, x] of a.associations) (_ instanceof Material || _ instanceof Texture) && f.set(_, x); return p.traverse(_ => { const x = a.associations.get(_); x != null && f.set(_, x) }), f }; return a.associations = d(o), o }) } _createAnimationTracks(e, i, s, a, o) { const l = [], c = e.name ? e.name : e.uuid, h = []; PATH_PROPERTIES[o.path] === PATH_PROPERTIES.weights ? e.traverse(function (_) { _.morphTargetInfluences && h.push(_.name ? _.name : _.uuid) }) : h.push(c); let d; switch (PATH_PROPERTIES[o.path]) { case PATH_PROPERTIES.weights: d = NumberKeyframeTrack; break; case PATH_PROPERTIES.rotation: d = QuaternionKeyframeTrack; break; case PATH_PROPERTIES.translation: case PATH_PROPERTIES.scale: d = VectorKeyframeTrack; break; default: switch (s.itemSize) { case 1: d = NumberKeyframeTrack; break; case 2: case 3: default: d = VectorKeyframeTrack; break }break }const p = a.interpolation !== void 0 ? INTERPOLATION[a.interpolation] : InterpolateLinear, f = this._getArrayFromAccessor(s); for (let _ = 0, x = h.length; _ < x; _++) { const b = new d(h[_] + "." + PATH_PROPERTIES[o.path], i.array, f, p); a.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(b), l.push(b) } return l } _getArrayFromAccessor(e) { let i = e.array; if (e.normalized) { const s = getNormalizedComponentScale(i.constructor), a = new Float32Array(i.length); for (let o = 0, l = i.length; o < l; o++)a[o] = i[o] * s; i = a } return i } _createCubicSplineTrackInterpolant(e) { e.createInterpolant = function (s) { const a = this instanceof QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant; return new a(this.times, this.values, this.getValueSize() / 3, s) }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0 } } function computeBounds(r, e, i) { const s = e.attributes, a = new Box3; if (s.POSITION !== void 0) { const c = i.json.accessors[s.POSITION], h = c.min, d = c.max; if (h !== void 0 && d !== void 0) { if (a.set(new Vector3(h[0], h[1], h[2]), new Vector3(d[0], d[1], d[2])), c.normalized) { const p = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[c.componentType]); a.min.multiplyScalar(p), a.max.multiplyScalar(p) } } else { console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION."); return } } else return; const o = e.targets; if (o !== void 0) { const c = new Vector3, h = new Vector3; for (let d = 0, p = o.length; d < p; d++) { const f = o[d]; if (f.POSITION !== void 0) { const _ = i.json.accessors[f.POSITION], x = _.min, b = _.max; if (x !== void 0 && b !== void 0) { if (h.setX(Math.max(Math.abs(x[0]), Math.abs(b[0]))), h.setY(Math.max(Math.abs(x[1]), Math.abs(b[1]))), h.setZ(Math.max(Math.abs(x[2]), Math.abs(b[2]))), _.normalized) { const T = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[_.componentType]); h.multiplyScalar(T) } c.max(h) } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.") } } a.expandByVector(c) } r.boundingBox = a; const l = new Sphere; a.getCenter(l.center), l.radius = a.min.distanceTo(a.max) / 2, r.boundingSphere = l } function addPrimitiveAttributes(r, e, i) { const s = e.attributes, a = []; function o(l, c) { return i.getDependency("accessor", l).then(function (h) { r.setAttribute(c, h) }) } for (const l in s) { const c = ATTRIBUTES[l] || l.toLowerCase(); c in r.attributes || a.push(o(s[l], c)) } if (e.indices !== void 0 && !r.index) { const l = i.getDependency("accessor", e.indices).then(function (c) { r.setIndex(c) }); a.push(l) } return ColorManagement.workingColorSpace !== LinearSRGBColorSpace && "COLOR_0" in s && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${ColorManagement.workingColorSpace}" not supported.`), assignExtrasToUserData(r, e), computeBounds(r, e, i), Promise.all(a).then(function () { return e.targets !== void 0 ? addMorphTargets(r, e.targets, i) : r }) } const loader = new GLTFLoader, gltfLoader = { _gltfCache: new Map }; function setGLTFPath() { loader.setPath(`${client$1.absolutePath}/assets/gltf/`) } function disposeGLTF() { gltfLoader._gltfCache.clear() } const plane = new PlaneGeometry, triangle$2 = new BufferGeometry; triangle$2.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]), 3)); triangle$2.setAttribute("uv", new BufferAttribute(new Float32Array([0, 0, 2, 0, 0, 2]), 2)); new Vector3; new Vector3; new Triangle; new Vector3; new Vector3; new Vector3; new Triangle; new Vector2; new Vector3; new Vector4; let FullScreenQuad$1 = class { constructor(e = null) { Ke(this, "camera", new OrthographicCamera(-1, 1, 1, -1, 0, 1)); Ke(this, "mesh", null); this.mesh = new Mesh(triangle$2, e), this.mesh.frustumCulled = !1 } get material() { return this.mesh.material } set material(e) { this.mesh.material = e } render(e) { e.render(this.mesh, this.camera) } dispose() { if (this.mesh.geometry.dispose(), this.mesh.material.dispose(), !!this.mesh.material.uniforms) for (const e in this.mesh.material.uniforms) { const i = this.mesh.material.uniforms[e]; i.value && i.value.dispose && i.value.dispose() } } }; new Vector3; new Vector2; new Vector3; const utils = { plane, triangle: triangle$2, fsQuad: FullScreenQuad$1, planeInteraction: new planeInteraction }; var kr, Ns, Ba; class gui { constructor() { pe(this, kr, null); pe(this, Ns, null); pe(this, Ba, !1) } async init() { } add(e, i, s) { var a; (a = L(this, kr)) == null || a.add(e, i, s) } showRenderInfo(e) { var i; (i = L(this, Ns)) == null || i.add(e) } hideRenderInfo() { var e; (e = L(this, Ns)) == null || e.remove() } } kr = new WeakMap, Ns = new WeakMap, Ba = new WeakMap; const gui$1 = new gui; let Pass$1 = class { constructor() { this.isPass = !0, this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1 } setSize() { } render() { console.error("THREE.Pass: .render() must be implemented in derived pass.") } dispose() { } }; const _camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1); class FullscreenTriangleGeometry extends BufferGeometry { constructor() { super(), this.setAttribute("position", new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), this.setAttribute("uv", new Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2)) } } const _geometry = new FullscreenTriangleGeometry; class FullScreenQuad { constructor(e) { this._mesh = new Mesh(_geometry, e) } dispose() { this._mesh.geometry.dispose() } render(e) { e.render(this._mesh, _camera) } get material() { return this._mesh.material } set material(e) { this._mesh.material = e } } let RenderPass$1 = class extends Pass$1 { constructor(e, i, s = null, a = null, o = null) { super(), this.scene = e, this.camera = i, this.overrideMaterial = s, this.clearColor = a, this.clearAlpha = o, this.clear = !0, this.clearDepth = !1, this.needsSwap = !1, this._oldClearColor = new Color } render(e, i, s) { const a = e.autoClear; e.autoClear = !1; let o, l; this.overrideMaterial !== null && (l = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor !== null && (e.getClearColor(this._oldClearColor), e.setClearColor(this.clearColor, e.getClearAlpha())), this.clearAlpha !== null && (o = e.getClearAlpha(), e.setClearAlpha(this.clearAlpha)), this.clearDepth == !0 && e.clearDepth(), e.setRenderTarget(this.renderToScreen ? null : s), this.clear === !0 && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), e.render(this.scene, this.camera), this.clearColor !== null && e.setClearColor(this._oldClearColor), this.clearAlpha !== null && e.setClearAlpha(o), this.overrideMaterial !== null && (this.scene.overrideMaterial = l), e.autoClear = a } }; var hs, io, no; class keys { constructor() { pe(this, hs); Ke(this, "boundKeyDown", Pe(this, hs, io).bind(this)); Ke(this, "boundKeyUp", Pe(this, hs, no).bind(this)) } init() { window.addEventListener("keydown", this.boundKeyDown), window.addEventListener("keyup", this.boundKeyUp) } dispose() { window.removeEventListener("keydown", this.boundKeyDown), window.removeEventListener("keyup", this.boundKeyUp) } } hs = new WeakSet, io = function (e) { events.emit("keydown", e) }, no = function (e) { events.emit("keyup", e) }; const keys$1 = new keys; var Os, zr, rs, Gr, Vr, Hr, Qr, ks, zs, Wr, ji, Pn, as, Li, Ln, ui, ya, fs, ba; class adaptiveDPR { constructor(e) { pe(this, ui); pe(this, Os, null); pe(this, zr, 2); pe(this, rs, 0); pe(this, Gr, 4); pe(this, Vr, 5); pe(this, Hr, 30); pe(this, Qr, 60); pe(this, ks, .1); pe(this, zs, .6); pe(this, Wr, 4); pe(this, ji, []); pe(this, Pn, 0); pe(this, as, 0); pe(this, Li, 1); pe(this, Ln, 0); Xe(this, Os, e) } get hasRun() { return L(this, Ln) !== 0 } get multiplier() { return L(this, Li) } start() { this.stop(), Xe(this, rs, renderInfo.time + L(this, zr)), Xe(this, Ln, L(this, rs)), events.on("average_fps_update", Pe(this, ui, ya), this), events.on("adaptive_dpr_force", Pe(this, ui, fs), this), events.on("adaptive_dpr_renderinfo_report", Pe(this, ui, ba), this) } stop() { L(this, ji).length = 0, events.off("average_fps_update", Pe(this, ui, ya), this), events.off("adaptive_dpr_force", Pe(this, ui, fs), this), events.off("adaptive_dpr_renderinfo_report", Pe(this, ui, ba), this) } } Os = new WeakMap, zr = new WeakMap, rs = new WeakMap, Gr = new WeakMap, Vr = new WeakMap, Hr = new WeakMap, Qr = new WeakMap, ks = new WeakMap, zs = new WeakMap, Wr = new WeakMap, ji = new WeakMap, Pn = new WeakMap, as = new WeakMap, Li = new WeakMap, Ln = new WeakMap, ui = new WeakSet, ya = function (e) { if (!(renderInfo.time < L(this, rs)) && client$1.visible && (L(this, ji).push(e), renderInfo.time - L(this, Ln) >= L(this, Gr) && L(this, ji).length >= L(this, Vr))) { const i = L(this, ji).reduce((s, a) => s + a, 0) / L(this, ji).length; i < L(this, Hr) && L(this, Li) > L(this, zs) ? (Pe(this, ui, fs).call(this, Math.max(L(this, zs), L(this, Li) - L(this, ks))), L(this, Pn) === 1 && pr(this, as)._++, Xe(this, Pn, -1)) : i >= L(this, Qr) && L(this, Li) < 1 && (Pe(this, ui, fs).call(this, Math.min(1, L(this, Li) + L(this, ks))), L(this, Pn) === -1 && pr(this, as)._++, Xe(this, Pn, 1)), L(this, ji).length = 0, Xe(this, Ln, renderInfo.time), L(this, as) >= L(this, Wr) && (console.warn("Adaptive DPR stopped."), this.stop()) } }, fs = function (e = 1) { Xe(this, Li, e), L(this, Os).setDPRMultiplier(e) }, ba = function (e = {}) { e.adaptiveDPR = L(this, Li) }; var qr, so; class globalBase { constructor() { pe(this, qr); Ke(this, "canvasCnt", null); Ke(this, "canvasNode", null); Ke(this, "interactionNode", null); Ke(this, "contextMenu", !1); Ke(this, "fingers", 1); Ke(this, "baseDPR", 1); Ke(this, "currentDPR", 1); Ke(this, "adaptiveDPR", null); Ke(this, "audioContext", audiocontext) } init({ canvasCnt: e, relativePath: i, interactionNode: s, fingers: a = 1, contextMenu: o = !1, DPR: l = 1, adaptiveDPR: c = !0 } = {}) { var h; Pe(this, qr, so).call(this, i), this.canvasCnt = e, this.baseDPR = l, this.adaptiveDPR = c ? new adaptiveDPR(this) : null, this.currentDPR = this.baseDPR * (((h = this.adaptiveDPR) == null ? void 0 : h.multiplier) || 1), this.fingers = a, this.interactionNode = s, this.contextMenu = o, this.audioContext.init() } setDPRMultiplier(e = 1) { this.currentDPR = this.baseDPR * e, events.emit("resize", client$1.screen.w, client$1.screen.h) } initInteraction() { touches$1.init({ element: this.interactionNode, fingers: this.fingers, contextMenu: this.contextMenu }), wheel$1.init({ element: this.interactionNode }), gamepad$1.init(), keys$1.init() } setDevScene(e) { } setRenderScene(e) { } dispose({ audios: e = !0, fonts: i = !0, geometries: s = !0, textures: a = !0, gltf: o = !0, input: l = !1, renderer: c = !1, audioContext: h = !1 } = {}) { var d; e && disposeAudioBuffers(), i && disposeGlyphs(), s && disposeGeometries(), a && disposeTextures(), o && disposeGLTF(), c && ((d = this.adaptiveDPR) == null || d.stop()), h && this.audioContext.dispose(), l && (touches$1.dispose(), wheel$1.dispose(), keys$1.dispose(), gamepad$1.dispose(), this.interactionNode = null) } } qr = new WeakSet, so = function (e) { client$1.setRelativePath(e || ""), setAudioBuffersPath(), setGlyphsPath(), setGeometryPath(), setTexturesPath(), setGLTFPath() }; const _forward = new Vector3, _right = new Vector3, _up = new Vector3, _v0$j = new Vector3, _m0$4 = new Matrix4, HALF_PI = Math.PI * .5, ZERO_V2 = new Vector2, CAMERA_TYPE = { PERSPECTIVE: 1, ORTHOGRAPHIC: 2 }, CAMERA_SIZING = { SCREEN: 1, CUSTOM: 2 }, BASE_NEAR = .1, BASE_FAR = 1e3, BASE_Z = 6; function baseCamera(r) { const e = CAMERA_TYPE[r.toUpperCase()], i = e === CAMERA_TYPE.PERSPECTIVE ? PerspectiveCamera : OrthographicCamera; return class extends i { constructor() { e === CAMERA_TYPE.PERSPECTIVE ? super(45, client$1.screen.w / client$1.screen.h, BASE_NEAR, BASE_FAR) : super(client$1.screen.w * -.5, client$1.screen.w * .5, client$1.screen.h * .5, client$1.screen.h * -.5, BASE_NEAR, BASE_FAR), this.isBaseCamera = !0, this._sizing = CAMERA_SIZING.SCREEN, this._size = new Vector2(client$1.screen.w, client$1.screen.h), this._prevSize = this._size.clone(), this._prevPosition = new Vector3, this._prevTarget = new Vector3, this._prevUp = new Vector3, this._additionalSphericalPosition = new Spherical, this._additionalSphericalTarget = new Spherical, this._additionalRotationUp = 0, this._touchPosition = new Vector2, this._touchVelocity = new Vector2, this.target = new Vector3, this.basePosition = new Vector3(0, 0, BASE_Z), this.baseTarget = new Vector3, this.baseUp = new Vector3(0, 1, 0), this.displacement = { position: new Vector2, target: new Vector2, rotation: 0 }, this.lerpPosition = .05, this.lerpTarget = .05, this.lerpRotation = .05, this.shake = new Vector3, this.shakeSpeed = new Vector3(1, 1, 1), this.touchAmount = 1, this.resetOnTouch = !0 } _update(s = !1) { const a = touches$1.get(0), o = this.resetOnTouch && a.input === "touch" && a.touchID === !1, l = o ? .5 : 1, c = o ? 0 : math.fit(a.position11.x, -1, 1, -HALF_PI, HALF_PI), h = o ? 0 : math.fit(a.position11.y, 1, -1, -HALF_PI, HALF_PI), d = this._touchPosition.x, p = this._touchPosition.y, f = s ? 1 : math.lerpCoefFPS(.1); this._touchPosition.x = math.lerp(this._touchPosition.x, c, f), this._touchPosition.y = math.lerp(this._touchPosition.y, h, f), this._touchVelocity.x += this._touchPosition.x - d, this._touchVelocity.y += this._touchPosition.y - p, this._touchVelocity.multiplyScalar(math.frictionFPS(.95)), (this._touchVelocity.lengthSq() < 1e-4 || s) && this._touchVelocity.set(0, 0); const _ = math.lerp(0, this._touchPosition.x, this.touchAmount), x = math.lerp(0, this._touchPosition.y, this.touchAmount), b = math.lerp(0, this._touchVelocity.x, this.touchAmount); if (_forward.subVectors(this.basePosition, this.baseTarget), _forward.lengthSq() === 0 && (_forward.z = 1), _forward.normalize(), _right.crossVectors(this.baseUp, _forward), _right.lengthSq() === 0 && (Math.abs(this.baseUp.z) === 1 ? _forward.x += 1e-4 : _forward.z += 1e-4, _forward.normalize(), _right.crossVectors(this.baseUp, _forward)), _right.normalize(), _up.crossVectors(_forward, _right), this.displacement.position.equals(ZERO_V2)) this.position.copy(this.basePosition), this._additionalSphericalPosition.set(1, 0, 0); else { const T = s ? 1 : math.lerpCoefFPS(this.lerpPosition * l), M = _ * this.displacement.position.x, w = x * this.displacement.position.y; this._additionalSphericalPosition.theta = math.lerp(this._additionalSphericalPosition.theta, M, T), this._additionalSphericalPosition.phi = math.lerp(this._additionalSphericalPosition.phi, w, T), _v0$j.subVectors(this.basePosition, this.baseTarget), _v0$j.applyAxisAngle(_right, this._additionalSphericalPosition.phi).applyAxisAngle(_up, this._additionalSphericalPosition.theta), this.position.copy(this.baseTarget).add(_v0$j) } if (this.displacement.target.equals(ZERO_V2) && this.shake.x === 0 && this.shake.y === 0) this.target.copy(this.baseTarget), this._additionalSphericalTarget.set(1, 0, 0); else { const T = s ? 1 : math.lerpCoefFPS(this.lerpTarget * l), M = _ * this.displacement.target.x, w = x * this.displacement.target.y; this._additionalSphericalTarget.theta = math.lerp(this._additionalSphericalTarget.theta, M, T), this._additionalSphericalTarget.phi = math.lerp(this._additionalSphericalTarget.phi, w, T); const D = this.shake.x === 0 ? 0 : noises.sineNoise1(12.23, 3.44, -3.234 + renderInfo.time * this.shakeSpeed.x) * this.shake.x * this.touchAmount, R = this.shake.y === 0 ? 0 : noises.sineNoise1(-2.45, 4.789, 7.343 + renderInfo.time * this.shakeSpeed.y) * this.shake.y * this.touchAmount; _v0$j.subVectors(this.baseTarget, this.basePosition), _v0$j.applyAxisAngle(_right, this._additionalSphericalTarget.phi + R).applyAxisAngle(_up, this._additionalSphericalTarget.theta + D), this.target.copy(this.basePosition).add(_v0$j) } if (this.displacement.rotation === 0 && this.shake.z === 0) this.up.copy(this.baseUp), this._additionalRotationUp = 0; else { const T = s ? 1 : math.lerpCoefFPS(this.lerpRotation * l), M = b * this.displacement.rotation * this.touchAmount; this._additionalRotationUp = math.lerp(this._additionalRotationUp, M, T); const w = this.shake.z === 0 ? 0 : noises.sineNoise1(23.434, -1.565, 8.454 + renderInfo.time * this.shakeSpeed.z) * this.shake.z * this.touchAmount; _v0$j.subVectors(this.position, this.target).normalize(), this.up.copy(this.baseUp).applyAxisAngle(_v0$j, this._additionalRotationUp + w) } (!this.position.equals(this._prevPosition) || !this.target.equals(this._prevTarget) || !this.up.equals(this._prevUp)) && (this._prevPosition.copy(this.position), this._prevTarget.copy(this.target), this._prevUp.copy(this.up), this.quaternion.setFromRotationMatrix(_m0$4.lookAt(this.position, this.target, this.up))) } _resize() { if (this._sizing === CAMERA_SIZING.SCREEN && this._size.set(client$1.screen.w, client$1.screen.h), !this._prevSize.equals(this._size)) { if (this._prevSize.copy(this._size), this.isPerspectiveCamera) this.aspect = this._size.x / this._size.y; else { const s = this._size.x * .5, a = this._size.y * .5; this.left = -s, this.right = s, this.top = a, this.bottom = -a } this.updateProjectionMatrix() } } setCustomSize(s, a) { this._sizing = CAMERA_SIZING.CUSTOM, this._size.set(s, a) } } } function baseCamera$1(r = "perspective") { const e = baseCamera(r); return new e } const STATE = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, ZOOM_PAN: 3, ZOOM_ROTATE: 4 }, TOUCH_ACTIONS = { ROTATE: 0, PAN: 1, ZOOM_PAN: 2, ZOOM_ROTATE: 3 }, MAGIC_NUMBER_ZOOM_MULTIPLIER = .02, EPS = 1e-6, _v1$c = new Vector2, _v2$3 = new Vector2, _v0$i = new Vector3, _pi = new planeInteraction; function orbitCamera(r) { return class extends r { constructor() { super(), this.isOrbitCamera = !0, this.displacement.position.setScalar(0), this.displacement.target.setScalar(0), this.displacement.rotation = 0, this.lerpPosition = 1, this.lerpTarget = 1, this.lerpRotation = 1, this.buttons = { ROTATE: 0, ZOOM: 1, PAN: 2 }, this.touches = { ONE: TOUCH_ACTIONS.ROTATE, TWO: TOUCH_ACTIONS.ZOOM_PAN }, this.lerpRotate = .075, this.lerpZoom = .1, this.lerpPan = .1, this.enableRotate = !0, this.rotateSpeed = 1, this.enableZoom = !0, this.enableMouseZoom = !1, this.zoomToCursor = !1, this.zoomSpeed = 1, this.zoomSpeedWheel = .25, this.enablePan = !0, this.panSpeed = 1, this.autoRotate = !1, this.autoRotateSpeed = 1, this.touchResetPan = !1, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.minPanPosition = new Vector3().setScalar(-1 / 0), this.maxPanPosition = new Vector3().setScalar(1 / 0), this._spherical = new Spherical, this._sphericalDelta = new Spherical, this._sphericalTarget = new Spherical, this._panDelta = new Vector3, this._panTarget = new Vector3, this._multiTouchDistance = 0, this._multiTouchPosition = new Vector2, this._zoomCursorPosition = new Vector2, this._zoomDelta = 1, this._zoomTarget = 1, this._zoomPrev = 1, this._state = STATE.NONE, this._enabled = !1, this._firstOrbitUpdate = !0, this.enable() } _fromPositionTarget() { this._sphericalTarget.setFromVector3(_v0$i.copy(this.basePosition).sub(this.baseTarget)) } _update(e = !1) { if (this._firstOrbitUpdate && this._fromPositionTarget(), (e || this._firstOrbitUpdate) && (this._spherical.copy(this._sphericalTarget), this._sphericalDelta.set(1, 0, 0), this._panTarget.copy(this.baseTarget), this._panDelta.setScalar(0), this._zoomTarget = this.zoom, this._zoomDelta = 1), this.autoRotate && (this._sphericalDelta.theta -= 2 * Math.PI / 60 / 60 * this.autoRotateSpeed * math.deltaRatio()), this.zoomToCursor) { const o = this.isOrthographicCamera ? this._zoomDelta - 1 : 1 - this._sphericalDelta.radius; o !== 0 && (_v1$c.set(this._zoomCursorPosition.x / client$1.screen.w, 1 - this._zoomCursorPosition.y / client$1.screen.h).multiplyScalar(2).subScalar(1), this._panDelta.add(_v0$i.subVectors(_pi.setCamera(this).unprojectPoint(_v1$c), this._panTarget).multiplyScalar(o))) } this._sphericalTarget.theta += this._sphericalDelta.theta, this._sphericalTarget.phi += this._sphericalDelta.phi, this._sphericalTarget.radius *= this._sphericalDelta.radius, this._panTarget.add(this._panDelta), this._sphericalDelta.set(1, 0, 0), this._panDelta.setScalar(0), this._sphericalTarget.theta = math.clamp(this._sphericalTarget.theta, this.minAzimuthAngle, this.maxAzimuthAngle), this._sphericalTarget.phi = math.clamp(this._sphericalTarget.phi, this.minPolarAngle, this.maxPolarAngle), this._sphericalTarget.phi = math.clamp(this._sphericalTarget.phi, EPS, Math.PI - EPS), this._sphericalTarget.radius = math.clamp(this._sphericalTarget.radius, this.minDistance, this.maxDistance), this._panTarget.clamp(this.minPanPosition, this.maxPanPosition); const i = math.lerpCoefFPS(this.lerpRotate), s = math.lerpCoefFPS(this.lerpZoom), a = math.lerpCoefFPS(this.lerpPan); this._spherical.theta = math.lerp(this._spherical.theta, this._sphericalTarget.theta, i), this._spherical.phi = math.lerp(this._spherical.phi, this._sphericalTarget.phi, i), this._spherical.radius = math.lerp(this._spherical.radius, this._sphericalTarget.radius, s), this.baseTarget.lerp(this._panTarget, a), _v0$i.setFromSpherical(this._spherical), this.basePosition.copy(this.baseTarget).add(_v0$i), this.isOrthographicCamera && (this._zoomTarget *= this._zoomDelta, this._zoomDelta = 1, this._zoomTarget = math.clamp(this._zoomTarget, this.minZoom, this.maxZoom), this.zoom = math.lerp(this.zoom, this._zoomTarget, s), this.zoom !== this._zoomPrev && (this._zoomPrev = this.zoom, this.updateProjectionMatrix())), this._firstOrbitUpdate = !1, super._update(e) } _handleRotateMove(e) { _v1$c.copy(e.delta).multiplyScalar(this.rotateSpeed), this._sphericalDelta.theta -= 2 * Math.PI * _v1$c.x / client$1.screen.h, this._sphericalDelta.phi -= 2 * Math.PI * _v1$c.y / client$1.screen.h } _handleZoomMove(e) { const i = e.isPinching !== void 0; this._zoomCursorPosition.copy(e.isMultiTouchZoom ? this._multiTouchPosition : touches$1.get(0).position); let s = e.delta.y; i ? s *= MAGIC_NUMBER_ZOOM_MULTIPLIER * this.zoomSpeedWheel * (e.isPinching ? 10 : 1) : s /= MAGIC_NUMBER_ZOOM_MULTIPLIER * client$1.screen.h; const a = Math.pow(.95, this.zoomSpeed * Math.abs(s)); this.isPerspectiveCamera ? s < 0 ? this._sphericalDelta.radius *= a : s > 0 && (this._sphericalDelta.radius /= a) : s < 0 ? this._zoomDelta /= a : s > 0 && (this._zoomDelta *= a) } _handlePanMove(e) { if (_v1$c.copy(e.delta).multiplyScalar(this.panSpeed), this.isPerspectiveCamera) { _v0$i.copy(this.basePosition).sub(this.baseTarget); let i = _v0$i.length(); i *= Math.tan(this.fov / 2 * Math.PI / 180), this._panLeft(2 * _v1$c.x * i / client$1.screen.h, this.matrix), this._panUp(2 * _v1$c.y * i / client$1.screen.h, this.matrix) } else this._panLeft(_v1$c.x * (this.right - this.left) / this.zoom / client$1.screen.w, this.matrix), this._panUp(_v1$c.y * (this.top - this.bottom) / this.zoom / client$1.screen.h, this.matrix) } _panLeft(e, i) { _v0$i.setFromMatrixColumn(i, 0), _v0$i.multiplyScalar(-e), this._panDelta.add(_v0$i) } _panUp(e, i) { _v0$i.setFromMatrixColumn(i, 1), _v0$i.multiplyScalar(e), this._panDelta.add(_v0$i) } _getTouchesDistance() { return _v1$c.subVectors(touches$1.get(0).position, touches$1.get(1).position).length() } _getTouchesMiddle() { return _v1$c.addVectors(touches$1.get(0).position, touches$1.get(1).position).multiplyScalar(.5) } _handleMultitouchMove() { if (!(touches$1.getActive().length < 2)) { if (_v2$3.copy(this._multiTouchPosition), this._multiTouchPosition.copy(this._getTouchesMiddle()), this.enableZoom) { const i = this._multiTouchDistance; this._multiTouchDistance = this._getTouchesDistance(), this._handleZoomMove({ delta: { y: i - this._multiTouchDistance }, isMultiTouchZoom: !0 }) } this.enablePan && this._state === STATE.ZOOM_PAN ? this._handlePanMove({ delta: _v1$c.subVectors(this._multiTouchPosition, _v2$3) }) : this.enableRotate && this._state === STATE.ZOOM_ROTATE && this._handleRotateMove({ delta: _v1$c.subVectors(this._multiTouchPosition, _v2$3) }) } } _wheel(e) { this.enableZoom && (this._state !== STATE.NONE && this._state !== STATE.ROTATE || this._handleZoomMove(e)) } _touchStart(e) { if (e.input === "mouse") switch (e.button) { case this.buttons.ROTATE: if (!this.enableRotate) return; this._state = STATE.ROTATE; break; case this.buttons.ZOOM: case this.buttons.PAN: if (!this.enablePan) return; this._state = STATE.PAN; break } else switch (touches$1.getActive().length) { case 1: switch (this.touches.ONE) { case TOUCH_ACTIONS.ROTATE: if (!this.enableRotate) return; this._state = STATE.ROTATE; break; case TOUCH_ACTIONS.PAN: if (!this.enablePan) return; this._state = STATE.PAN; break; default: this._state = STATE.NONE }break; case 2: switch (this.touches.TWO) { case TOUCH_ACTIONS.ZOOM_PAN: if (!this.enableZoom && !this.enablePan) return; this._state = STATE.ZOOM_PAN, this._multiTouchDistance = this._getTouchesDistance(), this._multiTouchPosition.copy(this._getTouchesMiddle()); break; case TOUCH_ACTIONS.ZOOM_ROTATE: if (!this.enableZoom && !this.enableRotate) return; this._state = STATE.ZOOM_ROTATE, this._multiTouchDistance = this._getTouchesDistance(), this._multiTouchPosition.copy(this._getTouchesMiddle()); break; default: this._state = STATE.NONE }break; default: this._state = STATE.NONE } } _touchDrag(e) { switch (this._state) { case STATE.ROTATE: if (!this.enableRotate) return; this._handleRotateMove(e); break; case STATE.ZOOM: if (!this.enableZoom) return; this._handleZoomMove(e); break; case STATE.PAN: if (!this.enablePan) return; this._handlePanMove(e); break; case STATE.ZOOM_PAN: if (!this.enableZoom && !this.enablePan) return; this._handleMultitouchMove(); break; case STATE.ZOOM_ROTATE: if (!this.enableZoom && !this.enableRotate) return; this._handleMultitouchMove(); break } } _touchEnd(e) { this.touchResetPan ? this._state = STATE.NONE : e.input === "mouse" ? this._state = STATE.NONE : this._touchStart(e) } enable() { this._enabled || (this._enabled = !0, events.on("touch_start", this._touchStart, this), events.on("touch_drag", this._touchDrag, this), events.on("touch_end", this._touchEnd, this), events.on("touch2_start", this._touchStart, this), events.on("touch2_drag", this._touchDrag, this), events.on("touch2_end", this._touchEnd, this), events.on("wheel", this._wheel, this)) } disable() { this._enabled && (this._enabled = !1, this._state = STATE.NONE, events.off("touch_start", this._touchStart, this), events.off("touch_drag", this._touchDrag, this), events.off("touch_end", this._touchEnd, this), events.off("touch2_start", this._touchStart, this), events.off("touch2_drag", this._touchDrag, this), events.off("touch2_end", this._touchEnd, this), events.off("wheel", this._wheel, this)) } dispose() { this.disable() } } } function orbitCamera$1(r = "perspective") { const e = baseCamera(r), i = orbitCamera(e); return new i } class webglrenderer { constructor() { Ke(this, "active", !1); Ke(this, "webgl", null); Ke(this, "domElement", null); Ke(this, "info", null); Ke(this, "clearColor", new Color("#000000")); Ke(this, "clearAlpha", 1) } init({ shadowMap: e, shadowMapType: i } = {}) { this.webgl = new WebGLRenderer({ alpha: !1, antialias: !1, stencil: !1, depth: !1 }), this.webgl.setClearColor(this.clearColor, this.clearAlpha), e === !0 && (this.webgl.shadowMap.enabled = !0, i && (this.webgl.shadowMap.type = i)), this.domElement = this.webgl.domElement, this.domElement.style.display = "block", this.domElement.style.position = "absolute", this.domElement.style.top = "0", this.domElement.style.left = "0", this.info = this.webgl.info, this.webgl.debug.checkShaderErrors = !1, this.webgl.capabilities.floatLinearFiltering = this.webgl.extensions.has("OES_texture_float_linear"), this.webgl.capabilities.floatRenderTarget = this.checkFloatRenderTarget() } checkFloatRenderTarget() { const e = new WebGLRenderTarget(1, 1, { minFilter: NearestFilter, magFilter: NearestFilter, type: FloatType }), i = new Scene, s = new ShaderMaterial({ vertexShader: " void main() { gl_Position = vec4(position, 1.0); } ", fragmentShader: " void main() { gl_FragColor.rgb = vec3(0.0, 1.0 / 10.0, 1.0 / 20.0); gl_FragColor.a = 1.0; } " }); i.add(new Mesh(triangle$2, s)); const a = this.webgl.getRenderTarget(); this.webgl.setRenderTarget(e), this.webgl.render(i, new OrthographicCamera(-1, 1, 1, -1, 0, 1)); const o = new Float32Array(4); return this.webgl.readRenderTargetPixels(e, 0, 0, 1, 1, o), this.webgl.setRenderTarget(a), e.dispose(), s.dispose(), !(o[0] !== 0 || o[1] < .1 || o[2] < .05 || o[3] < 1) } dispose() { this.webgl.dispose(), this.webgl = null, this.domElement = null, this.info = null } } const webglRenderer = new webglrenderer, uploadRT = new WebGLRenderTarget(1, 1, { type: HalfFloatType }); uploadRT.setSize = () => { }; uploadRT.dispose = () => { }; class scene extends Scene { constructor({ customCamera: e = null, orbit: i = !1, cameraType: s = "perspective" } = {}) { super(); const a = e || (i ? orbitCamera$1 : baseCamera$1); this.camera = a(s), this.composer = null, this.matrixWorldAutoUpdate = !0, this.matrixAutoUpdate = !1, this.beforeRenderCbs = [], this._textures = new Set, this.customUploadRT = null, this.uploaded = new Promise(o => { this._isUploaded = o }), this.ready = new Promise(o => { this.isReady = o }).then(() => { this._upload() }) } async _upload() { this.traverse(i => { var s, a, o, l, c, h, d; i !== this && (i.__uploadVars = { cull: i.frustumCulled, visible: i.visible }, i.frustumCulled = !1, i.visible = !0, i.frustumCulled && (i.boundingSphere === null ? (s = i.computeBoundingSphere) == null || s.call(i) : ((a = i.geometry) == null ? void 0 : a.boundingSphere) === null && ((l = (o = i.geometry).computeBoundingSphere) == null || l.call(o))), (c = i.material) != null && c.isMaterial && (i.material.uniforms && Object.entries(i.material.uniforms).forEach(([p, f]) => { var _; (_ = f.value) != null && _.isTexture && f.value._loaded && this._textures.add(f.value) }), Object.entries(i.material).forEach(([p, f]) => { f != null && f.isTexture && f._loaded && this._textures.add(f) }), i.__uploadVars.materialVisible = i.material.visible, i.__uploadVars.depthMaterialVisible = (h = i.customDepthMaterial) == null ? void 0 : h.visible, i.__uploadVars.distanceMaterialVisible = (d = i.customDistanceMaterial) == null ? void 0 : d.visible, i.material.visible = !0, i.customDepthMaterial && (i.customDepthMaterial.visible = !0), i.customDistanceMaterial && (i.customDistanceMaterial.visible = !0))) }); const e = []; webglRenderer.webgl.setRenderTarget(this.customUploadRT || uploadRT), webglRenderer.webgl.compile(this, this.camera), this._textures.size > 0 && e.push(...Array.from(this._textures).map(i => i._loaded.then(() => webglRenderer.webgl.initTexture(i)))), await Promise.all(e), webglRenderer.webgl.setRenderTarget(this.customUploadRT || uploadRT), webglRenderer.webgl.render(this, this.camera), this.traverse(i => { var s; i === this || !i.__uploadVars || (i.frustumCulled = i.__uploadVars.cull, i.visible = i.__uploadVars.visible, (s = i.material) != null && s.isMaterial && (i.material.visible = i.__uploadVars.materialVisible, i.customDepthMaterial && (i.customDepthMaterial.visible = i.__uploadVars.depthMaterialVisible), i.customDistanceMaterial && (i.customDistanceMaterial.visible = i.__uploadVars.distanceMaterialVisible)), delete i.__uploadVars) }), this._isUploaded() } debug() { gui$1.add(this) } updateMatrixWorld(e) { super.updateMatrixWorld(e), !miscutils.hasRunThisFrame(this) && (this.camera._resize(), this.camera._update(), this.camera.updateMatrixWorld(), this.beforeRenderCbs.forEach(i => i())) } dispose() { var e, i, s, a; this.composer = null, this.beforeRenderCbs = [], this.camera && ((i = (e = this.camera).dispose) == null || i.call(e), this.camera = null), this.customUploadRT && ((a = (s = this.customUploadRT).dispose) == null || a.call(s), this.customUploadRT = null), this._textures && (this._textures.forEach(o => { var l; return (l = o == null ? void 0 : o.dispose) == null ? void 0 : l.call(o) }), this._textures.clear(), this._textures = null), this.traverse(o => { var l, c, h, d, p, f, _, x; (c = (l = o.geometry) == null ? void 0 : l.dispose) == null || c.call(l), (d = (h = o.skeleton) == null ? void 0 : h.dispose) == null || d.call(h), (p = o.material) != null && p.isMaterial && (o.material.uniforms ? Object.entries(o.material.uniforms).forEach(([b, T]) => { var M, w, D; (M = T.value) != null && M.isTexture && ((D = (w = T.value).dispose) == null || D.call(w)) }) : Object.entries(o.material).forEach(([b, T]) => { var M; T != null && T.isTexture && ((M = T.dispose) == null || M.call(T)) }), (_ = (f = o.material).dispose) == null || _.call(f)), o !== this && ((x = o.dispose) == null || x.call(o)) }), this.clear() } } const uniforms$1 = { resolution: { value: new Vector2(2, 2), global: !0 }, resolutionUI: { value: new Vector2(2, 2), global: !0 }, aspect: { value: 1, global: !0 }, time: { value: 0, global: !0 }, dtRatio: { value: 1, global: !0 } }, UBO = new UniformsGroup; UBO.setName("Global"); UBO.add(uniforms$1.resolution); UBO.add(uniforms$1.resolutionUI); UBO.add(uniforms$1.aspect); UBO.add(uniforms$1.time); UBO.add(uniforms$1.dtRatio); const CopyShader = {
    name: "CopyShader", uniforms: { tDiffuse: { value: null }, opacity: { value: 1 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;


		}`}; let ShaderPass$1 = class extends Pass$1 { constructor(e, i = "tDiffuse") { super(), this.textureID = i, this.uniforms = null, this.material = null, e instanceof ShaderMaterial ? (this.uniforms = e.uniforms, this.material = e) : e && (this.uniforms = UniformsUtils.clone(e.uniforms), this.material = new ShaderMaterial({ name: e.name !== void 0 ? e.name : "unspecified", defines: Object.assign({}, e.defines), uniforms: this.uniforms, vertexShader: e.vertexShader, fragmentShader: e.fragmentShader })), this._fsQuad = new FullScreenQuad(this.material) } render(e, i, s) { this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = s.texture), this._fsQuad.material = this.material, this.renderToScreen ? (e.setRenderTarget(null), this._fsQuad.render(e)) : (e.setRenderTarget(i), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), this._fsQuad.render(e)) } dispose() { this.material.dispose(), this._fsQuad.dispose() } }, MaskPass$1 = class extends Pass$1 { constructor(e, i) { super(), this.scene = e, this.camera = i, this.clear = !0, this.needsSwap = !1, this.inverse = !1 } render(e, i, s) { const a = e.getContext(), o = e.state; o.buffers.color.setMask(!1), o.buffers.depth.setMask(!1), o.buffers.color.setLocked(!0), o.buffers.depth.setLocked(!0); let l, c; this.inverse ? (l = 0, c = 1) : (l = 1, c = 0), o.buffers.stencil.setTest(!0), o.buffers.stencil.setOp(a.REPLACE, a.REPLACE, a.REPLACE), o.buffers.stencil.setFunc(a.ALWAYS, l, 4294967295), o.buffers.stencil.setClear(c), o.buffers.stencil.setLocked(!0), e.setRenderTarget(s), this.clear && e.clear(), e.render(this.scene, this.camera), e.setRenderTarget(i), this.clear && e.clear(), e.render(this.scene, this.camera), o.buffers.color.setLocked(!1), o.buffers.depth.setLocked(!1), o.buffers.color.setMask(!0), o.buffers.depth.setMask(!0), o.buffers.stencil.setLocked(!1), o.buffers.stencil.setFunc(a.EQUAL, 1, 4294967295), o.buffers.stencil.setOp(a.KEEP, a.KEEP, a.KEEP), o.buffers.stencil.setLocked(!0) } }, ClearMaskPass$1 = class extends Pass$1 { constructor() { super(), this.needsSwap = !1 } render(e) { e.state.buffers.stencil.setLocked(!1), e.state.buffers.stencil.setTest(!1) } }, EffectComposer$1 = class { constructor(e, i) { if (this.renderer = e, this._pixelRatio = e.getPixelRatio(), i === void 0) { const s = e.getSize(new Vector2); this._width = s.width, this._height = s.height, i = new WebGLRenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio, { type: HalfFloatType }), i.texture.name = "EffectComposer.rt1" } else this._width = i.width, this._height = i.height; this.renderTarget1 = i, this.renderTarget2 = i.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = !0, this.passes = [], this.copyPass = new ShaderPass$1(CopyShader), this.copyPass.material.blending = NoBlending, this.clock = new Clock } swapBuffers() { const e = this.readBuffer; this.readBuffer = this.writeBuffer, this.writeBuffer = e } addPass(e) { this.passes.push(e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio) } insertPass(e, i) { this.passes.splice(i, 0, e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio) } removePass(e) { const i = this.passes.indexOf(e); i !== -1 && this.passes.splice(i, 1) } isLastEnabledPass(e) { for (let i = e + 1; i < this.passes.length; i++)if (this.passes[i].enabled) return !1; return !0 } render(e) { e === void 0 && (e = this.clock.getDelta()); const i = this.renderer.getRenderTarget(); let s = !1; for (let a = 0, o = this.passes.length; a < o; a++) { const l = this.passes[a]; if (l.enabled !== !1) { if (l.renderToScreen = this.renderToScreen && this.isLastEnabledPass(a), l.render(this.renderer, this.writeBuffer, this.readBuffer, e, s), l.needsSwap) { if (s) { const c = this.renderer.getContext(), h = this.renderer.state.buffers.stencil; h.setFunc(c.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, e), h.setFunc(c.EQUAL, 1, 4294967295) } this.swapBuffers() } MaskPass$1 !== void 0 && (l instanceof MaskPass$1 ? s = !0 : l instanceof ClearMaskPass$1 && (s = !1)) } } this.renderer.setRenderTarget(i) } reset(e) { if (e === void 0) { const i = this.renderer.getSize(new Vector2); this._pixelRatio = this.renderer.getPixelRatio(), this._width = i.width, this._height = i.height, e = this.renderTarget1.clone(), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio) } this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2 } setSize(e, i) { this._width = e, this._height = i; const s = this._width * this._pixelRatio, a = this._height * this._pixelRatio; this.renderTarget1.setSize(s, a), this.renderTarget2.setSize(s, a); for (let o = 0; o < this.passes.length; o++)this.passes[o].setSize(s, a) } setPixelRatio(e) { this._pixelRatio = e, this.setSize(this._width, this._height) } dispose() { this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.copyPass.dispose() } }; class effectComposerExtended extends EffectComposer$1 { constructor({ renderer: e = webglRenderer.webgl, renderTarget: i = void 0, autoResize: s = !0, renderToScreen: a = !1, depthTexture: o = !1, scene: l = null } = {}) { super(e, i), this.renderToScreen = a, o && (this.writeBuffer.depthTexture = new DepthTexture, this.readBuffer.depthTexture = new DepthTexture), webglRenderer.webgl.initRenderTarget(this.writeBuffer), webglRenderer.webgl.initRenderTarget(this.readBuffer), s && (this._autoResize(), events.on("resize", this._autoResize, this)), l != null && l.camera && (this.addPass(new RenderPass$1(l, l.camera)), l.composer = this) } _autoResize() { this.setSize(uniforms$1.resolution.value.x, uniforms$1.resolution.value.y) } addPass(e) { var i; super.addPass(e), (i = e.scene) != null && i.camera && (e.scene.composer = this), this.passes.sort((s, a) => { const o = [s, a].map(l => l.isGammaCorrectionPass ? 1 : 0); return o[0] - o[1] }) } dispose() { events.off("resize", this._autoResize, this), this.passes.forEach(e => { var i, s, a; (s = (i = e.scene) == null ? void 0 : i.dispose) == null || s.call(i), (a = e.dispose) == null || a.call(e) }), this.passes = [], super.dispose() } }/**
 * postprocessing v6.37.8 build Fri Sep 12 2025
 * https://github.com/pmndrs/postprocessing
 * Copyright 2015-2025 Raoul van Rschen
 * @license Zlib
 */var MILLISECONDS_TO_SECONDS = 1 / 1e3, SECONDS_TO_MILLISECONDS = 1e3, Timer = class { constructor() { this.startTime = performance.now(), this.previousTime = 0, this.currentTime = 0, this._delta = 0, this._elapsed = 0, this._fixedDelta = 1e3 / 60, this.timescale = 1, this.useFixedDelta = !1, this._autoReset = !1 } get autoReset() { return this._autoReset } set autoReset(r) { typeof document < "u" && document.hidden !== void 0 && (r ? document.addEventListener("visibilitychange", this) : document.removeEventListener("visibilitychange", this), this._autoReset = r) } get delta() { return this._delta * MILLISECONDS_TO_SECONDS } get fixedDelta() { return this._fixedDelta * MILLISECONDS_TO_SECONDS } set fixedDelta(r) { this._fixedDelta = r * SECONDS_TO_MILLISECONDS } get elapsed() { return this._elapsed * MILLISECONDS_TO_SECONDS } update(r) { this.useFixedDelta ? this._delta = this.fixedDelta : (this.previousTime = this.currentTime, this.currentTime = (r !== void 0 ? r : performance.now()) - this.startTime, this._delta = this.currentTime - this.previousTime), this._delta *= this.timescale, this._elapsed += this._delta } reset() { this._delta = 0, this._elapsed = 0, this.currentTime = performance.now() - this.startTime } getDelta() { return this.delta } getElapsed() { return this.elapsed } handleEvent(r) { document.hidden || (this.currentTime = performance.now() - this.startTime) } dispose() { this.autoReset = !1 } }, fullscreenGeometry = (() => { const r = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]), e = new Float32Array([0, 0, 2, 0, 0, 2]), i = new BufferGeometry; return i.setAttribute("position", new BufferAttribute(r, 3)), i.setAttribute("uv", new BufferAttribute(e, 2)), i })(), Pass = class wa { static get fullscreenGeometry() { return fullscreenGeometry } constructor(e = "Pass", i = new Scene, s = new Camera) { this.name = e, this.renderer = null, this.scene = i, this.camera = s, this.screen = null, this.rtt = !0, this.needsSwap = !0, this.needsDepthTexture = !1, this.enabled = !0 } get renderToScreen() { return !this.rtt } set renderToScreen(e) { if (this.rtt === e) { const i = this.fullscreenMaterial; i !== null && (i.needsUpdate = !0), this.rtt = !e } } set mainScene(e) { } set mainCamera(e) { } setRenderer(e) { this.renderer = e } isEnabled() { return this.enabled } setEnabled(e) { this.enabled = e } get fullscreenMaterial() { return this.screen !== null ? this.screen.material : null } set fullscreenMaterial(e) { let i = this.screen; i !== null ? i.material = e : (i = new Mesh(wa.fullscreenGeometry, e), i.frustumCulled = !1, this.scene === null && (this.scene = new Scene), this.scene.add(i), this.screen = i) } getFullscreenMaterial() { return this.fullscreenMaterial } setFullscreenMaterial(e) { this.fullscreenMaterial = e } getDepthTexture() { return null } setDepthTexture(e, i = BasicDepthPacking) { } render(e, i, s, a, o) { throw new Error("Render method not implemented!") } setSize(e, i) { } initialize(e, i, s) { } dispose() { for (const e of Object.keys(this)) { const i = this[e]; (i instanceof WebGLRenderTarget || i instanceof Material || i instanceof Texture || i instanceof wa) && this[e].dispose() } this.fullscreenMaterial !== null && this.fullscreenMaterial.dispose() } }, ClearMaskPass = class extends Pass { constructor() { super("ClearMaskPass", null, null), this.needsSwap = !1 } render(r, e, i, s, a) { const o = r.state.buffers.stencil; o.setLocked(!1), o.setTest(!1) } }, copy_default = `#include <common>
#include <dithering_pars_fragment>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;
#include <colorspace_fragment>
#include <dithering_fragment>
}`, common_default = "varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}", CopyMaterial = class extends ShaderMaterial { constructor() { super({ name: "CopyMaterial", uniforms: { inputBuffer: new Uniform(null), opacity: new Uniform(1) }, blending: NoBlending, toneMapped: !1, depthWrite: !1, depthTest: !1, fragmentShader: copy_default, vertexShader: common_default }) } set inputBuffer(r) { this.uniforms.inputBuffer.value = r } setInputBuffer(r) { this.uniforms.inputBuffer.value = r } getOpacity(r) { return this.uniforms.opacity.value } setOpacity(r) { this.uniforms.opacity.value = r } }, CopyPass = class extends Pass { constructor(r, e = !0) { super("CopyPass"), this.fullscreenMaterial = new CopyMaterial, this.needsSwap = !1, this.renderTarget = r, r === void 0 && (this.renderTarget = new WebGLRenderTarget(1, 1, { minFilter: LinearFilter, magFilter: LinearFilter, stencilBuffer: !1, depthBuffer: !1 }), this.renderTarget.texture.name = "CopyPass.Target"), this.autoResize = e } get resize() { return this.autoResize } set resize(r) { this.autoResize = r } get texture() { return this.renderTarget.texture } getTexture() { return this.renderTarget.texture } setAutoResizeEnabled(r) { this.autoResize = r } render(r, e, i, s, a) { this.fullscreenMaterial.inputBuffer = e.texture, r.setRenderTarget(this.renderToScreen ? null : this.renderTarget), r.render(this.scene, this.camera) } setSize(r, e) { this.autoResize && this.renderTarget.setSize(r, e) } initialize(r, e, i) { i !== void 0 && (this.renderTarget.texture.type = i, i !== UnsignedByteType ? this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1" : r !== null && r.outputColorSpace === SRGBColorSpace && (this.renderTarget.texture.colorSpace = SRGBColorSpace)) } }, color = new Color, ClearPass = class extends Pass { constructor(r = !0, e = !0, i = !1) { super("ClearPass", null, null), this.needsSwap = !1, this.color = r, this.depth = e, this.stencil = i, this.overrideClearColor = null, this.overrideClearAlpha = -1 } setClearFlags(r, e, i) { this.color = r, this.depth = e, this.stencil = i } getOverrideClearColor() { return this.overrideClearColor } setOverrideClearColor(r) { this.overrideClearColor = r } getOverrideClearAlpha() { return this.overrideClearAlpha } setOverrideClearAlpha(r) { this.overrideClearAlpha = r } render(r, e, i, s, a) { const o = this.overrideClearColor, l = this.overrideClearAlpha, c = r.getClearAlpha(), h = o !== null, d = l >= 0; h ? (r.getClearColor(color), r.setClearColor(o, d ? l : c)) : d && r.setClearAlpha(l), r.setRenderTarget(this.renderToScreen ? null : e), r.clear(this.color, this.depth, this.stencil), h ? r.setClearColor(color, c) : d && r.setClearAlpha(c) } }, MaskPass = class extends Pass { constructor(r, e) { super("MaskPass", r, e), this.needsSwap = !1, this.clearPass = new ClearPass(!1, !1, !0), this.inverse = !1 } set mainScene(r) { this.scene = r } set mainCamera(r) { this.camera = r } get inverted() { return this.inverse } set inverted(r) { this.inverse = r } get clear() { return this.clearPass.enabled } set clear(r) { this.clearPass.enabled = r } getClearPass() { return this.clearPass } isInverted() { return this.inverted } setInverted(r) { this.inverted = r } render(r, e, i, s, a) { const o = r.getContext(), l = r.state.buffers, c = this.scene, h = this.camera, d = this.clearPass, p = this.inverted ? 0 : 1, f = 1 - p; l.color.setMask(!1), l.depth.setMask(!1), l.color.setLocked(!0), l.depth.setLocked(!0), l.stencil.setTest(!0), l.stencil.setOp(o.REPLACE, o.REPLACE, o.REPLACE), l.stencil.setFunc(o.ALWAYS, p, 4294967295), l.stencil.setClear(f), l.stencil.setLocked(!0), this.clearPass.enabled && (this.renderToScreen ? d.render(r, null) : (d.render(r, e), d.render(r, i))), this.renderToScreen ? (r.setRenderTarget(null), r.render(c, h)) : (r.setRenderTarget(e), r.render(c, h), r.setRenderTarget(i), r.render(c, h)), l.color.setLocked(!1), l.depth.setLocked(!1), l.stencil.setLocked(!1), l.stencil.setFunc(o.EQUAL, 1, 4294967295), l.stencil.setOp(o.KEEP, o.KEEP, o.KEEP), l.stencil.setLocked(!0) } }, EffectComposer = class { constructor(r = null, { depthBuffer: e = !0, stencilBuffer: i = !1, multisampling: s = 0, frameBufferType: a } = {}) { this.renderer = null, this.inputBuffer = this.createBuffer(e, i, a, s), this.outputBuffer = this.inputBuffer.clone(), this.copyPass = new CopyPass, this.depthTexture = null, this.passes = [], this.timer = new Timer, this.autoRenderToScreen = !0, this.setRenderer(r) } get multisampling() { return this.inputBuffer.samples || 0 } set multisampling(r) { const e = this.inputBuffer, i = this.multisampling; i > 0 && r > 0 ? (this.inputBuffer.samples = r, this.outputBuffer.samples = r, this.inputBuffer.dispose(), this.outputBuffer.dispose()) : i !== r && (this.inputBuffer.dispose(), this.outputBuffer.dispose(), this.inputBuffer = this.createBuffer(e.depthBuffer, e.stencilBuffer, e.texture.type, r), this.inputBuffer.depthTexture = this.depthTexture, this.outputBuffer = this.inputBuffer.clone()) } getTimer() { return this.timer } getRenderer() { return this.renderer } setRenderer(r) { if (this.renderer = r, r !== null) { const e = r.getSize(new Vector2), i = r.getContext().getContextAttributes().alpha, s = this.inputBuffer.texture.type; s === UnsignedByteType && r.outputColorSpace === SRGBColorSpace && (this.inputBuffer.texture.colorSpace = SRGBColorSpace, this.outputBuffer.texture.colorSpace = SRGBColorSpace, this.inputBuffer.dispose(), this.outputBuffer.dispose()), r.autoClear = !1, this.setSize(e.width, e.height); for (const a of this.passes) a.initialize(r, i, s) } } replaceRenderer(r, e = !0) { const i = this.renderer, s = i.domElement.parentNode; return this.setRenderer(r), e && s !== null && (s.removeChild(i.domElement), s.appendChild(r.domElement)), i } createDepthTexture() { const r = this.depthTexture = new DepthTexture; return this.inputBuffer.depthTexture = r, this.inputBuffer.dispose(), this.inputBuffer.stencilBuffer ? (r.format = DepthStencilFormat, r.type = UnsignedInt248Type) : r.type = UnsignedIntType, r } deleteDepthTexture() { if (this.depthTexture !== null) { this.depthTexture.dispose(), this.depthTexture = null, this.inputBuffer.depthTexture = null, this.inputBuffer.dispose(); for (const r of this.passes) r.setDepthTexture(null) } } createBuffer(r, e, i, s) { const a = this.renderer, o = a === null ? new Vector2 : a.getDrawingBufferSize(new Vector2), l = { minFilter: LinearFilter, magFilter: LinearFilter, stencilBuffer: e, depthBuffer: r, type: i }, c = new WebGLRenderTarget(o.width, o.height, l); return s > 0 && (c.ignoreDepthForMultisampleCopy = !1, c.samples = s), i === UnsignedByteType && a !== null && a.outputColorSpace === SRGBColorSpace && (c.texture.colorSpace = SRGBColorSpace), c.texture.name = "EffectComposer.Buffer", c.texture.generateMipmaps = !1, c } setMainScene(r) { for (const e of this.passes) e.mainScene = r } setMainCamera(r) { for (const e of this.passes) e.mainCamera = r } addPass(r, e) { const i = this.passes, s = this.renderer, a = s.getDrawingBufferSize(new Vector2), o = s.getContext().getContextAttributes().alpha, l = this.inputBuffer.texture.type; if (r.setRenderer(s), r.setSize(a.width, a.height), r.initialize(s, o, l), this.autoRenderToScreen && (i.length > 0 && (i[i.length - 1].renderToScreen = !1), r.renderToScreen && (this.autoRenderToScreen = !1)), e !== void 0 ? i.splice(e, 0, r) : i.push(r), this.autoRenderToScreen && (i[i.length - 1].renderToScreen = !0), r.needsDepthTexture || this.depthTexture !== null) if (this.depthTexture === null) { const c = this.createDepthTexture(); for (r of i) r.setDepthTexture(c) } else r.setDepthTexture(this.depthTexture) } removePass(r) { const e = this.passes, i = e.indexOf(r); if (i !== -1 && e.splice(i, 1).length > 0) { if (this.depthTexture !== null) { const o = (c, h) => c || h.needsDepthTexture; e.reduce(o, !1) || (r.getDepthTexture() === this.depthTexture && r.setDepthTexture(null), this.deleteDepthTexture()) } this.autoRenderToScreen && i === e.length && (r.renderToScreen = !1, e.length > 0 && (e[e.length - 1].renderToScreen = !0)) } } removeAllPasses() { const r = this.passes; this.deleteDepthTexture(), r.length > 0 && (this.autoRenderToScreen && (r[r.length - 1].renderToScreen = !1), this.passes = []) } render(r) { const e = this.renderer, i = this.copyPass; let s = this.inputBuffer, a = this.outputBuffer, o = !1, l, c, h; r === void 0 && (this.timer.update(), r = this.timer.getDelta()); for (const d of this.passes) d.enabled && (d.render(e, s, a, r, o), d.needsSwap && (o && (i.renderToScreen = d.renderToScreen, l = e.getContext(), c = e.state.buffers.stencil, c.setFunc(l.NOTEQUAL, 1, 4294967295), i.render(e, s, a, r, o), c.setFunc(l.EQUAL, 1, 4294967295)), h = s, s = a, a = h), d instanceof MaskPass ? o = !0 : d instanceof ClearMaskPass && (o = !1)) } setSize(r, e, i) { const s = this.renderer, a = s.getSize(new Vector2); (r === void 0 || e === void 0) && (r = a.width, e = a.height), (a.width !== r || a.height !== e) && s.setSize(r, e, i); const o = s.getDrawingBufferSize(new Vector2); this.inputBuffer.setSize(o.width, o.height), this.outputBuffer.setSize(o.width, o.height); for (const l of this.passes) l.setSize(o.width, o.height) } reset() { this.dispose(), this.autoRenderToScreen = !0 } dispose() { for (const r of this.passes) r.dispose(); this.passes = [], this.inputBuffer !== null && this.inputBuffer.dispose(), this.outputBuffer !== null && this.outputBuffer.dispose(), this.deleteDepthTexture(), this.copyPass.dispose(), this.timer.dispose(), Pass.fullscreenGeometry.dispose() } }, EffectAttribute = { NONE: 0, DEPTH: 1, CONVOLUTION: 2 }, EffectShaderSection = { FRAGMENT_HEAD: "FRAGMENT_HEAD", FRAGMENT_MAIN_UV: "FRAGMENT_MAIN_UV", FRAGMENT_MAIN_IMAGE: "FRAGMENT_MAIN_IMAGE", VERTEX_HEAD: "VERTEX_HEAD", VERTEX_MAIN_SUPPORT: "VERTEX_MAIN_SUPPORT" }, EffectShaderData = class { constructor() { this.shaderParts = new Map([[EffectShaderSection.FRAGMENT_HEAD, null], [EffectShaderSection.FRAGMENT_MAIN_UV, null], [EffectShaderSection.FRAGMENT_MAIN_IMAGE, null], [EffectShaderSection.VERTEX_HEAD, null], [EffectShaderSection.VERTEX_MAIN_SUPPORT, null]]), this.defines = new Map, this.uniforms = new Map, this.blendModes = new Map, this.extensions = new Set, this.attributes = EffectAttribute.NONE, this.varyings = new Set, this.uvTransformation = !1, this.readDepth = !1, this.colorSpace = LinearSRGBColorSpace } }; function getCoefficients(r) { let e; if (r === 0) e = new Float64Array(0); else if (r === 1) e = new Float64Array([1]); else if (r > 1) { let i = new Float64Array(r), s = new Float64Array(r); for (let a = 1; a <= r; ++a) { for (let o = 0; o < a; ++o)s[o] = o === 0 || o === a - 1 ? 1 : i[o - 1] + i[o]; e = s, s = i, i = e } } return e } var GaussKernel = class { constructor(r, e = 2) { this.weights = null, this.offsets = null, this.linearWeights = null, this.linearOffsets = null, this.generate(r, e) } get steps() { return this.offsets === null ? 0 : this.offsets.length } get linearSteps() { return this.linearOffsets === null ? 0 : this.linearOffsets.length } generate(r, e) { if (r < 3 || r > 1020) throw new Error("The kernel size must be in the range [3, 1020]"); const i = r + e * 2, s = e > 0 ? getCoefficients(i).slice(e, -e) : getCoefficients(i), a = Math.floor((s.length - 1) / 2), o = s.reduce((f, _) => f + _, 0), l = s.slice(a), c = [...Array(a + 1).keys()], h = new Float64Array(Math.floor(c.length / 2)), d = new Float64Array(h.length); h[0] = l[0] / o; for (let f = 1, _ = 1, x = c.length - 1; f < x; f += 2, ++_) { const b = c[f], T = c[f + 1], M = l[f], w = l[f + 1], D = M + w, R = (b * M + T * w) / D; h[_] = D / o, d[_] = R } for (let f = 0, _ = l.length, x = 1 / o; f < _; ++f)l[f] *= x; const p = (h.reduce((f, _) => f + _, 0) - h[0] * .5) * 2; if (p !== 0) for (let f = 0, _ = h.length, x = 1 / p; f < _; ++f)h[f] *= x; this.offsets = c, this.weights = l, this.linearOffsets = d, this.linearWeights = h } }, workaroundEnabled = !1, OverrideMaterialManager = class { constructor(r = null) { this.originalMaterials = new Map, this.material = null, this.materials = null, this.materialsBackSide = null, this.materialsDoubleSide = null, this.materialsFlatShaded = null, this.materialsFlatShadedBackSide = null, this.materialsFlatShadedDoubleSide = null, this.setMaterial(r), this.meshCount = 0, this.replaceMaterial = e => { if (e.isMesh) { let i; if (e.material.flatShading) switch (e.material.side) { case DoubleSide: i = this.materialsFlatShadedDoubleSide; break; case BackSide: i = this.materialsFlatShadedBackSide; break; default: i = this.materialsFlatShaded; break } else switch (e.material.side) { case DoubleSide: i = this.materialsDoubleSide; break; case BackSide: i = this.materialsBackSide; break; default: i = this.materials; break }this.originalMaterials.set(e, e.material), e.isSkinnedMesh ? e.material = i[2] : e.isInstancedMesh ? e.material = i[1] : e.material = i[0], ++this.meshCount } } } cloneMaterial(r) { if (!(r instanceof ShaderMaterial)) return r.clone(); const e = r.uniforms, i = new Map; for (const a in e) { const o = e[a].value; o.isRenderTargetTexture && (e[a].value = null, i.set(a, o)) } const s = r.clone(); for (const a of i) e[a[0]].value = a[1], s.uniforms[a[0]].value = a[1]; return s } setMaterial(r) { if (this.disposeMaterials(), this.material = r, r !== null) { const e = this.materials = [this.cloneMaterial(r), this.cloneMaterial(r), this.cloneMaterial(r)]; for (const i of e) i.uniforms = Object.assign({}, r.uniforms), i.side = FrontSide; e[2].skinning = !0, this.materialsBackSide = e.map(i => { const s = this.cloneMaterial(i); return s.uniforms = Object.assign({}, r.uniforms), s.side = BackSide, s }), this.materialsDoubleSide = e.map(i => { const s = this.cloneMaterial(i); return s.uniforms = Object.assign({}, r.uniforms), s.side = DoubleSide, s }), this.materialsFlatShaded = e.map(i => { const s = this.cloneMaterial(i); return s.uniforms = Object.assign({}, r.uniforms), s.flatShading = !0, s }), this.materialsFlatShadedBackSide = e.map(i => { const s = this.cloneMaterial(i); return s.uniforms = Object.assign({}, r.uniforms), s.flatShading = !0, s.side = BackSide, s }), this.materialsFlatShadedDoubleSide = e.map(i => { const s = this.cloneMaterial(i); return s.uniforms = Object.assign({}, r.uniforms), s.flatShading = !0, s.side = DoubleSide, s }) } } render(r, e, i) { const s = r.shadowMap.enabled; if (r.shadowMap.enabled = !1, workaroundEnabled) { const a = this.originalMaterials; this.meshCount = 0, e.traverse(this.replaceMaterial), r.render(e, i); for (const o of a) o[0].material = o[1]; this.meshCount !== a.size && a.clear() } else { const a = e.overrideMaterial; e.overrideMaterial = this.material, r.render(e, i), e.overrideMaterial = a } r.shadowMap.enabled = s } disposeMaterials() { if (this.material !== null) { const r = this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide); for (const e of r) e.dispose() } } dispose() { this.originalMaterials.clear(), this.disposeMaterials() } static get workaroundEnabled() { return workaroundEnabled } static set workaroundEnabled(r) { workaroundEnabled = r } }, AUTO_SIZE = -1, Resolution = class extends EventDispatcher { constructor(r, e = AUTO_SIZE, i = AUTO_SIZE, s = 1) { super(), this.resizable = r, this.baseSize = new Vector2(1, 1), this.preferredSize = new Vector2(e, i), this.target = this.preferredSize, this.s = s, this.effectiveSize = new Vector2, this.addEventListener("change", () => this.updateEffectiveSize()), this.updateEffectiveSize() } updateEffectiveSize() { const r = this.baseSize, e = this.preferredSize, i = this.effectiveSize, s = this.scale; e.width !== AUTO_SIZE ? i.width = e.width : e.height !== AUTO_SIZE ? i.width = Math.round(e.height * (r.width / Math.max(r.height, 1))) : i.width = Math.round(r.width * s), e.height !== AUTO_SIZE ? i.height = e.height : e.width !== AUTO_SIZE ? i.height = Math.round(e.width / Math.max(r.width / Math.max(r.height, 1), 1)) : i.height = Math.round(r.height * s) } get width() { return this.effectiveSize.width } set width(r) { this.preferredWidth = r } get height() { return this.effectiveSize.height } set height(r) { this.preferredHeight = r } getWidth() { return this.width } getHeight() { return this.height } get scale() { return this.s } set scale(r) { this.s !== r && (this.s = r, this.preferredSize.setScalar(AUTO_SIZE), this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height)) } getScale() { return this.scale } setScale(r) { this.scale = r } get baseWidth() { return this.baseSize.width } set baseWidth(r) { this.baseSize.width !== r && (this.baseSize.width = r, this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height)) } getBaseWidth() { return this.baseWidth } setBaseWidth(r) { this.baseWidth = r } get baseHeight() { return this.baseSize.height } set baseHeight(r) { this.baseSize.height !== r && (this.baseSize.height = r, this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height)) } getBaseHeight() { return this.baseHeight } setBaseHeight(r) { this.baseHeight = r } setBaseSize(r, e) { (this.baseSize.width !== r || this.baseSize.height !== e) && (this.baseSize.set(r, e), this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height)) } get preferredWidth() { return this.preferredSize.width } set preferredWidth(r) { this.preferredSize.width !== r && (this.preferredSize.width = r, this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height)) } getPreferredWidth() { return this.preferredWidth } setPreferredWidth(r) { this.preferredWidth = r } get preferredHeight() { return this.preferredSize.height } set preferredHeight(r) { this.preferredSize.height !== r && (this.preferredSize.height = r, this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height)) } getPreferredHeight() { return this.preferredHeight } setPreferredHeight(r) { this.preferredHeight = r } setPreferredSize(r, e) { (this.preferredSize.width !== r || this.preferredSize.height !== e) && (this.preferredSize.set(r, e), this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height)) } copy(r) { this.s = r.scale, this.baseSize.set(r.baseWidth, r.baseHeight), this.preferredSize.set(r.preferredWidth, r.preferredHeight), this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height) } static get AUTO_SIZE() { return AUTO_SIZE } }, IdManager = class { constructor(r = 0) { this.nextId = r } getNextId() { return this.nextId++ } reset(r = 0) { return this.nextId = r, this } }, idManager = new IdManager(2), Selection = class extends Set { constructor(r, e = idManager.getNextId()) { super(), this.exclusive = !1, this._layer = e, (this._layer < 1 || this._layer > 31) && (console.warn("Layer out of range, resetting to 2"), idManager.reset(2), this._layer = idManager.getNextId()), r !== void 0 && this.set(r) } get layer() { return this._layer } set layer(r) { const e = this._layer; for (const i of this) i.layers.disable(e), i.layers.enable(r); this._layer = r } getLayer() { return this.layer } setLayer(r) { this.layer = r } isExclusive() { return this.exclusive } setExclusive(r) { this.exclusive = r } clear() { const r = this.layer; for (const e of this) e.layers.disable(r); return super.clear() } set(r) { this.clear(); for (const e of r) this.add(e); return this } indexOf(r) { return this.has(r) ? 0 : -1 } add(r) { return this.exclusive ? r.layers.set(this.layer) : r.layers.enable(this.layer), super.add(r) } delete(r) { return this.has(r) && r.layers.disable(this.layer), super.delete(r) } toggle(r) { let e; return this.has(r) ? (this.delete(r), e = !1) : (this.add(r), e = !0), e } setVisible(r) { for (const e of this) r ? e.layers.enable(0) : e.layers.disable(0); return this } }, BlendFunction = { ADD: 0, ALPHA: 1, AVERAGE: 2, COLOR: 3, COLOR_BURN: 4, COLOR_DODGE: 5, DARKEN: 6, DIFFERENCE: 7, DIVIDE: 8, DST: 9, EXCLUSION: 10, HARD_LIGHT: 11, HARD_MIX: 12, HUE: 13, INVERT: 14, INVERT_RGB: 15, LIGHTEN: 16, LINEAR_BURN: 17, LINEAR_DODGE: 18, LINEAR_LIGHT: 19, LUMINOSITY: 20, MULTIPLY: 21, NEGATION: 22, NORMAL: 23, OVERLAY: 24, PIN_LIGHT: 25, REFLECT: 26, SATURATION: 27, SCREEN: 28, SOFT_LIGHT: 29, SRC: 30, SUBTRACT: 31, VIVID_LIGHT: 32 }, add_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb+y.rgb,y.a),opacity);}", alpha_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,y.a*opacity);}", average_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4((x.rgb+y.rgb)*0.5,y.a),opacity);}", color_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.xy,xHSL.z));return mix(x,vec4(z,y.a),opacity);}", color_burn_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 a=x.rgb,b=y.rgb;vec3 z=mix(step(0.0,b)*(1.0-min(vec3(1.0),(1.0-a)/b)),vec3(1.0),step(1.0,a));return mix(x,vec4(z,y.a),opacity);}", color_dodge_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 a=x.rgb,b=y.rgb;vec3 z=step(0.0,a)*mix(min(vec3(1.0),a/max(1.0-b,1e-9)),vec3(1.0),step(1.0,b));return mix(x,vec4(z,y.a),opacity);}", darken_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(min(x.rgb,y.rgb),y.a),opacity);}", difference_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(abs(x.rgb-y.rgb),y.a),opacity);}", divide_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb/max(y.rgb,1e-12),y.a),opacity);}", exclusion_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4((x.rgb+y.rgb-2.0*x.rgb*y.rgb),y.a),opacity);}", hard_light_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 a=min(x.rgb,1.0);vec3 b=min(y.rgb,1.0);vec3 z=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,b));return mix(x,vec4(z,y.a),opacity);}", hard_mix_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(step(1.0,x.rgb+y.rgb),y.a),opacity);}", hue_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.x,xHSL.yz));return mix(x,vec4(z,y.a),opacity);}", invert_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(1.0-y.rgb,y.a),opacity);}", invert_rgb_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(y.rgb*(1.0-x.rgb),y.a),opacity);}", lighten_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(max(x.rgb,y.rgb),y.a),opacity);}", linear_burn_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(clamp(y.rgb+x.rgb-1.0,0.0,1.0),y.a),opacity);}", linear_dodge_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(min(x.rgb+y.rgb,1.0),y.a),opacity);}", linear_light_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(clamp(2.0*y.rgb+x.rgb-1.0,0.0,1.0),y.a),opacity);}", luminosity_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.xy,yHSL.z));return mix(x,vec4(z,y.a),opacity);}", multiply_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb*y.rgb,y.a),opacity);}", negation_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(1.0-abs(1.0-x.rgb-y.rgb),y.a),opacity);}", normal_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,opacity);}", overlay_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 z=mix(2.0*y.rgb*x.rgb,1.0-2.0*(1.0-y.rgb)*(1.0-x.rgb),step(0.5,x.rgb));return mix(x,vec4(z,y.a),opacity);}", pin_light_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 y2=2.0*y.rgb;vec3 z=mix(mix(y2,x.rgb,step(0.5*x.rgb,y.rgb)),max(y2-1.0,vec3(0.0)),step(x.rgb,y2-1.0));return mix(x,vec4(z,y.a),opacity);}", reflect_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 z=mix(min(x.rgb*x.rgb/max(1.0-y.rgb,1e-12),1.0),y.rgb,step(1.0,y.rgb));return mix(x,vec4(z,y.a),opacity);}", saturation_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.x,yHSL.y,xHSL.z));return mix(x,vec4(z,y.a),opacity);}", screen_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb+y.rgb-min(x.rgb*y.rgb,1.0),y.a),opacity);}", soft_light_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 a=x.rgb;vec3 b=y.rgb;vec3 y2=2.0*b;vec3 w=step(0.5,b);vec3 c=a-(1.0-y2)*a*(1.0-a);vec3 d=mix(a+(y2-1.0)*(sqrt(a)-a),a+(y2-1.0)*a*((16.0*a-12.0)*a+3.0),w*(1.0-step(0.25,a)));vec3 z=mix(c,d,w);return mix(x,vec4(z,y.a),opacity);}", src_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}", subtract_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(max(x.rgb+y.rgb-1.0,0.0),y.a),opacity);}", vivid_light_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 z=mix(max(1.0-min((1.0-x.rgb)/(2.0*y.rgb),1.0),0.0),min(x.rgb/(2.0*(1.0-y.rgb)),1.0),step(0.5,y.rgb));return mix(x,vec4(z,y.a),opacity);}", blendFunctions = new Map([[BlendFunction.ADD, add_default], [BlendFunction.ALPHA, alpha_default], [BlendFunction.AVERAGE, average_default], [BlendFunction.COLOR, color_default], [BlendFunction.COLOR_BURN, color_burn_default], [BlendFunction.COLOR_DODGE, color_dodge_default], [BlendFunction.DARKEN, darken_default], [BlendFunction.DIFFERENCE, difference_default], [BlendFunction.DIVIDE, divide_default], [BlendFunction.DST, null], [BlendFunction.EXCLUSION, exclusion_default], [BlendFunction.HARD_LIGHT, hard_light_default], [BlendFunction.HARD_MIX, hard_mix_default], [BlendFunction.HUE, hue_default], [BlendFunction.INVERT, invert_default], [BlendFunction.INVERT_RGB, invert_rgb_default], [BlendFunction.LIGHTEN, lighten_default], [BlendFunction.LINEAR_BURN, linear_burn_default], [BlendFunction.LINEAR_DODGE, linear_dodge_default], [BlendFunction.LINEAR_LIGHT, linear_light_default], [BlendFunction.LUMINOSITY, luminosity_default], [BlendFunction.MULTIPLY, multiply_default], [BlendFunction.NEGATION, negation_default], [BlendFunction.NORMAL, normal_default], [BlendFunction.OVERLAY, overlay_default], [BlendFunction.PIN_LIGHT, pin_light_default], [BlendFunction.REFLECT, reflect_default], [BlendFunction.SATURATION, saturation_default], [BlendFunction.SCREEN, screen_default], [BlendFunction.SOFT_LIGHT, soft_light_default], [BlendFunction.SRC, src_default], [BlendFunction.SUBTRACT, subtract_default], [BlendFunction.VIVID_LIGHT, vivid_light_default]]), BlendMode = class extends EventDispatcher { constructor(r, e = 1) { super(), this._blendFunction = r, this.opacity = new Uniform(e) } getOpacity() { return this.opacity.value } setOpacity(r) { this.opacity.value = r } get blendFunction() { return this._blendFunction } set blendFunction(r) { this._blendFunction = r, this.dispatchEvent({ type: "change" }) } getBlendFunction() { return this.blendFunction } setBlendFunction(r) { this.blendFunction = r } getShaderCode() { return blendFunctions.get(this.blendFunction) } }, Effect = class extends EventDispatcher { constructor(r, e, { attributes: i = EffectAttribute.NONE, blendFunction: s = BlendFunction.NORMAL, defines: a = new Map, uniforms: o = new Map, extensions: l = null, vertexShader: c = null } = {}) { super(), this.name = r, this.renderer = null, this.attributes = i, this.fragmentShader = e, this.vertexShader = c, this.defines = a, this.uniforms = o, this.extensions = l, this.blendMode = new BlendMode(s), this.blendMode.addEventListener("change", h => this.setChanged()), this._inputColorSpace = LinearSRGBColorSpace, this._outputColorSpace = NoColorSpace } get inputColorSpace() { return this._inputColorSpace } set inputColorSpace(r) { this._inputColorSpace = r, this.setChanged() } get outputColorSpace() { return this._outputColorSpace } set outputColorSpace(r) { this._outputColorSpace = r, this.setChanged() } set mainScene(r) { } set mainCamera(r) { } getName() { return this.name } setRenderer(r) { this.renderer = r } getDefines() { return this.defines } getUniforms() { return this.uniforms } getExtensions() { return this.extensions } getBlendMode() { return this.blendMode } getAttributes() { return this.attributes } setAttributes(r) { this.attributes = r, this.setChanged() } getFragmentShader() { return this.fragmentShader } setFragmentShader(r) { this.fragmentShader = r, this.setChanged() } getVertexShader() { return this.vertexShader } setVertexShader(r) { this.vertexShader = r, this.setChanged() } setChanged() { this.dispatchEvent({ type: "change" }) } setDepthTexture(r, e = BasicDepthPacking) { } update(r, e, i) { } setSize(r, e) { } initialize(r, e, i) { } dispose() { for (const r of Object.keys(this)) { const e = this[r]; (e instanceof WebGLRenderTarget || e instanceof Material || e instanceof Texture || e instanceof Pass) && this[r].dispose() } } }, KernelSize = { SMALL: 1, MEDIUM: 2, LARGE: 3 }, convolution_kawase_default = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;
#include <colorspace_fragment>
}`, convolution_kawase_default2 = "uniform vec4 texelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}", kernelPresets = [new Float32Array([0, 0]), new Float32Array([0, 1, 1]), new Float32Array([0, 1, 1, 2]), new Float32Array([0, 1, 2, 2, 3]), new Float32Array([0, 1, 2, 3, 4, 4, 5]), new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10])], KawaseBlurMaterial = class extends ShaderMaterial { constructor(r = new Vector4) { super({ name: "KawaseBlurMaterial", uniforms: { inputBuffer: new Uniform(null), texelSize: new Uniform(new Vector4), scale: new Uniform(1), kernel: new Uniform(0) }, blending: NoBlending, toneMapped: !1, depthWrite: !1, depthTest: !1, fragmentShader: convolution_kawase_default, vertexShader: convolution_kawase_default2 }), this.setTexelSize(r.x, r.y), this.kernelSize = KernelSize.MEDIUM } set inputBuffer(r) { this.uniforms.inputBuffer.value = r } setInputBuffer(r) { this.inputBuffer = r } get kernelSequence() { return kernelPresets[this.kernelSize] } get scale() { return this.uniforms.scale.value } set scale(r) { this.uniforms.scale.value = r } getScale() { return this.uniforms.scale.value } setScale(r) { this.uniforms.scale.value = r } getKernel() { return null } get kernel() { return this.uniforms.kernel.value } set kernel(r) { this.uniforms.kernel.value = r } setKernel(r) { this.kernel = r } setTexelSize(r, e) { this.uniforms.texelSize.value.set(r, e, r * .5, e * .5) } setSize(r, e) { const i = 1 / r, s = 1 / e; this.uniforms.texelSize.value.set(i, s, i * .5, s * .5) } }, KawaseBlurPass = class extends Pass { constructor({ kernelSize: r = KernelSize.MEDIUM, resolutionScale: e = .5, width: i = Resolution.AUTO_SIZE, height: s = Resolution.AUTO_SIZE, resolutionX: a = i, resolutionY: o = s } = {}) { super("KawaseBlurPass"), this.renderTargetA = new WebGLRenderTarget(1, 1, { depthBuffer: !1 }), this.renderTargetA.texture.name = "Blur.Target.A", this.renderTargetB = this.renderTargetA.clone(), this.renderTargetB.texture.name = "Blur.Target.B"; const l = this.resolution = new Resolution(this, a, o, e); l.addEventListener("change", c => this.setSize(l.baseWidth, l.baseHeight)), this._blurMaterial = new KawaseBlurMaterial, this._blurMaterial.kernelSize = r, this.copyMaterial = new CopyMaterial } getResolution() { return this.resolution } get blurMaterial() { return this._blurMaterial } set blurMaterial(r) { this._blurMaterial = r } get dithering() { return this.copyMaterial.dithering } set dithering(r) { this.copyMaterial.dithering = r } get kernelSize() { return this.blurMaterial.kernelSize } set kernelSize(r) { this.blurMaterial.kernelSize = r } get width() { return this.resolution.width } set width(r) { this.resolution.preferredWidth = r } get height() { return this.resolution.height } set height(r) { this.resolution.preferredHeight = r } get scale() { return this.blurMaterial.scale } set scale(r) { this.blurMaterial.scale = r } getScale() { return this.blurMaterial.scale } setScale(r) { this.blurMaterial.scale = r } getKernelSize() { return this.kernelSize } setKernelSize(r) { this.kernelSize = r } getResolutionScale() { return this.resolution.scale } setResolutionScale(r) { this.resolution.scale = r } render(r, e, i, s, a) { const o = this.scene, l = this.camera, c = this.renderTargetA, h = this.renderTargetB, d = this.blurMaterial, p = d.kernelSequence; let f = e; this.fullscreenMaterial = d; for (let _ = 0, x = p.length; _ < x; ++_) { const b = (_ & 1) === 0 ? c : h; d.kernel = p[_], d.inputBuffer = f.texture, r.setRenderTarget(b), r.render(o, l), f = b } this.fullscreenMaterial = this.copyMaterial, this.copyMaterial.inputBuffer = f.texture, r.setRenderTarget(this.renderToScreen ? null : i), r.render(o, l) } setSize(r, e) { const i = this.resolution; i.setBaseSize(r, e); const s = i.width, a = i.height; this.renderTargetA.setSize(s, a), this.renderTargetB.setSize(s, a), this.blurMaterial.setSize(r, e) } initialize(r, e, i) { i !== void 0 && (this.renderTargetA.texture.type = i, this.renderTargetB.texture.type = i, i !== UnsignedByteType ? (this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1", this.copyMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1") : r !== null && r.outputColorSpace === SRGBColorSpace && (this.renderTargetA.texture.colorSpace = SRGBColorSpace, this.renderTargetB.texture.colorSpace = SRGBColorSpace)) } static get AUTO_SIZE() { return Resolution.AUTO_SIZE } }, luminance_default = `#include <common>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef RANGE
uniform vec2 range;
#elif defined(THRESHOLD)
uniform float threshold;uniform float smoothing;
#endif
varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=luminance(texel.rgb);float mask=1.0;
#ifdef RANGE
float low=step(range.x,l);float high=step(l,range.y);mask=low*high;
#elif defined(THRESHOLD)
mask=smoothstep(threshold,threshold+smoothing,l);
#endif
#ifdef COLOR
gl_FragColor=texel*mask;
#else
gl_FragColor=vec4(l*mask);
#endif
}`, LuminanceMaterial = class extends ShaderMaterial { constructor(r = !1, e = null) { super({ name: "LuminanceMaterial", defines: { THREE_REVISION: REVISION.replace(/\D+/g, "") }, uniforms: { inputBuffer: new Uniform(null), threshold: new Uniform(0), smoothing: new Uniform(1), range: new Uniform(null) }, blending: NoBlending, toneMapped: !1, depthWrite: !1, depthTest: !1, fragmentShader: luminance_default, vertexShader: common_default }), this.colorOutput = r, this.luminanceRange = e } set inputBuffer(r) { this.uniforms.inputBuffer.value = r } setInputBuffer(r) { this.uniforms.inputBuffer.value = r } get threshold() { return this.uniforms.threshold.value } set threshold(r) { this.smoothing > 0 || r > 0 ? this.defines.THRESHOLD = "1" : delete this.defines.THRESHOLD, this.uniforms.threshold.value = r } getThreshold() { return this.threshold } setThreshold(r) { this.threshold = r } get smoothing() { return this.uniforms.smoothing.value } set smoothing(r) { this.threshold > 0 || r > 0 ? this.defines.THRESHOLD = "1" : delete this.defines.THRESHOLD, this.uniforms.smoothing.value = r } getSmoothingFactor() { return this.smoothing } setSmoothingFactor(r) { this.smoothing = r } get useThreshold() { return this.threshold > 0 || this.smoothing > 0 } set useThreshold(r) { } get colorOutput() { return this.defines.COLOR !== void 0 } set colorOutput(r) { r ? this.defines.COLOR = "1" : delete this.defines.COLOR, this.needsUpdate = !0 } isColorOutputEnabled(r) { return this.colorOutput } setColorOutputEnabled(r) { this.colorOutput = r } get useRange() { return this.luminanceRange !== null } set useRange(r) { this.luminanceRange = null } get luminanceRange() { return this.uniforms.range.value } set luminanceRange(r) { r !== null ? this.defines.RANGE = "1" : delete this.defines.RANGE, this.uniforms.range.value = r, this.needsUpdate = !0 } getLuminanceRange() { return this.luminanceRange } setLuminanceRange(r) { this.luminanceRange = r } }, LuminancePass = class extends Pass { constructor({ renderTarget: r, luminanceRange: e, colorOutput: i, resolutionScale: s = 1, width: a = Resolution.AUTO_SIZE, height: o = Resolution.AUTO_SIZE, resolutionX: l = a, resolutionY: c = o } = {}) { super("LuminancePass"), this.fullscreenMaterial = new LuminanceMaterial(i, e), this.needsSwap = !1, this.renderTarget = r, this.renderTarget === void 0 && (this.renderTarget = new WebGLRenderTarget(1, 1, { depthBuffer: !1 }), this.renderTarget.texture.name = "LuminancePass.Target"); const h = this.resolution = new Resolution(this, l, c, s); h.addEventListener("change", d => this.setSize(h.baseWidth, h.baseHeight)) } get texture() { return this.renderTarget.texture } getTexture() { return this.renderTarget.texture } getResolution() { return this.resolution } render(r, e, i, s, a) { const o = this.fullscreenMaterial; o.inputBuffer = e.texture, r.setRenderTarget(this.renderToScreen ? null : this.renderTarget), r.render(this.scene, this.camera) } setSize(r, e) { const i = this.resolution; i.setBaseSize(r, e), this.renderTarget.setSize(i.width, i.height) } initialize(r, e, i) { i !== void 0 && i !== UnsignedByteType && (this.renderTarget.texture.type = i, this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1") } }, convolution_downsampling_default = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#define WEIGHT_INNER 0.125
#define WEIGHT_OUTER 0.0555555
varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;float clampToBorder(const in vec2 uv){return float(uv.s>=0.0&&uv.s<=1.0&&uv.t>=0.0&&uv.t<=1.0);}void main(){vec4 c=vec4(0.0);vec4 w=WEIGHT_INNER*vec4(clampToBorder(vUv00),clampToBorder(vUv01),clampToBorder(vUv02),clampToBorder(vUv03));c+=w.x*texture2D(inputBuffer,vUv00);c+=w.y*texture2D(inputBuffer,vUv01);c+=w.z*texture2D(inputBuffer,vUv02);c+=w.w*texture2D(inputBuffer,vUv03);w=WEIGHT_OUTER*vec4(clampToBorder(vUv04),clampToBorder(vUv05),clampToBorder(vUv06),clampToBorder(vUv07));c+=w.x*texture2D(inputBuffer,vUv04);c+=w.y*texture2D(inputBuffer,vUv05);c+=w.z*texture2D(inputBuffer,vUv06);c+=w.w*texture2D(inputBuffer,vUv07);w=WEIGHT_OUTER*vec4(clampToBorder(vUv08),clampToBorder(vUv09),clampToBorder(vUv10),clampToBorder(vUv11));c+=w.x*texture2D(inputBuffer,vUv08);c+=w.y*texture2D(inputBuffer,vUv09);c+=w.z*texture2D(inputBuffer,vUv10);c+=w.w*texture2D(inputBuffer,vUv11);c+=WEIGHT_OUTER*texture2D(inputBuffer,vUv);gl_FragColor=c;
#include <colorspace_fragment>
}`, convolution_downsampling_default2 = "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;void main(){vUv=position.xy*0.5+0.5;vUv00=vUv+texelSize*vec2(-1.0,1.0);vUv01=vUv+texelSize*vec2(1.0,1.0);vUv02=vUv+texelSize*vec2(-1.0,-1.0);vUv03=vUv+texelSize*vec2(1.0,-1.0);vUv04=vUv+texelSize*vec2(-2.0,2.0);vUv05=vUv+texelSize*vec2(0.0,2.0);vUv06=vUv+texelSize*vec2(2.0,2.0);vUv07=vUv+texelSize*vec2(-2.0,0.0);vUv08=vUv+texelSize*vec2(2.0,0.0);vUv09=vUv+texelSize*vec2(-2.0,-2.0);vUv10=vUv+texelSize*vec2(0.0,-2.0);vUv11=vUv+texelSize*vec2(2.0,-2.0);gl_Position=vec4(position.xy,1.0,1.0);}", DownsamplingMaterial = class extends ShaderMaterial { constructor() { super({ name: "DownsamplingMaterial", uniforms: { inputBuffer: new Uniform(null), texelSize: new Uniform(new Vector2) }, blending: NoBlending, toneMapped: !1, depthWrite: !1, depthTest: !1, fragmentShader: convolution_downsampling_default, vertexShader: convolution_downsampling_default2 }) } set inputBuffer(r) { this.uniforms.inputBuffer.value = r } setSize(r, e) { this.uniforms.texelSize.value.set(1 / r, 1 / e) } }, convolution_upsampling_default = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;uniform mediump sampler2D supportBuffer;
#else
uniform lowp sampler2D inputBuffer;uniform lowp sampler2D supportBuffer;
#endif
uniform float radius;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vec4 c=vec4(0.0);c+=texture2D(inputBuffer,vUv0)*0.0625;c+=texture2D(inputBuffer,vUv1)*0.125;c+=texture2D(inputBuffer,vUv2)*0.0625;c+=texture2D(inputBuffer,vUv3)*0.125;c+=texture2D(inputBuffer,vUv)*0.25;c+=texture2D(inputBuffer,vUv4)*0.125;c+=texture2D(inputBuffer,vUv5)*0.0625;c+=texture2D(inputBuffer,vUv6)*0.125;c+=texture2D(inputBuffer,vUv7)*0.0625;vec4 baseColor=texture2D(supportBuffer,vUv);gl_FragColor=mix(baseColor,c,radius);
#include <colorspace_fragment>
}`, convolution_upsampling_default2 = "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,1.0);vUv1=vUv+texelSize*vec2(0.0,1.0);vUv2=vUv+texelSize*vec2(1.0,1.0);vUv3=vUv+texelSize*vec2(-1.0,0.0);vUv4=vUv+texelSize*vec2(1.0,0.0);vUv5=vUv+texelSize*vec2(-1.0,-1.0);vUv6=vUv+texelSize*vec2(0.0,-1.0);vUv7=vUv+texelSize*vec2(1.0,-1.0);gl_Position=vec4(position.xy,1.0,1.0);}", UpsamplingMaterial = class extends ShaderMaterial { constructor() { super({ name: "UpsamplingMaterial", uniforms: { inputBuffer: new Uniform(null), supportBuffer: new Uniform(null), texelSize: new Uniform(new Vector2), radius: new Uniform(.85) }, blending: NoBlending, toneMapped: !1, depthWrite: !1, depthTest: !1, fragmentShader: convolution_upsampling_default, vertexShader: convolution_upsampling_default2 }) } set inputBuffer(r) { this.uniforms.inputBuffer.value = r } set supportBuffer(r) { this.uniforms.supportBuffer.value = r } get radius() { return this.uniforms.radius.value } set radius(r) { this.uniforms.radius.value = r } setSize(r, e) { this.uniforms.texelSize.value.set(1 / r, 1 / e) } }, MipmapBlurPass = class extends Pass { constructor() { super("MipmapBlurPass"), this.needsSwap = !1, this.renderTarget = new WebGLRenderTarget(1, 1, { depthBuffer: !1 }), this.renderTarget.texture.name = "Upsampling.Mipmap0", this.downsamplingMipmaps = [], this.upsamplingMipmaps = [], this.downsamplingMaterial = new DownsamplingMaterial, this.upsamplingMaterial = new UpsamplingMaterial, this.resolution = new Vector2 } get texture() { return this.renderTarget.texture } get levels() { return this.downsamplingMipmaps.length } set levels(r) { if (this.levels !== r) { const e = this.renderTarget; this.dispose(), this.downsamplingMipmaps = [], this.upsamplingMipmaps = []; for (let i = 0; i < r; ++i) { const s = e.clone(); s.texture.name = "Downsampling.Mipmap" + i, this.downsamplingMipmaps.push(s) } this.upsamplingMipmaps.push(e); for (let i = 1, s = r - 1; i < s; ++i) { const a = e.clone(); a.texture.name = "Upsampling.Mipmap" + i, this.upsamplingMipmaps.push(a) } this.setSize(this.resolution.x, this.resolution.y) } } get radius() { return this.upsamplingMaterial.radius } set radius(r) { this.upsamplingMaterial.radius = r } render(r, e, i, s, a) { const { scene: o, camera: l } = this, { downsamplingMaterial: c, upsamplingMaterial: h } = this, { downsamplingMipmaps: d, upsamplingMipmaps: p } = this; let f = e; this.fullscreenMaterial = c; for (let _ = 0, x = d.length; _ < x; ++_) { const b = d[_]; c.setSize(f.width, f.height), c.inputBuffer = f.texture, r.setRenderTarget(b), r.render(o, l), f = b } this.fullscreenMaterial = h; for (let _ = p.length - 1; _ >= 0; --_) { const x = p[_]; h.setSize(f.width, f.height), h.inputBuffer = f.texture, h.supportBuffer = d[_].texture, r.setRenderTarget(x), r.render(o, l), f = x } } setSize(r, e) { const i = this.resolution; i.set(r, e); let s = i.width, a = i.height; for (let o = 0, l = this.downsamplingMipmaps.length; o < l; ++o)s = Math.round(s * .5), a = Math.round(a * .5), this.downsamplingMipmaps[o].setSize(s, a), o < this.upsamplingMipmaps.length && this.upsamplingMipmaps[o].setSize(s, a) } initialize(r, e, i) { if (i !== void 0) { const s = this.downsamplingMipmaps.concat(this.upsamplingMipmaps); for (const a of s) a.texture.type = i; if (i !== UnsignedByteType) this.downsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1", this.upsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1"; else if (r !== null && r.outputColorSpace === SRGBColorSpace) for (const a of s) a.texture.colorSpace = SRGBColorSpace } } dispose() { super.dispose(); for (const r of this.downsamplingMipmaps.concat(this.upsamplingMipmaps)) r.dispose() } }, bloom_default = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D map;
#else
uniform lowp sampler2D map;
#endif
uniform float intensity;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 texel=texture2D(map,uv);outputColor=vec4(texel.rgb*intensity,max(inputColor.a,texel.a));}`, BloomEffect = class extends Effect { constructor({ blendFunction: r = BlendFunction.SCREEN, luminanceThreshold: e = 1, luminanceSmoothing: i = .03, mipmapBlur: s = !0, intensity: a = 1, radius: o = .85, levels: l = 8, kernelSize: c = KernelSize.LARGE, resolutionScale: h = .5, width: d = Resolution.AUTO_SIZE, height: p = Resolution.AUTO_SIZE, resolutionX: f = d, resolutionY: _ = p } = {}) { super("BloomEffect", bloom_default, { blendFunction: r, uniforms: new Map([["map", new Uniform(null)], ["intensity", new Uniform(a)]]) }), this.renderTarget = new WebGLRenderTarget(1, 1, { depthBuffer: !1 }), this.renderTarget.texture.name = "Bloom.Target", this.blurPass = new KawaseBlurPass({ kernelSize: c }), this.luminancePass = new LuminancePass({ colorOutput: !0 }), this.luminanceMaterial.threshold = e, this.luminanceMaterial.smoothing = i, this.mipmapBlurPass = new MipmapBlurPass, this.mipmapBlurPass.enabled = s, this.mipmapBlurPass.radius = o, this.mipmapBlurPass.levels = l, this.uniforms.get("map").value = s ? this.mipmapBlurPass.texture : this.renderTarget.texture; const x = this.resolution = new Resolution(this, f, _, h); x.addEventListener("change", b => this.setSize(x.baseWidth, x.baseHeight)) } get texture() { return this.mipmapBlurPass.enabled ? this.mipmapBlurPass.texture : this.renderTarget.texture } getTexture() { return this.texture } getResolution() { return this.resolution } getBlurPass() { return this.blurPass } getLuminancePass() { return this.luminancePass } get luminanceMaterial() { return this.luminancePass.fullscreenMaterial } getLuminanceMaterial() { return this.luminancePass.fullscreenMaterial } get width() { return this.resolution.width } set width(r) { this.resolution.preferredWidth = r } get height() { return this.resolution.height } set height(r) { this.resolution.preferredHeight = r } get dithering() { return this.blurPass.dithering } set dithering(r) { this.blurPass.dithering = r } get kernelSize() { return this.blurPass.kernelSize } set kernelSize(r) { this.blurPass.kernelSize = r } get distinction() { return console.warn(this.name, "distinction was removed"), 1 } set distinction(r) { console.warn(this.name, "distinction was removed") } get intensity() { return this.uniforms.get("intensity").value } set intensity(r) { this.uniforms.get("intensity").value = r } getIntensity() { return this.intensity } setIntensity(r) { this.intensity = r } getResolutionScale() { return this.resolution.scale } setResolutionScale(r) { this.resolution.scale = r } update(r, e, i) { const s = this.renderTarget, a = this.luminancePass; a.enabled ? (a.render(r, e), this.mipmapBlurPass.enabled ? this.mipmapBlurPass.render(r, a.renderTarget) : this.blurPass.render(r, a.renderTarget, s)) : this.mipmapBlurPass.enabled ? this.mipmapBlurPass.render(r, e) : this.blurPass.render(r, e, s) } setSize(r, e) { const i = this.resolution; i.setBaseSize(r, e), this.renderTarget.setSize(i.width, i.height), this.blurPass.resolution.copy(i), this.luminancePass.setSize(r, e), this.mipmapBlurPass.setSize(r, e) } initialize(r, e, i) { this.blurPass.initialize(r, e, i), this.luminancePass.initialize(r, e, i), this.mipmapBlurPass.initialize(r, e, i), i !== void 0 && (this.renderTarget.texture.type = i, r !== null && r.outputColorSpace === SRGBColorSpace && (this.renderTarget.texture.colorSpace = SRGBColorSpace)) } }, ColorChannel = { RED: 0, GREEN: 1 }, MaskFunction = { DISCARD: 0, MULTIPLY_RGB: 3 }, convolution_bokeh_default = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#if PASS == 1
uniform vec4 kernel64[32];
#else
uniform vec4 kernel16[8];
#endif
uniform lowp sampler2D cocBuffer;uniform vec2 texelSize;uniform float scale;varying vec2 vUv;void main(){
#ifdef FOREGROUND
vec2 cocNearFar=texture2D(cocBuffer,vUv).rg*scale;float coc=cocNearFar.x;
#else
float coc=texture2D(cocBuffer,vUv).g*scale;
#endif
if(coc==0.0){gl_FragColor=texture2D(inputBuffer,vUv);}else{
#ifdef FOREGROUND
vec2 step=texelSize*max(cocNearFar.x,cocNearFar.y);
#else
vec2 step=texelSize*coc;
#endif
#if PASS == 1
vec4 acc=vec4(0.0);for(int i=0;i<32;++i){vec4 kernel=kernel64[i];vec2 uv=step*kernel.xy+vUv;acc+=texture2D(inputBuffer,uv);uv=step*kernel.zw+vUv;acc+=texture2D(inputBuffer,uv);}gl_FragColor=acc/64.0;
#else
vec4 maxValue=texture2D(inputBuffer,vUv);for(int i=0;i<8;++i){vec4 kernel=kernel16[i];vec2 uv=step*kernel.xy+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);uv=step*kernel.zw+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);}gl_FragColor=maxValue;
#endif
}}`, BokehMaterial = class extends ShaderMaterial { constructor(r = !1, e = !1) { super({ name: "BokehMaterial", defines: { PASS: r ? "2" : "1" }, uniforms: { inputBuffer: new Uniform(null), cocBuffer: new Uniform(null), texelSize: new Uniform(new Vector2), kernel64: new Uniform(null), kernel16: new Uniform(null), scale: new Uniform(1) }, blending: NoBlending, toneMapped: !1, depthWrite: !1, depthTest: !1, fragmentShader: convolution_bokeh_default, vertexShader: common_default }), e && (this.defines.FOREGROUND = "1"), this.generateKernel() } set inputBuffer(r) { this.uniforms.inputBuffer.value = r } setInputBuffer(r) { this.uniforms.inputBuffer.value = r } set cocBuffer(r) { this.uniforms.cocBuffer.value = r } setCoCBuffer(r) { this.uniforms.cocBuffer.value = r } get scale() { return this.uniforms.scale.value } set scale(r) { this.uniforms.scale.value = r } getScale(r) { return this.scale } setScale(r) { this.scale = r } generateKernel() { const r = 2.39996323, e = new Float64Array(128), i = new Float64Array(32); let s = 0, a = 0; for (let o = 0, l = Math.sqrt(80); o < 80; ++o) { const c = o * r, h = Math.sqrt(o) / l, d = h * Math.cos(c), p = h * Math.sin(c); o % 5 === 0 ? (i[a++] = d, i[a++] = p) : (e[s++] = d, e[s++] = p) } this.uniforms.kernel64.value = e, this.uniforms.kernel16.value = i } setTexelSize(r, e) { this.uniforms.texelSize.value.set(r, e) } setSize(r, e) { this.uniforms.texelSize.value.set(1 / r, 1 / e) } }; function orthographicDepthToViewZ(r, e, i) { return r * (e - i) - e } function viewZToOrthographicDepth(r, e, i) { return Math.min(Math.max((r + e) / (e - i), 0), 1) } var circle_of_confusion_default = `#include <common>
#include <packing>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform float focusDistance;uniform float focusRange;uniform float cameraNear;uniform float cameraFar;varying vec2 vUv;float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
float depth=unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
float depth=texture2D(depthBuffer,uv).r;
#endif
#ifdef LOG_DEPTH
float d=pow(2.0,depth*log2(cameraFar+1.0))-1.0;float a=cameraFar/(cameraFar-cameraNear);float b=cameraFar*cameraNear/(cameraNear-cameraFar);depth=a+b/d;
#endif
return depth;}void main(){float depth=readDepth(vUv);
#ifdef PERSPECTIVE_CAMERA
float viewZ=perspectiveDepthToViewZ(depth,cameraNear,cameraFar);float linearDepth=viewZToOrthographicDepth(viewZ,cameraNear,cameraFar);
#else
float linearDepth=depth;
#endif
float signedDistance=linearDepth-focusDistance;float magnitude=smoothstep(0.0,focusRange,abs(signedDistance));gl_FragColor.rg=magnitude*vec2(step(signedDistance,0.0),step(0.0,signedDistance));}`, CircleOfConfusionMaterial = class extends ShaderMaterial { constructor(r) { super({ name: "CircleOfConfusionMaterial", defines: { DEPTH_PACKING: "0" }, uniforms: { depthBuffer: new Uniform(null), focusDistance: new Uniform(0), focusRange: new Uniform(0), cameraNear: new Uniform(.3), cameraFar: new Uniform(1e3) }, blending: NoBlending, toneMapped: !1, depthWrite: !1, depthTest: !1, fragmentShader: circle_of_confusion_default, vertexShader: common_default }), this.uniforms.focalLength = this.uniforms.focusRange, this.copyCameraSettings(r) } get near() { return this.uniforms.cameraNear.value } get far() { return this.uniforms.cameraFar.value } set depthBuffer(r) { this.uniforms.depthBuffer.value = r } set depthPacking(r) { this.defines.DEPTH_PACKING = r.toFixed(0), this.needsUpdate = !0 } setDepthBuffer(r, e = BasicDepthPacking) { this.depthBuffer = r, this.depthPacking = e } get focusDistance() { return this.uniforms.focusDistance.value } set focusDistance(r) { this.uniforms.focusDistance.value = r } get worldFocusDistance() { return -orthographicDepthToViewZ(this.focusDistance, this.near, this.far) } set worldFocusDistance(r) { this.focusDistance = viewZToOrthographicDepth(-r, this.near, this.far) } getFocusDistance(r) { this.uniforms.focusDistance.value = r } setFocusDistance(r) { this.uniforms.focusDistance.value = r } get focalLength() { return this.focusRange } set focalLength(r) { this.focusRange = r } get focusRange() { return this.uniforms.focusRange.value } set focusRange(r) { this.uniforms.focusRange.value = r } get worldFocusRange() { return -orthographicDepthToViewZ(this.focusRange, this.near, this.far) } set worldFocusRange(r) { this.focusRange = viewZToOrthographicDepth(-r, this.near, this.far) } getFocalLength(r) { return this.focusRange } setFocalLength(r) { this.focusRange = r } adoptCameraSettings(r) { this.copyCameraSettings(r) } copyCameraSettings(r) { r && (this.uniforms.cameraNear.value = r.near, this.uniforms.cameraFar.value = r.far, r instanceof PerspectiveCamera ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA, this.needsUpdate = !0) } }, mask_default = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef MASK_PRECISION_HIGH
uniform mediump sampler2D maskTexture;
#else
uniform lowp sampler2D maskTexture;
#endif
#if MASK_FUNCTION != 0
uniform float strength;
#endif
varying vec2 vUv;void main(){
#if COLOR_CHANNEL == 0
float mask=texture2D(maskTexture,vUv).r;
#elif COLOR_CHANNEL == 1
float mask=texture2D(maskTexture,vUv).g;
#elif COLOR_CHANNEL == 2
float mask=texture2D(maskTexture,vUv).b;
#else
float mask=texture2D(maskTexture,vUv).a;
#endif
#if MASK_FUNCTION == 0
#ifdef INVERTED
mask=step(mask,0.0);
#else
mask=1.0-step(mask,0.0);
#endif
#else
mask=clamp(mask*strength,0.0,1.0);
#ifdef INVERTED
mask=1.0-mask;
#endif
#endif
#if MASK_FUNCTION == 3
vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=vec4(mask*texel.rgb,texel.a);
#elif MASK_FUNCTION == 2
gl_FragColor=vec4(mask*texture2D(inputBuffer,vUv).rgb,mask);
#else
gl_FragColor=mask*texture2D(inputBuffer,vUv);
#endif
}`, MaskMaterial = class extends ShaderMaterial { constructor(r = null) { super({ name: "MaskMaterial", uniforms: { maskTexture: new Uniform(r), inputBuffer: new Uniform(null), strength: new Uniform(1) }, blending: NoBlending, toneMapped: !1, depthWrite: !1, depthTest: !1, fragmentShader: mask_default, vertexShader: common_default }), this.colorChannel = ColorChannel.RED, this.maskFunction = MaskFunction.DISCARD } set inputBuffer(r) { this.uniforms.inputBuffer.value = r } setInputBuffer(r) { this.uniforms.inputBuffer.value = r } set maskTexture(r) { this.uniforms.maskTexture.value = r, delete this.defines.MASK_PRECISION_HIGH, r.type !== UnsignedByteType && (this.defines.MASK_PRECISION_HIGH = "1"), this.needsUpdate = !0 } setMaskTexture(r) { this.maskTexture = r } set colorChannel(r) { this.defines.COLOR_CHANNEL = r.toFixed(0), this.needsUpdate = !0 } setColorChannel(r) { this.colorChannel = r } set maskFunction(r) { this.defines.MASK_FUNCTION = r.toFixed(0), this.needsUpdate = !0 } setMaskFunction(r) { this.maskFunction = r } get inverted() { return this.defines.INVERTED !== void 0 } set inverted(r) { this.inverted && !r ? delete this.defines.INVERTED : r && (this.defines.INVERTED = "1"), this.needsUpdate = !0 } isInverted() { return this.inverted } setInverted(r) { this.inverted = r } get strength() { return this.uniforms.strength.value } set strength(r) { this.uniforms.strength.value = r } getStrength() { return this.strength } setStrength(r) { this.strength = r } }, ShaderPass = class extends Pass { constructor(r, e = "inputBuffer") { super("ShaderPass"), this.fullscreenMaterial = r, this.input = e } setInput(r) { this.input = r } render(r, e, i, s, a) { const o = this.fullscreenMaterial.uniforms; e !== null && o !== void 0 && o[this.input] !== void 0 && (o[this.input].value = e.texture), r.setRenderTarget(this.renderToScreen ? null : i), r.render(this.scene, this.camera) } initialize(r, e, i) { i !== void 0 && i !== UnsignedByteType && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1") } }, depth_of_field_default = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D nearColorBuffer;uniform mediump sampler2D farColorBuffer;
#else
uniform lowp sampler2D nearColorBuffer;uniform lowp sampler2D farColorBuffer;
#endif
uniform lowp sampler2D nearCoCBuffer;uniform lowp sampler2D farCoCBuffer;uniform float scale;void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){vec4 colorNear=texture2D(nearColorBuffer,uv);vec4 colorFar=texture2D(farColorBuffer,uv);
#if MASK_FUNCTION == 1
vec2 cocNearFar=vec2(texture2D(nearCoCBuffer,uv).r,colorFar.a);cocNearFar.x=min(cocNearFar.x*scale,1.0);
#else
vec2 cocNearFar=vec2(texture2D(nearCoCBuffer,uv).r,texture2D(farCoCBuffer,uv).g);cocNearFar=min(cocNearFar*scale,1.0);
#endif
vec4 result=inputColor*(1.0-cocNearFar.y)+colorFar;result=mix(result,colorNear,cocNearFar.x);outputColor=result;}`, DepthOfFieldEffect = class extends Effect { constructor(r, { blendFunction: e, worldFocusDistance: i, worldFocusRange: s, focusDistance: a = 0, focalLength: o = .1, focusRange: l = o, bokehScale: c = 1, resolutionScale: h = 1, width: d = Resolution.AUTO_SIZE, height: p = Resolution.AUTO_SIZE, resolutionX: f = d, resolutionY: _ = p } = {}) { super("DepthOfFieldEffect", depth_of_field_default, { blendFunction: e, attributes: EffectAttribute.DEPTH, uniforms: new Map([["nearColorBuffer", new Uniform(null)], ["farColorBuffer", new Uniform(null)], ["nearCoCBuffer", new Uniform(null)], ["farCoCBuffer", new Uniform(null)], ["scale", new Uniform(1)]]) }), this.camera = r, this.renderTarget = new WebGLRenderTarget(1, 1, { depthBuffer: !1 }), this.renderTarget.texture.name = "DoF.Intermediate", this.renderTargetMasked = this.renderTarget.clone(), this.renderTargetMasked.texture.name = "DoF.Masked.Far", this.renderTargetNear = this.renderTarget.clone(), this.renderTargetNear.texture.name = "DoF.Bokeh.Near", this.uniforms.get("nearColorBuffer").value = this.renderTargetNear.texture, this.renderTargetFar = this.renderTarget.clone(), this.renderTargetFar.texture.name = "DoF.Bokeh.Far", this.uniforms.get("farColorBuffer").value = this.renderTargetFar.texture, this.renderTargetCoC = this.renderTarget.clone(), this.renderTargetCoC.texture.name = "DoF.CoC", this.uniforms.get("farCoCBuffer").value = this.renderTargetCoC.texture, this.renderTargetCoCBlurred = this.renderTargetCoC.clone(), this.renderTargetCoCBlurred.texture.name = "DoF.CoC.Blurred", this.uniforms.get("nearCoCBuffer").value = this.renderTargetCoCBlurred.texture, this.cocPass = new ShaderPass(new CircleOfConfusionMaterial(r)); const x = this.cocMaterial; x.focusDistance = a, x.focusRange = l, i !== void 0 && (x.worldFocusDistance = i), s !== void 0 && (x.worldFocusRange = s), this.blurPass = new KawaseBlurPass({ resolutionScale: h, resolutionX: f, resolutionY: _, kernelSize: KernelSize.MEDIUM }), this.maskPass = new ShaderPass(new MaskMaterial(this.renderTargetCoC.texture)); const b = this.maskPass.fullscreenMaterial; b.colorChannel = ColorChannel.GREEN, this.maskFunction = MaskFunction.MULTIPLY_RGB, this.bokehNearBasePass = new ShaderPass(new BokehMaterial(!1, !0)), this.bokehNearBasePass.fullscreenMaterial.cocBuffer = this.renderTargetCoCBlurred.texture, this.bokehNearFillPass = new ShaderPass(new BokehMaterial(!0, !0)), this.bokehNearFillPass.fullscreenMaterial.cocBuffer = this.renderTargetCoCBlurred.texture, this.bokehFarBasePass = new ShaderPass(new BokehMaterial(!1, !1)), this.bokehFarBasePass.fullscreenMaterial.cocBuffer = this.renderTargetCoC.texture, this.bokehFarFillPass = new ShaderPass(new BokehMaterial(!0, !1)), this.bokehFarFillPass.fullscreenMaterial.cocBuffer = this.renderTargetCoC.texture, this.target = null; const T = this.resolution = new Resolution(this, f, _, h); T.addEventListener("change", M => this.setSize(T.baseWidth, T.baseHeight)), this.bokehScale = c } set mainCamera(r) { this.camera = r, this.cocMaterial.copyCameraSettings(r) } get cocTexture() { return this.renderTargetCoC.texture } get maskFunction() { return this.maskPass.fullscreenMaterial.maskFunction } set maskFunction(r) { this.maskFunction !== r && (this.defines.set("MASK_FUNCTION", r.toFixed(0)), this.maskPass.fullscreenMaterial.maskFunction = r, this.setChanged()) } get cocMaterial() { return this.cocPass.fullscreenMaterial } get circleOfConfusionMaterial() { return this.cocMaterial } getCircleOfConfusionMaterial() { return this.cocMaterial } getBlurPass() { return this.blurPass } getResolution() { return this.resolution } get bokehScale() { return this.uniforms.get("scale").value } set bokehScale(r) { this.bokehNearBasePass.fullscreenMaterial.scale = r, this.bokehNearFillPass.fullscreenMaterial.scale = r, this.bokehFarBasePass.fullscreenMaterial.scale = r, this.bokehFarFillPass.fullscreenMaterial.scale = r, this.maskPass.fullscreenMaterial.strength = r, this.uniforms.get("scale").value = r } getBokehScale() { return this.bokehScale } setBokehScale(r) { this.bokehScale = r } getTarget() { return this.target } setTarget(r) { this.target = r } calculateFocusDistance(r) { const e = this.camera, i = e.position.distanceTo(r); return viewZToOrthographicDepth(-i, e.near, e.far) } setDepthTexture(r, e = BasicDepthPacking) { this.cocMaterial.depthBuffer = r, this.cocMaterial.depthPacking = e } update(r, e, i) { const s = this.renderTarget, a = this.renderTargetCoC, o = this.renderTargetCoCBlurred, l = this.renderTargetMasked; if (this.target !== null) { const c = this.calculateFocusDistance(this.target); this.cocMaterial.focusDistance = c } this.cocPass.render(r, null, a), this.blurPass.render(r, a, o), this.maskPass.render(r, e, l), this.bokehFarBasePass.render(r, l, s), this.bokehFarFillPass.render(r, s, this.renderTargetFar), this.bokehNearBasePass.render(r, e, s), this.bokehNearFillPass.render(r, s, this.renderTargetNear) } setSize(r, e) { const i = this.resolution; i.setBaseSize(r, e); const s = i.width, a = i.height; this.cocPass.setSize(r, e), this.blurPass.setSize(r, e), this.maskPass.setSize(r, e), this.renderTargetFar.setSize(r, e), this.renderTargetCoC.setSize(r, e), this.renderTargetMasked.setSize(r, e), this.renderTarget.setSize(s, a), this.renderTargetNear.setSize(s, a), this.renderTargetCoCBlurred.setSize(s, a), this.bokehNearBasePass.fullscreenMaterial.setSize(r, e), this.bokehNearFillPass.fullscreenMaterial.setSize(r, e), this.bokehFarBasePass.fullscreenMaterial.setSize(r, e), this.bokehFarFillPass.fullscreenMaterial.setSize(r, e) } initialize(r, e, i) { this.cocPass.initialize(r, e, i), this.maskPass.initialize(r, e, i), this.bokehNearBasePass.initialize(r, e, i), this.bokehNearFillPass.initialize(r, e, i), this.bokehFarBasePass.initialize(r, e, i), this.bokehFarFillPass.initialize(r, e, i), this.blurPass.initialize(r, e, UnsignedByteType), r.capabilities.logarithmicDepthBuffer && (this.cocPass.fullscreenMaterial.defines.LOG_DEPTH = "1"), i !== void 0 && (this.renderTarget.texture.type = i, this.renderTargetNear.texture.type = i, this.renderTargetFar.texture.type = i, this.renderTargetMasked.texture.type = i, r !== null && r.outputColorSpace === SRGBColorSpace && (this.renderTarget.texture.colorSpace = SRGBColorSpace, this.renderTargetNear.texture.colorSpace = SRGBColorSpace, this.renderTargetFar.texture.colorSpace = SRGBColorSpace, this.renderTargetMasked.texture.colorSpace = SRGBColorSpace)) } }, fxaa_default = `#define QUALITY(q) ((q) < 5 ? 1.0 : ((q) > 5 ? ((q) < 10 ? 2.0 : ((q) < 11 ? 4.0 : 8.0)) : 1.5))
#define ONE_OVER_TWELVE 0.08333333333333333
varying vec2 vUvDown;varying vec2 vUvUp;varying vec2 vUvLeft;varying vec2 vUvRight;varying vec2 vUvDownLeft;varying vec2 vUvUpRight;varying vec2 vUvUpLeft;varying vec2 vUvDownRight;vec4 fxaa(const in vec4 inputColor,const in vec2 uv){float lumaCenter=luminance(inputColor.rgb);float lumaDown=luminance(texture2D(inputBuffer,vUvDown).rgb);float lumaUp=luminance(texture2D(inputBuffer,vUvUp).rgb);float lumaLeft=luminance(texture2D(inputBuffer,vUvLeft).rgb);float lumaRight=luminance(texture2D(inputBuffer,vUvRight).rgb);float lumaMin=min(lumaCenter,min(min(lumaDown,lumaUp),min(lumaLeft,lumaRight)));float lumaMax=max(lumaCenter,max(max(lumaDown,lumaUp),max(lumaLeft,lumaRight)));float lumaRange=lumaMax-lumaMin;if(lumaRange<max(EDGE_THRESHOLD_MIN,lumaMax*EDGE_THRESHOLD_MAX)){return inputColor;}float lumaDownLeft=luminance(texture2D(inputBuffer,vUvDownLeft).rgb);float lumaUpRight=luminance(texture2D(inputBuffer,vUvUpRight).rgb);float lumaUpLeft=luminance(texture2D(inputBuffer,vUvUpLeft).rgb);float lumaDownRight=luminance(texture2D(inputBuffer,vUvDownRight).rgb);float lumaDownUp=lumaDown+lumaUp;float lumaLeftRight=lumaLeft+lumaRight;float lumaLeftCorners=lumaDownLeft+lumaUpLeft;float lumaDownCorners=lumaDownLeft+lumaDownRight;float lumaRightCorners=lumaDownRight+lumaUpRight;float lumaUpCorners=lumaUpRight+lumaUpLeft;float edgeHorizontal=(abs(-2.0*lumaLeft+lumaLeftCorners)+abs(-2.0*lumaCenter+lumaDownUp)*2.0+abs(-2.0*lumaRight+lumaRightCorners));float edgeVertical=(abs(-2.0*lumaUp+lumaUpCorners)+abs(-2.0*lumaCenter+lumaLeftRight)*2.0+abs(-2.0*lumaDown+lumaDownCorners));bool isHorizontal=(edgeHorizontal>=edgeVertical);float stepLength=isHorizontal?texelSize.y:texelSize.x;float luma1=isHorizontal?lumaDown:lumaLeft;float luma2=isHorizontal?lumaUp:lumaRight;float gradient1=abs(luma1-lumaCenter);float gradient2=abs(luma2-lumaCenter);bool is1Steepest=gradient1>=gradient2;float gradientScaled=0.25*max(gradient1,gradient2);float lumaLocalAverage=0.0;if(is1Steepest){stepLength=-stepLength;lumaLocalAverage=0.5*(luma1+lumaCenter);}else{lumaLocalAverage=0.5*(luma2+lumaCenter);}vec2 currentUv=uv;if(isHorizontal){currentUv.y+=stepLength*0.5;}else{currentUv.x+=stepLength*0.5;}vec2 offset=isHorizontal?vec2(texelSize.x,0.0):vec2(0.0,texelSize.y);vec2 uv1=currentUv-offset*QUALITY(0);vec2 uv2=currentUv+offset*QUALITY(0);float lumaEnd1=luminance(texture2D(inputBuffer,uv1).rgb);float lumaEnd2=luminance(texture2D(inputBuffer,uv2).rgb);lumaEnd1-=lumaLocalAverage;lumaEnd2-=lumaLocalAverage;bool reached1=abs(lumaEnd1)>=gradientScaled;bool reached2=abs(lumaEnd2)>=gradientScaled;bool reachedBoth=reached1&&reached2;if(!reached1){uv1-=offset*QUALITY(1);}if(!reached2){uv2+=offset*QUALITY(1);}if(!reachedBoth){for(int i=2;i<SAMPLES;++i){if(!reached1){lumaEnd1=luminance(texture2D(inputBuffer,uv1).rgb);lumaEnd1=lumaEnd1-lumaLocalAverage;}if(!reached2){lumaEnd2=luminance(texture2D(inputBuffer,uv2).rgb);lumaEnd2=lumaEnd2-lumaLocalAverage;}reached1=abs(lumaEnd1)>=gradientScaled;reached2=abs(lumaEnd2)>=gradientScaled;reachedBoth=reached1&&reached2;if(!reached1){uv1-=offset*QUALITY(i);}if(!reached2){uv2+=offset*QUALITY(i);}if(reachedBoth){break;}}}float distance1=isHorizontal?(uv.x-uv1.x):(uv.y-uv1.y);float distance2=isHorizontal?(uv2.x-uv.x):(uv2.y-uv.y);bool isDirection1=distance1<distance2;float distanceFinal=min(distance1,distance2);float edgeThickness=(distance1+distance2);bool isLumaCenterSmaller=lumaCenter<lumaLocalAverage;bool correctVariation1=(lumaEnd1<0.0)!=isLumaCenterSmaller;bool correctVariation2=(lumaEnd2<0.0)!=isLumaCenterSmaller;bool correctVariation=isDirection1?correctVariation1:correctVariation2;float pixelOffset=-distanceFinal/edgeThickness+0.5;float finalOffset=correctVariation?pixelOffset:0.0;float lumaAverage=ONE_OVER_TWELVE*(2.0*(lumaDownUp+lumaLeftRight)+lumaLeftCorners+lumaRightCorners);float subPixelOffset1=clamp(abs(lumaAverage-lumaCenter)/lumaRange,0.0,1.0);float subPixelOffset2=(-2.0*subPixelOffset1+3.0)*subPixelOffset1*subPixelOffset1;float subPixelOffsetFinal=subPixelOffset2*subPixelOffset2*SUBPIXEL_QUALITY;finalOffset=max(finalOffset,subPixelOffsetFinal);vec2 finalUv=uv;if(isHorizontal){finalUv.y+=finalOffset*stepLength;}else{finalUv.x+=finalOffset*stepLength;}return texture2D(inputBuffer,finalUv);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=fxaa(inputColor,uv);}`, fxaa_default2 = "varying vec2 vUvDown;varying vec2 vUvUp;varying vec2 vUvLeft;varying vec2 vUvRight;varying vec2 vUvDownLeft;varying vec2 vUvUpRight;varying vec2 vUvUpLeft;varying vec2 vUvDownRight;void mainSupport(const in vec2 uv){vUvDown=uv+vec2(0.0,-1.0)*texelSize;vUvUp=uv+vec2(0.0,1.0)*texelSize;vUvRight=uv+vec2(1.0,0.0)*texelSize;vUvLeft=uv+vec2(-1.0,0.0)*texelSize;vUvDownLeft=uv+vec2(-1.0,-1.0)*texelSize;vUvUpRight=uv+vec2(1.0,1.0)*texelSize;vUvUpLeft=uv+vec2(-1.0,1.0)*texelSize;vUvDownRight=uv+vec2(1.0,-1.0)*texelSize;}", FXAAEffect = class extends Effect { constructor({ blendFunction: r = BlendFunction.SRC } = {}) { super("FXAAEffect", fxaa_default, { vertexShader: fxaa_default2, blendFunction: r, defines: new Map([["EDGE_THRESHOLD_MIN", "0.0312"], ["EDGE_THRESHOLD_MAX", "0.125"], ["SUBPIXEL_QUALITY", "0.75"], ["SAMPLES", "12"]]) }) } get minEdgeThreshold() { return Number(this.defines.get("EDGE_THRESHOLD_MIN")) } set minEdgeThreshold(r) { this.defines.set("EDGE_THRESHOLD_MIN", r.toFixed(12)), this.setChanged() } get maxEdgeThreshold() { return Number(this.defines.get("EDGE_THRESHOLD_MAX")) } set maxEdgeThreshold(r) { this.defines.set("EDGE_THRESHOLD_MAX", r.toFixed(12)), this.setChanged() } get subpixelQuality() { return Number(this.defines.get("SUBPIXEL_QUALITY")) } set subpixelQuality(r) { this.defines.set("SUBPIXEL_QUALITY", r.toFixed(12)), this.setChanged() } get samples() { return Number(this.defines.get("SAMPLES")) } set samples(r) { this.defines.set("SAMPLES", r.toFixed(0)), this.setChanged() } }, DepthTestStrategy = { KEEP_MAX_DEPTH: 1, DISCARD_MAX_DEPTH: 2 }, depth_mask_default = `#include <common>
#include <packing>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer0;uniform highp sampler2D depthBuffer1;
#else
uniform mediump sampler2D depthBuffer0;uniform mediump sampler2D depthBuffer1;
#endif
uniform sampler2D inputBuffer;uniform vec2 cameraNearFar;float getViewZ(const in float depth){
#ifdef PERSPECTIVE_CAMERA
return perspectiveDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);
#else
return orthographicDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);
#endif
}varying vec2 vUv;void main(){vec2 depth;
#if DEPTH_PACKING_0 == 3201
depth.x=unpackRGBAToDepth(texture2D(depthBuffer0,vUv));
#else
depth.x=texture2D(depthBuffer0,vUv).r;
#ifdef LOG_DEPTH
float d=pow(2.0,depth.x*log2(cameraNearFar.y+1.0))-1.0;float a=cameraNearFar.y/(cameraNearFar.y-cameraNearFar.x);float b=cameraNearFar.y*cameraNearFar.x/(cameraNearFar.x-cameraNearFar.y);depth.x=a+b/d;
#endif
#endif
#if DEPTH_PACKING_1 == 3201
depth.y=unpackRGBAToDepth(texture2D(depthBuffer1,vUv));
#else
depth.y=texture2D(depthBuffer1,vUv).r;
#ifdef LOG_DEPTH
float d=pow(2.0,depth.y*log2(cameraNearFar.y+1.0))-1.0;float a=cameraNearFar.y/(cameraNearFar.y-cameraNearFar.x);float b=cameraNearFar.y*cameraNearFar.x/(cameraNearFar.x-cameraNearFar.y);depth.y=a+b/d;
#endif
#endif
bool isMaxDepth=(depth.x==1.0);
#ifdef PERSPECTIVE_CAMERA
depth.x=viewZToOrthographicDepth(getViewZ(depth.x),cameraNearFar.x,cameraNearFar.y);depth.y=viewZToOrthographicDepth(getViewZ(depth.y),cameraNearFar.x,cameraNearFar.y);
#endif
#if DEPTH_TEST_STRATEGY == 0
bool keep=depthTest(depth.x,depth.y);
#elif DEPTH_TEST_STRATEGY == 1
bool keep=isMaxDepth||depthTest(depth.x,depth.y);
#else
bool keep=!isMaxDepth&&depthTest(depth.x,depth.y);
#endif
if(keep){gl_FragColor=texture2D(inputBuffer,vUv);}else{discard;}}`, DepthMaskMaterial = class extends ShaderMaterial { constructor() { super({ name: "DepthMaskMaterial", defines: { DEPTH_EPSILON: "0.0001", DEPTH_PACKING_0: "0", DEPTH_PACKING_1: "0", DEPTH_TEST_STRATEGY: DepthTestStrategy.KEEP_MAX_DEPTH }, uniforms: { inputBuffer: new Uniform(null), depthBuffer0: new Uniform(null), depthBuffer1: new Uniform(null), cameraNearFar: new Uniform(new Vector2(1, 1)) }, blending: NoBlending, toneMapped: !1, depthWrite: !1, depthTest: !1, fragmentShader: depth_mask_default, vertexShader: common_default }), this.depthMode = LessDepth } set depthBuffer0(r) { this.uniforms.depthBuffer0.value = r } set depthPacking0(r) { this.defines.DEPTH_PACKING_0 = r.toFixed(0), this.needsUpdate = !0 } setDepthBuffer0(r, e = BasicDepthPacking) { this.depthBuffer0 = r, this.depthPacking0 = e } set depthBuffer1(r) { this.uniforms.depthBuffer1.value = r } set depthPacking1(r) { this.defines.DEPTH_PACKING_1 = r.toFixed(0), this.needsUpdate = !0 } setDepthBuffer1(r, e = BasicDepthPacking) { this.depthBuffer1 = r, this.depthPacking1 = e } get maxDepthStrategy() { return Number(this.defines.DEPTH_TEST_STRATEGY) } set maxDepthStrategy(r) { this.defines.DEPTH_TEST_STRATEGY = r.toFixed(0), this.needsUpdate = !0 } get keepFar() { return this.maxDepthStrategy } set keepFar(r) { this.maxDepthStrategy = r ? DepthTestStrategy.KEEP_MAX_DEPTH : DepthTestStrategy.DISCARD_MAX_DEPTH } getMaxDepthStrategy() { return this.maxDepthStrategy } setMaxDepthStrategy(r) { this.maxDepthStrategy = r } get epsilon() { return Number(this.defines.DEPTH_EPSILON) } set epsilon(r) { this.defines.DEPTH_EPSILON = r.toFixed(16), this.needsUpdate = !0 } getEpsilon() { return this.epsilon } setEpsilon(r) { this.epsilon = r } get depthMode() { return Number(this.defines.DEPTH_MODE) } set depthMode(r) { let e; switch (r) { case NeverDepth: e = "false"; break; case AlwaysDepth: e = "true"; break; case EqualDepth: e = "abs(d1 - d0) <= DEPTH_EPSILON"; break; case NotEqualDepth: e = "abs(d1 - d0) > DEPTH_EPSILON"; break; case LessDepth: e = "d0 > d1"; break; case LessEqualDepth: e = "d0 >= d1"; break; case GreaterEqualDepth: e = "d0 <= d1"; break; case GreaterDepth: default: e = "d0 < d1"; break }this.defines.DEPTH_MODE = r.toFixed(0), this.defines["depthTest(d0, d1)"] = e, this.needsUpdate = !0 } getDepthMode() { return this.depthMode } setDepthMode(r) { this.depthMode = r } adoptCameraSettings(r) { this.copyCameraSettings(r) } copyCameraSettings(r) { r && (this.uniforms.cameraNearFar.value.set(r.near, r.far), r instanceof PerspectiveCamera ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA, this.needsUpdate = !0) } }, convolution_god_rays_default = `#include <common>
#include <dithering_pars_fragment>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform vec2 lightPosition;uniform float exposure;uniform float decay;uniform float density;uniform float weight;uniform float clampMax;varying vec2 vUv;void main(){vec2 coord=vUv;vec2 delta=lightPosition-coord;delta*=1.0/SAMPLES_FLOAT*density;float illuminationDecay=1.0;vec4 color=vec4(0.0);for(int i=0;i<SAMPLES_INT;++i){coord+=delta;vec4 texel=texture2D(inputBuffer,coord);texel*=illuminationDecay*weight;color+=texel;illuminationDecay*=decay;}gl_FragColor=clamp(color*exposure,0.0,clampMax);
#include <dithering_fragment>
}`, GodRaysMaterial = class extends ShaderMaterial { constructor(r) { super({ name: "GodRaysMaterial", defines: { SAMPLES_INT: "60", SAMPLES_FLOAT: "60.0" }, uniforms: { inputBuffer: new Uniform(null), lightPosition: new Uniform(r), density: new Uniform(1), decay: new Uniform(1), weight: new Uniform(1), exposure: new Uniform(1), clampMax: new Uniform(1) }, blending: NoBlending, toneMapped: !1, depthWrite: !1, depthTest: !1, fragmentShader: convolution_god_rays_default, vertexShader: common_default }) } set inputBuffer(r) { this.uniforms.inputBuffer.value = r } setInputBuffer(r) { this.uniforms.inputBuffer.value = r } get lightPosition() { return this.uniforms.lightPosition.value } getLightPosition() { return this.uniforms.lightPosition.value } setLightPosition(r) { this.uniforms.lightPosition.value = r } get density() { return this.uniforms.density.value } set density(r) { this.uniforms.density.value = r } getDensity() { return this.uniforms.density.value } setDensity(r) { this.uniforms.density.value = r } get decay() { return this.uniforms.decay.value } set decay(r) { this.uniforms.decay.value = r } getDecay() { return this.uniforms.decay.value } setDecay(r) { this.uniforms.decay.value = r } get weight() { return this.uniforms.weight.value } set weight(r) { this.uniforms.weight.value = r } getWeight() { return this.uniforms.weight.value } setWeight(r) { this.uniforms.weight.value = r } get exposure() { return this.uniforms.exposure.value } set exposure(r) { this.uniforms.exposure.value = r } getExposure() { return this.uniforms.exposure.value } setExposure(r) { this.uniforms.exposure.value = r } get maxIntensity() { return this.uniforms.clampMax.value } set maxIntensity(r) { this.uniforms.clampMax.value = r } getMaxIntensity() { return this.uniforms.clampMax.value } setMaxIntensity(r) { this.uniforms.clampMax.value = r } get samples() { return Number(this.defines.SAMPLES_INT) } set samples(r) { const e = Math.floor(r); this.defines.SAMPLES_INT = e.toFixed(0), this.defines.SAMPLES_FLOAT = e.toFixed(1), this.needsUpdate = !0 } getSamples() { return this.samples } setSamples(r) { this.samples = r } }, RenderPass = class extends Pass { constructor(r, e, i = null) { super("RenderPass", r, e), this.needsSwap = !1, this.clearPass = new ClearPass, this.overrideMaterialManager = i === null ? null : new OverrideMaterialManager(i), this.ignoreBackground = !1, this.skipShadowMapUpdate = !1, this.selection = null } set mainScene(r) { this.scene = r } set mainCamera(r) { this.camera = r } get renderToScreen() { return super.renderToScreen } set renderToScreen(r) { super.renderToScreen = r, this.clearPass.renderToScreen = r } get overrideMaterial() { const r = this.overrideMaterialManager; return r !== null ? r.material : null } set overrideMaterial(r) { const e = this.overrideMaterialManager; r !== null ? e !== null ? e.setMaterial(r) : this.overrideMaterialManager = new OverrideMaterialManager(r) : e !== null && (e.dispose(), this.overrideMaterialManager = null) } getOverrideMaterial() { return this.overrideMaterial } setOverrideMaterial(r) { this.overrideMaterial = r } get clear() { return this.clearPass.enabled } set clear(r) { this.clearPass.enabled = r } getSelection() { return this.selection } setSelection(r) { this.selection = r } isBackgroundDisabled() { return this.ignoreBackground } setBackgroundDisabled(r) { this.ignoreBackground = r } isShadowMapDisabled() { return this.skipShadowMapUpdate } setShadowMapDisabled(r) { this.skipShadowMapUpdate = r } getClearPass() { return this.clearPass } render(r, e, i, s, a) { const o = this.scene, l = this.camera, c = this.selection, h = l.layers.mask, d = o.background, p = r.shadowMap.autoUpdate, f = this.renderToScreen ? null : e; c !== null && l.layers.set(c.getLayer()), this.skipShadowMapUpdate && (r.shadowMap.autoUpdate = !1), (this.ignoreBackground || this.clearPass.overrideClearColor !== null) && (o.background = null), this.clearPass.enabled && this.clearPass.render(r, e), r.setRenderTarget(f), this.overrideMaterialManager !== null ? this.overrideMaterialManager.render(r, o, l) : r.render(o, l), l.layers.mask = h, o.background = d, r.shadowMap.autoUpdate = p } }, god_rays_default = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D map;
#else
uniform lowp sampler2D map;
#endif
void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=texture2D(map,uv);}`, v = new Vector3, m = new Matrix4, GodRaysEffect = class extends Effect { constructor(r, e, { blendFunction: i = BlendFunction.SCREEN, samples: s = 60, density: a = .96, decay: o = .9, weight: l = .4, exposure: c = .6, clampMax: h = 1, blur: d = !0, kernelSize: p = KernelSize.SMALL, resolutionScale: f = .5, width: _ = Resolution.AUTO_SIZE, height: x = Resolution.AUTO_SIZE, resolutionX: b = _, resolutionY: T = x } = {}) { super("GodRaysEffect", god_rays_default, { blendFunction: i, attributes: EffectAttribute.DEPTH, uniforms: new Map([["map", new Uniform(null)]]) }), this.camera = r, this._lightSource = e, this.lightSource = e, this.lightScene = new Scene, this.screenPosition = new Vector2, this.renderTargetA = new WebGLRenderTarget(1, 1, { depthBuffer: !1 }), this.renderTargetA.texture.name = "GodRays.Target.A", this.renderTargetB = this.renderTargetA.clone(), this.renderTargetB.texture.name = "GodRays.Target.B", this.uniforms.get("map").value = this.renderTargetB.texture, this.renderTargetLight = new WebGLRenderTarget(1, 1), this.renderTargetLight.texture.name = "GodRays.Light", this.renderTargetLight.depthTexture = new DepthTexture, this.renderPassLight = new RenderPass(this.lightScene, r), this.renderPassLight.clearPass.overrideClearColor = new Color(0), this.clearPass = new ClearPass(!0, !1, !1), this.clearPass.overrideClearColor = new Color(0), this.blurPass = new KawaseBlurPass({ kernelSize: p }), this.blurPass.enabled = d, this.depthMaskPass = new ShaderPass(new DepthMaskMaterial); const M = this.depthMaskMaterial; M.depthBuffer1 = this.renderTargetLight.depthTexture, M.copyCameraSettings(r), this.godRaysPass = new ShaderPass(new GodRaysMaterial(this.screenPosition)); const w = this.godRaysMaterial; w.density = a, w.decay = o, w.weight = l, w.exposure = c, w.maxIntensity = h, w.samples = s; const D = this.resolution = new Resolution(this, b, T, f); D.addEventListener("change", R => this.setSize(D.baseWidth, D.baseHeight)) } set mainCamera(r) { this.camera = r, this.renderPassLight.mainCamera = r, this.depthMaskMaterial.copyCameraSettings(r) } get lightSource() { return this._lightSource } set lightSource(r) { this._lightSource = r, r !== null && (r.material.depthWrite = !1, r.material.transparent = !0) } getBlurPass() { return this.blurPass } get texture() { return this.renderTargetB.texture } getTexture() { return this.texture } get depthMaskMaterial() { return this.depthMaskPass.fullscreenMaterial } get godRaysMaterial() { return this.godRaysPass.fullscreenMaterial } getGodRaysMaterial() { return this.godRaysMaterial } getResolution() { return this.resolution } get width() { return this.resolution.width } set width(r) { this.resolution.preferredWidth = r } get height() { return this.resolution.height } set height(r) { this.resolution.preferredHeight = r } get dithering() { return this.godRaysMaterial.dithering } set dithering(r) { const e = this.godRaysMaterial; e.dithering = r, e.needsUpdate = !0 } get blur() { return this.blurPass.enabled } set blur(r) { this.blurPass.enabled = r } get kernelSize() { return this.blurPass.kernelSize } set kernelSize(r) { this.blurPass.kernelSize = r } getResolutionScale() { return this.resolution.scale } setResolutionScale(r) { this.resolution.scale = r } get samples() { return this.godRaysMaterial.samples } set samples(r) { this.godRaysMaterial.samples = r } setDepthTexture(r, e = BasicDepthPacking) { this.depthMaskPass.fullscreenMaterial.depthBuffer0 = r, this.depthMaskPass.fullscreenMaterial.depthPacking0 = e } update(r, e, i) { const s = this.lightSource, a = s.parent, o = s.matrixAutoUpdate, l = this.renderTargetA, c = this.renderTargetLight; s.material.depthWrite = !0, s.matrixAutoUpdate = !1, s.updateWorldMatrix(!0, !1), a !== null && (o || m.copy(s.matrix), s.matrix.copy(s.matrixWorld)), this.lightScene.add(s), this.renderPassLight.render(r, c), this.clearPass.render(r, l), this.depthMaskPass.render(r, c, l), s.material.depthWrite = !1, s.matrixAutoUpdate = o, a !== null && (o || s.matrix.copy(m), a.add(s)), v.setFromMatrixPosition(s.matrixWorld).project(this.camera), this.screenPosition.set(Math.min(Math.max((v.x + 1) * .5, -1), 2), Math.min(Math.max((v.y + 1) * .5, -1), 2)), this.blurPass.enabled && this.blurPass.render(r, l, l), this.godRaysPass.render(r, l, this.renderTargetB) } setSize(r, e) { const i = this.resolution; i.setBaseSize(r, e); const s = i.width, a = i.height; this.renderTargetA.setSize(s, a), this.renderTargetB.setSize(s, a), this.renderTargetLight.setSize(s, a), this.blurPass.resolution.copy(i) } initialize(r, e, i) { this.blurPass.initialize(r, e, i), this.renderPassLight.initialize(r, e, i), this.depthMaskPass.initialize(r, e, i), this.godRaysPass.initialize(r, e, i), i !== void 0 && (this.renderTargetA.texture.type = i, this.renderTargetB.texture.type = i, this.renderTargetLight.texture.type = i, r !== null && r.outputColorSpace === SRGBColorSpace && (this.renderTargetA.texture.colorSpace = SRGBColorSpace, this.renderTargetB.texture.colorSpace = SRGBColorSpace, this.renderTargetLight.texture.colorSpace = SRGBColorSpace)) } }, EdgeDetectionMode = { COLOR: 2 }, PredicationMode = { DISABLED: 0 }, SMAAPreset = { LOW: 0, MEDIUM: 1, HIGH: 2, ULTRA: 3 }, ToneMappingMode = { LINEAR: 0, REINHARD: 1, REINHARD2: 2, REINHARD2_ADAPTIVE: 3, OPTIMIZED_CINEON: 5, CINEON: 5, ACES_FILMIC: 6, AGX: 7, NEUTRAL: 8 }, DepthPass = class extends Pass { constructor(r, e, { renderTarget: i, resolutionScale: s = 1, width: a = Resolution.AUTO_SIZE, height: o = Resolution.AUTO_SIZE, resolutionX: l = a, resolutionY: c = o } = {}) { super("DepthPass"), this.needsSwap = !1, this.renderPass = new RenderPass(r, e, new MeshDepthMaterial({ depthPacking: RGBADepthPacking })); const h = this.renderPass; h.skipShadowMapUpdate = !0, h.ignoreBackground = !0; const d = h.clearPass; d.overrideClearColor = new Color(16777215), d.overrideClearAlpha = 1, this.renderTarget = i, this.renderTarget === void 0 && (this.renderTarget = new WebGLRenderTarget(1, 1, { minFilter: NearestFilter, magFilter: NearestFilter }), this.renderTarget.texture.name = "DepthPass.Target"); const p = this.resolution = new Resolution(this, l, c, s); p.addEventListener("change", f => this.setSize(p.baseWidth, p.baseHeight)) } set mainScene(r) { this.renderPass.mainScene = r } set mainCamera(r) { this.renderPass.mainCamera = r } get texture() { return this.renderTarget.texture } getTexture() { return this.renderTarget.texture } getResolution() { return this.resolution } getResolutionScale() { return this.resolution.scale } setResolutionScale(r) { this.resolution.scale = r } render(r, e, i, s, a) { const o = this.renderToScreen ? null : this.renderTarget; this.renderPass.render(r, o) } setSize(r, e) { const i = this.resolution; i.setBaseSize(r, e), this.renderTarget.setSize(i.width, i.height) } }, SelectiveBloomEffect = class extends BloomEffect { constructor(r, e, i) { super(i), this.setAttributes(this.getAttributes() | EffectAttribute.DEPTH), this.camera = e, this.depthPass = new DepthPass(r, e), this.clearPass = new ClearPass(!0, !1, !1), this.clearPass.overrideClearColor = new Color(0), this.depthMaskPass = new ShaderPass(new DepthMaskMaterial); const s = this.depthMaskMaterial; s.copyCameraSettings(e), s.depthBuffer1 = this.depthPass.texture, s.depthPacking1 = RGBADepthPacking, s.depthMode = EqualDepth, this.renderTargetMasked = new WebGLRenderTarget(1, 1, { depthBuffer: !1 }), this.renderTargetMasked.texture.name = "Bloom.Masked", this.selection = new Selection, this._inverted = !1, this._ignoreBackground = !1 } set mainScene(r) { this.depthPass.mainScene = r } set mainCamera(r) { this.camera = r, this.depthPass.mainCamera = r, this.depthMaskMaterial.copyCameraSettings(r) } getSelection() { return this.selection } get depthMaskMaterial() { return this.depthMaskPass.fullscreenMaterial } get inverted() { return this._inverted } set inverted(r) { this._inverted = r, this.depthMaskMaterial.depthMode = r ? NotEqualDepth : EqualDepth } isInverted() { return this.inverted } setInverted(r) { this.inverted = r } get ignoreBackground() { return this._ignoreBackground } set ignoreBackground(r) { this._ignoreBackground = r, this.depthMaskMaterial.maxDepthStrategy = r ? DepthTestStrategy.DISCARD_MAX_DEPTH : DepthTestStrategy.KEEP_MAX_DEPTH } isBackgroundDisabled() { return this.ignoreBackground } setBackgroundDisabled(r) { this.ignoreBackground = r } setDepthTexture(r, e = BasicDepthPacking) { this.depthMaskMaterial.depthBuffer0 = r, this.depthMaskMaterial.depthPacking0 = e } update(r, e, i) { const s = this.camera, a = this.selection, o = this.inverted; let l = e; if (this.ignoreBackground || !o || a.size > 0) { const c = s.layers.mask; s.layers.set(a.layer), this.depthPass.render(r), s.layers.mask = c, l = this.renderTargetMasked, this.clearPass.render(r, l), this.depthMaskPass.render(r, e, l) } super.update(r, l, i) } setSize(r, e) { super.setSize(r, e), this.renderTargetMasked.setSize(r, e), this.depthPass.setSize(r, e) } initialize(r, e, i) { super.initialize(r, e, i), this.clearPass.initialize(r, e, i), this.depthPass.initialize(r, e, i), this.depthMaskPass.initialize(r, e, i), r !== null && r.capabilities.logarithmicDepthBuffer && (this.depthMaskPass.fullscreenMaterial.defines.LOG_DEPTH = "1"), i !== void 0 && (this.renderTargetMasked.texture.type = i, r !== null && r.outputColorSpace === SRGBColorSpace && (this.renderTargetMasked.texture.colorSpace = SRGBColorSpace)) } }, edge_detection_default = `varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;
#if EDGE_DETECTION_MODE != 0
varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;
#endif
#if EDGE_DETECTION_MODE == 1
#include <common>
#endif
#if EDGE_DETECTION_MODE == 0 || PREDICATION_MODE == 1
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}vec3 gatherNeighbors(){float p=readDepth(vUv);float pLeft=readDepth(vUv0);float pTop=readDepth(vUv1);return vec3(p,pLeft,pTop);}
#elif PREDICATION_MODE == 2
uniform sampler2D predicationBuffer;vec3 gatherNeighbors(){float p=texture2D(predicationBuffer,vUv).r;float pLeft=texture2D(predicationBuffer,vUv0).r;float pTop=texture2D(predicationBuffer,vUv1).r;return vec3(p,pLeft,pTop);}
#endif
#if PREDICATION_MODE != 0
vec2 calculatePredicatedThreshold(){vec3 neighbours=gatherNeighbors();vec2 delta=abs(neighbours.xx-neighbours.yz);vec2 edges=step(PREDICATION_THRESHOLD,delta);return PREDICATION_SCALE*EDGE_THRESHOLD*(1.0-PREDICATION_STRENGTH*edges);}
#endif
#if EDGE_DETECTION_MODE != 0
uniform sampler2D inputBuffer;
#endif
void main(){
#if EDGE_DETECTION_MODE == 0
const vec2 threshold=vec2(DEPTH_THRESHOLD);
#elif PREDICATION_MODE != 0
vec2 threshold=calculatePredicatedThreshold();
#else
const vec2 threshold=vec2(EDGE_THRESHOLD);
#endif
#if EDGE_DETECTION_MODE == 0
vec3 neighbors=gatherNeighbors();vec2 delta=abs(neighbors.xx-vec2(neighbors.y,neighbors.z));vec2 edges=step(threshold,delta);if(dot(edges,vec2(1.0))==0.0){discard;}gl_FragColor=vec4(edges,0.0,1.0);
#elif EDGE_DETECTION_MODE == 1
float l=luminance(texture2D(inputBuffer,vUv).rgb);float lLeft=luminance(texture2D(inputBuffer,vUv0).rgb);float lTop=luminance(texture2D(inputBuffer,vUv1).rgb);vec4 delta;delta.xy=abs(l-vec2(lLeft,lTop));vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}float lRight=luminance(texture2D(inputBuffer,vUv2).rgb);float lBottom=luminance(texture2D(inputBuffer,vUv3).rgb);delta.zw=abs(l-vec2(lRight,lBottom));vec2 maxDelta=max(delta.xy,delta.zw);float lLeftLeft=luminance(texture2D(inputBuffer,vUv4).rgb);float lTopTop=luminance(texture2D(inputBuffer,vUv5).rgb);delta.zw=abs(vec2(lLeft,lTop)-vec2(lLeftLeft,lTopTop));maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges.xy*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);
#elif EDGE_DETECTION_MODE == 2
vec4 delta;vec3 c=texture2D(inputBuffer,vUv).rgb;vec3 cLeft=texture2D(inputBuffer,vUv0).rgb;vec3 t=abs(c-cLeft);delta.x=max(max(t.r,t.g),t.b);vec3 cTop=texture2D(inputBuffer,vUv1).rgb;t=abs(c-cTop);delta.y=max(max(t.r,t.g),t.b);vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}vec3 cRight=texture2D(inputBuffer,vUv2).rgb;t=abs(c-cRight);delta.z=max(max(t.r,t.g),t.b);vec3 cBottom=texture2D(inputBuffer,vUv3).rgb;t=abs(c-cBottom);delta.w=max(max(t.r,t.g),t.b);vec2 maxDelta=max(delta.xy,delta.zw);vec3 cLeftLeft=texture2D(inputBuffer,vUv4).rgb;t=abs(c-cLeftLeft);delta.z=max(max(t.r,t.g),t.b);vec3 cTopTop=texture2D(inputBuffer,vUv5).rgb;t=abs(c-cTopTop);delta.w=max(max(t.r,t.g),t.b);maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);
#endif
}`, edge_detection_default2 = `uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;
#if EDGE_DETECTION_MODE != 0
varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;
#endif
void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,0.0);vUv1=vUv+texelSize*vec2(0.0,-1.0);
#if EDGE_DETECTION_MODE != 0
vUv2=vUv+texelSize*vec2(1.0,0.0);vUv3=vUv+texelSize*vec2(0.0,1.0);vUv4=vUv+texelSize*vec2(-2.0,0.0);vUv5=vUv+texelSize*vec2(0.0,-2.0);
#endif
gl_Position=vec4(position.xy,1.0,1.0);}`, EdgeDetectionMaterial = class extends ShaderMaterial { constructor(r = new Vector2, e = EdgeDetectionMode.COLOR) { super({ name: "EdgeDetectionMaterial", defines: { THREE_REVISION: REVISION.replace(/\D+/g, ""), LOCAL_CONTRAST_ADAPTATION_FACTOR: "2.0", EDGE_THRESHOLD: "0.1", DEPTH_THRESHOLD: "0.01", PREDICATION_MODE: "0", PREDICATION_THRESHOLD: "0.01", PREDICATION_SCALE: "2.0", PREDICATION_STRENGTH: "1.0", DEPTH_PACKING: "0" }, uniforms: { inputBuffer: new Uniform(null), depthBuffer: new Uniform(null), predicationBuffer: new Uniform(null), texelSize: new Uniform(r) }, blending: NoBlending, toneMapped: !1, depthWrite: !1, depthTest: !1, fragmentShader: edge_detection_default, vertexShader: edge_detection_default2 }), this.edgeDetectionMode = e } set depthBuffer(r) { this.uniforms.depthBuffer.value = r } set depthPacking(r) { this.defines.DEPTH_PACKING = r.toFixed(0), this.needsUpdate = !0 } setDepthBuffer(r, e = BasicDepthPacking) { this.depthBuffer = r, this.depthPacking = e } get edgeDetectionMode() { return Number(this.defines.EDGE_DETECTION_MODE) } set edgeDetectionMode(r) { this.defines.EDGE_DETECTION_MODE = r.toFixed(0), this.needsUpdate = !0 } getEdgeDetectionMode() { return this.edgeDetectionMode } setEdgeDetectionMode(r) { this.edgeDetectionMode = r } get localContrastAdaptationFactor() { return Number(this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR) } set localContrastAdaptationFactor(r) { this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR = r.toFixed("6"), this.needsUpdate = !0 } getLocalContrastAdaptationFactor() { return this.localContrastAdaptationFactor } setLocalContrastAdaptationFactor(r) { this.localContrastAdaptationFactor = r } get edgeDetectionThreshold() { return Number(this.defines.EDGE_THRESHOLD) } set edgeDetectionThreshold(r) { this.defines.EDGE_THRESHOLD = r.toFixed("6"), this.defines.DEPTH_THRESHOLD = (r * .1).toFixed("6"), this.needsUpdate = !0 } getEdgeDetectionThreshold() { return this.edgeDetectionThreshold } setEdgeDetectionThreshold(r) { this.edgeDetectionThreshold = r } get predicationMode() { return Number(this.defines.PREDICATION_MODE) } set predicationMode(r) { this.defines.PREDICATION_MODE = r.toFixed(0), this.needsUpdate = !0 } getPredicationMode() { return this.predicationMode } setPredicationMode(r) { this.predicationMode = r } set predicationBuffer(r) { this.uniforms.predicationBuffer.value = r } setPredicationBuffer(r) { this.uniforms.predicationBuffer.value = r } get predicationThreshold() { return Number(this.defines.PREDICATION_THRESHOLD) } set predicationThreshold(r) { this.defines.PREDICATION_THRESHOLD = r.toFixed("6"), this.needsUpdate = !0 } getPredicationThreshold() { return this.predicationThreshold } setPredicationThreshold(r) { this.predicationThreshold = r } get predicationScale() { return Number(this.defines.PREDICATION_SCALE) } set predicationScale(r) { this.defines.PREDICATION_SCALE = r.toFixed("6"), this.needsUpdate = !0 } getPredicationScale() { return this.predicationScale } setPredicationScale(r) { this.predicationScale = r } get predicationStrength() { return Number(this.defines.PREDICATION_STRENGTH) } set predicationStrength(r) { this.defines.PREDICATION_STRENGTH = r.toFixed("6"), this.needsUpdate = !0 } getPredicationStrength() { return this.predicationStrength } setPredicationStrength(r) { this.predicationStrength = r } setSize(r, e) { this.uniforms.texelSize.value.set(1 / r, 1 / e) } }, smaa_weights_default = `#define sampleLevelZeroOffset(t, coord, offset) texture2D(t, coord + offset * texelSize)
#if __VERSION__ < 300
#define round(v) floor(v + 0.5)
#endif
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform lowp sampler2D areaTexture;uniform lowp sampler2D searchTexture;uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}vec2 decodeDiagBilinearAccess(in vec2 e){e.r=e.r*abs(5.0*e.r-5.0*0.75);return round(e);}vec4 decodeDiagBilinearAccess(in vec4 e){e.rb=e.rb*abs(5.0*e.rb-5.0*0.75);return round(e);}vec2 searchDiag1(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 searchDiag2(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);coord.x+=0.25*texelSize.x;vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;e=decodeDiagBilinearAccess(e);coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 areaDiag(const in vec2 dist,const in vec2 e,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE_DIAG,AREATEX_MAX_DISTANCE_DIAG)*e+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.x+=0.5;texCoord.y+=AREATEX_SUBTEX_SIZE*offset;return texture2D(areaTexture,texCoord).rg;}vec2 calculateDiagWeights(const in vec2 texCoord,const in vec2 e,const in vec4 subsampleIndices){vec2 weights=vec2(0.0);vec4 d;vec2 end;if(e.r>0.0){d.xz=searchDiag1(texCoord,vec2(-1.0,1.0),end);d.x+=float(end.y>0.9);}else{d.xz=vec2(0.0);}d.yw=searchDiag1(texCoord,vec2(1.0,-1.0),end);if(d.x+d.y>2.0){vec4 coords=vec4(-d.x+0.25,d.x,d.y,-d.y-0.25)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.xy=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).rg;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).rg;c.yxwz=decodeDiagBilinearAccess(c.xyzw);vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.z);}d.xz=searchDiag2(texCoord,vec2(-1.0,-1.0),end);if(sampleLevelZeroOffset(inputBuffer,texCoord,vec2(1,0)).r>0.0){d.yw=searchDiag2(texCoord,vec2(1.0),end);d.y+=float(end.y>0.9);}else{d.yw=vec2(0.0);}if(d.x+d.y>2.0){vec4 coords=vec4(-d.x,-d.x,d.y,d.y)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.x=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).g;c.y=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(0,-1)).r;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).gr;vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.w).gr;}return weights;}float searchLength(const in vec2 e,const in float offset){vec2 scale=SEARCHTEX_SIZE*vec2(0.5,-1.0);vec2 bias=SEARCHTEX_SIZE*vec2(offset,1.0);scale+=vec2(-1.0,1.0);bias+=vec2(0.5,-0.5);scale*=1.0/SEARCHTEX_PACKED_SIZE;bias*=1.0/SEARCHTEX_PACKED_SIZE;return texture2D(searchTexture,scale*e+bias).r;}float searchXLeft(in vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x>end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(-2.0,0.0)*texelSize+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.0)+3.25;return texelSize.x*offset+texCoord.x;}float searchXRight(vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x<end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(2.0,0.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.5)+3.25;return-texelSize.x*offset+texCoord.x;}float searchYUp(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.y>end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=-vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.0)+3.25;return texelSize.y*offset+texCoord.y;}float searchYDown(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;i++){if(!(texCoord.y<end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.5)+3.25;return-texelSize.y*offset+texCoord.y;}vec2 area(const in vec2 dist,const in float e1,const in float e2,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE)*round(4.0*vec2(e1,e2))+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.y=AREATEX_SUBTEX_SIZE*offset+texCoord.y;return texture2D(areaTexture,texCoord).rg;}void detectHorizontalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){
#if !defined(DISABLE_CORNER_DETECTION)
vec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,1)).r;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).r;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,-2)).r;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,-2)).r;weights*=clamp(factor,0.0,1.0);
#endif
}void detectVerticalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){
#if !defined(DISABLE_CORNER_DETECTION)
vec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(1,0)).g;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).g;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(-2,0)).g;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(-2,1)).g;weights*=clamp(factor,0.0,1.0);
#endif
}void main(){vec4 weights=vec4(0.0);vec4 subsampleIndices=vec4(0.0);vec2 e=texture2D(inputBuffer,vUv).rg;if(e.g>0.0){
#if !defined(DISABLE_DIAG_DETECTION)
weights.rg=calculateDiagWeights(vUv,e,subsampleIndices);if(weights.r==-weights.g){
#endif
vec2 d;vec3 coords;coords.x=searchXLeft(vOffset[0].xy,vOffset[2].x);coords.y=vOffset[1].y;d.x=coords.x;float e1=texture2D(inputBuffer,coords.xy).r;coords.z=searchXRight(vOffset[0].zw,vOffset[2].y);d.y=coords.z;d=round(resolution.xx*d+-vPixCoord.xx);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.zy,vec2(1,0)).r;weights.rg=area(sqrtD,e1,e2,subsampleIndices.y);coords.y=vUv.y;detectHorizontalCornerPattern(weights.rg,coords.xyzy,d);
#if !defined(DISABLE_DIAG_DETECTION)
}else{e.r=0.0;}
#endif
}if(e.r>0.0){vec2 d;vec3 coords;coords.y=searchYUp(vOffset[1].xy,vOffset[2].z);coords.x=vOffset[0].x;d.x=coords.y;float e1=texture2D(inputBuffer,coords.xy).g;coords.z=searchYDown(vOffset[1].zw,vOffset[2].w);d.y=coords.z;d=round(resolution.yy*d-vPixCoord.yy);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.xz,vec2(0,1)).g;weights.ba=area(sqrtD,e1,e2,subsampleIndices.x);coords.x=vUv.x;detectVerticalCornerPattern(weights.ba,coords.xyxz,d);}gl_FragColor=weights;}`, smaa_weights_default2 = "uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void main(){vUv=position.xy*0.5+0.5;vPixCoord=vUv*resolution;vOffset[0]=vUv.xyxy+texelSize.xyxy*vec4(-0.25,-0.125,1.25,-0.125);vOffset[1]=vUv.xyxy+texelSize.xyxy*vec4(-0.125,-0.25,-0.125,1.25);vOffset[2]=vec4(vOffset[0].xz,vOffset[1].yw)+vec4(-2.0,2.0,-2.0,2.0)*texelSize.xxyy*MAX_SEARCH_STEPS_FLOAT;gl_Position=vec4(position.xy,1.0,1.0);}", SMAAWeightsMaterial = class extends ShaderMaterial { constructor(r = new Vector2, e = new Vector2) { super({ name: "SMAAWeightsMaterial", defines: { MAX_SEARCH_STEPS_INT: "16", MAX_SEARCH_STEPS_FLOAT: "16.0", MAX_SEARCH_STEPS_DIAG_INT: "8", MAX_SEARCH_STEPS_DIAG_FLOAT: "8.0", CORNER_ROUNDING: "25", CORNER_ROUNDING_NORM: "0.25", AREATEX_MAX_DISTANCE: "16.0", AREATEX_MAX_DISTANCE_DIAG: "20.0", AREATEX_PIXEL_SIZE: "(1.0 / vec2(160.0, 560.0))", AREATEX_SUBTEX_SIZE: "(1.0 / 7.0)", SEARCHTEX_SIZE: "vec2(66.0, 33.0)", SEARCHTEX_PACKED_SIZE: "vec2(64.0, 16.0)" }, uniforms: { inputBuffer: new Uniform(null), searchTexture: new Uniform(null), areaTexture: new Uniform(null), resolution: new Uniform(e), texelSize: new Uniform(r) }, blending: NoBlending, toneMapped: !1, depthWrite: !1, depthTest: !1, fragmentShader: smaa_weights_default, vertexShader: smaa_weights_default2 }) } set inputBuffer(r) { this.uniforms.inputBuffer.value = r } setInputBuffer(r) { this.uniforms.inputBuffer.value = r } get searchTexture() { return this.uniforms.searchTexture.value } set searchTexture(r) { this.uniforms.searchTexture.value = r } get areaTexture() { return this.uniforms.areaTexture.value } set areaTexture(r) { this.uniforms.areaTexture.value = r } setLookupTextures(r, e) { this.searchTexture = r, this.areaTexture = e } get orthogonalSearchSteps() { return Number(this.defines.MAX_SEARCH_STEPS_INT) } set orthogonalSearchSteps(r) { const e = Math.min(Math.max(r, 0), 112); this.defines.MAX_SEARCH_STEPS_INT = e.toFixed("0"), this.defines.MAX_SEARCH_STEPS_FLOAT = e.toFixed("1"), this.needsUpdate = !0 } setOrthogonalSearchSteps(r) { this.orthogonalSearchSteps = r } get diagonalSearchSteps() { return Number(this.defines.MAX_SEARCH_STEPS_DIAG_INT) } set diagonalSearchSteps(r) { const e = Math.min(Math.max(r, 0), 20); this.defines.MAX_SEARCH_STEPS_DIAG_INT = e.toFixed("0"), this.defines.MAX_SEARCH_STEPS_DIAG_FLOAT = e.toFixed("1"), this.needsUpdate = !0 } setDiagonalSearchSteps(r) { this.diagonalSearchSteps = r } get diagonalDetection() { return this.defines.DISABLE_DIAG_DETECTION === void 0 } set diagonalDetection(r) { r ? delete this.defines.DISABLE_DIAG_DETECTION : this.defines.DISABLE_DIAG_DETECTION = "1", this.needsUpdate = !0 } isDiagonalDetectionEnabled() { return this.diagonalDetection } setDiagonalDetectionEnabled(r) { this.diagonalDetection = r } get cornerRounding() { return Number(this.defines.CORNER_ROUNDING) } set cornerRounding(r) { const e = Math.min(Math.max(r, 0), 100); this.defines.CORNER_ROUNDING = e.toFixed("4"), this.defines.CORNER_ROUNDING_NORM = (e / 100).toFixed("4"), this.needsUpdate = !0 } setCornerRounding(r) { this.cornerRounding = r } get cornerDetection() { return this.defines.DISABLE_CORNER_DETECTION === void 0 } set cornerDetection(r) { r ? delete this.defines.DISABLE_CORNER_DETECTION : this.defines.DISABLE_CORNER_DETECTION = "1", this.needsUpdate = !0 } isCornerRoundingEnabled() { return this.cornerDetection } setCornerRoundingEnabled(r) { this.cornerDetection = r } setSize(r, e) { const i = this.uniforms; i.texelSize.value.set(1 / r, 1 / e), i.resolution.value.set(r, e) } }, searchImageDataURL_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAQCAYAAACm53kpAAAAeElEQVRYR+2XSwqAMAxEJ168ePEqwRSKhIIiuHjJqiU0gWE+1CQdApcVAMUAuARaMGCX1MIL/Ow13++9lW2s3mW9MWvsnWc/2fvGygwPAN4E8QzAA4CXAB6AHjG4JTHYI1ey3pcx6FHnEfhLDOIBKAmUBK6/ANUDTlROXAHd9EC1AAAAAElFTkSuQmCC", areaImageDataURL_default = "data:image/png;base64,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", smaa_default = "uniform sampler2D weightMap;varying vec2 vOffset0;varying vec2 vOffset1;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 a;a.x=texture2D(weightMap,vOffset0).a;a.y=texture2D(weightMap,vOffset1).g;a.wz=texture2D(weightMap,uv).rb;vec4 color=inputColor;if(dot(a,vec4(1.0))>=1e-5){bool h=max(a.x,a.z)>max(a.y,a.w);vec4 blendingOffset=vec4(0.0,a.y,0.0,a.w);vec2 blendingWeight=a.yw;movec(bvec4(h),blendingOffset,vec4(a.x,0.0,a.z,0.0));movec(bvec2(h),blendingWeight,a.xz);blendingWeight/=dot(blendingWeight,vec2(1.0));vec4 blendingCoord=blendingOffset*vec4(texelSize,-texelSize)+uv.xyxy;color=blendingWeight.x*texture2D(inputBuffer,blendingCoord.xy);color+=blendingWeight.y*texture2D(inputBuffer,blendingCoord.zw);}outputColor=color;}", smaa_default2 = "varying vec2 vOffset0;varying vec2 vOffset1;void mainSupport(const in vec2 uv){vOffset0=uv+texelSize*vec2(1.0,0.0);vOffset1=uv+texelSize*vec2(0.0,1.0);}", SMAAEffect = class extends Effect { constructor({ blendFunction: r = BlendFunction.SRC, preset: e = SMAAPreset.MEDIUM, edgeDetectionMode: i = EdgeDetectionMode.COLOR, predicationMode: s = PredicationMode.DISABLED } = {}) { super("SMAAEffect", smaa_default, { vertexShader: smaa_default2, blendFunction: r, attributes: EffectAttribute.CONVOLUTION | EffectAttribute.DEPTH, uniforms: new Map([["weightMap", new Uniform(null)]]) }); let a, o; arguments.length > 1 && (a = arguments[0], o = arguments[1], arguments.length > 2 && (e = arguments[2]), arguments.length > 3 && (i = arguments[3])), this.renderTargetEdges = new WebGLRenderTarget(1, 1, { depthBuffer: !1 }), this.renderTargetEdges.texture.name = "SMAA.Edges", this.renderTargetWeights = this.renderTargetEdges.clone(), this.renderTargetWeights.texture.name = "SMAA.Weights", this.uniforms.get("weightMap").value = this.renderTargetWeights.texture, this.clearPass = new ClearPass(!0, !1, !1), this.clearPass.overrideClearColor = new Color(0), this.clearPass.overrideClearAlpha = 1, this.edgeDetectionPass = new ShaderPass(new EdgeDetectionMaterial), this.edgeDetectionMaterial.edgeDetectionMode = i, this.edgeDetectionMaterial.predicationMode = s, this.weightsPass = new ShaderPass(new SMAAWeightsMaterial); const l = new LoadingManager; l.onLoad = () => { const c = new Texture(a); c.name = "SMAA.Search", c.magFilter = NearestFilter, c.minFilter = NearestFilter, c.generateMipmaps = !1, c.needsUpdate = !0, c.flipY = !0, this.weightsMaterial.searchTexture = c; const h = new Texture(o); h.name = "SMAA.Area", h.magFilter = LinearFilter, h.minFilter = LinearFilter, h.generateMipmaps = !1, h.needsUpdate = !0, h.flipY = !1, this.weightsMaterial.areaTexture = h, this.dispatchEvent({ type: "load" }) }, l.itemStart("search"), l.itemStart("area"), a !== void 0 && o !== void 0 ? (l.itemEnd("search"), l.itemEnd("area")) : typeof Image < "u" && (a = new Image, o = new Image, a.addEventListener("load", () => l.itemEnd("search")), o.addEventListener("load", () => l.itemEnd("area")), a.src = searchImageDataURL_default, o.src = areaImageDataURL_default), this.applyPreset(e) } get edgesTexture() { return this.renderTargetEdges.texture } getEdgesTexture() { return this.edgesTexture } get weightsTexture() { return this.renderTargetWeights.texture } getWeightsTexture() { return this.weightsTexture } get edgeDetectionMaterial() { return this.edgeDetectionPass.fullscreenMaterial } get colorEdgesMaterial() { return this.edgeDetectionMaterial } getEdgeDetectionMaterial() { return this.edgeDetectionMaterial } get weightsMaterial() { return this.weightsPass.fullscreenMaterial } getWeightsMaterial() { return this.weightsMaterial } setEdgeDetectionThreshold(r) { this.edgeDetectionMaterial.edgeDetectionThreshold = r } setOrthogonalSearchSteps(r) { this.weightsMaterial.orthogonalSearchSteps = r } applyPreset(r) { const e = this.edgeDetectionMaterial, i = this.weightsMaterial; switch (r) { case SMAAPreset.LOW: e.edgeDetectionThreshold = .15, i.orthogonalSearchSteps = 4, i.diagonalDetection = !1, i.cornerDetection = !1; break; case SMAAPreset.MEDIUM: e.edgeDetectionThreshold = .1, i.orthogonalSearchSteps = 8, i.diagonalDetection = !1, i.cornerDetection = !1; break; case SMAAPreset.HIGH: e.edgeDetectionThreshold = .1, i.orthogonalSearchSteps = 16, i.diagonalSearchSteps = 8, i.cornerRounding = 25, i.diagonalDetection = !0, i.cornerDetection = !0; break; case SMAAPreset.ULTRA: e.edgeDetectionThreshold = .05, i.orthogonalSearchSteps = 32, i.diagonalSearchSteps = 16, i.cornerRounding = 25, i.diagonalDetection = !0, i.cornerDetection = !0; break } } setDepthTexture(r, e = BasicDepthPacking) { this.edgeDetectionMaterial.depthBuffer = r, this.edgeDetectionMaterial.depthPacking = e } update(r, e, i) { this.clearPass.render(r, this.renderTargetEdges), this.edgeDetectionPass.render(r, e, this.renderTargetEdges), this.weightsPass.render(r, this.renderTargetEdges, this.renderTargetWeights) } setSize(r, e) { this.edgeDetectionMaterial.setSize(r, e), this.weightsMaterial.setSize(r, e), this.renderTargetEdges.setSize(r, e), this.renderTargetWeights.setSize(r, e) } dispose() { const { searchTexture: r, areaTexture: e } = this.weightsMaterial; r !== null && e !== null && (r.dispose(), e.dispose()), super.dispose() } static get searchImageDataURL() { return searchImageDataURL_default } static get areaImageDataURL() { return areaImageDataURL_default } }, adaptive_luminance_default = `#include <packing>
#define packFloatToRGBA(v) packDepthToRGBA(v)
#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)
uniform lowp sampler2D luminanceBuffer0;uniform lowp sampler2D luminanceBuffer1;uniform float minLuminance;uniform float deltaTime;uniform float tau;varying vec2 vUv;void main(){float l0=unpackRGBAToFloat(texture2D(luminanceBuffer0,vUv));
#if __VERSION__ < 300
float l1=texture2DLodEXT(luminanceBuffer1,vUv,MIP_LEVEL_1X1).r;
#else
float l1=textureLod(luminanceBuffer1,vUv,MIP_LEVEL_1X1).r;
#endif
l0=max(minLuminance,l0);l1=max(minLuminance,l1);float adaptedLum=l0+(l1-l0)*(1.0-exp(-deltaTime*tau));gl_FragColor=(adaptedLum==1.0)?vec4(1.0):packFloatToRGBA(adaptedLum);}`, AdaptiveLuminanceMaterial = class extends ShaderMaterial { constructor() { super({ name: "AdaptiveLuminanceMaterial", defines: { MIP_LEVEL_1X1: "0.0" }, uniforms: { luminanceBuffer0: new Uniform(null), luminanceBuffer1: new Uniform(null), minLuminance: new Uniform(.01), deltaTime: new Uniform(0), tau: new Uniform(1) }, extensions: { shaderTextureLOD: !0 }, blending: NoBlending, toneMapped: !1, depthWrite: !1, depthTest: !1, fragmentShader: adaptive_luminance_default, vertexShader: common_default }) } set luminanceBuffer0(r) { this.uniforms.luminanceBuffer0.value = r } setLuminanceBuffer0(r) { this.uniforms.luminanceBuffer0.value = r } set luminanceBuffer1(r) { this.uniforms.luminanceBuffer1.value = r } setLuminanceBuffer1(r) { this.uniforms.luminanceBuffer1.value = r } set mipLevel1x1(r) { this.defines.MIP_LEVEL_1X1 = r.toFixed(1), this.needsUpdate = !0 } setMipLevel1x1(r) { this.mipLevel1x1 = r } set deltaTime(r) { this.uniforms.deltaTime.value = r } setDeltaTime(r) { this.uniforms.deltaTime.value = r } get minLuminance() { return this.uniforms.minLuminance.value } set minLuminance(r) { this.uniforms.minLuminance.value = r } getMinLuminance() { return this.uniforms.minLuminance.value } setMinLuminance(r) { this.uniforms.minLuminance.value = r } get adaptationRate() { return this.uniforms.tau.value } set adaptationRate(r) { this.uniforms.tau.value = r } getAdaptationRate() { return this.uniforms.tau.value } setAdaptationRate(r) { this.uniforms.tau.value = r } }, AdaptiveLuminancePass = class extends Pass { constructor(r, { minLuminance: e = .01, adaptationRate: i = 1 } = {}) { super("AdaptiveLuminancePass"), this.fullscreenMaterial = new AdaptiveLuminanceMaterial, this.needsSwap = !1, this.renderTargetPrevious = new WebGLRenderTarget(1, 1, { minFilter: NearestFilter, magFilter: NearestFilter, depthBuffer: !1 }), this.renderTargetPrevious.texture.name = "Luminance.Previous"; const s = this.fullscreenMaterial; s.luminanceBuffer0 = this.renderTargetPrevious.texture, s.luminanceBuffer1 = r, s.minLuminance = e, s.adaptationRate = i, this.renderTargetAdapted = this.renderTargetPrevious.clone(), this.renderTargetAdapted.texture.name = "Luminance.Adapted", this.copyPass = new CopyPass(this.renderTargetPrevious, !1) } get texture() { return this.renderTargetAdapted.texture } getTexture() { return this.renderTargetAdapted.texture } set mipLevel1x1(r) { this.fullscreenMaterial.mipLevel1x1 = r } get adaptationRate() { return this.fullscreenMaterial.adaptationRate } set adaptationRate(r) { this.fullscreenMaterial.adaptationRate = r } render(r, e, i, s, a) { this.fullscreenMaterial.deltaTime = s, r.setRenderTarget(this.renderToScreen ? null : this.renderTargetAdapted), r.render(this.scene, this.camera), this.copyPass.render(r, this.renderTargetAdapted) } }, tone_mapping_default = `#include <tonemapping_pars_fragment>
uniform float whitePoint;
#if TONE_MAPPING_MODE == 2 || TONE_MAPPING_MODE == 3
uniform float middleGrey;
#if TONE_MAPPING_MODE == 3
uniform lowp sampler2D luminanceBuffer;
#else
uniform float averageLuminance;
#endif
vec3 Reinhard2ToneMapping(vec3 color){color*=toneMappingExposure;float l=luminance(color);
#if TONE_MAPPING_MODE == 3
float lumAvg=unpackRGBAToFloat(texture2D(luminanceBuffer,vec2(0.5)));
#else
float lumAvg=averageLuminance;
#endif
float lumScaled=(l*middleGrey)/max(lumAvg,1e-6);float lumCompressed=lumScaled*(1.0+lumScaled/(whitePoint*whitePoint));lumCompressed/=(1.0+lumScaled);return clamp(lumCompressed*color,0.0,1.0);}
#elif TONE_MAPPING_MODE == 4
#define A 0.15
#define B 0.50
#define C 0.10
#define D 0.20
#define E 0.02
#define F 0.30
vec3 Uncharted2Helper(const in vec3 x){return((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}vec3 Uncharted2ToneMapping(vec3 color){color*=toneMappingExposure;return clamp(Uncharted2Helper(color)/Uncharted2Helper(vec3(whitePoint)),0.0,1.0);}
#endif
void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){
#if TONE_MAPPING_MODE == 2 || TONE_MAPPING_MODE == 3
outputColor=vec4(Reinhard2ToneMapping(inputColor.rgb),inputColor.a);
#elif TONE_MAPPING_MODE == 4
outputColor=vec4(Uncharted2ToneMapping(inputColor.rgb),inputColor.a);
#else
outputColor=vec4(toneMapping(inputColor.rgb),inputColor.a);
#endif
}`, ToneMappingEffect = class extends Effect { constructor({ blendFunction: r = BlendFunction.SRC, adaptive: e = !1, mode: i = e ? ToneMappingMode.REINHARD2_ADAPTIVE : ToneMappingMode.AGX, resolution: s = 256, maxLuminance: a = 4, whitePoint: o = a, middleGrey: l = .6, minLuminance: c = .01, averageLuminance: h = 1, adaptationRate: d = 1 } = {}) { super("ToneMappingEffect", tone_mapping_default, { blendFunction: r, uniforms: new Map([["luminanceBuffer", new Uniform(null)], ["maxLuminance", new Uniform(a)], ["whitePoint", new Uniform(o)], ["middleGrey", new Uniform(l)], ["averageLuminance", new Uniform(h)]]) }), this.renderTargetLuminance = new WebGLRenderTarget(1, 1, { minFilter: LinearMipmapLinearFilter, depthBuffer: !1 }), this.renderTargetLuminance.texture.generateMipmaps = !0, this.renderTargetLuminance.texture.name = "Luminance", this.luminancePass = new LuminancePass({ renderTarget: this.renderTargetLuminance }), this.adaptiveLuminancePass = new AdaptiveLuminancePass(this.luminancePass.texture, { minLuminance: c, adaptationRate: d }), this.uniforms.get("luminanceBuffer").value = this.adaptiveLuminancePass.texture, this.resolution = s, this.mode = i } get mode() { return Number(this.defines.get("TONE_MAPPING_MODE")) } set mode(r) { if (this.mode === r) return; const i = REVISION.replace(/\D+/g, "") >= 168 ? "CineonToneMapping(texel)" : "OptimizedCineonToneMapping(texel)"; switch (this.defines.clear(), this.defines.set("TONE_MAPPING_MODE", r.toFixed(0)), r) { case ToneMappingMode.LINEAR: this.defines.set("toneMapping(texel)", "LinearToneMapping(texel)"); break; case ToneMappingMode.REINHARD: this.defines.set("toneMapping(texel)", "ReinhardToneMapping(texel)"); break; case ToneMappingMode.CINEON: case ToneMappingMode.OPTIMIZED_CINEON: this.defines.set("toneMapping(texel)", i); break; case ToneMappingMode.ACES_FILMIC: this.defines.set("toneMapping(texel)", "ACESFilmicToneMapping(texel)"); break; case ToneMappingMode.AGX: this.defines.set("toneMapping(texel)", "AgXToneMapping(texel)"); break; case ToneMappingMode.NEUTRAL: this.defines.set("toneMapping(texel)", "NeutralToneMapping(texel)"); break; default: this.defines.set("toneMapping(texel)", "texel"); break }this.adaptiveLuminancePass.enabled = r === ToneMappingMode.REINHARD2_ADAPTIVE, this.setChanged() } getMode() { return this.mode } setMode(r) { this.mode = r } get whitePoint() { return this.uniforms.get("whitePoint").value } set whitePoint(r) { this.uniforms.get("whitePoint").value = r } get middleGrey() { return this.uniforms.get("middleGrey").value } set middleGrey(r) { this.uniforms.get("middleGrey").value = r } get averageLuminance() { return this.uniforms.get("averageLuminance").value } set averageLuminance(r) { this.uniforms.get("averageLuminance").value = r } get adaptiveLuminanceMaterial() { return this.adaptiveLuminancePass.fullscreenMaterial } getAdaptiveLuminanceMaterial() { return this.adaptiveLuminanceMaterial } get resolution() { return this.luminancePass.resolution.width } set resolution(r) { const e = Math.max(0, Math.ceil(Math.log2(r))), i = Math.pow(2, e); this.luminancePass.resolution.setPreferredSize(i, i), this.adaptiveLuminanceMaterial.mipLevel1x1 = e } getResolution() { return this.resolution } setResolution(r) { this.resolution = r } get adaptive() { return this.mode === ToneMappingMode.REINHARD2_ADAPTIVE } set adaptive(r) { this.mode = r ? ToneMappingMode.REINHARD2_ADAPTIVE : ToneMappingMode.REINHARD2 } get adaptationRate() { return this.adaptiveLuminanceMaterial.adaptationRate } set adaptationRate(r) { this.adaptiveLuminanceMaterial.adaptationRate = r } get distinction() { return console.warn(this.name, "distinction was removed."), 1 } set distinction(r) { console.warn(this.name, "distinction was removed.") } update(r, e, i) { this.adaptiveLuminancePass.enabled && (this.luminancePass.render(r, e), this.adaptiveLuminancePass.render(r, null, null, i)) } initialize(r, e, i) { this.adaptiveLuminancePass.initialize(r, e, i) } }, effect_default = `#include <common>
#include <packing>
#include <dithering_pars_fragment>
#define packFloatToRGBA(v) packDepthToRGBA(v)
#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#if DEPTH_PACKING == 3201
uniform lowp sampler2D depthBuffer;
#elif defined(GL_FRAGMENT_PRECISION_HIGH)
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;vec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}float getViewZ(const in float depth){
#ifdef PERSPECTIVE_CAMERA
return perspectiveDepthToViewZ(depth,cameraNear,cameraFar);
#else
return orthographicDepthToViewZ(depth,cameraNear,cameraFar);
#endif
}vec3 RGBToHCV(const in vec3 RGB){vec4 P=mix(vec4(RGB.bg,-1.0,2.0/3.0),vec4(RGB.gb,0.0,-1.0/3.0),step(RGB.b,RGB.g));vec4 Q=mix(vec4(P.xyw,RGB.r),vec4(RGB.r,P.yzx),step(P.x,RGB.r));float C=Q.x-min(Q.w,Q.y);float H=abs((Q.w-Q.y)/(6.0*C+EPSILON)+Q.z);return vec3(H,C,Q.x);}vec3 RGBToHSL(const in vec3 RGB){vec3 HCV=RGBToHCV(RGB);float L=HCV.z-HCV.y*0.5;float S=HCV.y/(1.0-abs(L*2.0-1.0)+EPSILON);return vec3(HCV.x,S,L);}vec3 HueToRGB(const in float H){float R=abs(H*6.0-3.0)-1.0;float G=2.0-abs(H*6.0-2.0);float B=2.0-abs(H*6.0-4.0);return clamp(vec3(R,G,B),0.0,1.0);}vec3 HSLToRGB(const in vec3 HSL){vec3 RGB=HueToRGB(HSL.x);float C=(1.0-abs(2.0*HSL.z-1.0))*HSL.y;return(RGB-0.5)*C+HSL.z;}FRAGMENT_HEAD void main(){FRAGMENT_MAIN_UV vec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGE color0.a=clamp(color0.a,0.0,1.0);gl_FragColor=color0;
#ifdef ENCODE_OUTPUT
#include <colorspace_fragment>
#endif
#include <dithering_fragment>
}`, effect_default2 = "uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEAD void main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORT gl_Position=vec4(position.xy,1.0,1.0);}", EffectMaterial = class extends ShaderMaterial { constructor(r, e, i, s, a = !1) { super({ name: "EffectMaterial", defines: { THREE_REVISION: REVISION.replace(/\D+/g, ""), DEPTH_PACKING: "0", ENCODE_OUTPUT: "1" }, uniforms: { inputBuffer: new Uniform(null), depthBuffer: new Uniform(null), resolution: new Uniform(new Vector2), texelSize: new Uniform(new Vector2), cameraNear: new Uniform(.3), cameraFar: new Uniform(1e3), aspect: new Uniform(1), time: new Uniform(0) }, blending: NoBlending, toneMapped: !1, depthWrite: !1, depthTest: !1, dithering: a }), r && this.setShaderParts(r), e && this.setDefines(e), i && this.setUniforms(i), this.copyCameraSettings(s) } set inputBuffer(r) { this.uniforms.inputBuffer.value = r } setInputBuffer(r) { this.uniforms.inputBuffer.value = r } get depthBuffer() { return this.uniforms.depthBuffer.value } set depthBuffer(r) { this.uniforms.depthBuffer.value = r } get depthPacking() { return Number(this.defines.DEPTH_PACKING) } set depthPacking(r) { this.defines.DEPTH_PACKING = r.toFixed(0), this.needsUpdate = !0 } setDepthBuffer(r, e = BasicDepthPacking) { this.depthBuffer = r, this.depthPacking = e } setShaderData(r) { this.setShaderParts(r.shaderParts), this.setDefines(r.defines), this.setUniforms(r.uniforms), this.setExtensions(r.extensions) } setShaderParts(r) { return this.fragmentShader = effect_default.replace(EffectShaderSection.FRAGMENT_HEAD, r.get(EffectShaderSection.FRAGMENT_HEAD) || "").replace(EffectShaderSection.FRAGMENT_MAIN_UV, r.get(EffectShaderSection.FRAGMENT_MAIN_UV) || "").replace(EffectShaderSection.FRAGMENT_MAIN_IMAGE, r.get(EffectShaderSection.FRAGMENT_MAIN_IMAGE) || ""), this.vertexShader = effect_default2.replace(EffectShaderSection.VERTEX_HEAD, r.get(EffectShaderSection.VERTEX_HEAD) || "").replace(EffectShaderSection.VERTEX_MAIN_SUPPORT, r.get(EffectShaderSection.VERTEX_MAIN_SUPPORT) || ""), this.needsUpdate = !0, this } setDefines(r) { for (const e of r.entries()) this.defines[e[0]] = e[1]; return this.needsUpdate = !0, this } setUniforms(r) { for (const e of r.entries()) this.uniforms[e[0]] = e[1]; return this } setExtensions(r) { this.extensions = {}; for (const e of r) this.extensions[e] = !0; return this } get encodeOutput() { return this.defines.ENCODE_OUTPUT !== void 0 } set encodeOutput(r) { this.encodeOutput !== r && (r ? this.defines.ENCODE_OUTPUT = "1" : delete this.defines.ENCODE_OUTPUT, this.needsUpdate = !0) } isOutputEncodingEnabled(r) { return this.encodeOutput } setOutputEncodingEnabled(r) { this.encodeOutput = r } get time() { return this.uniforms.time.value } set time(r) { this.uniforms.time.value = r } setDeltaTime(r) { this.uniforms.time.value += r } adoptCameraSettings(r) { this.copyCameraSettings(r) } copyCameraSettings(r) { r && (this.uniforms.cameraNear.value = r.near, this.uniforms.cameraFar.value = r.far, r instanceof PerspectiveCamera ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA, this.needsUpdate = !0) } setSize(r, e) { const i = this.uniforms; i.resolution.value.set(r, e), i.texelSize.value.set(1 / r, 1 / e), i.aspect.value = r / e } static get Section() { return EffectShaderSection } }, convolution_gaussian_default = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform vec2 kernel[STEPS];varying vec2 vOffset;varying vec2 vUv;void main(){vec4 result=texture2D(inputBuffer,vUv)*kernel[0].y;for(int i=1;i<STEPS;++i){vec2 offset=kernel[i].x*vOffset;vec4 c0=texture2D(inputBuffer,vUv+offset);vec4 c1=texture2D(inputBuffer,vUv-offset);result+=(c0+c1)*kernel[i].y;}gl_FragColor=result;
#include <colorspace_fragment>
}`, convolution_gaussian_default2 = "uniform vec2 texelSize;uniform vec2 direction;uniform float scale;varying vec2 vOffset;varying vec2 vUv;void main(){vOffset=direction*texelSize*scale;vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}", GaussianBlurMaterial = class extends ShaderMaterial { constructor({ kernelSize: r = 35 } = {}) { super({ name: "GaussianBlurMaterial", uniforms: { inputBuffer: new Uniform(null), texelSize: new Uniform(new Vector2), direction: new Uniform(new Vector2), kernel: new Uniform(null), scale: new Uniform(1) }, blending: NoBlending, toneMapped: !1, depthWrite: !1, depthTest: !1, fragmentShader: convolution_gaussian_default, vertexShader: convolution_gaussian_default2 }), this._kernelSize = 0, this.kernelSize = r } set inputBuffer(r) { this.uniforms.inputBuffer.value = r } get kernelSize() { return this._kernelSize } set kernelSize(r) { this._kernelSize = r, this.generateKernel(r) } get direction() { return this.uniforms.direction.value } get scale() { return this.uniforms.scale.value } set scale(r) { this.uniforms.scale.value = r } generateKernel(r) { const e = new GaussKernel(r), i = e.linearSteps, s = new Float64Array(i * 2); for (let a = 0, o = 0; a < i; ++a)s[o++] = e.linearOffsets[a], s[o++] = e.linearWeights[a]; this.uniforms.kernel.value = s, this.defines.STEPS = i.toFixed(0), this.needsUpdate = !0 } setSize(r, e) { this.uniforms.texelSize.value.set(1 / r, 1 / e) } }; function prefixSubstrings(r, e, i) { for (const s of e) { const a = "$1" + r + s.charAt(0).toUpperCase() + s.slice(1), o = new RegExp("([^\\.])(\\b" + s + "\\b)", "g"); for (const l of i.entries()) l[1] !== null && i.set(l[0], l[1].replace(o, a)) } } function integrateEffect(r, e, i) {
    let s = e.getFragmentShader(), a = e.getVertexShader(); const o = s !== void 0 && /mainImage/.test(s), l = s !== void 0 && /mainUv/.test(s); if (i.attributes |= e.getAttributes(), s === void 0) throw new Error(`Missing fragment shader (${e.name})`); if (l && (i.attributes & EffectAttribute.CONVOLUTION) !== 0) throw new Error(`Effects that transform UVs are incompatible with convolution effects (${e.name})`); if (!o && !l) throw new Error(`Could not find mainImage or mainUv function (${e.name})`); {
        const c = /\w+\s+(\w+)\([\w\s,]*\)\s*{/g, h = i.shaderParts; let d = h.get(EffectShaderSection.FRAGMENT_HEAD) || "", p = h.get(EffectShaderSection.FRAGMENT_MAIN_UV) || "", f = h.get(EffectShaderSection.FRAGMENT_MAIN_IMAGE) || "", _ = h.get(EffectShaderSection.VERTEX_HEAD) || "", x = h.get(EffectShaderSection.VERTEX_MAIN_SUPPORT) || ""; const b = new Set, T = new Set; if (l && (p += `	${r}MainUv(UV);
`, i.uvTransformation = !0), a !== null && /mainSupport/.test(a)) {
            const D = /mainSupport *\([\w\s]*?uv\s*?\)/.test(a); x += `	${r}MainSupport(`, x += D ? `vUv);
`: `);
`; for (const R of a.matchAll(/(?:varying\s+\w+\s+([\S\s]*?);)/g)) for (const P of R[1].split(/\s*,\s*/)) i.varyings.add(P), b.add(P), T.add(P); for (const R of a.matchAll(c)) T.add(R[1])
        } for (const D of s.matchAll(c)) T.add(D[1]); for (const D of e.defines.keys()) T.add(D.replace(/\([\w\s,]*\)/g, "")); for (const D of e.uniforms.keys()) T.add(D); T.delete("while"), T.delete("for"), T.delete("if"), e.uniforms.forEach((D, R) => i.uniforms.set(r + R.charAt(0).toUpperCase() + R.slice(1), D)), e.defines.forEach((D, R) => i.defines.set(r + R.charAt(0).toUpperCase() + R.slice(1), D)); const M = new Map([["fragment", s], ["vertex", a]]); prefixSubstrings(r, T, i.defines), prefixSubstrings(r, T, M), s = M.get("fragment"), a = M.get("vertex"); const w = e.blendMode; if (i.blendModes.set(w.blendFunction, w), o) {
            e.inputColorSpace !== null && e.inputColorSpace !== i.colorSpace && (f += e.inputColorSpace === SRGBColorSpace ? `color0 = sRGBTransferOETF(color0);
	`: `color0 = sRGBToLinear(color0);
	`), e.outputColorSpace !== NoColorSpace ? i.colorSpace = e.outputColorSpace : e.inputColorSpace !== null && (i.colorSpace = e.inputColorSpace); const D = /MainImage *\([\w\s,]*?depth[\w\s,]*?\)/; f += `${r}MainImage(color0, UV, `, (i.attributes & EffectAttribute.DEPTH) !== 0 && D.test(s) && (f += "depth, ", i.readDepth = !0), f += `color1);
	`; const R = r + "BlendOpacity"; i.uniforms.set(R, w.opacity), f += `color0 = blend${w.blendFunction}(color0, color1, ${R});

	`, d += `uniform float ${R};

`} if (d += s + `
`, a !== null && (_ += a + `
`), h.set(EffectShaderSection.FRAGMENT_HEAD, d), h.set(EffectShaderSection.FRAGMENT_MAIN_UV, p), h.set(EffectShaderSection.FRAGMENT_MAIN_IMAGE, f), h.set(EffectShaderSection.VERTEX_HEAD, _), h.set(EffectShaderSection.VERTEX_MAIN_SUPPORT, x), e.extensions !== null) for (const D of e.extensions) i.extensions.add(D)
    }
} var EffectPass = class extends Pass {
    constructor(r, ...e) { super("EffectPass"), this.fullscreenMaterial = new EffectMaterial(null, null, null, r), this.listener = i => this.handleEvent(i), this.effects = [], this.setEffects(e), this.skipRendering = !1, this.minTime = 1, this.maxTime = Number.POSITIVE_INFINITY, this.timeScale = 1 } set mainScene(r) { for (const e of this.effects) e.mainScene = r } set mainCamera(r) { this.fullscreenMaterial.copyCameraSettings(r); for (const e of this.effects) e.mainCamera = r } get encodeOutput() { return this.fullscreenMaterial.encodeOutput } set encodeOutput(r) { this.fullscreenMaterial.encodeOutput = r } get dithering() { return this.fullscreenMaterial.dithering } set dithering(r) { const e = this.fullscreenMaterial; e.dithering = r, e.needsUpdate = !0 } setEffects(r) { for (const e of this.effects) e.removeEventListener("change", this.listener); this.effects = r.sort((e, i) => i.attributes - e.attributes); for (const e of this.effects) e.addEventListener("change", this.listener) } updateMaterial() {
        const r = new EffectShaderData; let e = 0; for (const l of this.effects) if (l.blendMode.blendFunction === BlendFunction.DST) r.attributes |= l.getAttributes() & EffectAttribute.DEPTH; else { if ((r.attributes & l.getAttributes() & EffectAttribute.CONVOLUTION) !== 0) throw new Error(`Convolution effects cannot be merged (${l.name})`); integrateEffect("e" + e++, l, r) } let i = r.shaderParts.get(EffectShaderSection.FRAGMENT_HEAD), s = r.shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_IMAGE), a = r.shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_UV); const o = /\bblend\b/g; for (const l of r.blendModes.values()) i += l.getShaderCode().replace(o, `blend${l.blendFunction}`) + `
`; (r.attributes & EffectAttribute.DEPTH) !== 0 ? (r.readDepth && (s = `float depth = readDepth(UV);

	`+ s), this.needsDepthTexture = this.getDepthTexture() === null) : this.needsDepthTexture = !1, r.colorSpace === SRGBColorSpace && (s += `color0 = sRGBToLinear(color0);
	`), r.uvTransformation ? (a = `vec2 transformedUv = vUv;
`+ a, r.defines.set("UV", "transformedUv")) : r.defines.set("UV", "vUv"), r.shaderParts.set(EffectShaderSection.FRAGMENT_HEAD, i), r.shaderParts.set(EffectShaderSection.FRAGMENT_MAIN_IMAGE, s), r.shaderParts.set(EffectShaderSection.FRAGMENT_MAIN_UV, a); for (const [l, c] of r.shaderParts) c !== null && r.shaderParts.set(l, c.trim().replace(/^#/, `
#`)); this.skipRendering = e === 0, this.needsSwap = !this.skipRendering, this.fullscreenMaterial.setShaderData(r)
    } recompile() { this.updateMaterial() } getDepthTexture() { return this.fullscreenMaterial.depthBuffer } setDepthTexture(r, e = BasicDepthPacking) { this.fullscreenMaterial.depthBuffer = r, this.fullscreenMaterial.depthPacking = e; for (const i of this.effects) i.setDepthTexture(r, e) } render(r, e, i, s, a) { for (const o of this.effects) o.update(r, e, s); if (!this.skipRendering || this.renderToScreen) { const o = this.fullscreenMaterial; o.inputBuffer = e.texture, o.time += s * this.timeScale, r.setRenderTarget(this.renderToScreen ? null : i), r.render(this.scene, this.camera) } } setSize(r, e) { this.fullscreenMaterial.setSize(r, e); for (const i of this.effects) i.setSize(r, e) } initialize(r, e, i) { this.renderer = r; for (const s of this.effects) s.initialize(r, e, i); this.updateMaterial(), i !== void 0 && i !== UnsignedByteType && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1") } dispose() { super.dispose(); for (const r of this.effects) r.removeEventListener("change", this.listener), r.dispose() } handleEvent(r) { switch (r.type) { case "change": this.recompile(); break } }
}, GaussianBlurPass = class extends Pass { constructor({ kernelSize: r = 35, iterations: e = 1, resolutionScale: i = 1, resolutionX: s = Resolution.AUTO_SIZE, resolutionY: a = Resolution.AUTO_SIZE } = {}) { super("GaussianBlurPass"), this.renderTargetA = new WebGLRenderTarget(1, 1, { depthBuffer: !1 }), this.renderTargetA.texture.name = "Blur.Target.A", this.renderTargetB = this.renderTargetA.clone(), this.renderTargetB.texture.name = "Blur.Target.B", this.blurMaterial = new GaussianBlurMaterial({ kernelSize: r }), this.copyMaterial = new CopyMaterial, this.copyMaterial.inputBuffer = this.renderTargetB.texture; const o = this.resolution = new Resolution(this, s, a, i); o.addEventListener("change", l => this.setSize(o.baseWidth, o.baseHeight)), this.iterations = e } render(r, e, i, s, a) { const o = this.scene, l = this.camera, c = this.renderTargetA, h = this.renderTargetB, d = this.blurMaterial; this.fullscreenMaterial = d; let p = e; for (let f = 0, _ = Math.max(this.iterations, 1); f < _; ++f)d.direction.set(1, 0), d.inputBuffer = p.texture, r.setRenderTarget(c), r.render(o, l), d.direction.set(0, 1), d.inputBuffer = c.texture, r.setRenderTarget(h), r.render(o, l), f === 0 && _ > 1 && (p = h); this.fullscreenMaterial = this.copyMaterial, r.setRenderTarget(this.renderToScreen ? null : i), r.render(o, l) } setSize(r, e) { const i = this.resolution; i.setBaseSize(r, e); const s = i.width, a = i.height; this.renderTargetA.setSize(s, a), this.renderTargetB.setSize(s, a), this.blurMaterial.setSize(r, e) } initialize(r, e, i) { i !== void 0 && (this.renderTargetA.texture.type = i, this.renderTargetB.texture.type = i, i !== UnsignedByteType ? (this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1", this.copyMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1") : r !== null && r.outputColorSpace === SRGBColorSpace && (this.renderTargetA.texture.colorSpace = SRGBColorSpace, this.renderTargetB.texture.colorSpace = SRGBColorSpace)) } }; const effectCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1), dummyRT = new WebGLRenderTarget(1, 1, { type: HalfFloatType }); dummyRT.setSize = () => { }; dummyRT.dispose = () => { }; class postprocessing extends Pass$1 { constructor() { super(), this.isPostprocessingPass = !0, this._effectComposer = new EffectComposer(webglRenderer.webgl, { frameBufferType: HalfFloatType }), this._effectComposer.inputBuffer.dispose(), this._effectComposer.outputBuffer.dispose(), this._effectComposer.inputBuffer = dummyRT, this._effectComposer.outputBuffer = dummyRT, this._effectComposer.autoRenderToScreen = !1 } setSize(e, i) { for (const s of this._effectComposer.passes) s.setSize(e, i) } render(e, i, s, a) { this._effectComposer.inputBuffer = s, this._effectComposer.outputBuffer = i, this._effectComposer.render(a) } addGammaCorrection() { const e = new EffectPass(effectCamera); return e.renderToScreen = !0, e.fullscreenMaterial.encodeOutput = !0, this._effectComposer.addPass(e), this } addFXAA() { const e = new EffectPass(effectCamera, new FXAAEffect); return e.renderToScreen = !0, e.fullscreenMaterial.encodeOutput = !0, this._effectComposer.addPass(e), this } addSMAA(e = {}) { var s; const i = new EffectPass(effectCamera, new SMAAEffect({ preset: SMAAPreset[((s = e.quality) == null ? void 0 : s.toUpperCase()) || "HIGH"] })); return i.renderToScreen = !0, i.fullscreenMaterial.encodeOutput = !0, this._effectComposer.addPass(i), this } addKawaseBlur(e = {}) { const i = new KawaseBlurPass(e); return i.blurMaterial.kernelSize = typeof e.kernelSize == "number" ? e.kernelSize : KernelSize.MEDIUM, this._effectComposer.addPass(i), e.debug && gui$1.add(i, " Kawase Blur"), this } addGaussianBlur(e = {}) { const i = new GaussianBlurPass(e); return this._effectComposer.addPass(i), e.debug && gui$1.add(i, " Gaussian Blur"), this } addBloom(e = {}) { const i = new EffectPass(effectCamera, new BloomEffect({ ...e, mipmapBlur: !0 })); return i.fullscreenMaterial.encodeOutput = !1, this._effectComposer.addPass(i), e.debug && gui$1.add(i, " Bloom"), this } addToneMapping(e = {}) { const i = new EffectPass(effectCamera, new ToneMappingEffect({ ...e })); return this._effectComposer.addPass(i), this } addSelectiveBloom({ scene: e, objects: i, sceneDepthTexture: s, options: a = {} } = {}) { if (!e || !i || !s) throw new Error("Selective Bloom requires scene, objects and depth texture."); const o = new SelectiveBloomEffect(e, e.camera, { ...a, mipmapBlur: !0 }); o.selection.set(i.length ? i : [i]); const l = new EffectPass(effectCamera, o); return l.needsDepthTexture = !1, l.setDepthTexture(s), l.fullscreenMaterial.encodeOutput = !1, this._effectComposer.addPass(l), a.debug && gui$1.add(l, " Selective Bloom"), this } addGodRays({ camera: e, lightSource: i, sceneDepthTexture: s, options: a = {} } = {}) { if (!e || !i || !s) throw new Error("Godrays requires scene camera, light source and depth texture."); const o = new EffectPass(e, new GodRaysEffect(e, i, { kernelSize: KernelSize.SMALL, ...a })); return o.needsDepthTexture = !1, o.setDepthTexture(s), o.effects[0].blurPass.kernelSize = a.kernelSize || KernelSize.SMALL, o.fullscreenMaterial.encodeOutput = !1, this._effectComposer.addPass(o), a.debug && gui$1.add(o, " Godrays"), this } addDOF(e, i, s = {}) { if (!e || !i) throw new Error("DOF requires scene camera and depth texture."); const a = new EffectPass(e, new DepthOfFieldEffect(e, { resolutionScale: .5, worldFocusDistance: 4, worldFocusRange: 10, bokehScale: 5, ...s })); return s.cameraTarget && (a.effects[0].target = e.target), a.needsDepthTexture = !1, a.setDepthTexture(i), a.fullscreenMaterial.encodeOutput = !1, this._effectComposer.addPass(a), s.debug && gui$1.add(a, " DOF"), this } dispose() { const e = { depthTexture: null, dispose: () => { } }; this._effectComposer.inputBuffer = e, this._effectComposer.outputBuffer = e, this._effectComposer.dispose() } } var Vt, ro, ao, xr, Sa, Ca, yr, oo; class globalWebGL extends globalBase { constructor() { super(...arguments); pe(this, Vt); Ke(this, "renderer", webglRenderer); Ke(this, "uniforms", uniforms$1); Ke(this, "UBO", UBO); Ke(this, "composer", null); Ke(this, "renderPass", null) } async init(i = {}) { super.init(i), await gui$1.init(); const { shadowMap: s, shadowMapType: a } = i; Pe(this, Vt, ro).call(this, { shadowMap: s, shadowMapType: a }), client$1.query.renderinfo !== null && gui$1.showRenderInfo(this.canvasCnt), Pe(this, Vt, ao).call(this), this.initInteraction(), Pe(this, Vt, oo).call(this) } setDevScene(i) { this.setRenderScene(i), Pe(this, Vt, yr).call(this, !0) } setRenderScene(i) { this.renderPass.scene = i, this.renderPass.camera = i.camera, i.composer = this.composer } dispose(i = {}) { i.renderer && (gui$1.hideRenderInfo(), this.renderer.active = !1, events.off("resize", Pe(this, Vt, xr), this), events.off("prerender", Pe(this, Vt, Sa), this), events.off("render", Pe(this, Vt, Ca), this), events.off("render_active", Pe(this, Vt, yr), this), this.composer.dispose(), this.composer = null, this.renderPass = null, this.canvasCnt.removeChild(this.canvasNode), this.canvasCnt = null, this.canvasNode = null, this.renderer.dispose()), super.dispose(i) } } Vt = new WeakSet, ro = function ({ shadowMap: i, shadowMapType: s } = {}) { this.renderer.init({ shadowMap: i, shadowMapType: s }), this.renderer.info.autoReset = !1; { const a = document.createElement("div"); a.attachShadow({ mode: "closed" }).append(this.renderer.domElement), this.canvasNode = a } this.canvasCnt.prepend(this.canvasNode), this.interactionNode || (this.interactionNode = this.renderer.domElement), ktx2Loader.detectSupport(this.renderer.webgl) }, ao = function () { Pe(this, Vt, xr).call(this, client$1.screen.w, client$1.screen.h), events.on("resize", Pe(this, Vt, xr), this), events.on("prerender", Pe(this, Vt, Sa), this), events.on("render", Pe(this, Vt, Ca), this), events.on("render_active", Pe(this, Vt, yr), this) }, xr = function (i, s) { uniforms$1.resolution.value.set(i, s).multiplyScalar(this.currentDPR).floor(), uniforms$1.aspect.value = uniforms$1.resolution.value.x / uniforms$1.resolution.value.y, uniforms$1.resolutionUI.value.set(i, s), this.renderer.webgl.setSize(uniforms$1.resolution.value.x, uniforms$1.resolution.value.y, !1), this.renderer.domElement.style.width = `${i}px`, this.renderer.domElement.style.height = `${s}px` }, Sa = function (i) { uniforms$1.time.value = i, uniforms$1.dtRatio.value = math.deltaRatio() }, Ca = function (i, s) { var a, o; this.renderer.active && ((a = this.renderer.info) == null || a.reset(), (o = this.composer) == null || o.render(s)) }, yr = function (i) { i && this.adaptiveDPR && !this.adaptiveDPR.hasRun && this.adaptiveDPR.start(), this.renderer.active = i }, oo = function () { this.composer = new effectComposerExtended({ renderToScreen: !0 }); const i = new scene; this.renderPass = new RenderPass$1(i, i.camera, void 0, this.renderer.clearColor, this.renderer.clearAlpha), this.composer.addPass(this.renderPass); const s = new postprocessing().addSMAA({ quality: "high" }); s.isGammaCorrectionPass = !0, this.composer.addPass(s) }; const global$1 = new globalWebGL; class MultipleRenderPass extends Pass$1 { constructor({ scene: e = null, finalMaterials: i = [], rtCount: s = 2, rtOptions: a = {}, clearColor: o = null, clearAlpha: l = null, onBeforeMultiRender: c = null, onAfterMultiRender: h = null } = {}) { if (!e) throw new Error("MultipleRenderPass requires a scene."); super(), this.scene = e, this.camera = e.camera, this.clearColor = o, this.clearAlpha = l, this.clear = !0, this.clearDepth = !1, this.needsSwap = !1, this._oldClearColor = new Color, this._oldClearAlpha = null, this.renderTarget = new WebGLRenderTarget(2, 2, { count: s, type: HalfFloatType, ...a }), this.scene.customUploadRT = this.renderTarget.clone(), this.onBeforeMultiRender = c, this.onAfterMultiRender = h, this.finalPasses = i.map(d => new ShaderPass$1(d, "__textureAssignDisabled__")) } render(e, i, s) { const a = e.autoClear; e.autoClear = !1, this.clearColor !== null && (e.getClearColor(this._oldClearColor), e.setClearColor(this.clearColor, this.clearAlpha)), this.clearAlpha !== null && (this._oldClearAlpha = e.getClearAlpha(), e.setClearAlpha(this.clearAlpha)), e.setRenderTarget(this.renderTarget), this.clearDepth && e.clearDepth(), this.clear === !0 && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), this.onBeforeMultiRender && this.onBeforeMultiRender(), e.render(this.scene, this.camera), this.onAfterMultiRender && this.onAfterMultiRender(), this.clearColor !== null && e.setClearColor(this._oldClearColor, this._oldClearAlpha), this.clearAlpha !== null && e.setClearAlpha(this._oldClearAlpha), e.autoClear = a; const o = this.finalPasses.length % 2 === 1; let l = o ? s : i, c = o ? i : s, h = null; this.finalPasses.forEach((d, p) => { d.uniforms.tDiffuse && (d.uniforms.tDiffuse.value = p === 0 ? this.renderTarget.textures[0] : c.texture), d.clear = p === 0, d.render(e, l), h = c, c = l, l = h }) } setSize(e, i) { this.renderTarget.setSize(e, i), this.finalPasses.forEach(s => s.setSize(e, i)) } dispose() { this.renderTarget.dispose(), this.finalPasses.forEach(e => e.dispose()) } } const _c0$3 = new Color, _clearColor = new Color("#000000"); class GPUSim { constructor({ count: e = 4, width: i = null, height: s = null, textures: a = 1, initialTextures: o = [], material: l = null, afterCompute: c = null } = {}) { var p; const h = i || math.getTextureSizeParticles(e), d = s || h; this.rt1 = new WebGLRenderTarget(h, d, { count: a || 1, wrapS: ClampToEdgeWrapping, wrapT: ClampToEdgeWrapping, minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat, type: webglRenderer.webgl.capabilities.floatRenderTarget ? FloatType : HalfFloatType, depthBuffer: !1 }), this.rt2 = this.rt1.clone(), this.rtCurrent = 0, webglRenderer.webgl.initRenderTarget(this.rt1), webglRenderer.webgl.initRenderTarget(this.rt2), this.initialTextures = o, ((p = this.initialTextures) == null ? void 0 : p.length) > 0 && this.initialTextures.forEach((f, _) => { webglRenderer.webgl.copyTextureToTexture(f, this.rt1.textures[_]), webglRenderer.webgl.copyTextureToTexture(f, this.rt2.textures[_]) }), this.computationMaterial = l, this.computationMaterial.name = "particlesGPU", this.fsQuad = new utils.fsQuad(this.computationMaterial), webglRenderer.webgl.compile(this.fsQuad.mesh, this.fsQuad.camera), this.afterCompute = c } compute({ mesh: e = null, camera: i = null } = {}) { var f, _; const s = this.computationMaterial.uniforms.uModelMatrix, a = this.computationMaterial.uniforms.uViewMatrix, o = this.computationMaterial.uniforms.uProjMatrix; e && s && s.value.copy(e.matrixWorld), i && a && a.value.copy(i.matrixWorldInverse), i && o && o.value.copy(i.projectionMatrix); const l = this.rtCurrent === 0 ? this.rt1 : this.rt2, c = this.rtCurrent === 0 ? this.rt2 : this.rt1; this.rtCurrent = (this.rtCurrent + 1) % 2; for (let x = 0; x < c.textures.length; x++) { const b = this.computationMaterial.uniforms[`tTexture${x + 1}`]; b && (b.value = c.textures[x]) } const h = webglRenderer.webgl.autoClear; webglRenderer.webgl.autoClear = !1; const d = webglRenderer.webgl.getRenderTarget(); webglRenderer.webgl.setRenderTarget(l), webglRenderer.webgl.getClearColor(_c0$3); const p = webglRenderer.webgl.getClearAlpha(); if (webglRenderer.webgl.setClearColor(_clearColor, 0), webglRenderer.webgl.clear(!0, !1, !1), this.fsQuad.render(webglRenderer.webgl), webglRenderer.webgl.autoClear = h, webglRenderer.webgl.setRenderTarget(d), webglRenderer.webgl.setClearColor(_c0$3, p), (f = e == null ? void 0 : e.material) != null && f.uniforms) { const x = e.material.uniforms; for (let b = 0; b < l.textures.length; b++) { const T = x[`tTexture${b + 1}`]; T && (T.value = l.textures[b]); const M = x[`tTexture${b + 1}Prev`]; M && (M.value = c.textures[b]) } } (_ = this.afterCompute) == null || _.call(this, { mesh: e, camera: i }) } dispose() { this.fsQuad.dispose(), this.computationMaterial.dispose(), this.rt1.dispose(), this.rt2.dispose() } } var encoding_default = `vec2 encodeNormal(vec3 n) {
    n /= (abs(n.x) + abs(n.y) + abs(n.z));
    return (n.z >= 0.0) ? n.xy : (1.0 - abs(n.yx)) * sign(n.xy);
}

vec3 decodeNormal(vec2 f) {
    vec3 n = vec3(f, 1.0 - abs(f.x) - abs(f.y));
    float t = max(-n.z, 0.0);
    n.x += (n.x > 0.0) ? -t : t;
    n.y += (n.y > 0.0) ? -t : t;
    return normalize(n);
}

vec2 encodeNormalUint8(vec3 n) {
    return encodeNormal(n) * 0.5 + 0.5;
}

vec3 deodeNormalUint8(vec2 n) {
    return decodeNormal(n * 2.0 - 1.0);
}

vec2 encodeNormalSpheremap(vec3 n) {
    float f = sqrt(8.0 * n.z + 8.0);
    return n.xy / f * 2.0;
}

vec3 decodeNormalSpheremap(vec2 n) {
    vec4 nn = vec4(n.xy, 1.0, -1.0);
    float l = dot(nn.xyz, -nn.xyw);
    nn.z = l;
    nn.xy *= sqrt(l);
    return nn.xyz * 2.0 + vec3(0.0, 0.0, -1.0);
}

vec2 encodeNormalSpheremapUint8(vec3 n) {
    return encodeNormalSpheremap(n) * 0.5 + 0.5;
}

vec3 deodeNormalSimpleUint8(vec2 n) {
    return decodeNormalSpheremap(n * 2.0 - 1.0);
}`, matrixutils_default = `vec3 getMatrixTranslation(mat4 mat) {
    return vec3(mat[3]);
}

void setMatrixTranslation(inout mat4 mat, vec3 translation) {
    mat[3].xyz = translation;
}

vec3 getMatrixScale(mat4 mat) {
    vec3 scale = vec3(length(mat[0].xyz), length(mat[1].xyz), length(mat[2].xyz));
    return determinant(mat) < 0.0 ? vec3(-scale.x, scale.yz) : scale;
}

void setMatrixScale(inout mat4 mat, vec3 scale) {
    vec3 invScale = 1.0 / getMatrixScale(mat);
    mat[0] *= invScale.x * scale.x;
    mat[1] *= invScale.y * scale.y;
    mat[2] *= invScale.z * scale.z;
}

mat4 getMatrixRotation(mat4 mat) {
    mat4 m = mat4(1.0);
    vec3 scale = getMatrixScale(mat);
    m[0] = mat[0] / scale.x;
    m[1] = mat[1] / scale.y;
    m[2] = mat[2] / scale.z;
    return m;
}

void setMatrixRotation(inout mat4 mat, vec3 rotation) {
    vec3 scale = getMatrixScale(mat);

    float x = rotation.x, y = rotation.y, z = rotation.z;
    float a = cos(x), b = sin(x);
    float c = cos(y), d = sin(y);
    float e = cos(z), f = sin(z);

    
    float ae = a * e, af = a * f, be = b * e, bf = b * f;
    mat[0].xyz = vec3(c * e, -c * f, d) * scale.x;
    mat[1].xyz = vec3(af + be * d, ae - bf * d, -b * c) * scale.y;
    mat[2].xyz = vec3(bf - ae * d, be + af * d, a * c) * scale.z;
}

void matrixCompose(inout mat4 mat, vec3 translation, vec4 quaternion, vec3 scale) {
    float x = quaternion.x; float y = quaternion.y; float z = quaternion.z; float w = quaternion.w;
    float x2 = x + x; float y2 = y + y; float z2 = z + z;
    float xx = x * x2; float xy = x * y2; float xz = x * z2;
    float yy = y * y2; float yz = y * z2; float zz = z * z2;
    float wx = w * x2; float wy = w * y2; float wz = w * z2;
    float sx = scale.x; float sy = scale.y; float sz = scale.z;
    mat[0] = vec4((1.0 - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0.0);
    mat[1] = vec4((xy - wz) * sy, (1.0 - (xx + zz)) * sy, (yz + wx) * sy, 0.0);
    mat[2] = vec4((xz + wy) * sz, (yz - wx) * sz, (1.0 - (xx + yy)) * sz, 0.0);
    mat[3] = vec4(translation.xyz, 1.0);
}

vec3 getViewRight() {
    return vec3(viewMatrix[0][0], viewMatrix[1][0], viewMatrix[2][0]);
}

vec3 getViewLeft() {
    return -getViewRight();
}

vec3 getViewUp() {
    return vec3(viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1]);
}

vec3 getViewDown() {
    return -getViewUp();
}

vec3 getViewBack() {
    return vec3(viewMatrix[0][2], viewMatrix[1][2], viewMatrix[2][2]);
}

vec3 getViewForward() {
    return -getViewBack();
}

mat4 billBoardMatrix(mat4 mat) {
    mat4 m = mat4(1.0);
    vec3 scale = getMatrixScale(mat);
    m[0].xyz = getViewRight() * scale.x;
    m[1].xyz = getViewUp() * scale.y;
    m[2].xyz = getViewBack() * scale.z;
    m[3].xyz = getMatrixTranslation(mat);
    return m;
}

mat4 billboardModelMatrix(vec3 offset) {
    mat4 m = billBoardMatrix(modelMatrix);
    setMatrixTranslation(m, offset);
    return m;
}

mat4 billboardModelMatrix() {
    return billBoardMatrix(modelMatrix);
}`, globalUBO_default = `uniform Global {
    vec2 resolution;
    vec2 resolutionUI;
    float aspect;
    float time;
    float dtRatio;
};`, lerpfriction_default = `float lerpCoefFPS(float t, float dt) {
    return 1.0 - exp2(log2(1.0 - t) * dt);
}

float frictionFPS(float t, float dt) {
    return exp2(log2(t) * dt);
}

float lerpFPS(float x, float y, float t, float dt) {
    return mix(x, y, lerpCoefFPS(t, dt));
}`, base_default = `uvec2 _pcg3d16(uvec3 p)
{
	uvec3 v = p * 1664525u + 1013904223u;
	v.x += v.y*v.z; v.y += v.z*v.x; v.z += v.x*v.y;
	v.x += v.y*v.z; v.y += v.z*v.x;
	return v.xy;
}
uvec2 _pcg4d16(uvec4 p)
{
	uvec4 v = p * 1664525u + 1013904223u;
	v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;
	v.x += v.y*v.w; v.y += v.z*v.x;
	return v.xy;
}

vec3 _gradient3d(uint hash)
{
	vec3 g = vec3(uvec3(hash) & uvec3(0x80000, 0x40000, 0x20000));
	return g * (1.0 / vec3(0x40000, 0x20000, 0x10000)) - 1.0;
}
vec4 _gradient4d(uint hash)
{
	vec4 g = vec4(uvec4(hash) & uvec4(0x80000, 0x40000, 0x20000, 0x10000));
	return g * (1.0 / vec4(0x40000, 0x20000, 0x10000, 0x8000)) - 1.0;
}

vec3 BitangentNoise3D(vec3 p)
{
	const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);
	const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);

	
	vec3 i = floor(p + dot(p, C.yyy));
	vec3 x0 = p - i + dot(i, C.xxx);

	
	vec3 g = step(x0.yzx, x0.xyz);
	vec3 l = 1.0 - g;
	vec3 i1 = min(g.xyz, l.zxy);
	vec3 i2 = max(g.xyz, l.zxy);

	
	
	
	
	vec3 x1 = x0 - i1 + C.xxx;
	vec3 x2 = x0 - i2 + C.yyy; 
	vec3 x3 = x0 - D.yyy;      

	i = i + 32768.5;
	uvec2 hash0 = _pcg3d16(uvec3(i));
	uvec2 hash1 = _pcg3d16(uvec3(i + i1));
	uvec2 hash2 = _pcg3d16(uvec3(i + i2));
	uvec2 hash3 = _pcg3d16(uvec3(i + 1.0 ));

	vec3 p00 = _gradient3d(hash0.x); vec3 p01 = _gradient3d(hash0.y);
	vec3 p10 = _gradient3d(hash1.x); vec3 p11 = _gradient3d(hash1.y);
	vec3 p20 = _gradient3d(hash2.x); vec3 p21 = _gradient3d(hash2.y);
	vec3 p30 = _gradient3d(hash3.x); vec3 p31 = _gradient3d(hash3.y);

	
	vec4 m = clamp(0.5 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0, 1.0);
	vec4 mt = m * m;
	vec4 m4 = mt * mt;

	mt = mt * m;
	vec4 pdotx = vec4(dot(p00, x0), dot(p10, x1), dot(p20, x2), dot(p30, x3));
	vec4 temp = mt * pdotx;
	vec3 gradient0 = -8.0 * (temp.x * x0 + temp.y * x1 + temp.z * x2 + temp.w * x3);
	gradient0 += m4.x * p00 + m4.y * p10 + m4.z * p20 + m4.w * p30;

	pdotx = vec4(dot(p01, x0), dot(p11, x1), dot(p21, x2), dot(p31, x3));
	temp = mt * pdotx;
	vec3 gradient1 = -8.0 * (temp.x * x0 + temp.y * x1 + temp.z * x2 + temp.w * x3);
	gradient1 += m4.x * p01 + m4.y * p11 + m4.z * p21 + m4.w * p31;

	
	return cross(gradient0, gradient1) * 3918.76;
}

vec3 BitangentNoise4D(vec4 p)
{
	const vec4 F4 = vec4( 0.309016994374947451 );
	const vec4  C = vec4( 0.138196601125011,  
	                      0.276393202250021,  
	                      0.414589803375032,  
	                     -0.447213595499958 ); 

	
	vec4 i  = floor(p + dot(p, F4) );
	vec4 x0 = p -   i + dot(i, C.xxxx);

	

	
	vec4 i0;
	vec3 isX = step( x0.yzw, x0.xxx );
	vec3 isYZ = step( x0.zww, x0.yyz );
	
	i0.x = isX.x + isX.y + isX.z;
	i0.yzw = 1.0 - isX;
	
	i0.y += isYZ.x + isYZ.y;
	i0.zw += 1.0 - isYZ.xy;
	i0.z += isYZ.z;
	i0.w += 1.0 - isYZ.z;

	
	vec4 i3 = clamp( i0, 0.0, 1.0 );
	vec4 i2 = clamp( i0 - 1.0, 0.0, 1.0 );
	vec4 i1 = clamp( i0 - 2.0, 0.0, 1.0 );

	
	
	
	
	
	vec4 x1 = x0 - i1 + C.xxxx;
	vec4 x2 = x0 - i2 + C.yyyy;
	vec4 x3 = x0 - i3 + C.zzzz;
	vec4 x4 = x0 + C.wwww;

	i = i + 32768.5;
	uvec2 hash0 = _pcg4d16(uvec4(i));
	uvec2 hash1 = _pcg4d16(uvec4(i + i1));
	uvec2 hash2 = _pcg4d16(uvec4(i + i2));
	uvec2 hash3 = _pcg4d16(uvec4(i + i3));
	uvec2 hash4 = _pcg4d16(uvec4(i + 1.0 ));

	vec4 p00 = _gradient4d(hash0.x); vec4 p01 = _gradient4d(hash0.y);
	vec4 p10 = _gradient4d(hash1.x); vec4 p11 = _gradient4d(hash1.y);
	vec4 p20 = _gradient4d(hash2.x); vec4 p21 = _gradient4d(hash2.y);
	vec4 p30 = _gradient4d(hash3.x); vec4 p31 = _gradient4d(hash3.y);
	vec4 p40 = _gradient4d(hash4.x); vec4 p41 = _gradient4d(hash4.y);

	
	vec3 m0 = clamp(0.6 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2)), 0.0, 1.0);
	vec2 m1 = clamp(0.6 - vec2(dot(x3, x3), dot(x4, x4)             ), 0.0, 1.0);
	vec3 m02 = m0 * m0; vec3 m03 = m02 * m0;
	vec2 m12 = m1 * m1; vec2 m13 = m12 * m1;

	vec3 temp0 = m02 * vec3(dot(p00, x0), dot(p10, x1), dot(p20, x2));
	vec2 temp1 = m12 * vec2(dot(p30, x3), dot(p40, x4));
	vec4 grad0 = -6.0 * (temp0.x * x0 + temp0.y * x1 + temp0.z * x2 + temp1.x * x3 + temp1.y * x4);
	grad0 += m03.x * p00 + m03.y * p10 + m03.z * p20 + m13.x * p30 + m13.y * p40;

	temp0 = m02 * vec3(dot(p01, x0), dot(p11, x1), dot(p21, x2));
	temp1 = m12 * vec2(dot(p31, x3), dot(p41, x4));
	vec4 grad1 = -6.0 * (temp0.x * x0 + temp0.y * x1 + temp0.z * x2 + temp1.x * x3 + temp1.y * x4);
	grad1 += m03.x * p01 + m03.y * p11 + m03.z * p21 + m13.x * p31 + m13.y * p41;

	
	return cross(grad0.xyz, grad1.xyz) * 81.0;
}`; class batchedGPU extends BatchedMesh {
    constructor(e = {}, i = {}) {
        const s = e.maxInstanceCount || 256, a = e.maxVertexCount || 4, o = e.maxIndexCount || 2, l = e.material; super(s, s * a, s * a * o, l || new ShaderMaterial({
            uniforms: { batchingTexture: { value: null }, batchingIdTexture: { value: null }, tTexture1: { value: null }, tTexture2: { value: null }, tTexture3: { value: null } }, vertexShader: `
                    /* BATCHING */
                    #if ! defined(GL_ANGLE_multi_draw)
                        #define gl_DrawID _gl_DrawID
                        uniform int _gl_DrawID;
                    #endif

                    ${matrixutils_default}

                    uniform sampler2D tTexture1;
                    uniform sampler2D tTexture2;
                    uniform sampler2D tTexture3;

                    uniform highp usampler2D batchingIdTexture;

                    vec4 getInfo(const in sampler2D map, const in int i) {
                        int size = textureSize(map, 0).x;
                        return texelFetch(map, ivec2(i % size, i / size), 0);
                    }

                    float getIndirectIndex(const in int i) {
                        int size = textureSize(batchingIdTexture, 0).x;
                        return float(texelFetch(batchingIdTexture, ivec2(i % size, i / size), 0).r);
                    }

                    varying vec2 vUv;
                    flat varying float vScale;
                    flat varying float vRand;
                    varying vec2 vHighPrecisionZW;

                    void main() {
                        vUv = uv;

                        int batchID = int(getIndirectIndex(gl_DrawID));
                        vec4 info1 = getInfo(tTexture1, batchID);
                        vec3 offset = info1.rgb;
                        float life = info1.a;

                        vScale = smoothstep(0.0, 0.15, life) * smoothstep(1.0, 0.7, life);

                        vec4 wPos = billboardModelMatrix(offset) * vec4(position * vScale, 1.0);

                        gl_Position = projectionMatrix * viewMatrix * wPos;
                        vHighPrecisionZW = gl_Position.zw;

                        vec4 info2 = getInfo(tTexture2, batchID);
                        vRand = info2.a;
                    }
                `, fragmentShader: `
                    layout(location = 1) out highp vec4 gInfo;

                    ${encoding_default}

                    varying vec2 vUv;
                    flat varying float vScale;
                    flat varying float vRand;
                    varying vec2 vHighPrecisionZW;

                    void main() {
                        if (vScale < 0.001) discard;

                        gl_FragColor = vec4(vec3(1.0), vRand);
                        gInfo = vec4(1.0 - (0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5), vec2(0.0), 1.0);
                    }
                `})), this.material.uniforms.batchingTexture && (this.material.uniforms.batchingTexture.value = this._matricesTexture), this.material.uniforms.batchingIdTexture && (this.material.uniforms.batchingIdTexture.value = this._indirectTexture), this.isBatchedGPU = !0, this.name = "BatchedGPU", this.visible = !1, this.frustumCulled = !1, this.perObjectFrustumCulled = !1, this.sortObjects = !1, this._onSpawn = e.onSpawn || null, this._onDeath = e.onDeath || null, this._pixelsPerInstance = i.pixelsPerInstance || 3; const c = math.getTextureSizeParticles(s, this._pixelsPerInstance), h = new Float32Array(c * c * 4); if (this._simInitTexture = new DataTexture(h, c, c, RGBAFormat, FloatType), this._resetSimTexture = i.resetSimTexture !== !1, this.simulation = new GPUSim({
                count: s, textures: i.textures || 1, initialTextures: i.initialTextures, material: i.material || new ShaderMaterial({
                    uniformsGroups: [global$1.UBO], uniforms: { tSimInit: { value: null }, tTexture1: { value: null }, tTexture2: { value: null }, tTexture3: { value: null } }, vertexShader: `
                    void main() {
                        gl_Position = vec4(position, 1.0);
                    }
                `, fragmentShader: `
                    #define outPos pc_fragColor
                    uniform sampler2D tTexture1;

                    layout(location = 1) out highp vec4 outVel;
                    uniform sampler2D tTexture2;

                    layout(location = 2) out highp vec4 outData;
                    uniform sampler2D tTexture3;

                    uniform sampler2D tSimInit;

                    ${globalUBO_default}
                    ${lerpfriction_default}
                    ${base_default}

                    void main() {
                        ivec2 uv = ivec2(gl_FragCoord.xy);

                        vec4 data1 = texelFetch(tTexture1, uv, 0);
                        vec4 data2 = texelFetch(tTexture2, uv, 0);
                        vec4 data3 = texelFetch(tTexture3, uv, 0);

                        vec3 position = data1.xyz;
                        float life = data1.w;
                        vec3 velocity = data2.xyz;
                        float random = data2.w;
                        vec3 up = data3.xyz;

                        // get particle id and index on emitting texture
                        int tsize = textureSize(tTexture1, 0).x;
                        int particleid = uv.y * tsize + uv.x;
                        int emitSize = textureSize(tSimInit, 0).x;
                        int indexEmitting = particleid * 3;
                        ivec2 emittinguv = ivec2(indexEmitting % emitSize, indexEmitting / emitSize);
                        vec4 simInit1 = texelFetch(tSimInit, emittinguv, 0);

                        if (simInit1.w > 0.0) {
                            // particle needs to spawn. get all info from spawn
                            vec4 simInit2 = texelFetch(tSimInit, emittinguv + ivec2(1, 0), 0);
                            vec4 simInit3 = texelFetch(tSimInit, emittinguv + ivec2(2, 0), 0);

                            position = simInit1.xyz;
                            life = simInit1.w;
                            velocity = simInit2.xyz;
                            random = simInit2.w;
                            data3 = simInit3;
                        } else if (life > 0.0) {
                            // substract life
                            life -= 0.01 * dtRatio;

                            // add upward force to velocity
                            velocity += up * 0.00075 * dtRatio;

                            // add curl noise
                            vec3 curl = BitangentNoise4D(vec4(vec3(position * 1.15 + random * 20.23), time * 0.2));
                            velocity += curl * 0.0005 * dtRatio;

                            // add friction
                            velocity *= frictionFPS(0.9, dtRatio);

                            // add to position
                            position += velocity * dtRatio;
                        }

                        outPos = vec4(position, life);
                        outVel = vec4(velocity, random);
                        outData = data3;
                    }
                `}), afterCompute: i.afterCompute
            }), this.simulation.computationMaterial.uniforms.tSimInit ? this.simulation.computationMaterial.uniforms.tSimInit.value = this._simInitTexture : this.visible = !0, i.autoCompute !== !1) { const d = this.onBeforeRender.bind(this); this.onBeforeRender = (p, f, _, x, b, T) => { var w; if (d(p, f, _, x, b, T), miscutils.hasRunThisFrame(this) || (this.simulation.compute({ mesh: this, camera: _ }), !this.simulation.computationMaterial.uniforms.tSimInit)) return; this._resetSimTexture && (this._simInitTexture.image.data.fill(0, 0), this._simInitTexture.needsUpdate = !0); let M = !1; for (let D = 0; D < this._instanceInfo.length; D++) { const R = this._instanceInfo[D]; R.active && (R.expiration && R.expiration < renderInfo.time ? (this.deleteInstance(D), (w = this._onDeath) == null || w.call(this, D)) : M = !0) } M || (this.visible = !1) } } this.simulation.compute()
    } spawn(e = {}) { var a, o; if (this._instanceInfo.length >= this.maxInstanceCount) return -1; const i = this.addInstance(e.geometryID || 0); this._instanceInfo[i].expiration = renderInfo.time + (e.expiration || 1); const s = []; return (a = e.data) == null || a.forEach(l => { typeof l == "number" ? s.push(l) : Array.isArray(l) && s.push(...l) }), this._simInitTexture.image.data.set(s, i * this._pixelsPerInstance * 4), this._simInitTexture.needsUpdate = !0, this.visible = !0, (o = this._onSpawn) == null || o.call(this, i), i } dispose() { super.dispose(), this._simInitTexture.dispose(), this._simInitTexture = null, this.simulation.dispose(), this.simulation = null }
} function createParticlesGeometry({ geometry: r, createPoints: e, count: i } = {}) { let s = null; if (e) s = new BufferGeometry, s.setAttribute("position", new BufferAttribute(new Float32Array(i * 3), 3)); else { s = new InstancedBufferGeometry, s.instanceCount = i; const a = r.clone(); a.index && s.setIndex(a.index); for (const o in a.attributes) s.setAttribute(o, a.attributes[o]) } return s } function particlesGPU(r) {
    var e, lo, Ea, co, ho, uo, c; return c = class extends r {
        constructor(d = {}, p = {}) {
            super(d.geometry, d.material || new ShaderMaterial({
                uniforms: { instancingIdTexture: { value: null }, tTexture1: { value: null }, tTexture2: { value: null }, tTexture3: { value: null } }, vertexShader: `
                        #if !defined(USE_INSTANCING)
                            #define gl_InstanceID _gl_InstanceID
                            attribute int _gl_InstanceID;
                        #endif

                        ${matrixutils_default}

                        uniform sampler2D tTexture1;
                        uniform sampler2D tTexture2;
                        uniform sampler2D tTexture3;

                        uniform highp usampler2D instancingIdTexture;

                        vec4 getInfo(const in sampler2D map, const in int i) {
                            int size = textureSize(map, 0).x;
                            return texelFetch(map, ivec2(i % size, i / size), 0);
                        }

                        float getIndirectIndex(const in int i) {
                            int size = textureSize(instancingIdTexture, 0).x;
                            return float(texelFetch(instancingIdTexture, ivec2(i % size, i / size), 0).r);
                        }

                        varying vec2 vUv;
                        flat varying float vScale;
                        flat varying float vRand;
                        varying vec2 vHighPrecisionZW;

                        void main() {
                            vUv = uv;

                            int instanceID = int(getIndirectIndex(gl_InstanceID));
                            vec4 info1 = getInfo(tTexture1, instanceID);
                            vec3 offset = info1.rgb;
                            float life = info1.a;

                            vScale = smoothstep(0.0, 0.15, life) * smoothstep(1.0, 0.7, life);

                            vec4 wPos = billboardModelMatrix(offset) * vec4(position * vScale, 1.0);

                            gl_Position = projectionMatrix * viewMatrix * wPos;
                            vHighPrecisionZW = gl_Position.zw;

                            vec4 info2 = getInfo(tTexture2, instanceID);
                            vRand = info2.a;
                        }
                    `, fragmentShader: `
                        layout(location = 1) out highp vec4 gInfo;

                        ${encoding_default}

                        varying vec2 vUv;
                        flat varying float vScale;
                        flat varying float vRand;
                        varying vec2 vHighPrecisionZW;

                        void main() {
                            if (vScale < 0.001) discard;

                            gl_FragColor = vec4(vec3(1.0), vRand);
                            gInfo = vec4(1.0 - (0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5), vec2(0.0), 1.0);
                        }
                    `}), d.count); pe(this, e); this.isParticlesGPU = !0, this.name = "ParticlesGPU", this.visible = !1, this.particlesCount = d.count, this.frustumCulled = !1, this._onSpawn = d.onSpawn || null, this._onDeath = d.onDeath || null, this._instanceInfo = [], this._availableInstanceIds = [], this._pixelsPerInstance = p.pixelsPerInstance || 1; const f = math.getTextureSizeParticles(this.particlesCount, 1), _ = new Uint32Array(f * f); this._indirectTexture = new DataTexture(_, f, f, RedIntegerFormat, UnsignedIntType), this.material.uniforms.instancingIdTexture && (this.material.uniforms.instancingIdTexture.value = this._indirectTexture); const x = math.getTextureSizeParticles(this.particlesCount, this._pixelsPerInstance), b = new Float32Array(x * x * 4); if (this._simInitTexture = new DataTexture(b, x, x, RGBAFormat, FloatType), this._resetSimTexture = p.resetSimTexture !== !1, this.simulation = new GPUSim({
                    count: this.particlesCount, textures: p.textures || 1, initialTextures: p.initialTextures, material: p.material || new ShaderMaterial({
                        uniformsGroups: [global$1.UBO], uniforms: { tSimInit: { value: null }, tTexture1: { value: null }, tTexture2: { value: null }, tTexture3: { value: null } }, vertexShader: `
                        void main() {
                            gl_Position = vec4(position, 1.0);
                        }
                    `, fragmentShader: `
                        #define outPos pc_fragColor
                        uniform sampler2D tTexture1;

                        layout(location = 1) out highp vec4 outVel;
                        uniform sampler2D tTexture2;

                        layout(location = 2) out highp vec4 outData;
                        uniform sampler2D tTexture3;

                        uniform sampler2D tSimInit;

                        ${globalUBO_default}
                        ${lerpfriction_default}
                        ${base_default}

                        void main() {
                            ivec2 uv = ivec2(gl_FragCoord.xy);

                            vec4 data1 = texelFetch(tTexture1, uv, 0);
                            vec4 data2 = texelFetch(tTexture2, uv, 0);
                            vec4 data3 = texelFetch(tTexture3, uv, 0);

                            vec3 position = data1.xyz;
                            float life = data1.w;
                            vec3 velocity = data2.xyz;
                            float random = data2.w;
                            vec3 up = data3.xyz;

                            // get particle id and index on emitting texture
                            int tsize = textureSize(tTexture1, 0).x;
                            int particleid = uv.y * tsize + uv.x;
                            int emitSize = textureSize(tSimInit, 0).x;
                            int indexEmitting = particleid * 3;
                            ivec2 emittinguv = ivec2(indexEmitting % emitSize, indexEmitting / emitSize);
                            vec4 simInit1 = texelFetch(tSimInit, emittinguv, 0);

                            if (simInit1.w > 0.0) {
                                // particle needs to spawn. get all info from spawn
                                vec4 simInit2 = texelFetch(tSimInit, emittinguv + ivec2(1, 0), 0);
                                vec4 simInit3 = texelFetch(tSimInit, emittinguv + ivec2(2, 0), 0);

                                position = simInit1.xyz;
                                life = simInit1.w;
                                velocity = simInit2.xyz;
                                random = simInit2.w;
                                data3 = simInit3;
                            } else if (life > 0.0) {
                                // substract life
                                life -= 0.01 * dtRatio;

                                // add upward force to velocity
                                velocity += up * 0.00075 * dtRatio;

                                // add curl noise
                                vec3 curl = BitangentNoise4D(vec4(vec3(position * 1.15 + random * 20.23), time * 0.2));
                                velocity += curl * 0.0005 * dtRatio;

                                // add friction
                                velocity *= frictionFPS(0.9, dtRatio);

                                // add to position
                                position += velocity * dtRatio;
                            }

                            outPos = vec4(position, life);
                            outVel = vec4(velocity, random);
                            outData = data3;
                        }
                    `}), afterCompute: p.afterCompute
                }), this.simulation.computationMaterial.uniforms.tSimInit ? (this.simulation.computationMaterial.uniforms.tSimInit.value = this._simInitTexture, this.isPoints && d.geometry.setAttribute("_gl_InstanceID", new BufferAttribute(new Int32Array(Array.from({ length: this.particlesCount }, (T, M) => M)), 1))) : this.visible = !0, p.autoCompute !== !1) { const T = this.onBeforeRender.bind(this); this.onBeforeRender = (M, w, D, R, P, U) => { var N; if (T(M, w, D, R, P, U), miscutils.hasRunThisFrame(this) || (this.simulation.compute({ mesh: this, camera: D }), !this.simulation.computationMaterial.uniforms.tSimInit)) return; this._resetSimTexture && (this._simInitTexture.image.data.fill(0, 0), this._simInitTexture.needsUpdate = !0); let O = !1; for (let H = 0; H < this._instanceInfo.length; H++) { const F = this._instanceInfo[H]; F.active && (F.expiration && F.expiration < renderInfo.time ? (Pe(this, e, ho).call(this, H), (N = this._onDeath) == null || N.call(this, H)) : O = !0) } O || (this.visible = !1), Pe(this, e, uo).call(this) } } this.simulation.compute()
        } spawn(d = {}) { var _, x; if (this._instanceInfo.length >= this.particlesCount) return -1; const p = Pe(this, e, co).call(this, renderInfo.time + (d.expiration || 1)), f = []; return (_ = d.data) == null || _.forEach(b => { typeof b == "number" ? f.push(b) : Array.isArray(b) && f.push(...b) }), this._simInitTexture.image.data.set(f, p * this._pixelsPerInstance * 4), this._simInitTexture.needsUpdate = !0, this.visible = !0, (x = this._onSpawn) == null || x.call(this, p), p } setVisibleAt(d, p) { Pe(this, e, Ea).call(this, d), this._instanceInfo[d].visible = p } dispose() { var d; this._indirectTexture.dispose(), this._indirectTexture = null, this._simInitTexture.dispose(), this._simInitTexture = null, this.simulation.dispose(), this.simulation = null, (d = super.dispose) == null || d.call(this) }
    }, e = new WeakSet, lo = function (d, p) { return d - p }, Ea = function (d) { if (d < 0 || d >= this._instanceInfo.length || this._instanceInfo[d].active === !1) throw new Error(`particlesGPU: Invalid instanceId ${d}. Instance is either out of range or has been deleted.`) }, co = function (d = 1 / 0) { if (this._instanceInfo.length >= this.particlesCount && this._availableInstanceIds.length === 0) throw new Error("particlesGPU: Maximum item count reached."); const f = { visible: !0, active: !0, expiration: d }; let _ = null; return this._availableInstanceIds.length > 0 ? (this._availableInstanceIds.sort(Pe(this, e, lo)), _ = this._availableInstanceIds.shift(), this._instanceInfo[_] = f) : (_ = this._instanceInfo.length, this._instanceInfo.push(f)), _ }, ho = function (d) { Pe(this, e, Ea).call(this, d), this._instanceInfo[d].active = !1, this._availableInstanceIds.push(d) }, uo = function () { let d = 0; for (let p = 0; p < this._instanceInfo.length; p++) { const f = this._instanceInfo[p]; !f.active || !f.visible || (this._indirectTexture.image.data[d] = p, d++) } this._indirectTexture.needsUpdate = !0, d = Math.max(1, d), this.isPoints ? this.geometry.setDrawRange(0, d) : this.count = d }, c
} function particlesGPU$1(r = {}, e = {}) { const i = !r.geometry || r.geometry === "points", s = r.count || 128, a = createParticlesGeometry({ geometry: r.geometry, createPoints: i, count: s }), o = particlesGPU(i ? Points : InstancedMesh); return new o({ geometry: a, material: r.material, count: s, onSpawn: r.onSpath, onDeath: r.onDeath }, e) } var slugvs_default = `attribute vec2 posnorm;
attribute vec4 texcoord;
attribute vec4 jacobian;
attribute vec4 banding;
attribute vec4 color;

varying vec2 vTexCoord;
varying vec4 vColor;
flat varying vec4 vBanding;
flat varying ivec4 vGlyph;

void GlyphUnpack(vec4 tex, vec4 bnd) {
    uvec2 g = floatBitsToUint(tex.zw);
    vGlyph = ivec4(g.x & 0xFFFFU, g.x >> 16U, g.y & 0xFFFFU, g.y >> 16U);
    vBanding = bnd;
}

vec3 SlugVS(vec4 color, vec2 dim, mat4 mvpMatrix) {
    
    mat4 mvp = mvpMatrix; 
    mat4 mvp_row = transpose(mvp);
    vec4 m0 = mvp_row[0];
    vec4 m1 = mvp_row[1];
    vec4 m3 = mvp_row[3];
    vec4 pos = vec4(position.xy, posnorm.xy);
    vec4 tex = texcoord;
    vec4 jac = jacobian;
    GlyphUnpack(texcoord, banding);
    vColor = color;

    
    vec2 n = normalize(pos.zw);
    float s = dot(m3.xy, pos.xy) + m3.w;
    float t = dot(m3.xy, n);

    float u = (s * dot(m0.xy, n) - t * (dot(m0.xy, pos.xy) + m0.w)) * dim.x;
    float v = (s * dot(m1.xy, n) - t * (dot(m1.xy, pos.xy) + m1.w)) * dim.y;

    float s2 = s * s;
    float st = s * t;
    float uv = u * u + v * v;
    vec2 d = pos.zw * (s2 * (st + sqrt(uv)) / (uv - st * st));

    vTexCoord = (vec2(tex.x + dot(d, jac.xy), tex.y + dot(d, jac.zw)));

    return vec3(pos.xy + d, 0.0);
}

vec3 SlugVS(mat4 mvpMatrix) {
    return SlugVS(color, resolution.xy, mvpMatrix);
}

vec3 SlugVS(vec2 dim) {
    return SlugVS(color, dim, projectionMatrix * modelViewMatrix);
}

vec3 SlugVS() {
    return SlugVS(resolution.xy);
}`, slugfs_default = `#define kLogBandTextureWidth 12
#define saturate(x) clamp(x, 0.0, 1.0)

varying vec2 vTexCoord;
varying vec4 vColor;
flat varying vec4 vBanding;
flat varying ivec4 vGlyph;

uint CalcRootCode(float y1, float y2, float y3) {
    uint i1 = floatBitsToUint(y1) >> 31U;
    uint i2 = floatBitsToUint(y2) >> 30U;
    uint i3 = floatBitsToUint(y3) >> 29U;

    uint shift = (i2 & 2U) | (i1 & ~2U);
    shift = (i3 & 4U) | (shift & ~4U);

    return ((0x2E74U >> shift) & 0x0101U);
}

bool TestCurve(uint code) {return (code != 0U);}
bool TestRoot1(uint code) {return ((code & 1U) != 0U);}
bool TestRoot2(uint code) {return (code > 1U);}

vec2 SolveHorizPoly(vec4 p12, vec2 p3) {
    vec2 a = p12.xy - p12.zw * 2.0 + p3;
    vec2 b = p12.xy - p12.zw;
    float ra = 1.0 / a.y;
    float rb = 0.5 / b.y;

    float d = sqrt(max(b.y * b.y - a.y * p12.y, 0.0));
    float t1 = (b.y - d) * ra;
    float t2 = (b.y + d) * ra;

    if (abs(a.y) < 1.0 / 65536.0) t1 = t2 = p12.y * rb;

    return (vec2((a.x * t1 - b.x * 2.0) * t1 + p12.x, (a.x * t2 - b.x * 2.0) * t2 + p12.x));
}

vec2 SolveVertPoly(vec4 p12, vec2 p3) {
    vec2 a = p12.xy - p12.zw * 2.0 + p3;
    vec2 b = p12.xy - p12.zw;
    float ra = 1.0 / a.x;
    float rb = 0.5 / b.x;

    float d = sqrt(max(b.x * b.x - a.x * p12.x, 0.0));
    float t1 = (b.x - d) * ra;
    float t2 = (b.x + d) * ra;

    if (abs(a.x) < 1.0 / 65536.0) t1 = t2 = p12.x * rb;

    return (vec2((a.y * t1 - b.y * 2.0) * t1 + p12.y, (a.y * t2 - b.y * 2.0) * t2 + p12.y));
}

ivec2 CalcBandLoc(ivec2 glyphLoc, uint offset) {
    ivec2 bandLoc = ivec2(glyphLoc.x + int(offset), glyphLoc.y);
    bandLoc.y += bandLoc.x >> kLogBandTextureWidth;
    bandLoc.x &= (1 << kLogBandTextureWidth) - 1;
    return (bandLoc);
}

float CalcCoverage(float xcov, float ycov, float xwgt, float ywgt, int flags) {
    float coverage = max(abs(xcov * xwgt + ycov * ywgt) / max(xwgt + ywgt, 1.0 / 65536.0), min(abs(xcov), abs(ycov)));

    coverage = saturate(coverage);

    #if defined(SLUG_WEIGHT)
        coverage = sqrt(coverage);
    #endif

    return (coverage);
}

vec4 RenderSlug(sampler2D curveData, usampler2D bandData, vec2 pixelPosition, vec4 vertexColor, vec4 bandTransform, ivec4 glyphData) {
    int curveIndex;

    vec2 renderCoord = pixelPosition;
    vec2 emsPerPixel = fwidth(renderCoord);
    vec2 pixelsPerEm = 1.0 / emsPerPixel;

    ivec2 bandMax = glyphData.zw;
    bandMax.y &= 0x00FF;

    ivec2 bandIndex = clamp(ivec2(renderCoord * bandTransform.xy + bandTransform.zw), ivec2(0, 0), bandMax);

    ivec2 glyphLoc = glyphData.xy;

    float xcov = 0.0;
    float xwgt = 0.0;

    uvec4 hbandData = texelFetch(bandData, ivec2(glyphLoc.x + bandIndex.y, glyphLoc.y), 0);
    ivec2 hbandLoc = CalcBandLoc(glyphLoc, hbandData.y);

    for (curveIndex = 0; curveIndex < int(hbandData.x); curveIndex++) {
        ivec2 curveLoc = ivec2(texelFetch(bandData, ivec2(hbandLoc.x + curveIndex, hbandLoc.y), 0).xy);
        vec4 p12 = texelFetch(curveData, curveLoc, 0) - vec4(renderCoord, renderCoord);
        vec2 p3 = texelFetch(curveData, ivec2(curveLoc.x + 1, curveLoc.y), 0).xy - renderCoord;

        if (max(max(p12.x, p12.z), p3.x) * pixelsPerEm.x < -0.5) break;

        uint code = CalcRootCode(p12.y, p12.w, p3.y);
        if (TestCurve(code)) {
            vec2 r = SolveHorizPoly(p12, p3) * pixelsPerEm.x;

            if (TestRoot1(code)) {
                xcov += saturate(r.x + 0.5);
                xwgt = max(xwgt, saturate(1.0 - abs(r.x) * 2.0));
            }

            if (TestRoot2(code)) {
                xcov -= saturate(r.y + 0.5);
                xwgt = max(xwgt, saturate(1.0 - abs(r.y) * 2.0));
            }
        }
    }

    float ycov = 0.0;
    float ywgt = 0.0;

    uvec4 vbandData = texelFetch(bandData, ivec2(glyphLoc.x + bandMax.y + 1 + bandIndex.x, glyphLoc.y), 0);
    ivec2 vbandLoc = CalcBandLoc(glyphLoc, vbandData.y);

    for (curveIndex = 0; curveIndex < int(vbandData.x); curveIndex++) {
        ivec2 curveLoc = ivec2(texelFetch(bandData, ivec2(vbandLoc.x + curveIndex, vbandLoc.y), 0).xy);
        vec4 p12 = texelFetch(curveData, curveLoc, 0) - vec4(renderCoord, renderCoord);
        vec2 p3 = texelFetch(curveData, ivec2(curveLoc.x + 1, curveLoc.y), 0).xy - renderCoord;

        if (max(max(p12.y, p12.w), p3.y) * pixelsPerEm.y < -0.5) break;

        uint code = CalcRootCode(p12.x, p12.z, p3.x);
        if (TestCurve(code)) {
            vec2 r = SolveVertPoly(p12, p3) * pixelsPerEm.y;

            if (TestRoot1(code)) {
                ycov -= saturate(r.x + 0.5);
                ywgt = max(ywgt, saturate(1.0 - abs(r.x) * 2.0));
            }

            if (TestRoot2(code)) {
                ycov += saturate(r.y + 0.5);
                ywgt = max(ywgt, saturate(1.0 - abs(r.y) * 2.0));
            }
        }
    }

    float coverage = CalcCoverage(xcov, ycov, xwgt, ywgt, glyphData.w);

    return vec4(vertexColor.xyz, coverage);
}

vec4 SlugFS(sampler2D curveData, usampler2D bandData) {
    vec4 color = RenderSlug(curveData, bandData, vTexCoord, vColor, vBanding, vGlyph);
    return vec4(color.xyz, color.w * vColor.w);
}`, falloff_default = `float _linstep(float begin, float end, float t) {
    return clamp((t - begin) / (end - begin), 0.0, 1.0);
}

float _pl(vec2 _input, vec2 start, vec2 end, float margin, float progress) {
    vec2 v = end - start;
    float dist = length(v);
    vec2 dir = v / dist;
    return dot(dir, _input - start - dir * (dist + margin) * progress);
}

float _pl(vec3 _input, vec3 start, vec3 end, float margin, float progress) {
    vec3 v = end - start;
    float dist = length(v);
    vec3 dir = v / dist;
    return dot(dir, _input - start - dir * (dist + margin) * progress);
}

float falloff(float _input, float start, float end, float margin, float progress) {
    float m = margin * sign(end - start);
    float p = mix(start - m, end, progress);
    return _linstep(p + m, p, _input);
}

float falloffsmooth(float _input, float start, float end, float margin, float progress) {
    float m = margin * sign(end - start);
    float p = mix(start - m, end, progress);
    return smoothstep(p + m, p, _input);
}

float falloff(vec2 _input, vec2 start, vec2 end, float margin, float progress) {
    return _linstep(0.0, -margin, _pl(_input, start, end, margin, progress));
}

float falloffsmooth(vec2 _input, vec2 start, vec2 end, float margin, float progress) {
    return smoothstep(0.0, -margin, _pl(_input, start, end, margin, progress));
}

float falloff(vec3 _input, vec3 start, vec3 end, float margin, float progress) {
    return _linstep(0.0, -margin, _pl(_input, start, end, margin, progress));
}

float falloffsmooth(vec3 _input, vec3 start, vec3 end, float margin, float progress) {
    return smoothstep(0.0, -margin, _pl(_input, start, end, margin, progress));
}`; const ANIMATIONS = { letter: 1, word: 2, line_letter: 3, line_word: 4, line: 5 }; async function createFontMaterial({ font: r, animationMask: e, animationTranslate: i, small: s } = {}) {
    const [a, o] = await Promise.all([glyphLoader.loadTexture(r, "curve"), glyphLoader.loadTexture(r, "band")]); return new ShaderMaterial({
        defines: { ...i ? { ANIMATION_TRANSLATE: ANIMATIONS[i] } : {}, ...e ? { ANIMATION_MASK: ANIMATIONS[e] } : {}, ...s ? { SLUG_WEIGHT: 1 } : {} }, uniformsGroups: [global$1.UBO], uniforms: { tCurve: { value: a }, tBand: { value: o }, uAnimationOrder: { value: 0 }, uAnimationDirection: { value: new Vector2(0, 1) }, uAnimationMargin: { value: .5 }, uAnimationProgress: { value: 0 } }, vertexShader: `
            #if defined(ANIMATION_TRANSLATE) || defined(ANIMATION_MASK)
                attribute vec2 textWeights;
                attribute vec3 lineWeights;
                uniform vec2 uAnimationDirection;
                uniform float uAnimationOrder;
                uniform float uAnimationMargin;
                uniform float uAnimationProgress;
                varying float vAlpha;
                ${falloff_default}
            #endif

            ${globalUBO_default}
            ${slugvs_default}

            void main() {
                vec3 pos = SlugVS();

                #if defined(ANIMATION_TRANSLATE) || defined(ANIMATION_MASK)
                float weight = 0.0;
                #endif

                #if defined(ANIMATION_TRANSLATE)
                    #if ANIMATION_TRANSLATE == 1
                        weight = textWeights.x;
                    #elif ANIMATION_TRANSLATE == 2
                        weight = textWeights.y;
                    #elif ANIMATION_TRANSLATE == 3
                        weight = lineWeights.x;
                    #elif ANIMATION_TRANSLATE == 4
                        weight = lineWeights.y;
                    #elif ANIMATION_TRANSLATE == 5
                        weight = lineWeights.z;
                    #endif
                #endif

                #if defined(ANIMATION_MASK)
                    #if ANIMATION_MASK == 1
                        weight = textWeights.x;
                    #elif ANIMATION_MASK == 2
                        weight = textWeights.y;
                    #elif ANIMATION_MASK == 3
                        weight = lineWeights.x;
                    #elif ANIMATION_MASK == 4
                        weight = lineWeights.y;
                    #elif ANIMATION_MASK == 5
                        weight = lineWeights.z;
                    #endif
                #endif

                #if defined(ANIMATION_TRANSLATE) || defined(ANIMATION_MASK)
                    float a = falloffsmooth(abs(uAnimationOrder - weight), 0.0, 1.0, uAnimationMargin, clamp(uAnimationProgress, 0.0, 1.0));
                #endif

                #ifdef ANIMATION_TRANSLATE
                    vAlpha = a;
                    pos += vec3(uAnimationDirection, 0.0) * (1.0 - vAlpha);
                #endif

                #ifdef ANIMATION_MASK
                    vAlpha = 1.0;
                    vTexCoord += uAnimationDirection * (1.0 - a);
                #endif

                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
        `, fragmentShader: `
            uniform sampler2D tCurve;
            uniform usampler2D tBand;

            ${slugfs_default}

            #if defined(ANIMATION_TRANSLATE) || defined(ANIMATION_MASK)
                varying float vAlpha;
            #endif

            void main() {
                vec4 color = SlugFS(tCurve, tBand);

                #if defined(ANIMATION_TRANSLATE) || defined(ANIMATION_MASK)
                    color.a *= vAlpha;
                #endif

                gl_FragColor = color;
            }
        `, transparent: !0, depthWrite: !1
    })
} const startGeo = new PlaneGeometry().scale(1e-10, 1e-10, 1e-10), tagsRegex = /({#[\s\S]*?})/g; var Fi, Gs, Vs; class meshText extends Mesh { constructor(i = {}, s = null) { if (!i.font) throw new Error("You must specify a .font file."); super(startGeo); pe(this, Fi, {}); pe(this, Gs, !1); pe(this, Vs, !1); Xe(this, Fi, i), Xe(this, Gs, i.animationMask || !1), Xe(this, Vs, i.animationTranslate || !1), this.name = "Text (Font)", this.bboxSize = new Vector2, this.size = new Vector2, this.topAlign = 0, this.ready = miscutils.deferred(), this.update().then(() => s || createFontMaterial({ font: L(this, Fi).font, animationMask: L(this, Gs), animationTranslate: L(this, Vs), small: i.small || !1 })).then(a => { this.material = a, this.ready.resolve() }) } static getTextWithoutTags(i = "") { return i.replace(tagsRegex, "") } _updateSize() { const i = this.geometry._fontMetrics; this.topAlign = i.size * Math.abs(i.ascent - i.descent), this.lineSize = i.size * i.lineHeight, this.bboxSize.set(Math.abs(this.geometry.boundingBox.min.x - this.geometry.boundingBox.max.x), Math.abs(this.geometry.boundingBox.min.y - this.geometry.boundingBox.max.y)), this.size.set(this.bboxSize.x, this.lineSize * Math.max(0, i.lines - 1)) } setText(i = "", s = !0) { L(this, Fi).text = i, s && this.update() } async update(i = {}) { try { const s = this.geometry; Xe(this, Fi, { ...L(this, Fi), ...i }), this.geometry = await glyphLoader.loadGeometry(L(this, Fi).font, L(this, Fi)), this._updateSize(), s.dispose() } catch (s) { console.log("Error updating meshText geometry:", s) } } } Fi = new WeakMap, Gs = new WeakMap, Vs = new WeakMap; var msdf_default = `float screenPxRange(float pxRange, sampler2D tMap, vec2 uv) {
    vec2 unitRange = pxRange / vec2(textureSize(tMap, 0));
    vec2 screenTexSize = 1.0 / fwidth(uv);
    return max(0.5 * dot(unitRange, screenTexSize), 1.0);
}

float median(sampler2D tMap, vec2 uv) {
    vec3 tex = texture2D(tMap, uv).rgb;
    return max(min(tex.r, tex.g), min(max(tex.r, tex.g), tex.b));
}

float msdf(sampler2D tMap, vec2 uv, float pxRange) {
    float signedDist = median(tMap, uv);
    float screenPxDistance = screenPxRange(pxRange, tMap, uv) * (signedDist - 0.5);
    return clamp(screenPxDistance + 0.5, 0.0, 1.0);
}

const float DEFAULT_PXRANGE = 6.0;

float msdf(sampler2D tMap, vec2 uv) {
    return msdf(tMap, uv, DEFAULT_PXRANGE);
}`; new Vector3; new Vector3; new Vector3; new Vector3; console.log(" by https://abeto.co"); const _v0$h = new Vector3, _v1$b = new Vector3; class audioController { constructor(e) { this.mainController = e, this.camera = null, this._controller = new audioController$1({ volume: 1, muted: !0 }), events.on("prerender", this.updateCamera, this), this.init() } get muted() { return this._controller.muted } updateCamera() { if (!this.camera) return; _v0$h.set(0, 0, -1).applyQuaternion(this.camera.quaternion), _v1$b.set(0, 1, 0).applyQuaternion(this.camera.quaternion); const e = this._controller.listener.context, i = e.listener, s = e.currentTime, a = renderInfo.delta / 1e3, o = s + a; i.positionX ? (i.positionX.linearRampToValueAtTime(this.camera.position.x, o), i.positionY.linearRampToValueAtTime(this.camera.position.y, o), i.positionZ.linearRampToValueAtTime(this.camera.position.z, o), i.forwardX.linearRampToValueAtTime(_v0$h.x, o), i.forwardY.linearRampToValueAtTime(_v0$h.y, o), i.forwardZ.linearRampToValueAtTime(_v0$h.z, o), i.upX.linearRampToValueAtTime(_v1$b.x, o), i.upY.linearRampToValueAtTime(_v1$b.y, o), i.upZ.linearRampToValueAtTime(_v1$b.z, o)) : (i.setPosition(this.camera.position.x, this.camera.position.y, this.camera.position.z), i.setOrientation(_v0$h.x, _v0$h.y, _v0$h.z, _v1$b.x, _v1$b.y, _v1$b.z)) } init() { this.positionals = {}, events.on("webgl_set_audio_volume", this.setAudioVolume, this), events.on("webgl_play_audio", this.playAudio, this), events.on("webgl_stop_audio", this.stopAudio, this), events.on("webgl_play_positional", this.playPositional, this), events.on("webgl_stop_positional", this.stopPositional, this); const e = client$1.lowMemoryDevice ? "music/bgmusic-mobile.ogg" : "music/bgmusic-highq.ogg"; if (this._controller.addAudio({ name: "bgmusic", url: e, volume: .1, autoPlay: !0, loop: !0 }), client$1.lowMemoryDevice) { this._controller.addAudio({ name: "quest-complete", url: "ui/quest-complete.ogg", volume: .25 }); return } this._controller.addAudio({ name: "intro-letters", url: "intro/letters.ogg", volume: .1 }), this._controller.addAudio({ name: "button-turn", url: "intro/button-turn.ogg", volume: .1, minTimeBetweenPlays: .2 }), this._controller.addAudio({ name: "button-out", url: "intro/button-out.ogg", volume: .075 }), this._controller.addAudio({ name: "rune1", url: "intro/rune1.ogg", volume: .1, minTimeBetweenPlays: .2 }), this._controller.addAudio({ name: "rune2", url: "intro/rune2.ogg", volume: .1, minTimeBetweenPlays: .2 }), this._controller.addAudio({ name: "rune3", url: "intro/rune3.ogg", volume: .1, minTimeBetweenPlays: .2 }), this._controller.addAudio({ name: "rune4", url: "intro/rune4.ogg", volume: .1, minTimeBetweenPlays: .2 }), this._controller.addAudio({ name: "ambiance-base", url: "ambiances/base.ogg", volume: 0, autoPlay: !0, loop: !0 }), this._controller.addAudio({ name: "ambiance-forest", url: "ambiances/forest.ogg", volume: 0, autoPlay: !0, loop: !0 }), this._controller.addAudio({ name: "ambiance-city", url: "ambiances/city.ogg", volume: 0, autoPlay: !0, loop: !0 }), this._controller.addAudio({ name: "ambiance-factory", url: "ambiances/factory.ogg", volume: 0, autoPlay: !0, loop: !0 }), this._controller.addAudio({ name: "ambiance-beach", url: "ambiances/beach.ogg", volume: 0, autoPlay: !0, loop: !0 }), this._controller.addAudio({ name: "ambiance-waterfalls", url: "ambiances/waterfalls.ogg", volume: 0, autoPlay: !0, loop: !0 }), this._controller.addAudio({ name: "ambiance-temple", url: "ambiances/temple.ogg", volume: 0, autoPlay: !0, loop: !0 }), this._controller.addAudio({ name: "footsteps", url: "character/footsteps4.ogg", volume: 0, autoPlay: !0, loop: !0, sync: !0 }), this._controller.addAudio({ name: "footsteps-water", url: "character/footsteps-water.ogg", volume: 0, autoPlay: !0, loop: !0, sync: !0 }), this._controller.addAudio({ name: "jump", url: "character/jump-start.ogg", volume: .1 }), this._controller.addAudio({ name: "land", url: "character/jump-land.ogg", volume: .125 }), this._controller.addAudio({ name: "emoji-starts1", url: "character/emoji-starts1.ogg", volume: .15 }), this._controller.addAudio({ name: "emoji-starts2", url: "character/emoji-starts2.ogg", volume: .15 }), this._controller.addAudio({ name: "emoji-starts3", url: "character/emoji-starts3.ogg", volume: .15 }), this._controller.addAudio({ name: "emoji-ends1", url: "character/emoji-ends1.ogg", volume: .1 }), this._controller.addAudio({ name: "emoji-ends2", url: "character/emoji-ends2.ogg", volume: .1 }), this._controller.addAudio({ name: "emoji-ends3", url: "character/emoji-ends3.ogg", volume: .1 }), this._controller.addAudio({ name: "clothes", url: "character/clothes.ogg", volume: .2 }), this._controller.addAudio({ name: "zoom-off", url: "camera/zoom-off-5.ogg", volume: .1 }), this._controller.addAudio({ name: "zoom-in", url: "camera/zoom-in-5.ogg", volume: .1 }), this._controller.addAudio({ name: "whoosh", url: "camera/whoosh2.ogg", volume: .2 }), this._controller.addAudio({ name: "title", url: "ui/title.ogg", volume: .25 }), this._controller.addAudio({ name: "buttons", url: "ui/buttons2.ogg", volume: .05 }), this._controller.addAudio({ name: "hover2", url: "ui/hover2.ogg", volume: .2 }), this._controller.addAudio({ name: "click2", url: "ui/click2.ogg", volume: .15 }), this._controller.addAudio({ name: "click3", url: "ui/click3.ogg", volume: .05 }), this._controller.addAudio({ name: "open-box1", url: "ui/openbox1.ogg", volume: .1 }), this._controller.addAudio({ name: "open-box2", url: "ui/openbox2.ogg", volume: .15 }), this._controller.addAudio({ name: "open-box-emote", url: "ui/openbox-emote.ogg", volume: .15 }), this._controller.addAudio({ name: "open-box-checklist", url: "ui/openbox-checklist.ogg", volume: .6 }), this._controller.addAudio({ name: "paper1", url: "ui/paper1.ogg", volume: 0, autoPlay: !0, loop: !0, sync: !1 }), this._controller.addAudio({ name: "paper4", url: "ui/paper4.ogg", volume: 0, autoPlay: !0, loop: !0, sync: !1, offset: 3 }), this._controller.addAudio({ name: "nastroit", url: "ui/customize.ogg", volume: .06 }), this._controller.addAudio({ name: "quest-complete", url: "ui/quest-complete.ogg", volume: .25 }), this._controller.addAudio({ name: "dialogue-quest", url: "dialogues/quest.ogg", volume: 0, autoPlay: !0, loop: !0, sync: !1 }); const i = 2, s = 1; this._controller.addPositionalAudio({ name: "dialogue-male1", url: "dialogues/male1.ogg", volume: 0, autoPlay: !1, refDistance: i, rolloffFactor: s }).then(a => this.positionals["dialogue-male1"] = a), this._controller.addPositionalAudio({ name: "dialogue-male2", url: "dialogues/male2.ogg", volume: 0, autoPlay: !1, refDistance: i, rolloffFactor: s }).then(a => this.positionals["dialogue-male2"] = a), this._controller.addPositionalAudio({ name: "dialogue-male3", url: "dialogues/male3.ogg", volume: 0, autoPlay: !1, refDistance: i, rolloffFactor: s }).then(a => this.positionals["dialogue-male3"] = a), this._controller.addPositionalAudio({ name: "dialogue-female1", url: "dialogues/female1.ogg", volume: 0, autoPlay: !1, refDistance: i, rolloffFactor: s }).then(a => this.positionals["dialogue-female1"] = a), this._controller.addPositionalAudio({ name: "dialogue-female2", url: "dialogues/female2.ogg", volume: 0, autoPlay: !1, refDistance: i, rolloffFactor: s }).then(a => this.positionals["dialogue-female2"] = a), this._controller.addPositionalAudio({ name: "dialogue-female3", url: "dialogues/female3.ogg", volume: 0, autoPlay: !1, refDistance: i, rolloffFactor: s }).then(a => this.positionals["dialogue-female3"] = a), this._controller.addPositionalAudio({ name: "dialogue-wtf", url: "dialogues/wtf.ogg", volume: 0, autoPlay: !1, refDistance: i, rolloffFactor: s }).then(a => this.positionals["dialogue-wtf"] = a), this._controller.addPositionalAudio({ name: "bubble-starts", url: "character/bubble-starts.ogg", volume: 0, autoPlay: !1, loop: !1, refDistance: 2, rolloffFactor: .3 }).then(a => this.positionals["bubble-starts"] = a), this._controller.addPositionalAudio({ name: "bubble-ends", url: "character/bubble-ends.ogg", volume: 0, autoPlay: !1, loop: !1, refDistance: 2, rolloffFactor: .3 }).then(a => this.positionals["bubble-ends"] = a), this._controller.addPositionalAudio({ name: "dialogue-music-dave", url: "music/musician.ogg", volume: 0, autoPlay: !1, loop: !0, distanceModel: "linear", refDistance: 2.5, rolloffFactor: 1, maxDistance: 12 }).then(a => this.positionals["dialogue-music-dave"] = a) } setAudioVolume(e, i = 1) { this._controller.setAudioVolume(e, i) } playAudio(e) { this._controller.playAudio(e) } stopAudio(e) { this._controller.stopAudio(e) } ensurePositionalVolume(e) { e.__animVol === void 0 && (e.__animVol = { value: 0 }) } playPositional(e, i, s = .5, a = 0, o = !1) { this.positionals[e] && (i.isWorldNPC && e.startsWith("dialogue") ? (this.ensurePositionalVolume(this.positionals[e]), this._controller.setAudioVolume(e, 0), createTween(this.positionals[e].__animVol, { to: { value: s }, duration: .2, onStart: () => { i.add(this.positionals[e]), this.positionals[e].offset = Math.random() * this.positionals[e].buffer.duration, this._controller.playAudio(e, a) }, onUpdate: () => { this._controller.setAudioVolume(e, this.positionals[e].__animVol.value) } })) : o && (i.add(this.positionals[e]), this._controller.setAudioVolume(e, s), this._controller.playAudio(e, a))) } stopPositional(e, i) { this.positionals[e] && (this.ensurePositionalVolume(this.positionals[e]), createTween(this.positionals[e].__animVol, { to: { value: 0 }, duration: .2, onUpdate: () => { this._controller.setAudioVolume(e, this.positionals[e].__animVol.value) }, onComplete: () => { this.positionals[e].removeFromParent(), this._controller.stopAudio(e) } })) } } var colorutils_default = `float luma(float color) {
    return color;
}

float luma(vec3 color) {
    return dot(color, vec3(0.299, 0.587, 0.114));
}

float luma(vec4 color) {
    return dot(color.rgb, vec3(0.299, 0.587, 0.114));
}

vec3 rgb2hsv(vec3 c) {
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6. * d + e)), d / (q.x + e), q.x);
}

vec4 rgb2hsv(vec4 c) {
    return vec4(rgb2hsv(c.rgb), c.a);
}

vec3 hsv2rgb(vec3 c) {
    vec3 rgb = clamp(abs(mod(c.x * 6. + vec3(0., 4., 2.), 6.) - 3.) - 1., 0., 1.);
    return c.z * mix(vec3(1.), rgb, c.y);
}

vec4 hsv2rgb(vec4 c) {
    return vec4(hsv2rgb(c.rgb), c.a);
}

vec3 colorpalette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {
    return a + b * cos(6.28318 * (c * t + d));
}

vec4 colorpalette(float t, vec4 a, vec4 b, vec4 c, vec4 d) {
    return a + b * cos(6.28318 * (c * t + d));
}

float brightnessContrast(float color, float brightness, float contrast) {
    return (color - 0.5) * contrast + 0.5 + brightness;
}

vec3 brightnessContrast(vec3 color, float brightness, float contrast) {
    return (color - 0.5) * contrast + 0.5 + brightness;
}

vec4 brightnessContrast(vec4 color, float brightness, float contrast) {
    return vec4(brightnessContrast(color.rgb, brightness, contrast), color.a);
}

vec3 saturation(vec3 color, float adjustment) {
    const vec3 W = vec3(0.2125, 0.7154, 0.0721);
    vec3 intensity = vec3(dot(color, W));
    return mix(intensity, color, adjustment);
}

vec4 saturation(vec4 color, float adjustment) {
    return vec4(saturation(color.rgb, adjustment), color.a);
}

vec3 vibrance(vec3 color, float v) {
    float average = (color.r + color.g + color.b) / 3.0;
    float mx = max(color.r, max(color.g, color.b));
    float amt = (mx - average) * (-v * 3.0);
    return mix(color.rgb, vec3(mx), amt);
}

vec4 vibrance(vec4 color, float v) {
    return vec4(vibrance(color.rgb, v), color.a);
}`; class baseShader extends ShaderMaterial {
    constructor() {
        super({
            uniformsGroups: [global$1.UBO], uniforms: { tScene: { value: null }, uWipe1: { value: 1 }, uWipe2: { value: 0 }, uWipeColor: { value: new Color("#ffffff") }, uFlash: { value: 0 }, uOverlay: { value: 0 }, uOverlayColor: { value: new Color("#283436") } }, vertexShader: `
                varying vec2 vUv;

                void main() {
                    vUv = uv;
                    gl_Position = vec4(position, 1.0);
                }
            `, fragmentShader: `
                ${globalUBO_default}
                ${falloff_default}
                ${colorutils_default}

                uniform sampler2D tScene;
                uniform float uWipe1;
                uniform float uWipe2;
                uniform vec3 uWipeColor;
                uniform float uOverlay;
                uniform vec3 uOverlayColor;
                uniform float uFlash;

                varying vec2 vUv;

                void main() {
                    vec4 scene = texture2D(tScene, vUv);
                    vec3 color = scene.rgb;

                    // overlay
                    color = mix(color, uOverlayColor, clamp(uOverlay, 0.0, 1.0) * 0.9);

                    // wipes
                    if (uFlash > 0.0) {
                        color = vibrance(color, uFlash * 1.0);
                        color = brightnessContrast(color, uFlash, 1.0);
                    }

                    float inclination1 = 0.3 * uWipe1;
                    float uv1 = vUv.y - (1.0 - vUv.x) * inclination1;
                    float wipe1 = falloff(uv1, 1.0, -inclination1, 1e-6, uWipe1);

                    float inclination2 = 0.3 * (1.0 - uWipe2);
                    float uv2 = vUv.y - vUv.x * inclination2;
                    float wipe2 = falloff(uv2, -inclination2, 1.0, 1e-6, uWipe2);

                    color = mix(color, uWipeColor, wipe1);
                    color = mix(color, uWipeColor, wipe2);

                    gl_FragColor = vec4(color, 1.0);
                }
            `, depthTest: !1, depthWrite: !1
        })
    }
} var depth_default = `float getDepth(sampler2D depth, vec2 uv) {
    return texture(depth, uv).x;
}

float linearizeDepthLog(float depth, float near, float far) {
    float d = pow(2.0, depth * log2(far + 1.0)) - 1.0;
    float a = far / (far - near);
    float b = far * near / (near - far);
    return a + b / d;
}

float perspectiveDepthToViewZ(float depth, float near, float far) {
    return (near * far) / ((far - near) * depth - far);
}

float orthographicDepthToViewZ(float depth, float near, float far) {
    return depth * (near - far) - near;
}

float viewZToPerspectiveDepth(float viewZ, float near, float far) {
	return ((near + viewZ) * far) / ((far - near) * viewZ);
}

float viewZToOrthographicDepth(float viewZ, float near, float far) {
	return (viewZ + near) / (near - far);
}

float getViewZ(float depth, float near, float far) {
    float fragCoordZ = depth;

    #ifdef ORTHOGRAPHIC_CAMERA
        return orthographicDepthToViewZ(fragCoordZ, near, far);
    #else
        #ifdef LOGDEPTH
            fragCoordZ = linearizeDepthLog(fragCoordZ, near, far);
        #endif
        return perspectiveDepthToViewZ(fragCoordZ, near, far);
    #endif
}

float getViewZ(sampler2D depth, vec2 uv, float near, float far) {
    return getViewZ(getDepth(depth, uv), near, far);
}

float getLinearDepth(float depth, float near, float far) {
    float fragCoordZ = depth;

    #ifdef ORTHOGRAPHIC_CAMERA
        return fragCoordZ;
    #else
        #ifdef LOGDEPTH
            fragCoordZ = linearizeDepthLog(fragCoordZ, near, far);
        #endif
        float viewZ = perspectiveDepthToViewZ(fragCoordZ, near, far);
        return viewZToOrthographicDepth(viewZ, near, far);
    #endif
}

float getLinearDepth(sampler2D depth, vec2 uv, float near, float far) {
    return getLinearDepth(getDepth(depth, uv), near, far);
}

vec3 getViewPosition(float depth, vec2 uv, float near, float far, mat4 projMat) {
    float viewZ = getViewZ(depth, near, far);

    #ifdef LOGDEPTH
        float d = linearizeDepthLog(depth, near, far);
    #else
        float d = depth;
    #endif

    float clipW = projMat[2][3] * viewZ + projMat[3][3];
    vec4 clipPosition = vec4((vec3(uv, d) - 0.5) * 2.0, 1.0);
    clipPosition *= clipW; 
    return (inverse(projMat) * clipPosition).xyz;
}

vec3 getViewPosition(sampler2D depth, vec2 uv, float near, float far, mat4 projMat) {
    return getViewPosition(getDepth(depth, uv), uv, near, far, projMat);
}

vec3 getWorldPosition(float depth, vec2 uv, float near, float far, mat4 projMat, mat4 worldMat) {
    return (worldMat * vec4(getViewPosition(depth, uv, near, far, projMat), 1.0)).xyz;
}

vec3 getWorldPosition(sampler2D depth, vec2 uv, float near, float far, mat4 projMat, mat4 worldMat) {
    return (worldMat * vec4(getViewPosition(getDepth(depth, uv), uv, near, far, projMat), 1.0)).xyz;
}

vec3 getViewNormal(sampler2D depth, vec2 uv, float near, float far, mat4 projMat) {
    vec2 depthres = vec2(textureSize(depth, 0));
    ivec2 p = ivec2(uv * depthres);
    float c0 = texelFetch(depth, p, 0).x;
    float l2 = texelFetch(depth, p - ivec2(2, 0), 0).x;
    float l1 = texelFetch(depth, p - ivec2(1, 0), 0).x;
    float r1 = texelFetch(depth, p + ivec2(1, 0), 0).x;
    float r2 = texelFetch(depth, p + ivec2(2, 0), 0).x;
    float b2 = texelFetch(depth, p - ivec2(0, 2), 0).x;
    float b1 = texelFetch(depth, p - ivec2(0, 1), 0).x;
    float t1 = texelFetch(depth, p + ivec2(0, 1), 0).x;
    float t2 = texelFetch(depth, p + ivec2(0, 2), 0).x;

    float dl = abs((2.0 * l1 - l2) - c0);
    float dr = abs((2.0 * r1 - r2) - c0);
    float db = abs((2.0 * b1 - b2) - c0);
    float dt = abs((2.0 * t1 - t2) - c0);

    vec3 ce = getViewPosition(c0, uv, near, far, projMat).xyz;

    vec3 dpdx = (dl < dr) ? ce - getViewPosition(l1, (uv - vec2(1.0 / depthres.x, 0.0)), near, far, projMat).xyz
                          : -ce + getViewPosition(r1, (uv + vec2(1.0 / depthres.x, 0.0)), near, far, projMat).xyz;
    vec3 dpdy = (db < dt) ? ce - getViewPosition(b1, (uv - vec2(0.0, 1.0 / depthres.y)), near, far, projMat).xyz
                          : -ce + getViewPosition(t1, (uv + vec2(0.0, 1.0 / depthres.y)), near, far, projMat).xyz;
    return normalize(cross(dpdx, dpdy));
}

vec3 getWorldNormal(sampler2D depth, vec2 uv, float near, float far, mat4 projMat, mat4 worldMat) {
    vec2 depthres = vec2(textureSize(depth, 0));
    ivec2 p = ivec2(uv * depthres);
    float c0 = texelFetch(depth, p, 0).x;
    float l2 = texelFetch(depth, p - ivec2(2, 0), 0).x;
    float l1 = texelFetch(depth, p - ivec2(1, 0), 0).x;
    float r1 = texelFetch(depth, p + ivec2(1, 0), 0).x;
    float r2 = texelFetch(depth, p + ivec2(2, 0), 0).x;
    float b2 = texelFetch(depth, p - ivec2(0, 2), 0).x;
    float b1 = texelFetch(depth, p - ivec2(0, 1), 0).x;
    float t1 = texelFetch(depth, p + ivec2(0, 1), 0).x;
    float t2 = texelFetch(depth, p + ivec2(0, 2), 0).x;

    float dl = abs((2.0 * l1 - l2) - c0);
    float dr = abs((2.0 * r1 - r2) - c0);
    float db = abs((2.0 * b1 - b2) - c0);
    float dt = abs((2.0 * t1 - t2) - c0);

    vec3 ce = getWorldPosition(c0, uv, near, far, projMat, worldMat).xyz;

    vec3 dpdx = (dl < dr) ? ce - getWorldPosition(l1, (uv - vec2(1.0 / depthres.x, 0.0)), near, far, projMat, worldMat).xyz
                          : -ce + getWorldPosition(r1, (uv + vec2(1.0 / depthres.x, 0.0)), near, far, projMat, worldMat).xyz;
    vec3 dpdy = (db < dt) ? ce - getWorldPosition(b1, (uv - vec2(0.0, 1.0 / depthres.y)), near, far, projMat, worldMat).xyz
                          : -ce + getWorldPosition(t1, (uv + vec2(0.0, 1.0 / depthres.y)), near, far, projMat, worldMat).xyz;
    return normalize(cross(dpdx, dpdy));
}`, fit_default = `float efit(float x, float a1, float a2, float b1, float b2) {
    return b1 + ((x - a1) * (b2 - b1)) / (a2 - a1);
}

float fit(float x, float a1, float a2, float b1, float b2) {
    return clamp(efit(x, a1, a2, b1, b2), min(b1, b2), max(b1, b2));
}

float fit01(float x, float a1, float a2) {
    return fit(x, 0.0, 1.0, a1, a2);
}

float fit10(float x, float a1, float a2) {
    return fit(x, 1.0, 0.0, a1, a2);
}

float fit11(float x, float a1, float a2) {
    return fit(x, -1.0, 1.0, a1, a2);
}

vec3 efit(vec3 x, vec3 a1, vec3 a2, vec3 b1, vec3 b2) {
    return b1 + ((x - a1) * (b2 - b1)) / (a2 - a1);
}

vec3 fit(vec3 x, vec3 a1, vec3 a2, vec3 b1, vec3 b2) {
    return clamp(efit(x, a1, a2, b1, b2), min(b1, b2), max(b1, b2));
}

vec3 fit01(vec3 x, vec3 a1, vec3 a2) {
    return fit(x, vec3(0.0), vec3(1.0), a1, a2);
}

vec3 fit10(vec3 x, vec3 a1, vec3 a2) {
    return fit(x, vec3(1.0), vec3(0.0), a1, a2);
}

vec3 fit11(vec3 x, vec3 a1, vec3 a2) {
    return fit(x, vec3(-1.0), vec3(1.0), a1, a2);
}`, lut_default = `#ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp sampler3D;
#else
    precision mediump sampler3D;
#endif

vec3 LUTLinearTosRGB(in vec3 value) {
	return mix(pow(value.rgb, vec3(0.41666)) * 1.055 - vec3(0.055), value.rgb * 12.92, vec3(lessThanEqual(value.rgb, vec3(0.0031308))));
}
vec3 LUTsRGBToLinear(in vec3 value) {
    return mix(pow(value.rgb * 0.9478672986 + vec3(0.0521327014), vec3(2.4)), value.rgb * 0.0773993808, vec3(lessThanEqual(value.rgb, vec3(0.04045))));
}

vec3 apply3DLUT(vec3 color, sampler3D lutTexture, float lutIntensity) {
    float lutSize = float(textureSize(lutTexture, 0).x);
    float scale = (lutSize - 1.0) / lutSize;
    float offset = 1.0 / (2.0 * lutSize);

    vec3 col = LUTLinearTosRGB(color);
    vec3 rgb = col * scale + offset;
    vec4 lutColor = texture(lutTexture, rgb);
    return LUTsRGBToLinear(mix(col, lutColor.rgb, lutIntensity));
}

vec3 apply3DLUTTetrahedral(vec3 color, sampler3D lutTexture, float lutIntensity) {
    float lutSize = float(textureSize(lutTexture, 0).x);
    float scale = lutSize - 1.0;
    float offset = 0.0;
    float texelSize = 1.0 / lutSize;

    vec3 col = LUTLinearTosRGB(color);
    vec3 rgb = clamp(col, 0.0, 1.0) * scale + offset;
    vec3 p = floor(rgb);
    vec3 f = rgb - p;

    vec3 v1 = (p + 0.5) * texelSize;
    vec3 v4 = (p + 1.5) * texelSize;
    vec3 v2, v3;
    vec3 frac;

    if(f.r >= f.g) {
        if(f.g > f.b) {
            
            frac = f.rgb;
            v2 = vec3(v4.x, v1.y, v1.z);
            v3 = vec3(v4.x, v4.y, v1.z);
        } else if(f.r >= f.b) {
            
            frac = f.rbg;
            v2 = vec3(v4.x, v1.y, v1.z);
            v3 = vec3(v4.x, v1.y, v4.z);
        } else {
            
            frac = f.brg;
            v2 = vec3(v1.x, v1.y, v4.z);
            v3 = vec3(v4.x, v1.y, v4.z);
        }
    } else {
        if(f.b > f.g) {
            
            frac = f.bgr;
            v2 = vec3(v1.x, v1.y, v4.z);
            v3 = vec3(v1.x, v4.y, v4.z);
        } else if(f.r >= f.b) {
            
            frac = f.grb;
            v2 = vec3(v1.x, v4.y, v1.z);
            v3 = vec3(v4.x, v4.y, v1.z);
        } else {
            
            frac = f.gbr;
            v2 = vec3(v1.x, v4.y, v1.z);
            v3 = vec3(v1.x, v4.y, v4.z);
        }
    }

    vec4 n1 = texture(lutTexture, v1);
    vec4 n2 = texture(lutTexture, v2);
    vec4 n3 = texture(lutTexture, v3);
    vec4 n4 = texture(lutTexture, v4);

    vec4 weights = vec4(
        1.0 - frac.x,
        frac.x - frac.y,
        frac.y - frac.z,
        frac.z
    );

    vec4 result = weights * mat4(
        vec4(n1.r, n2.r, n3.r, n4.r),
        vec4(n1.g, n2.g, n3.g, n4.g),
        vec4(n1.b, n2.b, n3.b, n4.b),
        vec4(1.0)
    );

    return LUTsRGBToLinear(mix(col, result.rgb, lutIntensity));
}`, custom_default = `float outline(
    sampler2D tColor, 
    sampler2D tInfo, 
    vec2 uv, 
    float outlineWidth, 
    float scale, 
    vec3 idRange, 
    vec3 depthRange, 
    vec3 normalRange, 
    float rangeSmoothMargin, 
    float idMinScale, 
    vec2 distanceFadeRange, 
    vec2 nearFar, 

    
    inout float nearestDepth,
    inout float centDepth)
{
    vec2 offset = 1.0 / vec2(textureSize(tInfo, 0)) * outlineWidth * scale;

    
    
    float contributions[5];
    float faceIds[5];
    float depths[5];
    vec3 normals[5];

    vec2 dirs[5] = vec2[5](vec2(0, 0), vec2(-1, 0), vec2(1, 0), vec2(0, -1), vec2(0, 1)); 
    vec4 n; vec2 dir;
    #pragma unroll_loop_start
    for (int i = 0; i < 5; i++) {
        dir = dirs[i];
        n = texture(tInfo, uv + offset * dir); 
        contributions[i] = n.a; 
        depths[i] = getLinearDepth(1.0 - n.r, nearFar.x, nearFar.y);
        normals[i] = decodeNormalSpheremap(n.gb);
        faceIds[i] = texture(tColor, uv + offset * dir).a;
    }
    #pragma unroll_loop_end

    
    float centerId = faceIds[0];
    float centerDepth = depths[0];
    float centerContribution = contributions[0];
    vec3 centerNormal = normals[0];

    centDepth = centerDepth;

    vec2 idVariation = vec2((faceIds[1] - centerId) - (faceIds[2] - centerId), (faceIds[3] - centerId) - (faceIds[4] - centerId));
    vec2 depthVariation = vec2((depths[1] - centerDepth) - (depths[2] - centerDepth), (depths[3] - centerDepth) - (depths[4] - centerDepth));
    vec2 normalVariation = vec2(distance(normals[1], centerNormal) - distance(normals[2], centerNormal), distance(normals[3], centerNormal) - distance(normals[4], centerNormal));

    float idVariationTotal = sqrt((idVariation.x * idVariation.x) + (idVariation.y * idVariation.y));
    float depthVariationTotal = sqrt((depthVariation.x * depthVariation.x) + (depthVariation.y * depthVariation.y));
    float normalVariationTotal = sqrt((normalVariation.x * normalVariation.x) + (normalVariation.y * normalVariation.y));

    
    float idContribution = fit(fit(idVariationTotal, idRange.x, idRange.y, 0.0, 1.0), idRange.z, idRange.z + rangeSmoothMargin, 0.0, 1.0);
    idContribution = mix(idContribution * idMinScale, idContribution, clamp(scale, 0.0, 1.0));

    
    float normalContribution = fit(fit(normalVariationTotal, normalRange.x, normalRange.y, 0.0, 1.0), normalRange.z, normalRange.z + rangeSmoothMargin, 0.0, 1.0);

    
    float depthLimit = depthRange.z + 1.0 - centerNormal.z;
    float depthContribution = fit(fit(depthVariationTotal, depthRange.x, depthRange.y, 0.0, 1.0), depthLimit, depthLimit + rangeSmoothMargin, 0.0, 1.0);

    
    float minDepth = centerDepth;
    float minContrib = centerContribution;

    #pragma unroll_loop_start
    for (int i = 1; i < 5; i++) {
        if (depths[i] < minDepth) {
            minDepth = depths[i];
            minContrib = contributions[i];
        }
    }
    #pragma unroll_loop_end

    
    nearestDepth = minDepth;

    
    if (minDepth < centerDepth) {
        
        
        if (minContrib > centerContribution) centerContribution = max(centerContribution, ceil(minContrib));
        else centerContribution = min(centerContribution, floor(minContrib));
    }

    
    float viewZ = -orthographicDepthToViewZ(minDepth, nearFar.x, nearFar.y);
    centerContribution *= fit(viewZ, distanceFadeRange.x, distanceFadeRange.y, 1.0, 0.0);

    return clamp(idContribution + normalContribution + depthContribution, 0.0, 1.0) * centerContribution;
}`; const customUniforms$1 = { planet: { uOutlineFade: { value: new Vector2(50, 300) }, uOutlineThickness: { value: 1 }, uOutlineColor: { value: new Color("#373f42") }, uInfoRange: { value: new Vector3(1e-4, 2e-4, .1) }, uInfoMinScale: { value: .6 }, uDepthRange: { value: new Vector3(1e-4, .01001, .25) }, uNormalRange: { value: new Vector3(.4, .5, .3) }, uOutlineScale: { value: 1 }, uSmoothMargin: { value: .2 } } }; let outlines$1 = class extends ShaderMaterial {
    constructor(e) {
        super({
            uniformsGroups: [global$1.UBO], uniforms: { tDiffuse: { value: null }, tInfo: { value: null }, uCameraNear: { value: e.camera.near, ignore: !0 }, uCameraFar: { value: e.camera.far, ignore: !0 }, tLUT: { value: textureLoader.load("lut.ktx2", "luttetrahedral") }, uLUTIntensity: { value: 1 }, uOutlineFade: { value: new Vector2 }, uOutlineThickness: { value: 0 }, uOutlineColor: { value: new Color("#ff0000") }, uInfoRange: { value: new Vector3 }, uInfoMinScale: { value: 0 }, uDepthRange: { value: new Vector3 }, uNormalRange: { value: new Vector3 }, uOutlineScale: { value: 0 }, uSmoothMargin: { value: 0 } }, vertexShader: `
                ${globalUBO_default}

                varying vec2 vUv;

                void main() {
                    vUv = uv;
                    gl_Position = vec4(position, 1.0);
                }
            `, fragmentShader: `
                ${globalUBO_default}

                uniform sampler2D tDiffuse;
                uniform sampler2D tInfo;

                uniform float uCameraNear;
                uniform float uCameraFar;

                uniform vec2 uOutlineDepth;

                uniform vec2 uOutlineFade;
                uniform float uOutlineThickness;
                uniform vec3 uOutlineColor;
                uniform float uOutlineScale;

                uniform vec3 uInfoRange;
                uniform vec3 uDepthRange;
                uniform vec3 uNormalRange;
                uniform float uSmoothMargin;
                uniform float uInfoMinScale;

                ${lut_default}
                uniform sampler3D tLUT;
                uniform float uLUTIntensity;

                varying vec2 vUv;

                ${fit_default}
                ${depth_default}
                ${encoding_default}
                ${custom_default}

                void main() {
                    vec2 uv = vUv;
                    float aspect = resolution.x / resolution.y;

                    // get scene color
                    vec4 scene = texture2D(tDiffuse, vUv);
                    vec3 sceneColor = scene.rgb;

                    // compensate outline scale with resolution
                    float resScale = min(1.0, resolution.y / 1300.0) * uOutlineScale;

                    // get outline value
                    float centerDepth = 0.0;
                    float nearestDepth = 0.0;
                    float outlineValue = outline(tDiffuse, tInfo, vUv, uOutlineThickness, resScale, uInfoRange, uDepthRange, uNormalRange, uSmoothMargin, uInfoMinScale, uOutlineFade, vec2(uCameraNear, uCameraFar), nearestDepth, centerDepth);

                    // add the outline to the scene
                    sceneColor = mix(sceneColor, uOutlineColor, outlineValue);

                    // add color correction
                    sceneColor = apply3DLUTTetrahedral(sceneColor, tLUT, uLUTIntensity);

                    // outline debug
                    // gl_FragColor = vec4(vec3(outlineValue), 1.0); // debug

                    gl_FragColor = vec4(sceneColor, 1.0);
                }
            `})
    }
}; function adjustOutlinesUniforms$1(r, e) { const i = e.passes[0].finalPasses[0]; i.uniforms.uCameraNear.value = r.camera.near, i.uniforms.uCameraFar.value = r.camera.far; const s = customUniforms$1[r.name] || customUniforms$1.planet; Object.keys(s).forEach(a => { typeof i.uniforms[a].value == "number" ? i.uniforms[a].value = s[a].value : i.uniforms[a].value.copy(s[a].value) }) } function addPostProcessing$1(r, e) { const i = new MultipleRenderPass({ scene: r, rtCount: 2, rtOptions: { depthBuffer: !0 }, clearColor: new Color("#000000"), clearAlpha: global$1.renderer.clearAlpha, onAfterMultiRender: () => { }, finalMaterials: [new outlines$1(r)] }); e.passes.splice(0, 1), e.addPass(i), e === global$1.composer && (global$1.renderPass = i); const s = i.renderTarget.textures; s[0].name = "color", s[1].name = "info", i.finalPasses[0].uniforms.tInfo.value = s[1], adjustOutlinesUniforms$1(r, e), e === global$1.composer && (i.finalPasses[0]._fsQuad._mesh.name = "Big Triangle", gui$1.add(i.finalPasses[0]._fsQuad._mesh, "post-outline")) } var rotate_default = `mat2 rotation2D(float angle) {
    float s = sin(angle);
	float c = cos(angle);
	return mat2(c, s, -s, c);
}

vec2 rotate2D(vec2 v, float angle) {
	return rotation2D(angle) * v;
}

mat3 rotateX(float angle) {
    float s = sin(angle);
	float c = cos(angle);

	return mat3(
		1.0, 0.0, 0.0,
		0.0, c, s,
		0.0, -s, c
	);
}

mat3 rotateY(float angle) {
    float c = cos(angle);
    float s = sin(angle);

    return mat3(
		c, 0.0, -s,
		0.0, 1.0, 0.0,
		s, 0.0, c
	);
}

mat3 rotateZ(float angle) {
    float c = cos(angle);
    float s = sin(angle);

    return mat3(
		c, s, 0.0,
		-s, c, 0.0,
		0.0, 0.0, 1.0
	);
}

mat4 rotation3D(vec3 axis, float angle) {
    axis = normalize(axis);
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1.0 - c;

    return mat4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s,  0.0,
                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,  0.0,
                0.0, 0.0, 0.0, 1.0);
}

vec3 rotate3D(vec3 v, vec3 axis, float angle) {
	mat4 m = rotation3D(axis, angle);
	return (m * vec4(v, 1.0)).xyz;
}

vec3 applyQuat(vec3 vec, vec4 quat) {
    vec3 t = 2.0 * cross(quat.xyz, vec);
    return vec + quat.w * t + cross(quat.xyz, t);
}

vec4 quatNormalize(vec4 q) {
    float len = length(q);
    if (len == 0.0) return vec4(vec3(0.0), 1.0);
    return q / len;
}

vec4 quatFromAxisAngle(vec3 axis, float angle) {
	float sn = sin(angle * 0.5);
	float cs = cos(angle * 0.5);
	return vec4(axis * sn, cs);
}

vec4 quatFromUnitVectors(vec3 v1, vec3 v2) {
    float r = dot(v1, v2) + 1.0;
    if (r < 1e-6) return quatNormalize(abs(v1.x) > abs(v1.z) ? vec4(-v1.y, v1.x, 0.0, 0.0) : vec4(0.0, -v1.z, v1.y, 0.0));
    
    vec4 q = vec4(cross(v1, v2), r);
    return q / length(q);
}`, sinenoise_default = `#define sinlayer(frX, frY, frZ) val += sin(dot(p, vec3(frX, frY, frZ)));

float sinenoise1(vec3 p) {
    float val = 0.0;
    sinlayer(1.5, 3.4598, 1.234);
    sinlayer(3.12, -3.234, 4.221);
    sinlayer(0.355, 2.3, -1.375);
    sinlayer(-0.156, -3.34, -0.4566);
    sinlayer(-4.1235, -0.485, -1.45);
    sinlayer(2.54, -0.879, -2.123);
    return val / 6.0;
}`; const lightsFragmentBegin = `
/**
 * This is a template that can be used to light a material, it uses pluggable
 * RenderEquations (RE)for specific lighting scenarios.
 *
 * Instructions for use:
 * - Ensure that both RE_Direct, RE_IndirectDiffuse and RE_IndirectSpecular are defined
 * - Create a material parameter that is to be passed as the third parameter to your lighting functions.
 *
 * TODO:
 * - Add area light support.
 * - Add sphere light support.
 * - Add diffuse light probe (irradiance cubemap) support.
 */

vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );

vec3 geometryClearcoatNormal = vec3( 0.0 );

#ifdef USE_CLEARCOAT

	geometryClearcoatNormal = clearcoatNormal;

#endif

#ifdef USE_IRIDESCENCE

	float dotNVi = saturate( dot( normal, geometryViewDir ) );

	if ( material.iridescenceThickness == 0.0 ) {

		material.iridescence = 0.0;

	} else {

		material.iridescence = saturate( material.iridescence );

	}

	if ( material.iridescence > 0.0 ) {

		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );

		// Iridescence F0 approximation
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );

	}

#endif

IncidentLight directLight;

#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )

	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {

		pointLight = pointLights[ i ];

		getPointLightInfo( pointLight, geometryPosition, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif

		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )

	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;

	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {

		spotLight = spotLights[ i ];

		getSpotLightInfo( spotLight, geometryPosition, directLight );

		// spot lights are ordered [shadows with maps, shadows without maps, maps without shadows, none]
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif

		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif

		#undef SPOT_LIGHT_MAP_INDEX

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )

	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		directionalLight = directionalLights[ i ];

		getDirectionalLightInfo( directionalLight, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )

	RectAreaLight rectAreaLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {

		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if defined( RE_IndirectDiffuse )

	vec3 iblIrradiance = vec3( 0.0 );

	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );

	#if defined( USE_LIGHT_PROBES )

		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );

	#endif

	#if ( NUM_HEMI_LIGHTS > 0 )

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );

		}
		#pragma unroll_loop_end

	#endif

#endif

#if defined( RE_IndirectSpecular )

	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );

#endif
`; var linearstep_default = `float linearstep(float begin, float end, float t) {
    return clamp((t - begin) / (end - begin), 0.0, 1.0);
}`, triplanar_default = `vec4 triplanar(sampler2D tex, vec3 wNorm, vec3 wPos, float scale) {
    
    vec3 bf = normalize(abs(wNorm));
    bf /= dot(bf, vec3(1.0));

    
    vec2 tx = wPos.yz * scale;
    vec2 ty = wPos.zx * scale;
    vec2 tz = wPos.xy * scale;

    
    vec4 cx = texture(tex, tx) * bf.x;
    vec4 cy = texture(tex, ty) * bf.y;
    vec4 cz = texture(tex, tz) * bf.z;
    return cx + cy + cz;
}`, fog_default = `uniform vec3 uFogColorNear;
uniform vec3 uFogColorFar;
uniform float uFogDistance;
uniform float uFogDensity;

void addFog(inout vec3 outcolor, float lenCam) {
    float fogFactor = 1.0 - exp(-uFogDensity * uFogDensity * lenCam * lenCam);
    float range1 = smoothstep(0.0, uFogDistance, fogFactor);
    float range2 = 1.0 - range1;
    vec3 fogColor = uFogColorNear * range2 + uFogColorFar * range1;
    outcolor = mix(outcolor, fogColor, fogFactor);
}`, aastep_default = `float aastep(float threshold, float value) {
    float afwidth = length(vec2(dFdx(value), dFdy(value))) * 0.70710678118654757;
    return smoothstep(threshold - afwidth, threshold + afwidth, value);
}`; const fogUniforms = { uFogColorNear: { value: new Color("#93a2bf") }, uFogColorFar: { value: new Color("#9ea7b8") }, uFogDistance: { value: .8 }, uFogDensity: { value: .011 } }, uniforms = UniformsUtils.merge([UniformsLib.common, UniformsLib.lights, { emissive: { value: new Color(0) }, specular: { value: new Color(1118481) }, shininess: { value: 1 }, uShowChars: { value: 1 }, tColors: { value: null }, tNoise: { value: null }, tNoiseTerrain: { value: null }, ...fogUniforms, uFadeDistance: { value: 100 } }]); function getTweakedLightsFragment() {
    let r = lightsFragmentBegin; return r = r.replace("DirectionalLight directionalLight;", `
        DirectionalLight directionalLight;
        float _dirShadow = 1.0;
    `), r = r.replace("directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;", `

        float shadow = ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
        _dirShadow *= shadow; // accumulate shadow
        directLight.color *= shadow; // same as three.js

    `), r
} function getTerrainNoise() {
    return `
        ${triplanar_default}

        vec3 applyTerrainColor(vec3 norm, vec3 pos, vec3 color) {
            vec4 triplanarGrass = triplanar(tNoiseTerrain, norm, pos.xyz, 0.035);
            color = rgb2hsv(color);
            color.b -= step(0.7, triplanarGrass.r) * 0.03;

            float grassLight = step(triplanarGrass.g, 0.8);
            color.b += grassLight * 0.05;

            color = hsv2rgb(color);
            return color;
        }
    `} const vertex = `
    ${globalUBO_default}
    ${fit_default}

    #ifdef IS_TERRAIN
        attribute int surfaceId;
        attribute int elementId;
        flat varying int vElementId;
        varying vec3 vLocalNormal;
    #else
        attribute float surfaceId;
    #endif

    #if defined (IS_CHARACTER) || defined(IS_NPC)
        varying vec3 lPos;
    #endif

    #ifdef IS_CHARACTER
        flat varying int vIsLocal;
        flat varying float vBatchID;
    #endif

    varying vec3 vViewPosition;

    varying vec2 vUv;
    varying vec3 wPos;
    varying vec3 wNormal;
    varying vec3 vReflect;
    varying vec2 vHighPrecisionZW;
    flat varying float vSurfaceId;

    #include <common>
    #include <batching_pars_vertex>
    #include <normal_pars_vertex>

    // custom skinning_pars_vertex
    #ifdef USE_SKINNING
        uniform sampler2D boneTexture;

        #ifdef IS_CHARACTER
            mat4 bindMatrix = mat4(1.0);
            mat4 bindMatrixInverse = mat4(1.0);
            mat4 getBoneMatrix(const in float i, const in float id) {
                int x = int(i) * 4;
                int y = int(id);
                vec4 v1 = texelFetch(boneTexture, ivec2(x, y), 0);
                vec4 v2 = texelFetch(boneTexture, ivec2(x + 1, y), 0);
                vec4 v3 = texelFetch(boneTexture, ivec2(x + 2, y), 0);
                vec4 v4 = texelFetch(boneTexture, ivec2(x + 3, y), 0);
                return mat4(v1, v2, v3, v4);
            }
        #else
            uniform mat4 bindMatrix;
            uniform mat4 bindMatrixInverse;
            mat4 getBoneMatrix(const in float i) {
                int size = textureSize(boneTexture, 0).x;
                int j = int(i) * 4;
                int x = j % size;
                int y = j / size;
                vec4 v1 = texelFetch(boneTexture, ivec2(x, y), 0);
                vec4 v2 = texelFetch(boneTexture, ivec2(x + 1, y), 0);
                vec4 v3 = texelFetch(boneTexture, ivec2(x + 2, y), 0);
                vec4 v4 = texelFetch(boneTexture, ivec2(x + 3, y), 0);
                return mat4(v1, v2, v3, v4);
            }
        #endif
    #endif

    #include <shadowmap_pars_vertex>

    void main() {
        #ifdef IS_TERRAIN
            vElementId = elementId;
            vLocalNormal = normal;
            vSurfaceId = fract(float(surfaceId) / 10e5);
        #else
            vSurfaceId = surfaceId;
        #endif

        #include <uv_vertex>

        #if defined(USE_BATCHING) && !defined(IS_TERRAIN) // terrain is static, not moved by batched texture
            float batchID = getIndirectIndex(gl_DrawID);
            mat4 batchingMatrix = getBatchingMatrix(batchID);

            #ifdef IS_CHARACTER
                vBatchID = batchID;
                vSurfaceId += 0.02535 * batchID;
                vIsLocal = batchID == 0.0 ? 1 : 0;
            #endif
        #endif

        #if defined (IS_CHARACTER) || defined(IS_NPC)
            lPos = position;
        #endif

        #include <beginnormal_vertex>

        #ifdef USE_SKINNING
            #ifdef IS_CHARACTER
                mat4 boneMatX = getBoneMatrix(skinIndex.x, batchID);
                mat4 boneMatY = getBoneMatrix(skinIndex.y, batchID);
                mat4 boneMatZ = getBoneMatrix(skinIndex.z, batchID);
                mat4 boneMatW = getBoneMatrix(skinIndex.w, batchID);
            #else
                mat4 boneMatX = getBoneMatrix(skinIndex.x);
                mat4 boneMatY = getBoneMatrix(skinIndex.y);
                mat4 boneMatZ = getBoneMatrix(skinIndex.z);
                mat4 boneMatW = getBoneMatrix(skinIndex.w);
            #endif
        #endif

        #include <skinnormal_vertex>

        // custom defaultnormal_vertex
        vec3 transformedNormal = objectNormal;
        #if defined(USE_BATCHING) && !defined(IS_TERRAIN) // terrain is static, not moved by batched texture
            mat3 bm = mat3( batchingMatrix );
            transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
            transformedNormal = bm * transformedNormal;
        #endif
        #ifdef USE_INSTANCING
            mat3 im = mat3( instanceMatrix );
            transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
            transformedNormal = im * transformedNormal;
        #endif
        transformedNormal = normalMatrix * transformedNormal;
        #ifdef FLIP_SIDED
            transformedNormal = - transformedNormal;
        #endif

        #include <normal_vertex>
        #include <begin_vertex>
        #include <skinning_vertex>

        // custom project_vertex
        vec4 mvPosition = vec4(transformed, 1.0);

        #if defined(USE_BATCHING) && !defined(IS_TERRAIN)
            mvPosition = batchingMatrix * mvPosition;
        #endif
        #ifdef USE_INSTANCING
            mvPosition = instanceMatrix * mvPosition;
        #endif

        vec4 worldPosition = modelMatrix * mvPosition;

        // shake, anything custom...

        wPos = worldPosition.xyz;
        vec4 viewPosition = viewMatrix * worldPosition;
        gl_Position = projectionMatrix * viewPosition;

        vViewPosition = -viewPosition.xyz;

        #include <shadowmap_vertex>

        wNormal = inverseTransformDirection(transformedNormal, viewMatrix);
        vReflect = reflect(wNormal, normalize(worldPosition.xyz - cameraPosition.xyz));
        vHighPrecisionZW = gl_Position.zw;
    }
`, fragment = `
    layout(location = 1) out highp vec4 gInfo;

    ${globalUBO_default}
    ${fit_default}
    ${encoding_default}
    ${linearstep_default}
    ${sinenoise_default}
    ${colorutils_default}
    ${aastep_default}

    uniform sampler2D tColors;
    uniform sampler2D tNoise;
    uniform sampler2D tNoiseTerrain;

    #ifdef IS_TERRAIN
        flat varying int vElementId;
        varying vec3 vLocalNormal;
    #endif

    #if defined(IS_TERRAIN)
        ${getTerrainNoise()}
    #endif

    varying vec3 wPos;
    varying vec3 wNormal;
    varying vec3 vReflect;
    varying vec2 vHighPrecisionZW;
    flat varying float vSurfaceId;

    // fog
    ${fog_default}

    uniform float uFadeDistance;

    #if defined (IS_CHARACTER) || defined(IS_NPC)
        varying vec3 lPos;

        // face animation (blinking, talking)
        uniform sampler2D tEye;
        uniform vec3 uSkinColor;

        float hash11(float p) {
            p = fract(p * .1031);
            p *= p + 33.33;
            p *= p + p;
            return fract(p);
        }
    #endif

    #ifdef IS_CHARACTER
        uniform float uShowChars;
        uniform float uWetHeight;
        flat varying int vIsLocal;
        flat varying float vBatchID;
    #endif

    #ifdef IS_NPC
        uniform sampler2D tMouth;
        uniform vec3 uMouthColor;
        uniform float uIsTalking;
        uniform float uNPCSeed;
    #endif

    float lineFade(vec3 p, float size, float amount) {
        float h = size * 0.5;
        return 1.0 - step(amount * 1.01, (abs(mod(p.y, size) - h) / h));
    }

    float sphereFade(vec3 p, float size, float amount) {
        float h = size * 0.5;
        return clamp(1.0 - step(amount * 1.85, length(mod(p, size) - h) / h), 0.0, 1.0);
    }

    uniform vec3 diffuse;
    uniform vec3 emissive;
    uniform vec3 specular;
    uniform float shininess;
    uniform float opacity;

    #include <common>
    #include <packing>

    // custom uv_pars_fragment
    varying vec2 vUv;

    #include <bsdfs>
    #include <lights_pars_begin>
    #include <normal_pars_fragment>
    #include <lights_phong_pars_fragment>
    #include <shadowmap_pars_fragment>

    void main() {
        #ifdef IS_TERRAIN

            // triplanar texture used for adding detail
            vec4 triplanarNoise = triplanar(tNoise, wNormal, wPos.xyz * 0.4, 1.0);
            float height = length(wPos);
            float grassMask = 0.0;
            float wetMask = 0.0;

            if (vElementId == 1) { // mountain
                grassMask = step(0.15, max(0.0, -triplanarNoise.r * 1.5 + dot(wNormal, normalize(wPos))) - triplanarNoise.g * 0.35 + 0.1 - triplanarNoise.b * 0.05);
                wetMask = 1.0 - step(0.334, height * 0.015 + triplanarNoise.g * 0.006);
            }

        #endif

        // disappear part for nearby and far away elements
        float showAmount = 1.0;
        float dist = length(wPos - cameraPosition);

        #ifndef IS_CHARACTER
            showAmount = lineFade(wPos, 0.015, linearstep(0.1, 0.5, dist));
        #else
            if (uShowChars < 1.0) showAmount *= sphereFade(wPos, 0.15, uShowChars); // local char disappear var
        #endif

        #ifdef FADE_AWAY
            showAmount *= sphereFade(wPos, 0.3, smoothstep(uFadeDistance, uFadeDistance - 3.0, dist));
        #endif

        if (showAmount < 0.001) discard;

        vec4 diffuseColor = vec4(diffuse, opacity);
        ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
        vec3 totalEmissiveRadiance = emissive;
        float specularStrength = 1.0;

        #include <normal_fragment_begin>
        vec3 wNorm = normalize(wNormal);

        // accumulation
        #include <lights_phong_fragment>
        ${getTweakedLightsFragment()} // include lights_fragment_begin
        #include <lights_fragment_end>

        vec3 diffuseSpecular = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular;
        vec3 outgoingLight = diffuseSpecular + totalEmissiveRadiance;

        float shadowContribution = 1.0;
        float outlineContribution = 1.0;

        #if NUM_DIR_LIGHTS > 0
            float specularAmount = 0.075;

            #if defined(IS_CHARACTER) || defined(IS_NPC)
                specularAmount = 0.0;
            #endif

            #if defined(IS_DISABLED)
                outlineContribution = 0.0;
            #endif

            vec3 baseColor = diffuseColor.rgb;

            #ifdef IS_TERRAIN
                if (vElementId == 1) {
                    vec2 colorUV = vUv;

                    // apply grass color
                    if (grassMask > 0.5) colorUV = vec2(0.15, 0.95);

                    // apply wet color
                    if (wetMask > 0.5) colorUV = vec2(0.21, 0.54);

                    // get color and add noise
                    baseColor = applyTerrainColor(wNorm, wPos, texture2D(tColors, colorUV).rgb);
                } else {
                    baseColor = texture2D(tColors, vUv).rgb;

                    // TODO: add noise to manmade elements?
                }


            #elif defined(IS_CHARACTER) || defined(IS_NPC)

                baseColor = texture2D(tColors, vUv).rgb;

                // eyes
                if (vUv.y > 1.0) {
                    // a blink consists of three sprites: closed eye, almost-open eye, and open eye
                    vec2 eyeUv = vUv;

                    #ifdef IS_CHARACTER
                        float blinkTimeOffset = vBatchID;
                    #else
                        float blinkTimeOffset = uNPCSeed;
                    #endif

                    // create a "random" occuring blink by overlapping multiple 0...1 values with different intervals
                    float eyeTime = time * 3.0 + blinkTimeOffset * 23.73464;
                    float interval1 = 22.0;
                    float interval2 = 34.0;
                    float interval3 = 57.0;
                    float line1 = fract(eyeTime * (1.0 / interval1)) * interval1 - interval1 + 1.0;
                    float line2 = fract(eyeTime * (1.0 / interval2)) * interval2 - interval2 + 1.0;
                    float line3 = fract(eyeTime * (1.0 / interval3)) * interval3 - interval3 + 1.0;
                    float eyeProgress = max(0.0, max(max(line1, line2), line3));

                    // start with the first sprite
                    float spriteWidth = 0.25;
                    eyeUv.x *= spriteWidth;

                    // play through other sprites each time a blink occurs
                    float offset = floor(eyeProgress * 3.0);
                    eyeUv.x += offset * spriteWidth;

                    float mask = texture2D(tEye, eyeUv).r;
                    mask = aastep(0.5, mask);

                    baseColor = vec3(0.0);
                    baseColor += uSkinColor * (1.0 - mask);
                }

                #ifdef IS_NPC
                    // mouth
                    if (vUv.y < 0.0) {
                        // the mouth consists of three color channels
                        // r: mouth
                        // g: teeth
                        // b: tongue

                        // start with the first sprite
                        float spriteWidth = 0.25;
                        vec2 mouthUv = vUv;
                        mouthUv.x *= spriteWidth;

                        // default to first sprite (closed mouth)
                        float offset = 0.0;

                        // randomly choose a mouth sprite while speaking
                        if (uIsTalking > 0.5) {
                            offset = floor(hash11(floor(time * 8.0)) * 3.0);
                        }

                        mouthUv.x += offset * spriteWidth;
                        vec3 mask = texture2D(tMouth, mouthUv).rgb;
                        mask.r = aastep(0.5, mask.r);
                        mask.g = aastep(0.5, mask.g);
                        mask.b = aastep(0.5, mask.b);
                        float mouthMask = min(1.0, mask.r + mask.g + mask.b);
                        float skinMask = 1.0 - mouthMask;

                        // composite colors
                        vec3 teethColor = vec3(1.0);
                        vec3 skinColor = uSkinColor;
                        vec3 mouthColor = uMouthColor;

                        baseColor = vec3(0.0);
                        baseColor += teethColor * mask.g;
                        baseColor += mouthColor * mask.r;
                        baseColor += mix(mouthColor, skinColor, 0.1) * mask.b;
                        baseColor += skinColor * skinMask;

                        // add outline
                        // outlineContribution += mouthMask;
                    }
                #endif

            #elif defined(IS_GIVE)
                baseColor = texture2D(tColors, vUv).rgb;
            #endif

            vec3 colorhsv = rgb2hsv(baseColor);
            vec3 colorShadow = colorhsv;
            colorShadow.r -= 0.02;
            colorShadow.b *= 0.5;
            colorShadow = hsv2rgb(colorShadow);

            const float shadowLimit = 0.15;
            float totalShadow = reflectedLight.directDiffuse.r * _dirShadow * shadowContribution;

            // shadow "CUT". soft for everything so changes in shadows are smooth, and hard for characters
            #ifdef HARD_CUT_SHADOW
                float shadowCut = smoothstep(0.1, 0.15, totalShadow);
            #else
                float shadowCut = smoothstep(0.2, 0.4, totalShadow);
            #endif

            // set color
            outgoingLight = mix(colorShadow, baseColor, shadowCut);

            // add highlights on things that are not facing directly up
            outgoingLight += smoothstep(0.01, 0.011, reflectedLight.directSpecular) * specularAmount * fit(dot(wNorm, vec3(0.0, 1.0, 0.0)), 0.95, 0.9, 0.0, 1.0);

            // add indirect light
            outgoingLight += reflectedLight.indirectDiffuse;
        #endif

        float surfaceId = vSurfaceId;

        #ifdef IS_TERRAIN
            if (vElementId == 1) {
                // apply rock striations
                float n1 = sin(height * 0.1 + (vLocalNormal.x + vLocalNormal.y + vLocalNormal.z) * 0.5 + (wPos.x + wPos.y + wPos.z) * 2.0);
                float striations = texture2D(tNoise, vec2(n1 * 0.01, height * 0.07 - n1 * 0.02)).g;
                striations = step(0.47, striations + triplanarNoise.r * 0.2 + triplanarNoise.g * 0.05);
                outlineContribution *= step(0.3, triplanarNoise.r);

                surfaceId += striations * (1.0 - grassMask);
                surfaceId += grassMask * 0.1;
                surfaceId += wetMask * 0.12;
            }

            // break up outlines
            outlineContribution *= step(0.13, triplanarNoise.g * triplanarNoise.b);
        #endif

        #if defined (IS_CHARACTER) || defined(IS_NPC)
            float outlineNoise = sinenoise1(lPos * 12.0 + vec3(3.324, 34.2, 56.343) * surfaceId) * 0.5 + 0.5;
            outlineContribution = step(0.3, outlineNoise);

            #ifdef IS_CHARACTER
                // add wetness
                if (vIsLocal == 1) {
                    vec3 colorwet = rgb2hsv(outgoingLight);
                    colorwet.b = max(colorwet.b - 0.1, colorwet.b * 0.75);
                    colorwet = hsv2rgb(colorwet);
                    outgoingLight = mix(outgoingLight, colorwet, step(lPos.y, uWetHeight + (sin(lPos.x * 30.0) - 1.0) * 0.012));
                }
            #endif
        #endif

        #ifndef NO_FOG
            addFog(outgoingLight, vViewPosition.z);
        #endif

        gl_FragColor = vec4(outgoingLight, surfaceId);
        gInfo = vec4(1.0 - (0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5), encodeNormalSpheremap(geometryNormal), outlineContribution);
    }
`; class birds {
    constructor(e, i) { this.scene = e, this.ready = miscutils.deferred(), this.options = { count: 23, groups: 6, curve: "birds/curve-1.drc", bird: "birds/1.drc", noise: .4, speed: 1.5, multiplier: 1, direction: 1, ...i }, this.init() } async init() {
        const e = textureLoader.loadCurves(this.options.curve, !0, 1), [i] = await Promise.all([geometryLoader.load(this.options.bird)]), s = this.options.count, a = math.getTextureSizeParticles(s), o = new Float32Array(a * a * 4); for (let d = 3; d <= o.length; d += 4)o[d] = Math.random(); const l = new DataTexture(o, a, a, RGBAFormat, FloatType); l.needsUpdate = !0; const c = new Float32Array(a * a * 4); for (let d = 3; d <= c.length; d += 4)c[d] = Math.random(); const h = new DataTexture(c, a, a, RGBAFormat, FloatType); h.needsUpdate = !0, this.mesh = new particlesGPU$1({
            count: s, geometry: i, material: new ShaderMaterial({
                userData: { hotReload: "birds" }, uniformsGroups: [global$1.UBO], uniforms: { tTexture1: { value: null }, tTexture1Prev: { value: null }, tAtlas: { value: textureLoader.load("atlas.png") }, uLightPos: { value: new Vector3 }, uMultiplier: { value: this.options.multiplier }, uShow: { value: 1 }, ...fogUniforms }, vertexShader: `
                    attribute float surfaceId;

                    ${globalUBO_default}
                    ${rotate_default}

                    uniform sampler2D tPosition;
                    uniform sampler2D tNormal;

                    uniform sampler2D tTexture1;
                    uniform sampler2D tTexture1Prev;

                    uniform vec3 uLightPos;
                    uniform float uMultiplier;
                    uniform float uShow;

                    varying vec2 vUv;
                    varying vec4 vPos;
                    varying vec3 vLDir;
                    varying vec3 vNormal;
                    varying vec2 vHighPrecisionZW;
                    flat varying float vSurfaceId;

                    mat2 rotate(float a) {
                        float s = sin(a);
                        float c = cos(a);
                        return mat2(c, s, -s, c);
                    }
                    vec3 hash31(float p) {
                        vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));
                        p3 += dot(p3, p3.yzx+33.33);
                        return fract((p3.xxy+p3.yzz)*p3.zyx);
                        }

                    void main() {
                        vUv = uv;
                        vSurfaceId = fract(surfaceId + float(gl_InstanceID) * 5.435435);

                        int texWidth = textureSize(tTexture1, 0).x;
                        ivec2 texuv = ivec2(gl_InstanceID % texWidth, gl_InstanceID / texWidth);

                        vec4 currentOffset = texelFetch(tTexture1, texuv, 0);
                        vec4 prevOffset = texelFetch(tTexture1Prev, texuv, 0);

                        vec3 rand = hash31(float(gl_InstanceID));

                        vec3 pos = position * uShow;
                        float multiplier = uMultiplier;
                        float wingLength = abs(position.z);
                        float flapAnimation = sin(position.x * 5.0 + wingLength * 5.0 * multiplier - time * mix(10.0 * multiplier, 17.0, rand.x) * multiplier);
                        pos.y += flapAnimation * wingLength * 0.7;
                        pos *= mix(0.7, 1.2, rand.y);
                        pos.y -= 0.5;
                        pos.zy = rotate(0.6 * sin(time * multiplier + rand.z * 100.0 - pos.x)) * pos.zy;

                        vec3 forward = normalize(currentOffset.xyz - prevOffset.xyz);
                        vec3 up = normalize(currentOffset.xyz);
                        vec3 right = cross(forward, up);
                        mat3 TBN = mat3(forward, up, right);

                        pos = TBN * pos;
                        vec3 n = TBN * normal;

                        vNormal = normalize(normalMatrix * n);
                        vec3 wPos = pos + currentOffset.xyz;
                        vPos = viewMatrix * vec4(wPos, 1.0);

                        vLDir = (viewMatrix * vec4(normalize(uLightPos - wPos), 0.0)).xyz;

                        gl_Position = projectionMatrix * vPos;
                        vHighPrecisionZW = gl_Position.zw;
                    }
                `, fragmentShader: `
                    layout(location = 1) out highp vec4 gInfo;

                    uniform sampler2D tAtlas;


                    varying vec2 vUv;
                    varying vec3 vNormal;
                    varying vec4 vPos;
                    varying vec3 vLDir;
                    varying vec2 vHighPrecisionZW;
                    flat varying float vSurfaceId;

                    ${colorutils_default}
                    ${fit_default}
                    ${encoding_default}
                    ${fog_default}

                    void main() {
                        vec3 baseColor = texture(tAtlas, vUv).rgb;
                        vec3 colorShadow = rgb2hsv(baseColor);
                        colorShadow.b *= 0.5;
                        colorShadow = hsv2rgb(colorShadow);

                        vec3 nvNormal = normalize(vNormal);
                        float sh = max(0.0, dot(nvNormal, normalize(vLDir)));
                        sh = 1.0 - step(0.4, sh);

                        vec3 col = mix(baseColor, colorShadow, sh);

                        addFog(col, vPos.z);

                        gl_FragColor = vec4(col, vSurfaceId);
                        gInfo = vec4(1.0 - (0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5), encodeNormalSpheremap(nvNormal), 1.0);
                    }
                `})
        }, {
            textures: 2, initialTextures: [l, h], material: new ShaderMaterial({
                uniformsGroups: [global$1.UBO], uniforms: { uSeed: { value: Math.random() }, uGroups: { value: this.options.groups }, uNoise: { value: this.options.noise }, tTexture1: { value: null }, tTexture2: { value: null }, tCurve: { value: e }, uSnap: { value: 0 }, uSpeed: { value: this.options.speed }, uDirection: { value: this.options.direction } }, vertexShader: `
                    varying vec2 vUv;

                    void main() {
                        vUv = uv;
                        gl_Position = vec4(position, 1.0);
                    }
                `, fragmentShader: `
                    #define outPos pc_fragColor
                    uniform sampler2D tTexture1;

                    layout(location = 1) out highp vec4 outVel;
                    uniform sampler2D tTexture2;

                    uniform float uNoise;
                    uniform float uGroups;
                    uniform float uSnap;
                    uniform float uSpeed;
                    uniform float uSeed;
                    uniform float uDirection;
                    uniform sampler2D tCurve;

                    varying vec2 vUv;

                    ${globalUBO_default}
                    ${lerpfriction_default}
                    ${sinenoise_default}
                    ${fit_default}

                    float hash11(float p) {
                        p = fract(p * .1031);
                        p *= p + 33.33;
                        p *= p + p;
                        return fract(p);
                    }

                    void main() {
                        ivec2 uv = ivec2(gl_FragCoord.xy);
                        vec4 prevPos = texelFetch(tTexture1, uv, 0);
                        vec4 prevVel = texelFetch(tTexture2, uv, 0);

                        float hashFlock = hash11(prevPos.w * 8.54534);
                        float hashVel = hash11(vUv.x);

                        // randomize the flock
                        float offset = floor(hashFlock / (1.0 / uGroups));
                        float direction = uDirection; // mix(-1.0, 1.0, step(0.5, hashFlock));
                        float speed = 2.0 * direction * uSpeed * mix(0.75, 1.0, step(0.3, hashVel));
                        float curveWidth = float(textureSize(tCurve, 0).x);
                        float progress = time * speed + (curveWidth / uGroups) * offset + uSeed * 12.4234;

                        vec3 c1 = texelFetch(tCurve, ivec2(mod(progress, curveWidth), 0), 0).rgb;
                        vec3 c2 = texelFetch(tCurve, ivec2(mod(progress + 1.0, curveWidth), 0), 0).rgb;
                        vec3 target = mix(c1, c2, fract(abs(progress)));

                        if (uSnap > 0.9) {
                            prevPos.xyz = target;
                            prevVel.xyz = vec3(0.0);
                        } else {
                            // add some noise
                            float nAmount = 0.005 * uNoise * dtRatio;
                            prevVel.x += sinenoise1(prevPos.xyz + prevVel.w * 53.5645 + time * 0.05) * nAmount;
                            prevVel.y += sinenoise1(prevPos.xyz + prevVel.w * 653.8667 + time * 0.1) * nAmount;
                            prevVel.z += sinenoise1(prevPos.xyz + prevVel.w * 21.65465 + time * 0.025) * nAmount;

                            // towards target
                            vec3 delta = (target - prevPos.xyz) * 0.0003;
                            prevVel.xyz += delta * dtRatio;

                            // friction
                            prevVel.xyz *= frictionFPS(0.99, dtRatio);

                            // add to position
                            prevPos.xyz += prevVel.xyz * dtRatio;
                        }

                        outVel = prevVel;
                        outPos = prevPos;
                    }
                `})
        }), this.scene.add(this.mesh), this.mesh.name = "birds", this.mesh.frustumCulled = !1, this.mesh.matrixAutoUpdate = !1, this.scene.uploaded.then(() => { this.mesh.simulation.computationMaterial.uniforms.uSnap.value = 1, this.mesh.simulation.compute(), this.mesh.simulation.compute(), this.mesh.simulation.computationMaterial.uniforms.uSnap.value = 0 }), this.scene.beforeRenderCbs.push(() => { this.scene.directionalLight && this.mesh.material.uniforms.uLightPos.value.copy(this.scene.directionalLight.position) }), this.mesh.receiveShadow = !1, this.mesh.castShadow = !1, this.scene.add(this.mesh), this.ready.resolve()
    } playInAnimation(e = 0) { this.mesh.material.uniforms.uShow.value = 0, createTween(this.mesh.material.uniforms.uShow, { to: { value: 1 }, delay: e, duration: 2, ease: "none" }) }
} function introMaterial(r = {}) {
    const e = UniformsUtils.merge([UniformsLib.common, UniformsLib.lights, { tColors: { value: null }, tNoiseTerrain: { value: null }, tNoise: { value: null } }]); return e.tColors.value = textureLoader.load("atlas.png", "srgb-nearest"), e.tNoiseTerrain.value = textureLoader.load("noises-terrain.ktx2", "linearfilter-repeat"), e.tNoise.value = textureLoader.load("noise-simplex-layered-pixellated-highq.ktx2", "linearfilter-repeat"), new ShaderMaterial({
        lights: !0, uniformsGroups: [global$1.UBO], uniforms: e, vertexShader: `
            ${globalUBO_default}

            attribute float surfaceId;
            attribute int elementId;

            varying vec2 vUv;
            varying vec2 vHighPrecisionZW;

            varying vec3 wNormal;
            varying vec3 wPos;
            varying vec4 vPos;
            varying vec3 vNormal;
            varying float vSurfaceId;
            flat varying int vElementId;

            // for shadows
            #include <shadowmap_pars_vertex>
            vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
                return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
            }

            void main() {
                vUv = uv;
                vElementId = elementId;
                vSurfaceId = surfaceId;

                // get world position
                vec4 worldPosition = modelMatrix * vec4(position, 1.0);

                wNormal = normal;
                wPos = position.xyz;
                vNormal = normalize(normalMatrix * normal);

                // this requires worldPosition and transformedNormal
                vec3 transformedNormal = vNormal;
                #include <shadowmap_vertex>

                vPos = viewMatrix * worldPosition;

                gl_Position = projectionMatrix * vPos;
                vHighPrecisionZW = gl_Position.zw;
            }
        `, fragmentShader: `
            layout(location = 1) out highp vec4 gInfo;

            ${globalUBO_default}
            ${fit_default}
            ${encoding_default}
            ${linearstep_default}
            ${colorutils_default}
            ${triplanar_default}

            varying vec3 wPos;
            varying vec3 wNormal;
            varying vec3 vNormal;
            varying vec4 vPos;
            varying float vSurfaceId;
            flat varying int vElementId;

            uniform sampler2D tColors;
            uniform sampler2D tNoiseTerrain;
            uniform sampler2D tNoise;

            varying vec2 vUv;
            varying vec2 vHighPrecisionZW;

            // for shadows
            #include <packing>
            #include <shadowmap_pars_fragment>

            void main() {
                float shadowContribution = 1.0;
                float outlineContribution = 1.0;
                float surfaceId = vSurfaceId;

                // triplanar texture used for adding detail
                vec4 triplanarNoise = triplanar(tNoise, wNormal, wPos.xyz * 0.07, 1.0);
                float height = length(wPos);
                float grassMask = 0.0;
                float wetMask = 0.0;

                if (vElementId == 1) { // mountain
                    grassMask = step(0.15, max(0.0, -triplanarNoise.r * 1.5 + dot(wNormal, normalize(wPos))) - triplanarNoise.g * 0.35 + 0.1 - triplanarNoise.b * 0.05);

                    // apply rock striations
                    float n1 = sin(height * 0.025 + (wNormal.x + wNormal.y + wNormal.z) * 0.05 + (wPos.x + wPos.y + wPos.z) * 1.5);
                    float striations = texture2D(tNoise, vec2(n1 * 0.01, height * 0.07 - n1 * 0.02)).g;
                    striations = step(0.47, striations + triplanarNoise.r * 0.2 + triplanarNoise.g * 0.05);

                    surfaceId += striations * (1.0 - grassMask) * step(0.25, triplanarNoise.r);
                }

                vec2 colorUV = vUv;
                if (grassMask > 0.5) colorUV = vec2(0.15, 0.95);

                vec3 color = texture2D(tColors, colorUV).rgb;

                #if NUM_DIR_LIGHTS > 0

                    // color shadow
                    vec3 colorShadow = rgb2hsv(color);
                    colorShadow.r -= 0.02;
                    colorShadow.b *= 0.5;
                    colorShadow = hsv2rgb(colorShadow);

                    // shadow
                    float shadow = 0.0;
                    #if defined(USE_SHADOWMAP) && NUM_DIR_LIGHT_SHADOWS > 0
                        DirectionalLightShadow directionalLightShadow;
                        directionalLightShadow = directionalLightShadows[0];
                        shadow = getShadow(
                            directionalShadowMap[0],
                            directionalLightShadow.shadowMapSize,
                            directionalLightShadow.shadowIntensity,
                            directionalLightShadow.shadowBias,
                            directionalLightShadow.shadowRadius,
                            vDirectionalShadowCoord[0]
                        );
                    #endif

                    // set color
                    float shadowCut = smoothstep(0.2, 0.4, shadow);
                    color = mix(colorShadow, color, shadowCut);
                #endif

                // break up outlines
                outlineContribution *= step(0.17, triplanarNoise.g * triplanarNoise.b);
                outlineContribution = step(0.5, outlineContribution);

                surfaceId += grassMask * 0.1;

                gl_FragColor = vec4(color, surfaceId);
                // gInfo = vec4(1.0 - (0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5), encodeNormalSpheremap(normalize(vNormal)), outlineContribution);
                gInfo = vec4(1.0 - (0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5), vec2(0.0), outlineContribution);
            }
        `})
} function waterMaterial(r = {}) {
    const e = UniformsUtils.merge([UniformsLib.common, UniformsLib.lights, { tColors: { value: null }, tNoiseTerrain: { value: null }, tNoise: { value: null } }]); return e.tColors.value = textureLoader.load("atlas.png", "srgb-nearest"), e.tNoise.value = textureLoader.load("noise-simplex-layered-pixellated-highq.ktx2", "linearfilter-repeat"), new ShaderMaterial({
        lights: !0, uniformsGroups: [global$1.UBO], uniforms: e, vertexShader: `
            ${globalUBO_default}

            attribute float dist;
            attribute float surfaceId;
            attribute int elementId;

            varying vec2 vUv;
            varying vec2 vHighPrecisionZW;

            varying vec3 wNormal;
            varying vec3 wPos;
            varying vec4 vPos;
            varying vec3 vNormal;
            varying float vSurfaceId;
            varying float vDist;
            flat varying int vElementId;

            // for shadows
            #include <shadowmap_pars_vertex>
            vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
                return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
            }

            void main() {
                vUv = uv;
                vElementId = elementId;
                vSurfaceId = surfaceId;
                vDist = dist;

                // get world position
                vec4 worldPosition = modelMatrix * vec4(position, 1.0);

                wNormal = normal;
                wPos = position.xyz;
                vNormal = normalize(normalMatrix * normal);

                // this requires worldPosition and transformedNormal
                vec3 transformedNormal = vNormal;
                #include <shadowmap_vertex>

                vPos = viewMatrix * worldPosition;

                gl_Position = projectionMatrix * vPos;
                vHighPrecisionZW = gl_Position.zw;
            }
        `, fragmentShader: `
            layout(location = 1) out highp vec4 gInfo;

            ${globalUBO_default}
            ${fit_default}
            ${encoding_default}
            ${linearstep_default}
            ${colorutils_default}
            ${triplanar_default}

            varying vec3 wPos;
            varying vec3 wNormal;
            varying vec3 vNormal;
            varying vec4 vPos;
            varying float vSurfaceId;
            varying float vDist;
            flat varying int vElementId;

            uniform sampler2D tColors;
            uniform sampler2D tNoise;

            varying vec2 vUv;
            varying vec2 vHighPrecisionZW;

            // for shadows
            #include <packing>
            #include <shadowmap_pars_fragment>

            void main() {
                float shadowContribution = 1.0;
                float outlineContribution = 1.0;
                float surfaceId = vSurfaceId;

                // triplanar texture used for adding detail
                vec4 triplanarNoise = triplanar(tNoise, wNormal, wPos.xyz * 0.07 + time * 0.05, 1.0);

                vec2 colorUV = vUv;
                vec3 color = texture2D(tColors, colorUV).rgb;

                // add waves using baked distance attribute
                float waves = fract(triplanarNoise.r * 0.7 + vDist * 3.0 + time * 0.1);
                waves *= 1.0 - step(0.7, vDist);
                waves *= step(0.3, vDist);
                waves *= triplanarNoise.r;
                waves = step(0.3, waves);

                color = mix(color, vec3(1.0), waves);

                #if NUM_DIR_LIGHTS > 0

                    // color shadow
                    vec3 colorShadow = rgb2hsv(color);
                    colorShadow.r -= 0.02;
                    colorShadow.b *= 0.5;
                    colorShadow = hsv2rgb(colorShadow);

                    // shadow
                    float shadow = 0.0;
                    #if defined(USE_SHADOWMAP) && NUM_DIR_LIGHT_SHADOWS > 0
                        DirectionalLightShadow directionalLightShadow;
                        directionalLightShadow = directionalLightShadows[0];
                        shadow = getShadow(
                            directionalShadowMap[0],
                            directionalLightShadow.shadowMapSize,
                            directionalLightShadow.shadowIntensity,
                            directionalLightShadow.shadowBias,
                            directionalLightShadow.shadowRadius,
                            vDirectionalShadowCoord[0]
                        );
                    #endif

                    // set color
                    float shadowCut = smoothstep(0.2, 0.4, shadow);
                    color = mix(colorShadow, color, shadowCut);
                #endif

                // add stepped gradients
                color += smoothstep(0.3, 0.0, step(0.2, vDist  - triplanarNoise.r * 1.5)) * vec3(0.2, 0.8, 1.0) * 0.035;
                color += smoothstep(0.3, 0.0, step(1.15, vDist - triplanarNoise.b * 1.5)) * vec3(0.2, 0.8, 1.0) * 0.01;

                // break up outlines
                outlineContribution *= step(0.17, triplanarNoise.g * triplanarNoise.b);
                outlineContribution = step(0.5, outlineContribution);

                gl_FragColor = vec4(color, surfaceId);
                gInfo = vec4(1.0 - (0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5), vec2(0.0), outlineContribution);
            }
        `})
} function cloudMaterial(r = {}) {
    const e = UniformsUtils.merge([UniformsLib.common, UniformsLib.lights, { tNoiseTerrain: { value: null }, tNoise: { value: null }, uColor: { value: new Color("#F8F8F8") } }]); return e.tNoise.value = textureLoader.load("noise-simplex-layered-pixellated-highq.ktx2", "linearfilter-repeat"), new ShaderMaterial({
        lights: !0, uniformsGroups: [global$1.UBO], uniforms: e, vertexShader: `
            ${globalUBO_default}
            ${triplanar_default}

            attribute float surfaceId;
            attribute int elementId;

            uniform sampler2D tNoise;

            varying vec2 vUv;
            varying vec2 vHighPrecisionZW;

            varying vec3 wNormal;
            varying vec3 wPos;
            varying vec4 vPos;
            varying vec3 vNormal;
            varying float vSurfaceId;
            flat varying int vElementId;

            // for shadows
            #include <shadowmap_pars_vertex>
            vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
                return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
            }

            void main() {
                vUv = uv;
                vElementId = elementId;
                vSurfaceId = surfaceId;

                // get world position
                vec3 pos = position;

                vec4 triplanarNoise = triplanar(tNoise, normal, pos.xyz * 0.07, 1.0);
                vec3 displacement = sin(triplanarNoise.r * 180.0 + floor(time * 6.0) * 0.25) * normalize(pos) * 0.5;
                pos.xyz += displacement.xyz;

                vec4 worldPosition = modelMatrix * vec4(pos, 1.0);

                wNormal = normal;
                wPos = position.xyz;
                vNormal = normalize(normalMatrix * normal);

                // this requires worldPosition and transformedNormal
                vec3 transformedNormal = vNormal;
                #include <shadowmap_vertex>

                vPos = viewMatrix * worldPosition;

                gl_Position = projectionMatrix * vPos;
                vHighPrecisionZW = gl_Position.zw;
            }
        `, fragmentShader: `
            layout(location = 1) out highp vec4 gInfo;

            ${globalUBO_default}
            ${fit_default}
            ${encoding_default}
            ${linearstep_default}
            ${colorutils_default}
            ${triplanar_default}

            varying vec2 vUv;
            varying vec3 wPos;
            varying vec3 wNormal;
            varying vec3 vNormal;
            varying vec4 vPos;
            varying float vSurfaceId;
            flat varying int vElementId;

            varying vec2 vHighPrecisionZW;

            uniform vec3 uColor;
            uniform sampler2D tNoise;

            // for shadows
            #include <packing>
            #include <shadowmap_pars_fragment>

            void main() {

                float outlineContribution = 1.0;
                vec3 color = uColor;
                vec4 triplanarNoise = triplanar(tNoise, wNormal, wPos.xyz * 0.07, 1.0);

                #if NUM_DIR_LIGHTS > 0

                    // color shadow
                    vec3 colorShadow = rgb2hsv(color);
                    colorShadow.r -= 0.02;
                    colorShadow.b *= 0.5;
                    colorShadow = hsv2rgb(colorShadow);

                    // shadow
                    float shadow = 0.0;
                    #if defined(USE_SHADOWMAP) && NUM_DIR_LIGHT_SHADOWS > 0
                        DirectionalLightShadow directionalLightShadow;
                        directionalLightShadow = directionalLightShadows[0];
                        shadow = getShadow(
                            directionalShadowMap[0],
                            directionalLightShadow.shadowMapSize,
                            directionalLightShadow.shadowIntensity,
                            directionalLightShadow.shadowBias,
                            directionalLightShadow.shadowRadius,
                            vDirectionalShadowCoord[0]
                        );
                    #endif

                    // set color
                    float shadowCut = smoothstep(0.2, 0.4, shadow);
                    color = mix(colorShadow, color, shadowCut);
                #endif

                // break up outlines
                outlineContribution *= step(0.17, triplanarNoise.g * triplanarNoise.b);
                outlineContribution = step(0.5, outlineContribution);

                gl_FragColor = vec4(color, vSurfaceId);
                gInfo = vec4(1.0 - (0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5), encodeNormalSpheremap(normalize(vNormal)), outlineContribution);
            }
        `})
} class planet$1 { constructor(e) { this.scene = e, this.ready = miscutils.deferred(), this.init() } async init() { const [e, i, s, a] = await Promise.all([geometryLoader.load(`planets/present/intro/${client$1.lowMemoryDevice ? "low/" : ""}planet.drc`), geometryLoader.load("planets/present/intro/water.drc"), geometryLoader.load("planets/present/intro/trees.drc"), geometryLoader.load("planets/present/intro/clouds.drc")]); this.planetMesh = new Mesh(e, introMaterial({})), this.planetMesh.name = "Planet", this.waterMesh = new Mesh(i, waterMaterial({})), this.waterMesh.name = "Water", this.treeMesh = new Mesh(s, introMaterial({})), this.treeMesh.name = "Trees", this.cloudMesh = new Mesh(a, cloudMaterial({})), this.cloudMesh.name = "Clouds", this.planetMesh.receiveShadow = !0, this.planetMesh.castShadow = !0, this.waterMesh.castShadow = !1, this.waterMesh.receiveShadow = !0, this.treeMesh.castShadow = !0, this.treeMesh.receiveShadow = !0, this.cloudMesh.castShadow = !1, this.cloudMesh.receiveShadow = !1, this.mesh = new Group, this.scene.planetGroup.add(this.planetMesh), this.scene.planetGroup.add(this.waterMesh), this.scene.planetGroup.add(this.treeMesh), this.scene.planetGroup.add(this.cloudMesh), this.ready.resolve() } } function skyMaterial(r = {}) {
    const e = UniformsUtils.merge([UniformsLib.common, UniformsLib.lights, { uColor: { value: new Color("#75bdc3") } }]); return new ShaderMaterial({
        uniformsGroups: [global$1.UBO], uniforms: e, vertexShader: `
            ${globalUBO_default}

            void main() {
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `, fragmentShader: `
            layout(location = 1) out highp vec4 gInfo;

            ${globalUBO_default}

            uniform vec3 uColor;

            void main() {

                float outlineContribution = 1.0;
                float surfaceId = 1.0;
                vec3 color = uColor;
                gl_FragColor = vec4(color, surfaceId);
                gInfo = vec4(0.0, vec2(0.0), outlineContribution);

            }
        `})
} class sky$1 { constructor(e) { this.scene = e, this.ready = miscutils.deferred(), this.init() } init() { this.mesh = new Mesh(new SphereGeometry(150, 32, 16), skyMaterial({})), this.mesh.name = "Sky", this.mesh.material.side = BackSide, this.mesh.scale.setScalar(4), this.scene.add(this.mesh), this.ready.resolve() } } const _v0$g = new Vector3, _v1$a = new Vector3, _s$5 = new Sphere; class PlanetMesh extends Mesh { constructor(e, i, s, a = 15) { super(e, i), this._scene = s, this._visThreshold = a, events.on("internal_prerender", this.__checkVisibility, this) } __checkVisibility() { var a; if (!this._scene || !((a = this._scene.characters) != null && a.mesh)) return; const e = this._scene.characters.mesh._localObject; this.geometry.boundingSphere === null && this.geometry.computeBoundingSphere(), _s$5.copy(this.geometry.boundingSphere), _v0$g.copy(e.position).sub(_s$5.center).normalize(); const i = _s$5.center.distanceTo(e.position), s = Math.min(i, _s$5.radius); _v1$a.copy(_s$5.center).addScaledVector(_v0$g, s), this.visible = e.position.distanceTo(_v1$a) < this._visThreshold } dispose() { var e; events.off("internal_prerender", this.__checkVisibility, this), (e = super.dispose) == null || e.call(this) } } class cables$1 {
    constructor(e, i = {}) { this.scene = e, this.options = i, this.ready = miscutils.deferred(), this.mesh = new Group, this.mesh.name = "Cables", this.scene.planetGroup.add(this.mesh), this.init() } async init() {
        const e = ["cables-1", "cables-2"], i = await Promise.all(e.map(a => geometryLoader.load(`planets/present/${a}.drc`))), s = new ShaderMaterial({
            uniformsGroups: [global$1.UBO], uniforms: { tNoise: { value: textureLoader.load("clouds_noise_512.ktx2", "srgb-repeat") }, uColor: { value: new Color("#4d5457") }, uWidth: { value: 1 }, ...fogUniforms }, vertexShader: `
                attribute float randomm;
                attribute vec3 nextpos;
                attribute vec3 prevpos;
                attribute vec3 curvepos;

                ${globalUBO_default}
                ${fit_default}

                uniform float uWidth;
                uniform sampler2D tNoise;

                varying vec2 vHighPrecisionZW;
                varying vec2 vUv;
                varying vec4 vPos;
                varying float vRandom;

                void main() {
                    vUv = uv;
                    vRandom = randomm;

                    vec4 worldPos = modelMatrix * vec4(curvepos, 1.0);
                    vec4 worldPrevPos = modelMatrix * vec4(prevpos, 1.0);
                    vec4 worldNextPos = modelMatrix * vec4(nextpos, 1.0);

                    vec4 viewPos = viewMatrix * worldPos;
                    vPos = viewPos;

                    mat4 projView = projectionMatrix * viewMatrix;
                    vec4 finalPos = projView * worldPos;
                    vec4 finalPrevPos = projView * worldPrevPos;
                    vec4 finalNextPos = projView * worldNextPos;

                    float aspect = resolution.x / resolution.y;
                    vec2 aspectVec = vec2(aspect, 1.0);
                    vec2 posScreen = finalPos.xy / finalPos.w * aspectVec;
                    vec2 prevPosScreen = finalPrevPos.xy / finalPrevPos.w * aspectVec;
                    vec2 nextPosScreen = finalNextPos.xy / finalNextPos.w * aspectVec;

                    // calculate screen space line normal, so we can extrude it to give it thickness
                    vec2 dirA = normalize((posScreen - prevPosScreen));
                    vec2 dirB = normalize((nextPosScreen - posScreen));
                    vec2 tangent = normalize(dirA + dirB);
                    vec2 normal = normalize(vec2(-tangent.y, tangent.x));

                    // choose which direction to extrude
                    if (uv.x > 0.5) {
                        normal = -normal;
                    }
                    normal.x /= aspect;

                    // extrude line in screen space
                    // set thickness based on camera distance, so that far away lines don't appear too thin
                    float width = viewPos.z * 0.0009 * aspect;
                    normal *= width;
                    vec4 thicknessOffset = vec4(normal.xy, 0.0, 0.0);

                    gl_Position = finalPos + thicknessOffset;

                    vHighPrecisionZW = gl_Position.zw;
                }
            `, fragmentShader: `
                layout(location = 1) out highp vec4 gInfo;

                ${globalUBO_default}
                ${fog_default}

                uniform vec3 uColor;
                uniform sampler2D tNoise;

                varying float vRandom;
                varying vec2 vUv;
                varying vec4 vPos;
                varying vec2 vHighPrecisionZW;

                void main() {

                    float n = texture2D(tNoise, vec2(0.5 + vRandom, vUv.y * 0.02)).r;
                    if (n < 0.4) discard;

                    vec3 color = uColor;

                    gl_FragColor = vec4(color, 1.0);
                    gInfo = vec4(1.0, vec2(0.0), 0.0);
                }
            `, side: DoubleSide
        }); i.forEach((a, o) => { const l = new PlanetMesh(a, s, this.scene, 25); this.mesh.add(l) }), this.ready.resolve()
    }
} class waterfall {
    constructor(e, i = {}) { this.scene = e, this.options = i, this.ready = new Promise(s => { this.isReady = s }), this.init() } async init() {
        const [e, i, s] = await Promise.all([geometryLoader.load("./planets/present/waterfall_vfx.drc"), geometryLoader.load("./planets/present/waterfallsplash_vfx.drc"), geometryLoader.load("./planets/present/waterfall_inlet_vfx.drc")]); this.mesh = new PlanetMesh(e, new ShaderMaterial({
            userData: { hotReload: "waterfallvfx" }, uniformsGroups: [global$1.UBO], uniforms: { uColor1: { value: new Color("#739fb1") }, uColor2: { value: new Color("#376f74") }, uColor3: { value: new Color("#afe7eb") }, tNoise: { value: textureLoader.load("water-noises-highq.ktx2", "linearfilter-repeat") }, tNoise2: { value: textureLoader.load("noise-simplex-layered-blur-highq.ktx2", "linearfilter-repeat") }, tNoise3: { value: textureLoader.load("clouds_noise_64.ktx2", "linearfilter-repeat") }, ...fogUniforms }, vertexShader: `
                ${globalUBO_default}


                attribute float scalefactor;

                varying vec2 vHighPrecisionZW;
                varying vec2 vUv;
                varying vec2 vUv2;
                varying float vScaleFactor;
                varying vec3 vLocalPos;
                varying vec4 vPos;

                uniform sampler2D tNoise;

                void main() {
                    vLocalPos = position;

                    // vec2 displacementUv = uv;
                    // displacementUv.y *= 0.08;
                    // displacementUv * vec2(1.0, 0.5 + displacementUv.y * 0.5);
                    // displacementUv.y += time * 0.085;

                    // float n1 = texture2D(tNoise, displacementUv).r;

                    // float grad = 1.0 - abs(n1 - 0.5) * 2.0;
                    // grad = step(0.95, grad);

                    // vec3 pos = position + normal * grad * 0.03 * (1.0 - scalefactor * 1.75);
                    vec3 pos = position;

                    vPos = modelViewMatrix * vec4(pos, 1.0);

                    gl_Position = projectionMatrix * vPos;
                    vHighPrecisionZW = gl_Position.zw;
                    vUv = uv;
                    vUv2 = uv;
                    vScaleFactor = scalefactor;
                }
            `, fragmentShader: `
                ${globalUBO_default}
                ${aastep_default}
                ${fog_default}

                layout(location = 1) out highp vec4 gInfo;

                varying vec2 vHighPrecisionZW;
                varying vec2 vUv;
                varying vec2 vUv2;
                varying float vScaleFactor;
                varying vec3 vLocalPos;
                varying vec4 vPos;

                uniform sampler2D tNoise;
                uniform sampler2D tNoise2;
                uniform sampler2D tNoise3;
                uniform vec3 uColor1;
                uniform vec3 uColor2;
                uniform vec3 uColor3;

                void main() {

                    vec3 off = vLocalPos * 0.025;

                    vec2 uv = vUv;
                    uv.y *= 0.08;

                    uv.y += time * 0.04;

                    float n1 = texture2D(tNoise, vec2(uv.x * (0.5 - vScaleFactor * 0.3) + time * 0.01, uv.y + vScaleFactor * 0.25)).r; // foam
                    float n2 = texture2D(tNoise2, vUv * vec2(0.5, 0.1) + vec2(off.x, time * 0.05)).g;
                    n2 -= texture2D(tNoise2, vUv * vec2(2.0 - vScaleFactor * 2.0, 0.15) + vec2(off.z, time * 0.031)).g;
                    float n3 = texture2D(tNoise2, vUv * vec2(0.5, 0.5 + vUv.y * 0.25) + vec2(-off.x, time * 0.3)).r;

                    float n4 = 1.0 - texture2D(tNoise3, vUv * vec2(0.5, 0.5) - vec2(time * 0.02 - off.z, time * 0.11)).r;
                    n4 = 1.0 - pow(1.0 - n4, 2.0);

                    float edgegrad = 1.0 - abs(vUv.x - 0.5) * 2.0;
                    edgegrad -= n3 * 0.2;

                    float edgemask = 1.0 - aastep(0.125 + vScaleFactor * 0.25, edgegrad);

                    // streaks
                    float streaks = 1.0 - abs(n1 - 0.5) * 2.0;
                    streaks = streaks * streaks * streaks;
                    streaks = aastep(0.5, streaks);

                    // foam near ground
                    float foam = vUv.y - n4 * 0.04;
                    float foammask = 1.0 - step(0.002, foam);

                    if (edgegrad < 0.05) discard;

                    // stylized specular shine
                    float shine1 = 1.0 - clamp(abs(vUv.y - 0.6) * 4.0, 0.0, 1.0);
                    shine1 = 1.0 - pow(1.0 - shine1, 2.0);
                    shine1 -= n2 * 0.06;
                    shine1 = aastep(0.97, shine1);

                    // another specular shine
                    float shine2 = 1.0 - clamp(abs(vUv.y - 0.3) * 4.0, 0.0, 1.0);
                    shine2 = 1.0 - pow(1.0 - shine2, 2.0);
                    shine2 -= n2 * 0.2;
                    shine2 = aastep(0.91, shine2 - 0.05);

                    // darker color near base of waterfall
                    float shadow = vUv.y - n2 * 0.25;
                    shadow = 1.0 - aastep(0.275, shadow);

                    // composite all effects together
                    vec3 color = uColor1;
                    color = mix(color, uColor3, max(shine1, shine2));
                    color = mix(color, uColor2, shadow);
                    color = mix(color, vec3(1.0), max(streaks, edgemask));
                    color = mix(color, vec3(1.0), foammask);

                    gl_FragColor = vec4(color, 1.0 - (0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5));
                    gInfo = vec4(1.0, vec2(0.0), 0.0);

                }
            `, side: DoubleSide
        }), this.scene, 25), this.mesh.name = "waterfallvfx", this.scene.planetGroup.add(this.mesh), this.mesh2 = new PlanetMesh(i, new ShaderMaterial({
            userData: { hotReload: "waterfallsplashvfx" }, uniformsGroups: [global$1.UBO], uniforms: { uColor1: { value: new Color("#79adbd") }, uColor2: { value: new Color("#4a7683") }, uColor3: { value: new Color("#afe7eb") }, tNoise: { value: textureLoader.load("water-noises-highq.ktx2", "linearfilter-repeat") }, tNoise2: { value: textureLoader.load("noise-simplex-layered-pixellated-highq.ktx2", "linearfilter-repeat") }, tNoise3: { value: textureLoader.load("clouds_noise_64.ktx2", "linearfilter-repeat") }, ...fogUniforms }, vertexShader: `
                ${globalUBO_default}

                varying vec2 vHighPrecisionZW;
                varying vec2 vUv;
                varying vec4 vPos;

                void main() {
                    vPos = modelViewMatrix * vec4(position, 1.0);

                    gl_Position = projectionMatrix * vPos;
                    vHighPrecisionZW = gl_Position.zw;
                    vUv = uv;
                }
            `, fragmentShader: `
                ${globalUBO_default}
                ${aastep_default}
                ${fog_default}

                layout(location = 1) out highp vec4 gInfo;

                varying vec2 vHighPrecisionZW;
                varying vec2 vUv;
                varying vec4 vPos;

                uniform sampler2D tNoise;
                uniform sampler2D tNoise2;
                uniform sampler2D tNoise3;
                uniform vec3 uColor1;
                uniform vec3 uColor2;
                uniform vec3 uColor3;

                void main() {

                    vec2 uv = vUv * vec2(1.0, 5.0);
                    uv.x = pow(uv.x, 2.0);

                    // animated texture
                    float mask1 = texture2D(tNoise, uv + vec2(-time * 0.2, 0.0)).r;

                    // concentric rings that animate outwards
                    float concentric = sin(uv.x * 25.0 - time * 5.0) * 0.5 + 0.5;

                    // foam pattern that animates outwards
                    float foam = mask1 * 0.65;
                    foam += 0.3 * (pow(concentric, 20.0));
                    foam += pow(1.0 - vUv.x, 3.0);
                    foam *= 1.0 - pow(smoothstep(0.2, 1.0, vUv.x), 3.0);

                    float alpha = step(0.5, foam);
                    if (alpha < 0.5) discard;

                    vec3 color = vec3(1.0);

                    gl_FragColor = vec4(color, 1.0 - (0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5));
                    gInfo = vec4(1.0, vec2(0.0), 0.0);

                }
            `}), this.scene, 25), this.mesh2.name = "waterfallsplashvfx", this.scene.planetGroup.add(this.mesh2), this.mesh3 = new PlanetMesh(s, new ShaderMaterial({
                userData: { hotReload: "waterfallinletvfx" }, uniformsGroups: [global$1.UBO], uniforms: { uColor1: { value: new Color("#6695a7") }, uColor2: { value: new Color("#486c81") }, uColor3: { value: new Color("#afe7eb") }, tNoise: { value: textureLoader.load("water-noises-highq.ktx2", "linearfilter-repeat") }, tNoise2: { value: textureLoader.load("noise-simplex-layered-pixellated-highq.ktx2", "linearfilter-repeat") }, tNoise3: { value: textureLoader.load("clouds_noise_64.ktx2", "linearfilter-repeat") }, ...fogUniforms }, vertexShader: `
                ${globalUBO_default}

                attribute vec2 uv2;
                attribute float extrafoam;

                varying vec2 vHighPrecisionZW;
                varying vec2 vUv;
                varying vec2 vUv2;
                varying float vExtraFoam;
                varying vec4 vPos;

                void main() {
                    vPos = modelViewMatrix * vec4(position, 1.0);
                    gl_Position = projectionMatrix * vPos;
                    vHighPrecisionZW = gl_Position.zw;
                    vUv = uv;
                    vUv2 = uv2;
                    vExtraFoam = extrafoam;
                }
            `, fragmentShader: `
                ${globalUBO_default}
                ${aastep_default}
                ${fog_default}

                layout(location = 1) out highp vec4 gInfo;

                varying vec2 vHighPrecisionZW;
                varying vec2 vUv;
                varying vec2 vUv2;
                varying float vExtraFoam;
                varying vec4 vPos;

                uniform sampler2D tNoise;
                uniform sampler2D tNoise2;
                uniform sampler2D tNoise3;
                uniform vec3 uColor1;
                uniform vec3 uColor2;
                uniform vec3 uColor3;

                void main() {

                    // vec2 uv = vUv * vec2(1.0, 5.0);
                    // uv.x = pow(uv.x, 2.0);

                    float foam = texture2D(tNoise, vUv * vec2(0.5, 2.0) + vec2(0.5, time * 0.1)).r;
                    float foam2 = texture2D(tNoise, vUv * vec2(0.5, 2.0) * 2.0 + vec2(0.0, time * 0.09)).r;
                    float edges = smoothstep(0.3, 0.0, vUv.x) + smoothstep(0.8, 1.0, vUv.x);

                    // // concentric rings that animate outwards
                    // float concentric = sin(uv.x * 25.0 - time * 3.0) * 0.5 + 0.5;

                    // // foam pattern that animates outwards
                    // float foam = mask1 * 0.65;
                    // foam += 0.3 * (pow(concentric, 20.0));
                    // foam += pow(1.0 - vUv.x, 3.0);
                    // foam *= 1.0 - pow(smoothstep(0.2, 1.0, vUv.x), 3.0);

                    // float alpha = step(0.5, foam);
                    // if (alpha < 0.5) discard;

                    float value = max(foam, edges);
                    value = max(value, smoothstep(0.2, 0.0, vUv.y) - foam2 * 0.1 + vExtraFoam * foam2 * 1.5);
                    value = step(0.7, value);

                    // composite all effects together
                    vec3 color = uColor1;
                    color = mix(uColor1, uColor2, step(0.4, smoothstep(0.425, 0.6, vUv.y) - foam2 * 0.1));
                    color = mix(color, vec3(1.0), value);

                    float n2 = texture2D(tNoise2, vUv * vec2(0.55, 1.0) + vec2(0.0, time * 0.04)).g;
                    float alpha = smoothstep(0.0, 0.05, vUv.y) - foam2 * 0.4;
                    if (alpha < 0.05) discard;

                    gl_FragColor = vec4(color, 1.0 - (0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5));
                    gInfo = vec4(1.0, vec2(0.0), 0.0);

                }
            `}), this.scene, 25), this.mesh3.name = "waterfallinletvfx", this.scene.planetGroup.add(this.mesh3), this.isReady()
    }
} class atmosphere {
    constructor(e, i = {}) { this.scene = e, this.options = i, this.ready = new Promise(s => { this.isReady = s }), this.init() } init() {
        this.mesh = new Mesh(new SphereGeometry(38, 32, 32), new ShaderMaterial({
            userData: { hotReload: "Atmosphere" }, uniformsGroups: [global$1.UBO], uniforms: { uColor1: { value: new Color("#568f66") }, tCloudNoise: { value: textureLoader.load("clouds_noise_64.ktx2", "srgb-repeat") }, uShow: { value: 0 } }, vertexShader: `
                varying vec2 vHighPrecisionZW;
                varying vec3 vNormal;
                varying vec3 vPos;
                varying vec3 vMvPos;

                void main() {
                    vPos = position;
                    vMvPos = vec3(modelViewMatrix * vec4(position, 1.0));
                    gl_Position = projectionMatrix * vec4(vMvPos, 1.0);
                    vHighPrecisionZW = gl_Position.zw;
                    vNormal = normalize(normalMatrix * normal);
                }
            `, fragmentShader: `
                ${globalUBO_default}
                ${triplanar_default}

                layout(location = 1) out highp vec4 gInfo;

                varying vec2 vHighPrecisionZW;
                varying vec3 vNormal;
                varying vec3 vMvPos;
                varying vec3 vPos;

                uniform sampler2D tCloudNoise;
                uniform vec3 uColor1;
                uniform float uShow;

                void main() {
                    float fresnel = dot(normalize(vNormal), normalize(vMvPos.xyz));
                    fresnel = abs(fresnel);

                    // main cloud shape
                    float noise = triplanar(tCloudNoise, vNormal, vPos, 0.015).x;
                    noise *= 1.0 - pow(1.0 - fresnel, 2.0);
                    noise *= uShow;

                    if (noise < 0.3) discard;

                    gl_FragColor = vec4(uColor1, 0.434532);
                    gInfo = vec4(1.0 - (0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5), vec2(0.0), 0.0);
                }
            `, side: BackSide, transparent: !0, blending: CustomBlending, blendSrc: SrcAlphaFactor, blendSrcAlpha: ZeroFactor, blendDst: OneFactor, blendDstAlpha: OneFactor
        })), this.mesh.name = "Atmosphere", this.mesh.renderOrder = 5, this.scene.add(this.mesh), this.isReady()
    } playInAnimation(e = 0) { createTween(this.mesh.material.uniforms.uShow, { from: { value: 0 }, to: { value: 1 }, duration: 2.5, delay: e, ease: "sine.out" }) }
} function material$1(r = {}) {
    const e = UniformsUtils.merge([UniformsLib.common, UniformsLib.lights, { uColor: { value: new Color("#F8F8F8") }, uColor2: { value: new Color("#a0a8a6") }, tNoise: { value: null } }]); return e.tNoise.value = textureLoader.load("clouds_noise_64.ktx2", "srgb-repeat"), new ShaderMaterial({
        userData: { hotReload: "title" }, uniformsGroups: [global$1.UBO], uniforms: e, vertexShader: `
            ${globalUBO_default}
            ${matrixutils_default}

            /* BATCHING */
            #if ! defined(GL_ANGLE_multi_draw)
                #define gl_DrawID _gl_DrawID
                uniform int _gl_DrawID;
            #endif
            uniform highp sampler2D batchingTexture;
            uniform highp usampler2D batchingIdTexture;

            mat4 getBatchingMatrix(const in int i) {
                int size = textureSize(batchingTexture, 0).x;
                int j = i * 4;
                int x = j % size;
                int y = j / size;
                vec4 v1 = texelFetch(batchingTexture, ivec2(x, y), 0);
                vec4 v2 = texelFetch(batchingTexture, ivec2(x + 1, y), 0);
                vec4 v3 = texelFetch(batchingTexture, ivec2(x + 2, y), 0);
                vec4 v4 = texelFetch(batchingTexture, ivec2(x + 3, y), 0);
                return mat4(v1, v2, v3, v4);
            }

            float getIndirectIndex(const in int i) {
                int size = textureSize(batchingIdTexture, 0).x;
                int x = i % size;
                int y = i / size;
                return float(texelFetch(batchingIdTexture, ivec2(x, y), 0).r);
            }

            attribute float surfaceId;

            varying float vSurfaceId;
            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec2 vHighPrecisionZW;

            vec3 hash31(float p) {
                vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));
                p3 += dot(p3, p3.yzx+33.33);
                return fract((p3.xxy+p3.yzz)*p3.zyx);
            }

            mat4 rotation3D(vec3 axis, float angle) {
                axis = normalize(axis);
                float s = sin(angle);
                float c = cos(angle);
                float oc = 1.0 - c;

                return mat4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
                            oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s,  0.0,
                            oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,  0.0,
                            0.0, 0.0, 0.0, 1.0);
            }

            void main() {
                vSurfaceId = surfaceId;
                vUv = uv;

                float batchID = getIndirectIndex(gl_DrawID);
                mat4 batchingMatrix = getBatchingMatrix(int(batchID));

                vec3 norm = normal;
                mat3 bm = mat3(batchingMatrix);
                norm /= vec3(dot(bm[0], bm[0]), dot(bm[1], bm[1]), dot(bm[2], bm[2]));
                norm = bm * norm;
                vNormal = normalize(normalMatrix * norm);

                // random stepped rotation animation
                float t = floor(time * 3.0);
                vec3 axis = normalize(hash31(batchID + t) * 2.0 - 1.0);
                float angle = 0.03;

                vec4 pos = vec4(position, 1.0);
                pos = rotation3D(axis, angle) * pos;

                gl_Position = projectionMatrix * modelViewMatrix * batchingMatrix * pos;
                vHighPrecisionZW = gl_Position.zw;
            }
        `, fragmentShader: `
            layout(location = 1) out highp vec4 gInfo;

            ${globalUBO_default}
            ${encoding_default}

            varying float vSurfaceId;
            varying vec2 vHighPrecisionZW;
            varying vec3 vNormal;
            varying vec2 vUv;

            uniform sampler2D tNoise;
            uniform vec3 uColor;
            uniform vec3 uColor2;

            void main() {
                float noise = texture(tNoise, vUv * 6.0).r;

                float outlineContribution = step(0.25, noise);
                float surfaceId = vSurfaceId;

                vec3 norm = normalize(vNormal);
                float facing = abs(dot(norm, normalize(vec3(0.0, 0.0, 1.0))));
                vec3 color = mix(uColor, uColor2, 1.0 - smoothstep(0.2, 0.8, facing));


                gl_FragColor = vec4(color, surfaceId);
                gInfo = vec4(1.0 - (0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5), encodeNormalSpheremap(norm), outlineContribution);
            }
        `})
} const _v0$f = new Vector3, _v1$9 = new Vector3, _v2$2 = new Vector3, _m0$3 = new Matrix4; class title$1 { constructor(e) { this.scene = e, this.ready = miscutils.deferred(), this.baseOffset = 2, this.objs = [], this.hovering = !1, this.hoveredObj = null, this.lastPosition = { x: 0, y: 0 }, this.deltaAccum = { x: 0, y: 0 }, this.updateCamPosition = !0, this.camPosition = new Vector3, this.init() } async init() { const e = await geometryLoader.batched("planets/present/intro/title_vertical.drc"); this.group = new Group, this.group.name = "Title Group", this.groupHit = new Group; let i = e.length, s = e.reduce((l, c) => l + c.attributes.position.count, 0), a = e.reduce((l, c) => l + c.index.count, 0); this.mesh = new BatchedMesh(i, s, a, material$1({})), this.mesh.name = "Title", this.mesh.frustumCulled = !1, this.mesh.sortObjects = !1, this.mesh.receiveShadow = !1, this.mesh.castShadow = !1, this.mesh.perObjectFrustumCulled = !1, e.forEach((l, c) => { this.mesh.addInstance(this.mesh.addGeometry(l)); const h = new Group; h.__finalPosition = { x: 0, y: 0, z: 0 }, h.__position = { x: 0, y: 0, z: 0 }, h.__finalRotation = { x: 0, y: 0 }, h.__rotation = { x: 0, y: 0 }, h.__scale = { value: 1 }, h.__animRotation = { x: 0, y: 0 }, h.__animScale = { value: 1 }; const d = 5.35; h.__position.x = (c % 3 - 1) * d, h.__position.y = (Math.floor(c / 3) - 1) * -6.9, h.__position.z = 0, h.__finalPosition.x = h.__position.x, h.__finalPosition.y = h.__position.y, h.__finalPosition.z = h.__position.z, h.position.copy(h.__finalPosition), h.updateMatrix(), this.objs.push(h) }), this.group.add(this.mesh), this.scene.add(this.group); const o = e.map(() => new BoxGeometry(4.05, 5.35, 4.25)); i = o.length, s = o.reduce((l, c) => l + c.attributes.position.count, 0), a = o.reduce((l, c) => l + c.index.count, 0), this.hitMesh = new BatchedMesh(i, s, a, material$1({})), this.hitMesh.name = "Title Hitmesh", this.hitMesh.frustumCulled = !1, this.hitMesh.sortObjects = !1, this.hitMesh.receiveShadow = !1, this.hitMesh.castShadow = !1, this.hitMesh.perObjectFrustumCulled = !1, this.groupHit.add(this.hitMesh), o.forEach((l, c) => { this.hitMesh.addInstance(this.hitMesh.addGeometry(l)), this.hitMesh.setMatrixAt(c, this.objs[c].matrix) }), this.scene.beforeRenderCbs.push(this.update.bind(this)), this.interaction = new meshInteraction({ meshes: [this.hitMesh], camera: this.scene.camera, interactWhileTouching: !0, onMove: this.move, onHover: this.hover, onTouch: this.touch, ctx: this }), this.ready.resolve() } update() { if (this.scene.___disposed) return; const e = this.scene.camera; this.updateCamPosition && this.camPosition.copy(e.position), _v0$f.copy(e.target).sub(this.camPosition).normalize(), _v1$9.copy(this.camPosition).addScaledVector(_v0$f, 45), this.group.position.copy(_v1$9), _v0$f.subVectors(this.camPosition, e.target), _v0$f.lengthSq() === 0 && (_v0$f.z = 1), _v0$f.normalize(), _v1$9.crossVectors(e.up, _v0$f), _v1$9.lengthSq() === 0 && (Math.abs(e.up.z) === 1 ? _v0$f.x += 1e-4 : _v0$f.z += 1e-4, _v0$f.normalize(), _v1$9.crossVectors(e.up, _v0$f)), _v1$9.normalize(), _v2$2.crossVectors(_v0$f, _v1$9), this.group.position.addScaledVector(_v2$2, this.baseOffset), this.group.quaternion.setFromRotationMatrix(_m0$3.lookAt(this.camPosition, e.target, _v0$f.set(0, 1, 0))), this.group.updateMatrixWorld(), this.groupHit.position.copy(this.group.position), this.groupHit.quaternion.copy(this.group.quaternion), this.groupHit.scale.copy(this.group.scale), this.groupHit.updateMatrix(), this.groupHit.updateMatrixWorld(), this.objs.forEach((i, s) => { i.position.copy(i.__finalPosition), i.rotation.set(i.__finalRotation.x + i.__animRotation.x, i.__finalRotation.y + i.__animRotation.y, 0), i.scale.setScalar(i.__scale.value * i.__animScale.value), i.updateMatrix(), this.mesh.setMatrixAt(s, i.matrix) }), this.updateDelta() } updateDelta() { const e = touches$1.get(0), i = e.position.x - this.lastPosition.x, s = -(e.position.y - this.lastPosition.y); this.deltaAccum.x += i, this.deltaAccum.y += s, this.lastPosition.x = e.position.x, this.lastPosition.y = e.position.y; const a = math.frictionFPS(.4); this.deltaAccum.x *= a, this.deltaAccum.y *= a } touch(e) { e.action === "touch_start" ? (this.lastPosition.x = e.event.position.x, this.lastPosition.y = e.event.position.y, this.deltaAccum.x = 0, this.deltaAccum.y = 0, this.move(e)) : (this.updateDelta(), this.hovering && this.hover({ action: "hover_out" })) } move(e) { this.hovering = !0, this.hoveredObj = e.interactions[0].batchId } hover(e) { if (e.action === "hover_in") { this.hovering = !0, this.hoveredObj = e.interactions[0].batchId; const i = this.objs[this.hoveredObj]; createTween(i.__scale, { to: { value: 1.05 }, duration: .2, ease: "power2.out", onComplete: () => { createTween(i.__scale, { to: { value: 1 }, duration: .75, ease: "elastic.out(1, 0.6)" }) } }) } else { this.hovering = !1; const i = Math.abs(this.deltaAccum.x) > Math.abs(this.deltaAccum.y) ? "x" : "y", s = Math.sign(this.deltaAccum[i] * (i === "y" ? -1 : 1)); if (s === 0 || this.hoveredObj === null) return; const a = this.objs[this.hoveredObj]; let o = 1; i === "x" && (o = math.makeAnglePositive(a.__rotation.x) > .1 ? -1 : 1); const l = i === "x" ? "y" : "x"; a.__rotation[l] += Math.PI * s * o; const c = a.__rotation[l] - a.rotation[l]; a.__finalRotation[l] = math.makeAnglePositive(a.rotation[l]), a.__rotation[l] = a.__finalRotation[l] + c, a.__rotation[l] = Math.round(a.__rotation[l] / Math.PI) * Math.PI, createTween(a.__finalRotation, { to: l === "x" ? { x: a.__rotation[l] } : { y: a.__rotation[l] }, duration: 2.5, ease: `elastic.out(1,${(.5 + Math.random() * .3).toFixed(2)})` }), createTween(a.__scale, { to: { value: .9 }, duration: .4, ease: "power2.out", onComplete: () => { createTween(a.__scale, { to: { value: 1 }, duration: 1, ease: "elastic.out(1, 0.6)" }) } }), events.emit("webgl_play_audio", `rune${Math.floor(Math.random() * 3 + 1)}`) } } playInAnimation(e = 0) { for (let i = 0; i < this.objs.length; i++) { const s = this.objs[i]; s.__animScale.value = 0; const a = e + .075 * i; createTween(s.__animScale, { from: { value: 0 }, to: { value: 1 }, duration: 3, delay: a, ease: "elastic.out(1, 0.75)" }), createTween(s.__animRotation, { from: { x: (Math.random() - .5) * Math.PI * 2, y: (Math.random() - .5) * Math.PI * 2 }, to: { x: 0, y: 0 }, duration: 3, delay: a, ease: "elastic.out(1, 0.75)" }); const o = this.objs[4].__position; createTween(s.__finalPosition, { from: { x: o.x, y: o.y, z: o.z }, to: { x: s.__position.x, y: s.__position.y, z: s.__position.z }, duration: 3, delay: a, ease: "elastic.out(1, 0.75)" }) } } playOutAnimation(e = 0) { this.updateCamPosition = !1 } resize() { const e = this.scene.mobileLayout ? 1.2 : 1; this.mesh.scale.setScalar(e), this.hitMesh.scale.setScalar(e) } } class particles {
    constructor(e) { this.scene = e, this.ready = new Promise(i => { this.isReady = i }), this.init() } async init() {
        const e = await geometryLoader.load("/planets/intro/points.drc"), i = new ShaderMaterial({
            uniformsGroups: [global$1.UBO], uniforms: { tSprites: { value: textureLoader.load("particle_sprites.ktx2", "srgb-repeat") }, uColor: { value: new Color("#6a8f89") }, uShow1: { value: 0 } }, vertexShader: `
                ${globalUBO_default}
                ${fit_default}
                ${rotate_default}
                ${falloff_default}

                attribute vec3 color;

                uniform float uShow1;

                varying vec3 vNoise;
                varying float vProgress;
                varying float vRotation;
                varying float vSize;
                varying vec2 vHighPrecisionZW;

                void main() {
                    vNoise = color;

                    float steppedTime = floor(time * 2.0) / 2.0;
                    vec3 pos = position;

                    vRotation = sin(steppedTime + vNoise.r * 20.0) * 3.14 * vNoise.g;
                    pos.y += vRotation * 0.1;

                    vec4 mvPos = modelViewMatrix * vec4(pos, 1.0);

                    vProgress = fract(vNoise.g * 20.0);
                    vProgress = floor(vProgress * 16.0) / 16.0;
                    vProgress = clamp(vProgress, 0.0, 1.0);

                    vSize = vNoise.b;
                    if (vSize > 0.5) {
                        vSize *= 2.0;
                    }

                    gl_Position = projectionMatrix * mvPos;
                    vHighPrecisionZW = gl_Position.zw;

                    gl_PointSize = (resolution.y / mix(70.0, 50.0, vSize)) * uShow1;
                }
            `, fragmentShader: `
                layout(location = 1) out highp vec4 gInfo;

                ${globalUBO_default}
                ${falloff_default}

                varying vec3 vNoise;
                varying float vProgress;
                varying float vRotation;
                varying float vSize;
                varying vec2 vHighPrecisionZW;

                uniform sampler2D tSprites;
                uniform vec3 uColor;
                uniform float uShow1;

                mat2 rotate(float a) {
                    float s = sin(a);
                    float c = cos(a);
                    mat2 m = mat2(c, s, -s, c);
                    return m;
                }

                void main() {
                    vec2 uv = gl_PointCoord.xy;

                    // randomize sprite rotation
                    uv -= 0.5;
                    uv = rotate(vRotation) * uv;
                    uv += 0.5;

                    // scale uvs to match a single character of the spritesheet
                    uv.y = 1.0 - uv.y;
                    uv.x /= 16.0;
                    uv.x += 1.0 / 16.0;

                    // choose random sprite from spritesheet
                    uv.x += vProgress;

                    float sprite = texture2D(tSprites, uv).r;
                    float alpha = sprite;
                    if (alpha < 0.5) discard;

                    alpha *= smoothstep(0.0, 0.1, uShow1);

                    vec3 color = mix(uColor + uColor * 0.5, uColor * uColor, vNoise.r);

                    float outlineContribution = 0.0;
                    float depth = 1.0 - (0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5);

                    if (vSize > 1.5) {
                        outlineContribution = 0.1;
                        depth = 0.1; // overwrite to ignore outline fading on distance
                    }

                    gl_FragColor = vec4(color, alpha);
                    gInfo = vec4(depth, 0.0, 0.0, outlineContribution);
                }
            `, transparent: !0, blending: CustomBlending, blendSrc: SrcAlphaFactor, blendSrcAlpha: ZeroFactor, blendDst: OneFactor, blendDstAlpha: OneFactor
        }); this.mesh = new Points(e, i), this.mesh.name = "stars", this.mesh.renderOrder = 1, this.mesh.receiveShadow = !1, this.mesh.castShadow = !1, this.mesh.frustumCulled = !1, this.scene.add(this.mesh), this.isReady()
    } playInAnimation(e = 0) { createTween(this.mesh.material.uniforms.uShow1, { from: { value: 0 }, to: { value: 1 }, duration: 2, delay: e, ease: "sine.inOut" }), this.mesh.rotation.y = -Math.PI * .75, createTween(this.mesh.rotation, { to: { y: 0 }, duration: 4, delay: e + .5, ease: "inOut3" }) }
} class galaxies {
    constructor(e, i = {}) { this.scene = e, this.options = i, this.ready = new Promise(s => { this.isReady = s }), this.init() } async init() {
        const e = await geometryLoader.load("planets/present/intro/galaxies.drc"); this.mesh = new Mesh(e, new ShaderMaterial({
            userData: { hotReload: "Galaxies" }, uniformsGroups: [global$1.UBO], uniforms: { uColor1: { value: new Color("#4f755a") }, uColor2: { value: new Color("#3a726b") }, uColor3: { value: new Color("#4b5766") }, tCloudNoise: { value: textureLoader.load("clouds_noise_64.ktx2", "srgb-repeat") }, tGalaxy: { value: textureLoader.load("galaxy.ktx2", "srgb-repeat") }, uShow: { value: 0 } }, vertexShader: `
                attribute float surfaceId;

                varying vec2 vHighPrecisionZW;
                varying vec2 vUv;
                varying float vSurfaceId;

                void main() {
                    vSurfaceId = surfaceId;
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    vHighPrecisionZW = gl_Position.zw;
                }
            `, fragmentShader: `
                ${globalUBO_default}
                ${triplanar_default}
                ${colorutils_default}

                layout(location = 1) out highp vec4 gInfo;

                varying vec2 vHighPrecisionZW;
                varying vec2 vUv;
                varying float vSurfaceId;

                uniform sampler2D tCloudNoise;
                uniform sampler2D tGalaxy;
                uniform vec3 uColor1;
                uniform vec3 uColor2;
                uniform vec3 uColor3;
                uniform float uShow;

                mat2 rotation2D(float angle) {
                    float s = sin(angle);
                    float c = cos(angle);
                    return mat2(c, s, -s, c);
                }

                void main() {
                    float spinDir = vSurfaceId > 0.5 ? 1.0 : -1.0;
                    vec2 uv = vUv;
                    uv -= 0.5;
                    uv = rotation2D(floor(time * 2.0 + vSurfaceId * 100.0) * 0.06 * spinDir) * uv;
                    uv *= 1.5;
                    uv += 0.5;

                    float noise = texture2D(tCloudNoise, uv).x;

                    vec2 galaxyUv = vUv;

                    if (fract(vSurfaceId + 0.75) > 0.5) {
                        galaxyUv.x = 1.0 - galaxyUv.x;
                    }

                    float value = texture2D(tGalaxy, galaxyUv).r;
                    value = 1.0 - pow(1.0 - value, 5.0);

                    // make some planet shaped
                    if (fract(vSurfaceId + 0.2) > 0.5) {
                        value = 1.0 - clamp(length(vUv - 0.5) * 8.0, 0.0, 1.0);
                    }

                    value -= noise * mix(0.1, 0.95, fract(vSurfaceId + 0.873));

                    float alpha = step(0.25, value * uShow);

                    if (alpha < 0.9) discard;

                    float colorid = floor(vSurfaceId * 3.0);
                    vec3 color = mix(uColor1, uColor2, clamp(colorid, 0.0, 1.0));
                    color = mix(color, uColor3, clamp(colorid - 1.0, 0.0, 1.0));

                    gl_FragColor = vec4(color, alpha * mix(0.3, 0.4, vSurfaceId));
                    gInfo = vec4(1.0 - (0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5), vec2(0.0), 0.0);
                }
            `, transparent: !0, blending: CustomBlending, blendSrc: SrcAlphaFactor, blendSrcAlpha: ZeroFactor, blendDst: OneFactor, blendDstAlpha: OneFactor
        })), this.mesh.name = "Galaxies", this.mesh.renderOrder = 5, this.scene.add(this.mesh), this.mesh.scale.setScalar(3), this.isReady()
    } playInAnimation(e = 0) { createTween(this.mesh.material.uniforms.uShow, { from: { value: 0 }, to: { value: 1 }, duration: 3, delay: e, ease: "none" }) }
} const _v0$e = new Vector3, depthMaterial = new MeshDepthMaterial({ depthPacking: RGBADepthPacking }); class followCSM extends DirectionalLight { static setOrthographicFrustum(e, i) { e.left = -i, e.right = i, e.top = i, e.bottom = -i, e.updateProjectionMatrix() } constructor({ color: e = "#ffffff", intensity: i = 1, scene: s = null, positionOffset: a = new Spherical(2, Math.PI * .2, 0), forwardOffset: o = 5, castShadow: l = !0, shadowMapSize: c = 2048, shadowSize: h = 12, csm: d = !0, csmMapSize: p = Math.min(Math.min(client$1.screen.w, client$1.screen.h) < 640 ? 4096 : 8192, webglRenderer.webgl.capabilities.maxTextureSize), csmBoundingSphere: f = new Sphere(new Vector3, 1), csmNear: _ = 1, csmLODLevel: x = 1, cameraLayer: b = 30, skipCSMMeshes: T = [] } = {}) { var M; if (super(e, i), !s) throw new Error("Follow CSM light requires a scene"); if (this.name = "followCSM", this._scene = s, this._camera = this._scene.camera, this._offset = new Vector3().setFromSpherical(a), this._forwardOffset = o, this._shadowMapSize = c, this.castShadow = l, this.shadow.mapSize.width = this._shadowMapSize, this.shadow.mapSize.height = this._shadowMapSize, followCSM.setOrthographicFrustum(this.shadow.camera, h), d) { this.csmMaps = new Array(x).fill(null).map(() => new WebGLRenderTarget(p, p, { minFilter: NearestFilter, magFilter: NearestFilter })); const w = new OrthographicCamera, D = new Spherical().copy(a); if (D.radius = Math.max(D.radius, f.radius), _v0$e.setFromSpherical(D), (M = this._camera._followedMesh) != null && M.isWorldCharacters) { const N = this._camera._followedMesh._localObject; _v0$e.applyQuaternion(N.quaternion), _v0$e.applyAxisAngle(N.up, Math.PI - N.rotationHorizontal) } w.position.copy(f.center).add(_v0$e), w.lookAt(f.center), w.near = _, w.far = D.radius * 2 - _, followCSM.setOrthographicFrustum(w, D.radius), w.updateMatrixWorld(), w.layers.set(b), this.csmMatrix = new Matrix4, this.csmMatrix.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), this.csmMatrix.multiply(w.projectionMatrix), this.csmMatrix.multiply(w.matrixWorldInverse), this._scene.traverse(N => { var H, F; (H = N.material) != null && H.isMaterial && (N.visible || (F = N.parent) != null && F.isLOD) && N.castShadow && !N.isSkinnedMesh && !T.some(k => k === N) && (N.__prevMaterial = N.material, N.material = N.customDepthMaterial || depthMaterial, N.layers.enable(b)), N.isLOD && (N.__prevAutoUpdate = N.autoUpdate, N.autoUpdate = !1) }); const R = webglRenderer.webgl.getRenderTarget(), P = webglRenderer.webgl.autoClear, U = new Color; webglRenderer.webgl.getClearColor(U); const O = webglRenderer.webgl.getClearAlpha(); for (let N = 0; N < this.csmMaps.length; N++)this._scene.traverse(H => { H.isLOD && H.levels.forEach((F, k) => F.object.visible = k === N) }), webglRenderer.webgl.setRenderTarget(this.csmMaps[N]), webglRenderer.webgl.autoClear = !1, webglRenderer.webgl.setClearColor("#ffffff", 1), webglRenderer.webgl.clear(!0, !0, !1), webglRenderer.webgl.render(this._scene, w); webglRenderer.webgl.setClearColor(U, O), webglRenderer.webgl.autoClear = P, webglRenderer.webgl.setRenderTarget(R), this._scene.traverse(N => { var H, F, k, W, $, Z, J, se, re, ce, ee, Me; if (N.isLOD && (N.autoUpdate = N.__prevAutoUpdate, delete N.__prevAutoUpdate), !!((H = N.material) != null && H.isMaterial)) { if (N.__prevMaterial && (N.material = N.__prevMaterial, delete N.__prevMaterial), N.layers.test(b) && N.layers.disable(b), (k = (F = N.material) == null ? void 0 : F.uniforms) != null && k.csmMap) if (N.parent.isLOD) { const Ee = N.parent.levels.findIndex(Ue => Ue.object === N); Ee > -1 && (N.material.uniforms.csmMap.value = this.csmMaps[this.csmMaps.length > Ee ? Ee : 0].texture) } else N.material.uniforms.csmMap.value = this.csmMaps[0].texture; (Z = ($ = (W = N.material) == null ? void 0 : W.uniforms) == null ? void 0 : $.csmMatrix) != null && Z.value && N.material.uniforms.csmMatrix.value.copy(this.csmMatrix), (re = (se = (J = N.material) == null ? void 0 : J.uniforms) == null ? void 0 : se.csmOptions) != null && re.value && N.material.uniforms.csmOptions.value.set(p, 1, h * .75, h), (Me = (ee = (ce = N.material) == null ? void 0 : ce.uniforms) == null ? void 0 : ee.csmTarget) != null && Me.value && (N.material.uniforms.csmTarget.value = this.target.position) } }) } } updateMatrixWorld(e) { var i, s, a, o, l; if (!miscutils.hasRunThisFrame(this)) { if (this.target.position.copy(this._camera.target), this.target.position.addScaledVector(_v0$e.copy(this._camera.target).sub(this._camera.position).normalize(), this._forwardOffset), this.target.updateMatrixWorld(), (i = this._camera._followedMesh) != null && i.isWorldCharacters) { const c = this._camera._followedMesh._localObject; _v0$e.copy(this._offset).applyQuaternion(c.quaternion), _v0$e.applyAxisAngle(c.up, Math.PI - c.rotationHorizontal), this.position.copy(this.target.position).add(_v0$e), this.up.copy(c.up), this.shadow.camera.up.copy(c.up) } else this.position.copy(this.target.position).add(this._offset); global$1.adaptiveDPR && (global$1.adaptiveDPR.multiplier < .9 ? this.shadow.mapSize.width > this._shadowMapSize * .5 && (this.shadow.mapSize.width = this._shadowMapSize * .5, this.shadow.mapSize.height = this._shadowMapSize * .5, (a = (s = this.shadow.map) == null ? void 0 : s.dispose) == null || a.call(s), this.shadow.map = null) : this.shadow.mapSize.width < this._shadowMapSize && (this.shadow.mapSize.width = this._shadowMapSize, this.shadow.mapSize.height = this._shadowMapSize, (l = (o = this.shadow.map) == null ? void 0 : o.dispose) == null || l.call(o), this.shadow.map = null)) } super.updateMatrixWorld(e) } dispose() { var e; (e = this.csmMaps) == null || e.forEach(i => i.dispose()), super.dispose() } } function followCamera(r) { var e, i, s, a, o, l, ps, Ta, Ma, p; return p = class extends r { constructor() { super(); pe(this, l); pe(this, e, new Vector3); pe(this, i, new Vector3); pe(this, s, new Vector3); pe(this, a, new Spherical); pe(this, o, new Spherical); this.isFollowCamera = !0, this.displacement.position.set(-.075, -.05), this._sphericalCameraPosition = new Spherical, this._spherical = new Spherical, this._sphericalTarget = new Spherical, this._sphericalVerticalMinLimit = Math.PI * .25, this._sphericalVerticalMaxLimit = Math.PI * .75, this._followedMesh = void 0, this._followedMeshPhi = Math.PI * .5, this._followedMeshDistance = 1, this._followedMeshOffset = new Vector3, this._followedMeshOffsetDistance = 0, this._followedMeshOffsetTarget = new Vector3, this._followedMeshTarget = new Vector3, this._cameraCollisions = !0, this._cameraCollisionsMinDistance = .75, this._cameraCollisionsIncrement = .05, this._cameraCollisionsMaxIterations = 10, this._cameraTargetLocalLerp = .0125, this._cameraTargetWorldLerp = .175, this._cameraRotationLerp = .03, this._cameraSphericalRotationLerp = .075, this._cameraSphericalRotationFastLerp = .3, this._cameraSphericalRadiusLerp = .035, this._cameraSphericalRadiusCollisionsLerp = .35, this._cameraAutomaticCenteringActiveLerp = .1, this._cameraAutomaticCenteringInactiveLerp = .0125, this._disableAutomaticCentering = !1, this._automaticCenteringAmount = 1, this._cameraInactiveMultiplier = .025, this.additionalSpherical = new Spherical(0, 0, 0), this.overwriteSpherical = new Spherical(1, Math.PI * .5, 0), this.overwriteTarget = new Vector3, this.overwriteAmount = 0 } follow({ mesh: _ = null, relativeCameraPosition: x = new Vector3(0, 2, 5.75), relativeCameraOffset: b = new Vector3(0, 1, .5) } = {}) { if (!_ || !_._localObject) throw new Error("follow camera needs a mesh character"); this._followedMesh = _, this.setOffset(b.toArray()), L(this, a).setFromVector3(x), L(this, a).phi = math.clamp(L(this, a).phi, this._sphericalVerticalMinLimit, this._sphericalVerticalMaxLimit), this._followedMeshPhi = L(this, a).phi, this._followedMeshDistance = L(this, a).radius, this._spherical.copy(L(this, a)), this._spherical.theta = math.getShortestRotationAngle(this._spherical.theta, this._followedMesh._localObject.rotationHorizontal), this._sphericalTarget.copy(this._spherical), Pe(this, l, ps).call(this, { local: this._followedMesh._localObject, spherical: this._spherical, position: this.baseTarget, temp: L(this, e), target: this.basePosition }), this.baseUp.copy(this._followedMesh._localObject.up) } _update() { if (this._followedMesh) { const _ = this._followedMesh._localObject, x = this._followedMesh._collisionPhysics, b = math.lerpCoefFPS(this._cameraTargetLocalLerp), T = math.lerpCoefFPS(this._cameraTargetWorldLerp); Pe(this, l, Ta).call(this, L(this, e)), L(this, e).add(_.position), L(this, i).copy(this._followedMeshOffset).applyQuaternion(_.quaternion), x._rayCaster.set(L(this, e), L(this, s).copy(L(this, i)).normalize()); const M = x._rayCaster.intersectObject(x._collider)[0]; M && M.distance < this._followedMeshOffsetDistance && L(this, i).set(0, 0, 0), this._sphericalTarget.radius < this._followedMeshDistance * .75 && L(this, i).set(0, 0, 0), this._followedMeshOffsetTarget.lerp(L(this, i), b), this._followedMeshTarget.lerp(L(this, e).add(this._followedMeshOffsetTarget), T), this.baseTarget.lerpVectors(this._followedMeshTarget, this.overwriteTarget, this.overwriteAmount), L(this, e).setFromSpherical(this._spherical).setY(0).normalize(), L(this, i).set(0, 0, -1).applyAxisAngle(L(this, s).set(0, 1, 0), _.rotationHorizontal); const w = math.fit(L(this, e).dot(L(this, i)), 1, 0, 0, 1), D = x._isMoving ? w : this._cameraInactiveMultiplier, R = math.getShortestRotationAngle(this._sphericalTarget.theta, _.rotationHorizontal); let P = 1, U = 1; if (this._followedMesh._controlMode !== "automatic") { const F = this._followedMesh._controls, k = F._isLeftMousePressed === !1 && F._touchCameraFinger === -1 && F._gamepadMovingCamera === !1; P = k ? this._followedMesh._controlAutomaticInfluence : 0, U = k ? this._cameraAutomaticCenteringInactiveLerp : this._cameraAutomaticCenteringActiveLerp } this._automaticCenteringAmount = this._disableAutomaticCentering ? 0 : math.lerp(this._automaticCenteringAmount, P, math.lerpCoefFPS(U)), this._sphericalTarget.theta = math.lerp(this._sphericalTarget.theta, R, math.lerpCoefFPS(this._cameraRotationLerp * D * this._automaticCenteringAmount)), this._sphericalTarget.phi = math.lerp(this._sphericalTarget.phi, this._followedMeshPhi, math.lerpCoefFPS(this._cameraRotationLerp * this._automaticCenteringAmount)); let O = this._sphericalTarget.radius; if (this._cameraCollisions && x._collider) { let F = !1; Pe(this, l, ps).call(this, { local: _, spherical: this._sphericalTarget, position: this.baseTarget, temp: L(this, e), target: L(this, i) }); const k = this._sphericalTarget.radius - L(this, i).distanceTo(_.position); L(this, a).copy(this._sphericalTarget), x._rayCaster.set(this.baseTarget, L(this, s).subVectors(L(this, i), this.baseTarget).normalize()); const W = x._rayCaster.intersectObject(x._collider); W.length > 0 && W[0].distance < this._followedMeshDistance && W[0].distance > k && !Pe(this, l, Ma).call(this, W[0]) && (L(this, a).radius = Math.max(this._followedMeshOffsetDistance, W[0].distance * .9), F = !0); const $ = this._followedMeshDistance * this._cameraCollisionsIncrement; let Z = 0; for (; L(this, a).radius > this._followedMeshOffsetDistance && Z < this._cameraCollisionsMaxIterations;) { Pe(this, l, ps).call(this, { local: _, spherical: L(this, a), position: this.baseTarget, temp: L(this, e), target: L(this, i) }); const J = x._geometry.boundsTree.closestPointToPoint(L(this, i), void 0, 0, this._cameraCollisionsMinDistance); if (J && J.distance < this._cameraCollisionsMinDistance && !Pe(this, l, Ma).call(this, J)) L(this, a).radius = Math.max(this._followedMeshOffsetDistance, L(this, a).radius - $), Z++, F = !0; else break } F ? O = L(this, a).radius : O = Math.min(this._followedMeshDistance, L(this, a).radius + $ * renderInfo.ratio) } else O = this._followedMeshDistance; this._sphericalTarget.radius = math.lerpFPS(this._sphericalTarget.radius, O, this._cameraSphericalRadiusCollisionsLerp), L(this, a).radius = this._sphericalTarget.radius + this.additionalSpherical.radius, L(this, a).phi = this._sphericalTarget.phi + this.additionalSpherical.phi, L(this, a).theta = this._sphericalTarget.theta + this.additionalSpherical.theta, L(this, a).makeSafe(); const N = math.lerpCoefFPS(this._followedMesh._controlMode === "automatic" ? this._cameraSphericalRotationLerp : this._cameraSphericalRotationFastLerp), H = math.lerpCoefFPS(this._cameraSphericalRadiusLerp); this._spherical.phi = math.lerp(this._spherical.phi, L(this, a).phi, N), this._spherical.theta = math.lerp(this._spherical.theta, L(this, a).theta, N), this._spherical.radius = math.lerp(this._spherical.radius, L(this, a).radius, H), L(this, o).radius = math.lerp(this._spherical.radius, this.overwriteSpherical.radius, this.overwriteAmount), L(this, o).phi = math.lerp(this._spherical.phi, this.overwriteSpherical.phi, this.overwriteAmount), L(this, o).theta = math.lerp(this._spherical.theta, this.overwriteSpherical.theta, this.overwriteAmount), L(this, o).makeSafe(), Pe(this, l, ps).call(this, { local: _, spherical: L(this, o), position: this.baseTarget, temp: L(this, e), target: this.basePosition }), this.baseUp.copy(_.up) } super._update() } setOffset(_ = [0, 0, 0], x = !0) { Pe(this, l, Ta).call(this, L(this, e)), L(this, e).add(this._followedMesh._localObject.position), this._followedMeshOffset.fromArray(_), this._followedMeshOffsetDistance = this._followedMeshOffset.length(), x && (this._followedMeshOffsetTarget.copy(this._followedMeshOffset).applyQuaternion(this._followedMesh._localObject.quaternion), this._followedMeshTarget.copy(this._followedMeshOffsetTarget).add(L(this, e)), this.baseTarget.copy(this._followedMeshTarget)) } setFollowOverwrite({ phi: _ = Math.PI * .5, theta: x = 0, radius: b = 1, target: T = [0, 0, 0] } = {}) { this.overwriteSpherical.set(b, _, math.getShortestRotationAngle(this._spherical.theta, x)), this.overwriteTarget.fromArray(T) } }, e = new WeakMap, i = new WeakMap, s = new WeakMap, a = new WeakMap, o = new WeakMap, l = new WeakSet, ps = function ({ local: _, spherical: x, position: b, temp: T, target: M } = {}) { T.setFromSpherical(x).applyQuaternion(_.quaternion), T.applyAxisAngle(_.up, Math.PI - _.rotationHorizontal), M.copy(b).add(T) }, Ta = function (_) { _.copy(this._followedMesh._collisionPhysics._charactersCapsule.segment.end), _.y += this._followedMesh._collisionPhysics._charactersCapsule.radius, _.applyQuaternion(this._followedMesh._localObject.quaternion) }, Ma = function (_) { var D; if (!_ || typeof _.faceIndex != "number") return !1; const x = (D = this._followedMesh) == null ? void 0 : D._collisionPhysics; if (!x || !x._collider || !x._colliderMesh) return !1; const b = x._collider.geometry, T = x._colliderMesh.geometry; if (!T.attributes.skipcollision) return !1; const M = b.getIndex(), w = M ? M.array[_.faceIndex * 3] : _.faceIndex * 3; return T.attributes.skipcollision.array[w] > 0 }, p } function followCamera$1(r = "perspective") { const e = baseCamera(r), i = followCamera(e); return new i } const CENTER = 0, AVERAGE = 1, SAH = 2, CONTAINED = 2, TRIANGLE_INTERSECT_COST = 1.25, TRAVERSAL_COST = 1, BYTES_PER_NODE = 6 * 4 + 4 + 4, IS_LEAFNODE_FLAG = 65535, FLOAT32_EPSILON = Math.pow(2, -24), SKIP_GENERATION = Symbol("SKIP_GENERATION"); function getVertexCount(r) { return r.index ? r.index.count : r.attributes.position.count } function getTriCount(r) { return getVertexCount(r) / 3 } function getIndexArray(r, e = ArrayBuffer) { return r > 65535 ? new Uint32Array(new e(4 * r)) : new Uint16Array(new e(2 * r)) } function ensureIndex(r, e) { if (!r.index) { const i = r.attributes.position.count, s = e.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer, a = getIndexArray(i, s); r.setIndex(new BufferAttribute(a, 1)); for (let o = 0; o < i; o++)a[o] = o } } function getFullGeometryRange(r, e) { const i = getTriCount(r), s = e || r.drawRange, a = s.start / 3, o = (s.start + s.count) / 3, l = Math.max(0, a), c = Math.min(i, o) - l; return [{ offset: Math.floor(l), count: Math.floor(c) }] } function getRootIndexRanges(r, e) { if (!r.groups || !r.groups.length) return getFullGeometryRange(r, e); const i = [], s = new Set, a = e || r.drawRange, o = a.start / 3, l = (a.start + a.count) / 3; for (const h of r.groups) { const d = h.start / 3, p = (h.start + h.count) / 3; s.add(Math.max(o, d)), s.add(Math.min(l, p)) } const c = Array.from(s.values()).sort((h, d) => h - d); for (let h = 0; h < c.length - 1; h++) { const d = c[h], p = c[h + 1]; i.push({ offset: Math.floor(d), count: Math.floor(p - d) }) } return i } function hasGroupGaps(r, e) { const i = getTriCount(r), s = getRootIndexRanges(r, e).sort((l, c) => l.offset - c.offset), a = s[s.length - 1]; a.count = Math.min(i - a.offset, a.count); let o = 0; return s.forEach(({ count: l }) => o += l), i !== o } function getBounds(r, e, i, s, a) { let o = 1 / 0, l = 1 / 0, c = 1 / 0, h = -1 / 0, d = -1 / 0, p = -1 / 0, f = 1 / 0, _ = 1 / 0, x = 1 / 0, b = -1 / 0, T = -1 / 0, M = -1 / 0; for (let w = e * 6, D = (e + i) * 6; w < D; w += 6) { const R = r[w + 0], P = r[w + 1], U = R - P, O = R + P; U < o && (o = U), O > h && (h = O), R < f && (f = R), R > b && (b = R); const N = r[w + 2], H = r[w + 3], F = N - H, k = N + H; F < l && (l = F), k > d && (d = k), N < _ && (_ = N), N > T && (T = N); const W = r[w + 4], $ = r[w + 5], Z = W - $, J = W + $; Z < c && (c = Z), J > p && (p = J), W < x && (x = W), W > M && (M = W) } s[0] = o, s[1] = l, s[2] = c, s[3] = h, s[4] = d, s[5] = p, a[0] = f, a[1] = _, a[2] = x, a[3] = b, a[4] = T, a[5] = M } function computeTriangleBounds(r, e = null, i = null, s = null) { const a = r.attributes.position, o = r.index ? r.index.array : null, l = getTriCount(r), c = a.normalized; let h; e === null ? (h = new Float32Array(l * 6), i = 0, s = l) : (h = e, i = i || 0, s = s || l); const d = a.array, p = a.offset || 0; let f = 3; a.isInterleavedBufferAttribute && (f = a.data.stride); const _ = ["getX", "getY", "getZ"]; for (let x = i; x < i + s; x++) { const b = x * 3, T = x * 6; let M = b + 0, w = b + 1, D = b + 2; o && (M = o[M], w = o[w], D = o[D]), c || (M = M * f + p, w = w * f + p, D = D * f + p); for (let R = 0; R < 3; R++) { let P, U, O; c ? (P = a[_[R]](M), U = a[_[R]](w), O = a[_[R]](D)) : (P = d[M + R], U = d[w + R], O = d[D + R]); let N = P; U < N && (N = U), O < N && (N = O); let H = P; U > H && (H = U), O > H && (H = O); const F = (H - N) / 2, k = R * 2; h[T + k + 0] = N + F, h[T + k + 1] = F + (Math.abs(N) + F) * FLOAT32_EPSILON } } return h } function arrayToBox(r, e, i) { return i.min.x = e[r], i.min.y = e[r + 1], i.min.z = e[r + 2], i.max.x = e[r + 3], i.max.y = e[r + 4], i.max.z = e[r + 5], i } function getLongestEdgeIndex(r) { let e = -1, i = -1 / 0; for (let s = 0; s < 3; s++) { const a = r[s + 3] - r[s]; a > i && (i = a, e = s) } return e } function copyBounds(r, e) { e.set(r) } function unionBounds(r, e, i) { let s, a; for (let o = 0; o < 3; o++) { const l = o + 3; s = r[o], a = e[o], i[o] = s < a ? s : a, s = r[l], a = e[l], i[l] = s > a ? s : a } } function expandByTriangleBounds(r, e, i) { for (let s = 0; s < 3; s++) { const a = e[r + 2 * s], o = e[r + 2 * s + 1], l = a - o, c = a + o; l < i[s] && (i[s] = l), c > i[s + 3] && (i[s + 3] = c) } } function computeSurfaceArea(r) { const e = r[3] - r[0], i = r[4] - r[1], s = r[5] - r[2]; return 2 * (e * i + i * s + s * e) } const BIN_COUNT = 32, binsSort = (r, e) => r.candidate - e.candidate, sahBins = new Array(BIN_COUNT).fill().map(() => ({ count: 0, bounds: new Float32Array(6), rightCacheBounds: new Float32Array(6), leftCacheBounds: new Float32Array(6), candidate: 0 })), leftBounds = new Float32Array(6); function getOptimalSplit(r, e, i, s, a, o) { let l = -1, c = 0; if (o === CENTER) l = getLongestEdgeIndex(e), l !== -1 && (c = (e[l] + e[l + 3]) / 2); else if (o === AVERAGE) l = getLongestEdgeIndex(r), l !== -1 && (c = getAverage(i, s, a, l)); else if (o === SAH) { const h = computeSurfaceArea(r); let d = TRIANGLE_INTERSECT_COST * a; const p = s * 6, f = (s + a) * 6; for (let _ = 0; _ < 3; _++) { const x = e[_], M = (e[_ + 3] - x) / BIN_COUNT; if (a < BIN_COUNT / 4) { const w = [...sahBins]; w.length = a; let D = 0; for (let P = p; P < f; P += 6, D++) { const U = w[D]; U.candidate = i[P + 2 * _], U.count = 0; const { bounds: O, leftCacheBounds: N, rightCacheBounds: H } = U; for (let F = 0; F < 3; F++)H[F] = 1 / 0, H[F + 3] = -1 / 0, N[F] = 1 / 0, N[F + 3] = -1 / 0, O[F] = 1 / 0, O[F + 3] = -1 / 0; expandByTriangleBounds(P, i, O) } w.sort(binsSort); let R = a; for (let P = 0; P < R; P++) { const U = w[P]; for (; P + 1 < R && w[P + 1].candidate === U.candidate;)w.splice(P + 1, 1), R-- } for (let P = p; P < f; P += 6) { const U = i[P + 2 * _]; for (let O = 0; O < R; O++) { const N = w[O]; U >= N.candidate ? expandByTriangleBounds(P, i, N.rightCacheBounds) : (expandByTriangleBounds(P, i, N.leftCacheBounds), N.count++) } } for (let P = 0; P < R; P++) { const U = w[P], O = U.count, N = a - U.count, H = U.leftCacheBounds, F = U.rightCacheBounds; let k = 0; O !== 0 && (k = computeSurfaceArea(H) / h); let W = 0; N !== 0 && (W = computeSurfaceArea(F) / h); const $ = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (k * O + W * N); $ < d && (l = _, d = $, c = U.candidate) } } else { for (let R = 0; R < BIN_COUNT; R++) { const P = sahBins[R]; P.count = 0, P.candidate = x + M + R * M; const U = P.bounds; for (let O = 0; O < 3; O++)U[O] = 1 / 0, U[O + 3] = -1 / 0 } for (let R = p; R < f; R += 6) { let O = ~~((i[R + 2 * _] - x) / M); O >= BIN_COUNT && (O = BIN_COUNT - 1); const N = sahBins[O]; N.count++, expandByTriangleBounds(R, i, N.bounds) } const w = sahBins[BIN_COUNT - 1]; copyBounds(w.bounds, w.rightCacheBounds); for (let R = BIN_COUNT - 2; R >= 0; R--) { const P = sahBins[R], U = sahBins[R + 1]; unionBounds(P.bounds, U.rightCacheBounds, P.rightCacheBounds) } let D = 0; for (let R = 0; R < BIN_COUNT - 1; R++) { const P = sahBins[R], U = P.count, O = P.bounds, H = sahBins[R + 1].rightCacheBounds; U !== 0 && (D === 0 ? copyBounds(O, leftBounds) : unionBounds(O, leftBounds, leftBounds)), D += U; let F = 0, k = 0; D !== 0 && (F = computeSurfaceArea(leftBounds) / h); const W = a - D; W !== 0 && (k = computeSurfaceArea(H) / h); const $ = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (F * D + k * W); $ < d && (l = _, d = $, c = P.candidate) } } } } else console.warn(`MeshBVH: Invalid build strategy value ${o} used.`); return { axis: l, pos: c } } function getAverage(r, e, i, s) { let a = 0; for (let o = e, l = e + i; o < l; o++)a += r[o * 6 + s * 2]; return a / i } class MeshBVHNode { constructor() { this.boundingData = new Float32Array(6) } } function partition(r, e, i, s, a, o) { let l = s, c = s + a - 1; const h = o.pos, d = o.axis * 2; for (; ;) { for (; l <= c && i[l * 6 + d] < h;)l++; for (; l <= c && i[c * 6 + d] >= h;)c--; if (l < c) { for (let p = 0; p < 3; p++) { let f = e[l * 3 + p]; e[l * 3 + p] = e[c * 3 + p], e[c * 3 + p] = f } for (let p = 0; p < 6; p++) { let f = i[l * 6 + p]; i[l * 6 + p] = i[c * 6 + p], i[c * 6 + p] = f } l++, c-- } else return l } } function partition_indirect(r, e, i, s, a, o) { let l = s, c = s + a - 1; const h = o.pos, d = o.axis * 2; for (; ;) { for (; l <= c && i[l * 6 + d] < h;)l++; for (; l <= c && i[c * 6 + d] >= h;)c--; if (l < c) { let p = r[l]; r[l] = r[c], r[c] = p; for (let f = 0; f < 6; f++) { let _ = i[l * 6 + f]; i[l * 6 + f] = i[c * 6 + f], i[c * 6 + f] = _ } l++, c-- } else return l } } function IS_LEAF(r, e) { return e[r + 15] === 65535 } function OFFSET(r, e) { return e[r + 6] } function COUNT(r, e) { return e[r + 14] } function LEFT_NODE(r) { return r + 8 } function RIGHT_NODE(r, e) { return e[r + 6] } function SPLIT_AXIS(r, e) { return e[r + 7] } function BOUNDING_DATA_INDEX(r) { return r } let float32Array, uint32Array, uint16Array, uint8Array; const MAX_POINTER = Math.pow(2, 32); function countNodes(r) { return "count" in r ? 1 : 1 + countNodes(r.left) + countNodes(r.right) } function populateBuffer(r, e, i) { return float32Array = new Float32Array(i), uint32Array = new Uint32Array(i), uint16Array = new Uint16Array(i), uint8Array = new Uint8Array(i), _populateBuffer(r, e) } function _populateBuffer(r, e) { const i = r / 4, s = r / 2, a = "count" in e, o = e.boundingData; for (let l = 0; l < 6; l++)float32Array[i + l] = o[l]; if (a) if (e.buffer) { const l = e.buffer; uint8Array.set(new Uint8Array(l), r); for (let c = r, h = r + l.byteLength; c < h; c += BYTES_PER_NODE) { const d = c / 2; IS_LEAF(d, uint16Array) || (uint32Array[c / 4 + 6] += i) } return r + l.byteLength } else { const l = e.offset, c = e.count; return uint32Array[i + 6] = l, uint16Array[s + 14] = c, uint16Array[s + 15] = IS_LEAFNODE_FLAG, r + BYTES_PER_NODE } else { const l = e.left, c = e.right, h = e.splitAxis; let d; if (d = _populateBuffer(r + BYTES_PER_NODE, l), d / 4 > MAX_POINTER) throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits."); return uint32Array[i + 6] = d / 4, d = _populateBuffer(d, c), uint32Array[i + 7] = h, d } } function generateIndirectBuffer(r, e) { const i = (r.index ? r.index.count : r.attributes.position.count) / 3, s = i > 2 ** 16, a = s ? 4 : 2, o = e ? new SharedArrayBuffer(i * a) : new ArrayBuffer(i * a), l = s ? new Uint32Array(o) : new Uint16Array(o); for (let c = 0, h = l.length; c < h; c++)l[c] = c; return l } function buildTree(r, e, i, s, a) { const { maxDepth: o, verbose: l, maxLeafTris: c, strategy: h, onProgress: d, indirect: p } = a, f = r._indirectBuffer, _ = r.geometry, x = _.index ? _.index.array : null, b = p ? partition_indirect : partition, T = getTriCount(_), M = new Float32Array(6); let w = !1; const D = new MeshBVHNode; return getBounds(e, i, s, D.boundingData, M), P(D, i, s, M), D; function R(U) { d && d(U / T) } function P(U, O, N, H = null, F = 0) { if (!w && F >= o && (w = !0, l && (console.warn(`MeshBVH: Max depth of ${o} reached when generating BVH. Consider increasing maxDepth.`), console.warn(_))), N <= c || F >= o) return R(O + N), U.offset = O, U.count = N, U; const k = getOptimalSplit(U.boundingData, H, e, O, N, h); if (k.axis === -1) return R(O + N), U.offset = O, U.count = N, U; const W = b(f, x, e, O, N, k); if (W === O || W === O + N) R(O + N), U.offset = O, U.count = N; else { U.splitAxis = k.axis; const $ = new MeshBVHNode, Z = O, J = W - O; U.left = $, getBounds(e, Z, J, $.boundingData, M), P($, Z, J, M, F + 1); const se = new MeshBVHNode, re = W, ce = N - J; U.right = se, getBounds(e, re, ce, se.boundingData, M), P(se, re, ce, M, F + 1) } return U } } function buildPackedTree(r, e) { const i = r.geometry; e.indirect && (r._indirectBuffer = generateIndirectBuffer(i, e.useSharedArrayBuffer), hasGroupGaps(i, e.range) && !e.verbose && console.warn('MeshBVH: Provided geometry contains groups or a range that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')), r._indirectBuffer || ensureIndex(i, e); const s = e.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer, a = computeTriangleBounds(i), o = e.indirect ? getFullGeometryRange(i, e.range) : getRootIndexRanges(i, e.range); r._roots = o.map(l => { const c = buildTree(r, a, l.offset, l.count, e), h = countNodes(c), d = new s(BYTES_PER_NODE * h); return populateBuffer(0, c, d), d }) } class SeparatingAxisBounds { constructor() { this.min = 1 / 0, this.max = -1 / 0 } setFromPointsField(e, i) { let s = 1 / 0, a = -1 / 0; for (let o = 0, l = e.length; o < l; o++) { const h = e[o][i]; s = h < s ? h : s, a = h > a ? h : a } this.min = s, this.max = a } setFromPoints(e, i) { let s = 1 / 0, a = -1 / 0; for (let o = 0, l = i.length; o < l; o++) { const c = i[o], h = e.dot(c); s = h < s ? h : s, a = h > a ? h : a } this.min = s, this.max = a } isSeparated(e) { return this.min > e.max || e.min > this.max } } SeparatingAxisBounds.prototype.setFromBox = function () { const r = new Vector3; return function (i, s) { const a = s.min, o = s.max; let l = 1 / 0, c = -1 / 0; for (let h = 0; h <= 1; h++)for (let d = 0; d <= 1; d++)for (let p = 0; p <= 1; p++) { r.x = a.x * h + o.x * (1 - h), r.y = a.y * d + o.y * (1 - d), r.z = a.z * p + o.z * (1 - p); const f = i.dot(r); l = Math.min(f, l), c = Math.max(f, c) } this.min = l, this.max = c } }(); const closestPointLineToLine = function () { const r = new Vector3, e = new Vector3, i = new Vector3; return function (a, o, l) { const c = a.start, h = r, d = o.start, p = e; i.subVectors(c, d), r.subVectors(a.end, a.start), e.subVectors(o.end, o.start); const f = i.dot(p), _ = p.dot(h), x = p.dot(p), b = i.dot(h), M = h.dot(h) * x - _ * _; let w, D; M !== 0 ? w = (f * _ - b * x) / M : w = 0, D = (f + w * _) / x, l.x = w, l.y = D } }(), closestPointsSegmentToSegment = function () { const r = new Vector2, e = new Vector3, i = new Vector3; return function (a, o, l, c) { closestPointLineToLine(a, o, r); let h = r.x, d = r.y; if (h >= 0 && h <= 1 && d >= 0 && d <= 1) { a.at(h, l), o.at(d, c); return } else if (h >= 0 && h <= 1) { d < 0 ? o.at(0, c) : o.at(1, c), a.closestPointToPoint(c, !0, l); return } else if (d >= 0 && d <= 1) { h < 0 ? a.at(0, l) : a.at(1, l), o.closestPointToPoint(l, !0, c); return } else { let p; h < 0 ? p = a.start : p = a.end; let f; d < 0 ? f = o.start : f = o.end; const _ = e, x = i; if (a.closestPointToPoint(f, !0, e), o.closestPointToPoint(p, !0, i), _.distanceToSquared(f) <= x.distanceToSquared(p)) { l.copy(_), c.copy(f); return } else { l.copy(p), c.copy(x); return } } } }(), sphereIntersectTriangle = function () { const r = new Vector3, e = new Vector3, i = new Plane, s = new Line3; return function (o, l) { const { radius: c, center: h } = o, { a: d, b: p, c: f } = l; if (s.start = d, s.end = p, s.closestPointToPoint(h, !0, r).distanceTo(h) <= c || (s.start = d, s.end = f, s.closestPointToPoint(h, !0, r).distanceTo(h) <= c) || (s.start = p, s.end = f, s.closestPointToPoint(h, !0, r).distanceTo(h) <= c)) return !0; const T = l.getPlane(i); if (Math.abs(T.distanceToPoint(h)) <= c) { const w = T.projectPoint(h, e); if (l.containsPoint(w)) return !0 } return !1 } }(), ZERO_EPSILON = 1e-15; function isNearZero(r) { return Math.abs(r) < ZERO_EPSILON } class ExtendedTriangle extends Triangle { constructor(...e) { super(...e), this.isExtendedTriangle = !0, this.satAxes = new Array(4).fill().map(() => new Vector3), this.satBounds = new Array(4).fill().map(() => new SeparatingAxisBounds), this.points = [this.a, this.b, this.c], this.sphere = new Sphere, this.plane = new Plane, this.needsUpdate = !0 } intersectsSphere(e) { return sphereIntersectTriangle(e, this) } update() { const e = this.a, i = this.b, s = this.c, a = this.points, o = this.satAxes, l = this.satBounds, c = o[0], h = l[0]; this.getNormal(c), h.setFromPoints(c, a); const d = o[1], p = l[1]; d.subVectors(e, i), p.setFromPoints(d, a); const f = o[2], _ = l[2]; f.subVectors(i, s), _.setFromPoints(f, a); const x = o[3], b = l[3]; x.subVectors(s, e), b.setFromPoints(x, a), this.sphere.setFromPoints(this.points), this.plane.setFromNormalAndCoplanarPoint(c, e), this.needsUpdate = !1 } } ExtendedTriangle.prototype.closestPointToSegment = function () { const r = new Vector3, e = new Vector3, i = new Line3; return function (a, o = null, l = null) { const { start: c, end: h } = a, d = this.points; let p, f = 1 / 0; for (let _ = 0; _ < 3; _++) { const x = (_ + 1) % 3; i.start.copy(d[_]), i.end.copy(d[x]), closestPointsSegmentToSegment(i, a, r, e), p = r.distanceToSquared(e), p < f && (f = p, o && o.copy(r), l && l.copy(e)) } return this.closestPointToPoint(c, r), p = c.distanceToSquared(r), p < f && (f = p, o && o.copy(r), l && l.copy(c)), this.closestPointToPoint(h, r), p = h.distanceToSquared(r), p < f && (f = p, o && o.copy(r), l && l.copy(h)), Math.sqrt(f) } }(); ExtendedTriangle.prototype.intersectsTriangle = function () { const r = new ExtendedTriangle, e = new Array(3), i = new Array(3), s = new SeparatingAxisBounds, a = new SeparatingAxisBounds, o = new Vector3, l = new Vector3, c = new Vector3, h = new Vector3, d = new Vector3, p = new Line3, f = new Line3, _ = new Line3, x = new Vector3; function b(T, M, w) { const D = T.points; let R = 0, P = -1; for (let U = 0; U < 3; U++) { const { start: O, end: N } = p; O.copy(D[U]), N.copy(D[(U + 1) % 3]), p.delta(l); const H = isNearZero(M.distanceToPoint(O)); if (isNearZero(M.normal.dot(l)) && H) { w.copy(p), R = 2; break } const F = M.intersectLine(p, x); if (!F && H && x.copy(O), (F || H) && !isNearZero(x.distanceTo(N))) { if (R <= 1) (R === 1 ? w.start : w.end).copy(x), H && (P = R); else if (R >= 2) { (P === 1 ? w.start : w.end).copy(x), R = 2; break } if (R++, R === 2 && P === -1) break } } return R } return function (M, w = null, D = !1) { this.needsUpdate && this.update(), M.isExtendedTriangle ? M.needsUpdate && M.update() : (r.copy(M), r.update(), M = r); const R = this.plane, P = M.plane; if (Math.abs(R.normal.dot(P.normal)) > 1 - 1e-10) { const U = this.satBounds, O = this.satAxes; i[0] = M.a, i[1] = M.b, i[2] = M.c; for (let F = 0; F < 4; F++) { const k = U[F], W = O[F]; if (s.setFromPoints(W, i), k.isSeparated(s)) return !1 } const N = M.satBounds, H = M.satAxes; e[0] = this.a, e[1] = this.b, e[2] = this.c; for (let F = 0; F < 4; F++) { const k = N[F], W = H[F]; if (s.setFromPoints(W, e), k.isSeparated(s)) return !1 } for (let F = 0; F < 4; F++) { const k = O[F]; for (let W = 0; W < 4; W++) { const $ = H[W]; if (o.crossVectors(k, $), s.setFromPoints(o, e), a.setFromPoints(o, i), s.isSeparated(a)) return !1 } } return w && (D || console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."), w.start.set(0, 0, 0), w.end.set(0, 0, 0)), !0 } else { const U = b(this, P, f); if (U === 1 && M.containsPoint(f.end)) return w && (w.start.copy(f.end), w.end.copy(f.end)), !0; if (U !== 2) return !1; const O = b(M, R, _); if (O === 1 && this.containsPoint(_.end)) return w && (w.start.copy(_.end), w.end.copy(_.end)), !0; if (O !== 2) return !1; if (f.delta(c), _.delta(h), c.dot(h) < 0) { let Z = _.start; _.start = _.end, _.end = Z } const N = f.start.dot(c), H = f.end.dot(c), F = _.start.dot(c), k = _.end.dot(c), W = H < F, $ = N < k; return N !== k && F !== H && W === $ ? !1 : (w && (d.subVectors(f.start, _.start), d.dot(c) > 0 ? w.start.copy(f.start) : w.start.copy(_.start), d.subVectors(f.end, _.end), d.dot(c) < 0 ? w.end.copy(f.end) : w.end.copy(_.end)), !0) } } }(); ExtendedTriangle.prototype.distanceToPoint = function () { const r = new Vector3; return function (i) { return this.closestPointToPoint(i, r), i.distanceTo(r) } }(); ExtendedTriangle.prototype.distanceToTriangle = function () { const r = new Vector3, e = new Vector3, i = ["a", "b", "c"], s = new Line3, a = new Line3; return function (l, c = null, h = null) { const d = c || h ? s : null; if (this.intersectsTriangle(l, d)) return (c || h) && (c && d.getCenter(c), h && d.getCenter(h)), 0; let p = 1 / 0; for (let f = 0; f < 3; f++) { let _; const x = i[f], b = l[x]; this.closestPointToPoint(b, r), _ = b.distanceToSquared(r), _ < p && (p = _, c && c.copy(r), h && h.copy(b)); const T = this[x]; l.closestPointToPoint(T, r), _ = T.distanceToSquared(r), _ < p && (p = _, c && c.copy(T), h && h.copy(r)) } for (let f = 0; f < 3; f++) { const _ = i[f], x = i[(f + 1) % 3]; s.set(this[_], this[x]); for (let b = 0; b < 3; b++) { const T = i[b], M = i[(b + 1) % 3]; a.set(l[T], l[M]), closestPointsSegmentToSegment(s, a, r, e); const w = r.distanceToSquared(e); w < p && (p = w, c && c.copy(r), h && h.copy(e)) } } return Math.sqrt(p) } }(); class OrientedBox { constructor(e, i, s) { this.isOrientedBox = !0, this.min = new Vector3, this.max = new Vector3, this.matrix = new Matrix4, this.invMatrix = new Matrix4, this.points = new Array(8).fill().map(() => new Vector3), this.satAxes = new Array(3).fill().map(() => new Vector3), this.satBounds = new Array(3).fill().map(() => new SeparatingAxisBounds), this.alignedSatBounds = new Array(3).fill().map(() => new SeparatingAxisBounds), this.needsUpdate = !1, e && this.min.copy(e), i && this.max.copy(i), s && this.matrix.copy(s) } set(e, i, s) { this.min.copy(e), this.max.copy(i), this.matrix.copy(s), this.needsUpdate = !0 } copy(e) { this.min.copy(e.min), this.max.copy(e.max), this.matrix.copy(e.matrix), this.needsUpdate = !0 } } OrientedBox.prototype.update = function () { return function () { const e = this.matrix, i = this.min, s = this.max, a = this.points; for (let d = 0; d <= 1; d++)for (let p = 0; p <= 1; p++)for (let f = 0; f <= 1; f++) { const _ = 1 * d | 2 * p | 4 * f, x = a[_]; x.x = d ? s.x : i.x, x.y = p ? s.y : i.y, x.z = f ? s.z : i.z, x.applyMatrix4(e) } const o = this.satBounds, l = this.satAxes, c = a[0]; for (let d = 0; d < 3; d++) { const p = l[d], f = o[d], _ = 1 << d, x = a[_]; p.subVectors(c, x), f.setFromPoints(p, a) } const h = this.alignedSatBounds; h[0].setFromPointsField(a, "x"), h[1].setFromPointsField(a, "y"), h[2].setFromPointsField(a, "z"), this.invMatrix.copy(this.matrix).invert(), this.needsUpdate = !1 } }(); OrientedBox.prototype.intersectsBox = function () { const r = new SeparatingAxisBounds; return function (i) { this.needsUpdate && this.update(); const s = i.min, a = i.max, o = this.satBounds, l = this.satAxes, c = this.alignedSatBounds; if (r.min = s.x, r.max = a.x, c[0].isSeparated(r) || (r.min = s.y, r.max = a.y, c[1].isSeparated(r)) || (r.min = s.z, r.max = a.z, c[2].isSeparated(r))) return !1; for (let h = 0; h < 3; h++) { const d = l[h], p = o[h]; if (r.setFromBox(d, i), p.isSeparated(r)) return !1 } return !0 } }(); OrientedBox.prototype.intersectsTriangle = function () { const r = new ExtendedTriangle, e = new Array(3), i = new SeparatingAxisBounds, s = new SeparatingAxisBounds, a = new Vector3; return function (l) { this.needsUpdate && this.update(), l.isExtendedTriangle ? l.needsUpdate && l.update() : (r.copy(l), r.update(), l = r); const c = this.satBounds, h = this.satAxes; e[0] = l.a, e[1] = l.b, e[2] = l.c; for (let _ = 0; _ < 3; _++) { const x = c[_], b = h[_]; if (i.setFromPoints(b, e), x.isSeparated(i)) return !1 } const d = l.satBounds, p = l.satAxes, f = this.points; for (let _ = 0; _ < 3; _++) { const x = d[_], b = p[_]; if (i.setFromPoints(b, f), x.isSeparated(i)) return !1 } for (let _ = 0; _ < 3; _++) { const x = h[_]; for (let b = 0; b < 4; b++) { const T = p[b]; if (a.crossVectors(x, T), i.setFromPoints(a, e), s.setFromPoints(a, f), i.isSeparated(s)) return !1 } } return !0 } }(); OrientedBox.prototype.closestPointToPoint = function () { return function (e, i) { return this.needsUpdate && this.update(), i.copy(e).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix), i } }(); OrientedBox.prototype.distanceToPoint = function () { const r = new Vector3; return function (i) { return this.closestPointToPoint(i, r), i.distanceTo(r) } }(); OrientedBox.prototype.distanceToBox = function () { const r = ["x", "y", "z"], e = new Array(12).fill().map(() => new Line3), i = new Array(12).fill().map(() => new Line3), s = new Vector3, a = new Vector3; return function (l, c = 0, h = null, d = null) { if (this.needsUpdate && this.update(), this.intersectsBox(l)) return (h || d) && (l.getCenter(a), this.closestPointToPoint(a, s), l.closestPointToPoint(s, a), h && h.copy(s), d && d.copy(a)), 0; const p = c * c, f = l.min, _ = l.max, x = this.points; let b = 1 / 0; for (let M = 0; M < 8; M++) { const w = x[M]; a.copy(w).clamp(f, _); const D = w.distanceToSquared(a); if (D < b && (b = D, h && h.copy(w), d && d.copy(a), D < p)) return Math.sqrt(D) } let T = 0; for (let M = 0; M < 3; M++)for (let w = 0; w <= 1; w++)for (let D = 0; D <= 1; D++) { const R = (M + 1) % 3, P = (M + 2) % 3, U = w << R | D << P, O = 1 << M | w << R | D << P, N = x[U], H = x[O]; e[T].set(N, H); const k = r[M], W = r[R], $ = r[P], Z = i[T], J = Z.start, se = Z.end; J[k] = f[k], J[W] = w ? f[W] : _[W], J[$] = D ? f[$] : _[W], se[k] = _[k], se[W] = w ? f[W] : _[W], se[$] = D ? f[$] : _[W], T++ } for (let M = 0; M <= 1; M++)for (let w = 0; w <= 1; w++)for (let D = 0; D <= 1; D++) { a.x = M ? _.x : f.x, a.y = w ? _.y : f.y, a.z = D ? _.z : f.z, this.closestPointToPoint(a, s); const R = a.distanceToSquared(s); if (R < b && (b = R, h && h.copy(s), d && d.copy(a), R < p)) return Math.sqrt(R) } for (let M = 0; M < 12; M++) { const w = e[M]; for (let D = 0; D < 12; D++) { const R = i[D]; closestPointsSegmentToSegment(w, R, s, a); const P = s.distanceToSquared(a); if (P < b && (b = P, h && h.copy(s), d && d.copy(a), P < p)) return Math.sqrt(P) } } return Math.sqrt(b) } }(); class PrimitivePool { constructor(e) { this._getNewPrimitive = e, this._primitives = [] } getPrimitive() { const e = this._primitives; return e.length === 0 ? this._getNewPrimitive() : e.pop() } releasePrimitive(e) { this._primitives.push(e) } } class ExtendedTrianglePoolBase extends PrimitivePool { constructor() { super(() => new ExtendedTriangle) } } const ExtendedTrianglePool = new ExtendedTrianglePoolBase; class _BufferStack { constructor() { this.float32Array = null, this.uint16Array = null, this.uint32Array = null; const e = []; let i = null; this.setBuffer = s => { i && e.push(i), i = s, this.float32Array = new Float32Array(s), this.uint16Array = new Uint16Array(s), this.uint32Array = new Uint32Array(s) }, this.clearBuffer = () => { i = null, this.float32Array = null, this.uint16Array = null, this.uint32Array = null, e.length !== 0 && this.setBuffer(e.pop()) } } } const BufferStack = new _BufferStack; let _box1, _box2; const boxStack = [], boxPool = new PrimitivePool(() => new Box3); function shapecast(r, e, i, s, a, o) { _box1 = boxPool.getPrimitive(), _box2 = boxPool.getPrimitive(), boxStack.push(_box1, _box2), BufferStack.setBuffer(r._roots[e]); const l = shapecastTraverse(0, r.geometry, i, s, a, o); BufferStack.clearBuffer(), boxPool.releasePrimitive(_box1), boxPool.releasePrimitive(_box2), boxStack.pop(), boxStack.pop(); const c = boxStack.length; return c > 0 && (_box2 = boxStack[c - 1], _box1 = boxStack[c - 2]), l } function shapecastTraverse(r, e, i, s, a = null, o = 0, l = 0) { const { float32Array: c, uint16Array: h, uint32Array: d } = BufferStack; let p = r * 2; if (IS_LEAF(p, h)) { const _ = OFFSET(r, d), x = COUNT(p, h); return arrayToBox(r, c, _box1), s(_, x, !1, l, o + r, _box1) } else { let k = function ($) { const { uint16Array: Z, uint32Array: J } = BufferStack; let se = $ * 2; for (; !IS_LEAF(se, Z);)$ = LEFT_NODE($), se = $ * 2; return OFFSET($, J) }, W = function ($) { const { uint16Array: Z, uint32Array: J } = BufferStack; let se = $ * 2; for (; !IS_LEAF(se, Z);)$ = RIGHT_NODE($, J), se = $ * 2; return OFFSET($, J) + COUNT(se, Z) }; const _ = LEFT_NODE(r), x = RIGHT_NODE(r, d); let b = _, T = x, M, w, D, R; if (a && (D = _box1, R = _box2, arrayToBox(b, c, D), arrayToBox(T, c, R), M = a(D), w = a(R), w < M)) { b = x, T = _; const $ = M; M = w, w = $, D = R } D || (D = _box1, arrayToBox(b, c, D)); const P = IS_LEAF(b * 2, h), U = i(D, P, M, l + 1, o + b); let O; if (U === CONTAINED) { const $ = k(b), J = W(b) - $; O = s($, J, !0, l + 1, o + b, D) } else O = U && shapecastTraverse(b, e, i, s, a, o, l + 1); if (O) return !0; R = _box2, arrayToBox(T, c, R); const N = IS_LEAF(T * 2, h), H = i(R, N, w, l + 1, o + T); let F; if (H === CONTAINED) { const $ = k(T), J = W(T) - $; F = s($, J, !0, l + 1, o + T, R) } else F = H && shapecastTraverse(T, e, i, s, a, o, l + 1); return !!F } } const temp = new Vector3, temp1$2 = new Vector3; function closestPointToPoint(r, e, i = {}, s = 0, a = 1 / 0) { const o = s * s, l = a * a; let c = 1 / 0, h = null; if (r.shapecast({ boundsTraverseOrder: p => (temp.copy(e).clamp(p.min, p.max), temp.distanceToSquared(e)), intersectsBounds: (p, f, _) => _ < c && _ < l, intersectsTriangle: (p, f) => { p.closestPointToPoint(e, temp); const _ = e.distanceToSquared(temp); return _ < c && (temp1$2.copy(temp), c = _, h = f), _ < o } }), c === 1 / 0) return null; const d = Math.sqrt(c); return i.point ? i.point.copy(temp1$2) : i.point = temp1$2.clone(), i.distance = d, i.faceIndex = h, i } const IS_GT_REVISION_169 = parseInt(REVISION) >= 169, _vA = new Vector3, _vB = new Vector3, _vC = new Vector3, _uvA = new Vector2, _uvB = new Vector2, _uvC = new Vector2, _normalA = new Vector3, _normalB = new Vector3, _normalC = new Vector3, _intersectionPoint = new Vector3; function checkIntersection(r, e, i, s, a, o, l, c) { let h; if (o === BackSide ? h = r.intersectTriangle(s, i, e, !0, a) : h = r.intersectTriangle(e, i, s, o !== DoubleSide, a), h === null) return null; const d = r.origin.distanceTo(a); return d < l || d > c ? null : { distance: d, point: a.clone() } } function checkBufferGeometryIntersection(r, e, i, s, a, o, l, c, h, d, p) { _vA.fromBufferAttribute(e, o), _vB.fromBufferAttribute(e, l), _vC.fromBufferAttribute(e, c); const f = checkIntersection(r, _vA, _vB, _vC, _intersectionPoint, h, d, p); if (f) { const _ = new Vector3; Triangle.getBarycoord(_intersectionPoint, _vA, _vB, _vC, _), s && (_uvA.fromBufferAttribute(s, o), _uvB.fromBufferAttribute(s, l), _uvC.fromBufferAttribute(s, c), f.uv = Triangle.getInterpolation(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2)), a && (_uvA.fromBufferAttribute(a, o), _uvB.fromBufferAttribute(a, l), _uvC.fromBufferAttribute(a, c), f.uv1 = Triangle.getInterpolation(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2)), i && (_normalA.fromBufferAttribute(i, o), _normalB.fromBufferAttribute(i, l), _normalC.fromBufferAttribute(i, c), f.normal = Triangle.getInterpolation(_intersectionPoint, _vA, _vB, _vC, _normalA, _normalB, _normalC, new Vector3), f.normal.dot(r.direction) > 0 && f.normal.multiplyScalar(-1)); const x = { a: o, b: l, c, normal: new Vector3, materialIndex: 0 }; Triangle.getNormal(_vA, _vB, _vC, x.normal), f.face = x, f.faceIndex = o, IS_GT_REVISION_169 && (f.barycoord = _) } return f } function intersectTri(r, e, i, s, a, o, l) { const c = s * 3; let h = c + 0, d = c + 1, p = c + 2; const f = r.index; r.index && (h = f.getX(h), d = f.getX(d), p = f.getX(p)); const { position: _, normal: x, uv: b, uv1: T } = r.attributes, M = checkBufferGeometryIntersection(i, _, x, b, T, h, d, p, e, o, l); return M ? (M.faceIndex = s, a && a.push(M), M) : null } function setTriangle(r, e, i, s) { const a = r.a, o = r.b, l = r.c; let c = e, h = e + 1, d = e + 2; i && (c = i.getX(c), h = i.getX(h), d = i.getX(d)), a.x = s.getX(c), a.y = s.getY(c), a.z = s.getZ(c), o.x = s.getX(h), o.y = s.getY(h), o.z = s.getZ(h), l.x = s.getX(d), l.y = s.getY(d), l.z = s.getZ(d) } function intersectTris(r, e, i, s, a, o, l, c) { const { geometry: h, _indirectBuffer: d } = r; for (let p = s, f = s + a; p < f; p++)intersectTri(h, e, i, p, o, l, c) } function intersectClosestTri(r, e, i, s, a, o, l) { const { geometry: c, _indirectBuffer: h } = r; let d = 1 / 0, p = null; for (let f = s, _ = s + a; f < _; f++) { let x; x = intersectTri(c, e, i, f, null, o, l), x && x.distance < d && (p = x, d = x.distance) } return p } function iterateOverTriangles(r, e, i, s, a, o, l) { const { geometry: c } = i, { index: h } = c, d = c.attributes.position; for (let p = r, f = e + r; p < f; p++) { let _; if (_ = p, setTriangle(l, _ * 3, h, d), l.needsUpdate = !0, s(l, _, a, o)) return !0 } return !1 } function refit(r, e = null) { e && Array.isArray(e) && (e = new Set(e)); const i = r.geometry, s = i.index ? i.index.array : null, a = i.attributes.position; let o, l, c, h, d = 0; const p = r._roots; for (let _ = 0, x = p.length; _ < x; _++)o = p[_], l = new Uint32Array(o), c = new Uint16Array(o), h = new Float32Array(o), f(0, d), d += o.byteLength; function f(_, x, b = !1) { const T = _ * 2; if (c[T + 15] === IS_LEAFNODE_FLAG) { const w = l[_ + 6], D = c[T + 14]; let R = 1 / 0, P = 1 / 0, U = 1 / 0, O = -1 / 0, N = -1 / 0, H = -1 / 0; for (let F = 3 * w, k = 3 * (w + D); F < k; F++) { let W = s[F]; const $ = a.getX(W), Z = a.getY(W), J = a.getZ(W); $ < R && (R = $), $ > O && (O = $), Z < P && (P = Z), Z > N && (N = Z), J < U && (U = J), J > H && (H = J) } return h[_ + 0] !== R || h[_ + 1] !== P || h[_ + 2] !== U || h[_ + 3] !== O || h[_ + 4] !== N || h[_ + 5] !== H ? (h[_ + 0] = R, h[_ + 1] = P, h[_ + 2] = U, h[_ + 3] = O, h[_ + 4] = N, h[_ + 5] = H, !0) : !1 } else { const w = _ + 8, D = l[_ + 6], R = w + x, P = D + x; let U = b, O = !1, N = !1; e ? U || (O = e.has(R), N = e.has(P), U = !O && !N) : (O = !0, N = !0); const H = U || O, F = U || N; let k = !1; H && (k = f(w, x, U)); let W = !1; F && (W = f(D, x, U)); const $ = k || W; if ($) for (let Z = 0; Z < 3; Z++) { const J = w + Z, se = D + Z, re = h[J], ce = h[J + 3], ee = h[se], Me = h[se + 3]; h[_ + Z] = re < ee ? re : ee, h[_ + Z + 3] = ce > Me ? ce : Me } return $ } } } function intersectRay(r, e, i, s, a) { let o, l, c, h, d, p; const f = 1 / i.direction.x, _ = 1 / i.direction.y, x = 1 / i.direction.z, b = i.origin.x, T = i.origin.y, M = i.origin.z; let w = e[r], D = e[r + 3], R = e[r + 1], P = e[r + 3 + 1], U = e[r + 2], O = e[r + 3 + 2]; return f >= 0 ? (o = (w - b) * f, l = (D - b) * f) : (o = (D - b) * f, l = (w - b) * f), _ >= 0 ? (c = (R - T) * _, h = (P - T) * _) : (c = (P - T) * _, h = (R - T) * _), o > h || c > l || ((c > o || isNaN(o)) && (o = c), (h < l || isNaN(l)) && (l = h), x >= 0 ? (d = (U - M) * x, p = (O - M) * x) : (d = (O - M) * x, p = (U - M) * x), o > p || d > l) ? !1 : ((d > o || o !== o) && (o = d), (p < l || l !== l) && (l = p), o <= a && l >= s) } function intersectTris_indirect(r, e, i, s, a, o, l, c) { const { geometry: h, _indirectBuffer: d } = r; for (let p = s, f = s + a; p < f; p++) { let _ = d ? d[p] : p; intersectTri(h, e, i, _, o, l, c) } } function intersectClosestTri_indirect(r, e, i, s, a, o, l) { const { geometry: c, _indirectBuffer: h } = r; let d = 1 / 0, p = null; for (let f = s, _ = s + a; f < _; f++) { let x; x = intersectTri(c, e, i, h ? h[f] : f, null, o, l), x && x.distance < d && (p = x, d = x.distance) } return p } function iterateOverTriangles_indirect(r, e, i, s, a, o, l) { const { geometry: c } = i, { index: h } = c, d = c.attributes.position; for (let p = r, f = e + r; p < f; p++) { let _; if (_ = i.resolveTriangleIndex(p), setTriangle(l, _ * 3, h, d), l.needsUpdate = !0, s(l, _, a, o)) return !0 } return !1 } function raycast(r, e, i, s, a, o, l) { BufferStack.setBuffer(r._roots[e]), _raycast$1(0, r, i, s, a, o, l), BufferStack.clearBuffer() } function _raycast$1(r, e, i, s, a, o, l) { const { float32Array: c, uint16Array: h, uint32Array: d } = BufferStack, p = r * 2; if (IS_LEAF(p, h)) { const _ = OFFSET(r, d), x = COUNT(p, h); intersectTris(e, i, s, _, x, a, o, l) } else { const _ = LEFT_NODE(r); intersectRay(_, c, s, o, l) && _raycast$1(_, e, i, s, a, o, l); const x = RIGHT_NODE(r, d); intersectRay(x, c, s, o, l) && _raycast$1(x, e, i, s, a, o, l) } } const _xyzFields$1 = ["x", "y", "z"]; function raycastFirst(r, e, i, s, a, o) { BufferStack.setBuffer(r._roots[e]); const l = _raycastFirst$1(0, r, i, s, a, o); return BufferStack.clearBuffer(), l } function _raycastFirst$1(r, e, i, s, a, o) { const { float32Array: l, uint16Array: c, uint32Array: h } = BufferStack; let d = r * 2; if (IS_LEAF(d, c)) { const f = OFFSET(r, h), _ = COUNT(d, c); return intersectClosestTri(e, i, s, f, _, a, o) } else { const f = SPLIT_AXIS(r, h), _ = _xyzFields$1[f], b = s.direction[_] >= 0; let T, M; b ? (T = LEFT_NODE(r), M = RIGHT_NODE(r, h)) : (T = RIGHT_NODE(r, h), M = LEFT_NODE(r)); const D = intersectRay(T, l, s, a, o) ? _raycastFirst$1(T, e, i, s, a, o) : null; if (D) { const U = D.point[_]; if (b ? U <= l[M + f] : U >= l[M + f + 3]) return D } const P = intersectRay(M, l, s, a, o) ? _raycastFirst$1(M, e, i, s, a, o) : null; return D && P ? D.distance <= P.distance ? D : P : D || P || null } } const boundingBox$1 = new Box3, triangle$1 = new ExtendedTriangle, triangle2$1 = new ExtendedTriangle, invertedMat$1 = new Matrix4, obb$4 = new OrientedBox, obb2$3 = new OrientedBox; function intersectsGeometry(r, e, i, s) { BufferStack.setBuffer(r._roots[e]); const a = _intersectsGeometry$1(0, r, i, s); return BufferStack.clearBuffer(), a } function _intersectsGeometry$1(r, e, i, s, a = null) { const { float32Array: o, uint16Array: l, uint32Array: c } = BufferStack; let h = r * 2; if (a === null && (i.boundingBox || i.computeBoundingBox(), obb$4.set(i.boundingBox.min, i.boundingBox.max, s), a = obb$4), IS_LEAF(h, l)) { const p = e.geometry, f = p.index, _ = p.attributes.position, x = i.index, b = i.attributes.position, T = OFFSET(r, c), M = COUNT(h, l); if (invertedMat$1.copy(s).invert(), i.boundsTree) return arrayToBox(r, o, obb2$3), obb2$3.matrix.copy(invertedMat$1), obb2$3.needsUpdate = !0, i.boundsTree.shapecast({ intersectsBounds: D => obb2$3.intersectsBox(D), intersectsTriangle: D => { D.a.applyMatrix4(s), D.b.applyMatrix4(s), D.c.applyMatrix4(s), D.needsUpdate = !0; for (let R = T * 3, P = (M + T) * 3; R < P; R += 3)if (setTriangle(triangle2$1, R, f, _), triangle2$1.needsUpdate = !0, D.intersectsTriangle(triangle2$1)) return !0; return !1 } }); for (let w = T * 3, D = (M + T) * 3; w < D; w += 3) { setTriangle(triangle$1, w, f, _), triangle$1.a.applyMatrix4(invertedMat$1), triangle$1.b.applyMatrix4(invertedMat$1), triangle$1.c.applyMatrix4(invertedMat$1), triangle$1.needsUpdate = !0; for (let R = 0, P = x.count; R < P; R += 3)if (setTriangle(triangle2$1, R, x, b), triangle2$1.needsUpdate = !0, triangle$1.intersectsTriangle(triangle2$1)) return !0 } } else { const p = r + 8, f = c[r + 6]; return arrayToBox(p, o, boundingBox$1), !!(a.intersectsBox(boundingBox$1) && _intersectsGeometry$1(p, e, i, s, a) || (arrayToBox(f, o, boundingBox$1), a.intersectsBox(boundingBox$1) && _intersectsGeometry$1(f, e, i, s, a))) } } const tempMatrix$1 = new Matrix4, obb$3 = new OrientedBox, obb2$2 = new OrientedBox, temp1$1 = new Vector3, temp2$1 = new Vector3, temp3$1 = new Vector3, temp4$1 = new Vector3; function closestPointToGeometry(r, e, i, s = {}, a = {}, o = 0, l = 1 / 0) { e.boundingBox || e.computeBoundingBox(), obb$3.set(e.boundingBox.min, e.boundingBox.max, i), obb$3.needsUpdate = !0; const c = r.geometry, h = c.attributes.position, d = c.index, p = e.attributes.position, f = e.index, _ = ExtendedTrianglePool.getPrimitive(), x = ExtendedTrianglePool.getPrimitive(); let b = temp1$1, T = temp2$1, M = null, w = null; a && (M = temp3$1, w = temp4$1); let D = 1 / 0, R = null, P = null; return tempMatrix$1.copy(i).invert(), obb2$2.matrix.copy(tempMatrix$1), r.shapecast({ boundsTraverseOrder: U => obb$3.distanceToBox(U), intersectsBounds: (U, O, N) => N < D && N < l ? (O && (obb2$2.min.copy(U.min), obb2$2.max.copy(U.max), obb2$2.needsUpdate = !0), !0) : !1, intersectsRange: (U, O) => { if (e.boundsTree) return e.boundsTree.shapecast({ boundsTraverseOrder: H => obb2$2.distanceToBox(H), intersectsBounds: (H, F, k) => k < D && k < l, intersectsRange: (H, F) => { for (let k = H, W = H + F; k < W; k++) { setTriangle(x, 3 * k, f, p), x.a.applyMatrix4(i), x.b.applyMatrix4(i), x.c.applyMatrix4(i), x.needsUpdate = !0; for (let $ = U, Z = U + O; $ < Z; $++) { setTriangle(_, 3 * $, d, h), _.needsUpdate = !0; const J = _.distanceToTriangle(x, b, M); if (J < D && (T.copy(b), w && w.copy(M), D = J, R = $, P = k), J < o) return !0 } } } }); { const N = getTriCount(e); for (let H = 0, F = N; H < F; H++) { setTriangle(x, 3 * H, f, p), x.a.applyMatrix4(i), x.b.applyMatrix4(i), x.c.applyMatrix4(i), x.needsUpdate = !0; for (let k = U, W = U + O; k < W; k++) { setTriangle(_, 3 * k, d, h), _.needsUpdate = !0; const $ = _.distanceToTriangle(x, b, M); if ($ < D && (T.copy(b), w && w.copy(M), D = $, R = k, P = H), $ < o) return !0 } } } } }), ExtendedTrianglePool.releasePrimitive(_), ExtendedTrianglePool.releasePrimitive(x), D === 1 / 0 ? null : (s.point ? s.point.copy(T) : s.point = T.clone(), s.distance = D, s.faceIndex = R, a && (a.point ? a.point.copy(w) : a.point = w.clone(), a.point.applyMatrix4(tempMatrix$1), T.applyMatrix4(tempMatrix$1), a.distance = T.sub(a.point).length(), a.faceIndex = P), s) } function refit_indirect(r, e = null) { e && Array.isArray(e) && (e = new Set(e)); const i = r.geometry, s = i.index ? i.index.array : null, a = i.attributes.position; let o, l, c, h, d = 0; const p = r._roots; for (let _ = 0, x = p.length; _ < x; _++)o = p[_], l = new Uint32Array(o), c = new Uint16Array(o), h = new Float32Array(o), f(0, d), d += o.byteLength; function f(_, x, b = !1) { const T = _ * 2; if (c[T + 15] === IS_LEAFNODE_FLAG) { const w = l[_ + 6], D = c[T + 14]; let R = 1 / 0, P = 1 / 0, U = 1 / 0, O = -1 / 0, N = -1 / 0, H = -1 / 0; for (let F = w, k = w + D; F < k; F++) { const W = 3 * r.resolveTriangleIndex(F); for (let $ = 0; $ < 3; $++) { let Z = W + $; Z = s ? s[Z] : Z; const J = a.getX(Z), se = a.getY(Z), re = a.getZ(Z); J < R && (R = J), J > O && (O = J), se < P && (P = se), se > N && (N = se), re < U && (U = re), re > H && (H = re) } } return h[_ + 0] !== R || h[_ + 1] !== P || h[_ + 2] !== U || h[_ + 3] !== O || h[_ + 4] !== N || h[_ + 5] !== H ? (h[_ + 0] = R, h[_ + 1] = P, h[_ + 2] = U, h[_ + 3] = O, h[_ + 4] = N, h[_ + 5] = H, !0) : !1 } else { const w = _ + 8, D = l[_ + 6], R = w + x, P = D + x; let U = b, O = !1, N = !1; e ? U || (O = e.has(R), N = e.has(P), U = !O && !N) : (O = !0, N = !0); const H = U || O, F = U || N; let k = !1; H && (k = f(w, x, U)); let W = !1; F && (W = f(D, x, U)); const $ = k || W; if ($) for (let Z = 0; Z < 3; Z++) { const J = w + Z, se = D + Z, re = h[J], ce = h[J + 3], ee = h[se], Me = h[se + 3]; h[_ + Z] = re < ee ? re : ee, h[_ + Z + 3] = ce > Me ? ce : Me } return $ } } } function raycast_indirect(r, e, i, s, a, o, l) { BufferStack.setBuffer(r._roots[e]), _raycast(0, r, i, s, a, o, l), BufferStack.clearBuffer() } function _raycast(r, e, i, s, a, o, l) { const { float32Array: c, uint16Array: h, uint32Array: d } = BufferStack, p = r * 2; if (IS_LEAF(p, h)) { const _ = OFFSET(r, d), x = COUNT(p, h); intersectTris_indirect(e, i, s, _, x, a, o, l) } else { const _ = LEFT_NODE(r); intersectRay(_, c, s, o, l) && _raycast(_, e, i, s, a, o, l); const x = RIGHT_NODE(r, d); intersectRay(x, c, s, o, l) && _raycast(x, e, i, s, a, o, l) } } const _xyzFields = ["x", "y", "z"]; function raycastFirst_indirect(r, e, i, s, a, o) { BufferStack.setBuffer(r._roots[e]); const l = _raycastFirst(0, r, i, s, a, o); return BufferStack.clearBuffer(), l } function _raycastFirst(r, e, i, s, a, o) { const { float32Array: l, uint16Array: c, uint32Array: h } = BufferStack; let d = r * 2; if (IS_LEAF(d, c)) { const f = OFFSET(r, h), _ = COUNT(d, c); return intersectClosestTri_indirect(e, i, s, f, _, a, o) } else { const f = SPLIT_AXIS(r, h), _ = _xyzFields[f], b = s.direction[_] >= 0; let T, M; b ? (T = LEFT_NODE(r), M = RIGHT_NODE(r, h)) : (T = RIGHT_NODE(r, h), M = LEFT_NODE(r)); const D = intersectRay(T, l, s, a, o) ? _raycastFirst(T, e, i, s, a, o) : null; if (D) { const U = D.point[_]; if (b ? U <= l[M + f] : U >= l[M + f + 3]) return D } const P = intersectRay(M, l, s, a, o) ? _raycastFirst(M, e, i, s, a, o) : null; return D && P ? D.distance <= P.distance ? D : P : D || P || null } } const boundingBox = new Box3, triangle = new ExtendedTriangle, triangle2 = new ExtendedTriangle, invertedMat = new Matrix4, obb$2 = new OrientedBox, obb2$1 = new OrientedBox; function intersectsGeometry_indirect(r, e, i, s) { BufferStack.setBuffer(r._roots[e]); const a = _intersectsGeometry(0, r, i, s); return BufferStack.clearBuffer(), a } function _intersectsGeometry(r, e, i, s, a = null) { const { float32Array: o, uint16Array: l, uint32Array: c } = BufferStack; let h = r * 2; if (a === null && (i.boundingBox || i.computeBoundingBox(), obb$2.set(i.boundingBox.min, i.boundingBox.max, s), a = obb$2), IS_LEAF(h, l)) { const p = e.geometry, f = p.index, _ = p.attributes.position, x = i.index, b = i.attributes.position, T = OFFSET(r, c), M = COUNT(h, l); if (invertedMat.copy(s).invert(), i.boundsTree) return arrayToBox(r, o, obb2$1), obb2$1.matrix.copy(invertedMat), obb2$1.needsUpdate = !0, i.boundsTree.shapecast({ intersectsBounds: D => obb2$1.intersectsBox(D), intersectsTriangle: D => { D.a.applyMatrix4(s), D.b.applyMatrix4(s), D.c.applyMatrix4(s), D.needsUpdate = !0; for (let R = T, P = M + T; R < P; R++)if (setTriangle(triangle2, 3 * e.resolveTriangleIndex(R), f, _), triangle2.needsUpdate = !0, D.intersectsTriangle(triangle2)) return !0; return !1 } }); for (let w = T, D = M + T; w < D; w++) { const R = e.resolveTriangleIndex(w); setTriangle(triangle, 3 * R, f, _), triangle.a.applyMatrix4(invertedMat), triangle.b.applyMatrix4(invertedMat), triangle.c.applyMatrix4(invertedMat), triangle.needsUpdate = !0; for (let P = 0, U = x.count; P < U; P += 3)if (setTriangle(triangle2, P, x, b), triangle2.needsUpdate = !0, triangle.intersectsTriangle(triangle2)) return !0 } } else { const p = r + 8, f = c[r + 6]; return arrayToBox(p, o, boundingBox), !!(a.intersectsBox(boundingBox) && _intersectsGeometry(p, e, i, s, a) || (arrayToBox(f, o, boundingBox), a.intersectsBox(boundingBox) && _intersectsGeometry(f, e, i, s, a))) } } const tempMatrix = new Matrix4, obb$1 = new OrientedBox, obb2 = new OrientedBox, temp1 = new Vector3, temp2 = new Vector3, temp3 = new Vector3, temp4 = new Vector3; function closestPointToGeometry_indirect(r, e, i, s = {}, a = {}, o = 0, l = 1 / 0) { e.boundingBox || e.computeBoundingBox(), obb$1.set(e.boundingBox.min, e.boundingBox.max, i), obb$1.needsUpdate = !0; const c = r.geometry, h = c.attributes.position, d = c.index, p = e.attributes.position, f = e.index, _ = ExtendedTrianglePool.getPrimitive(), x = ExtendedTrianglePool.getPrimitive(); let b = temp1, T = temp2, M = null, w = null; a && (M = temp3, w = temp4); let D = 1 / 0, R = null, P = null; return tempMatrix.copy(i).invert(), obb2.matrix.copy(tempMatrix), r.shapecast({ boundsTraverseOrder: U => obb$1.distanceToBox(U), intersectsBounds: (U, O, N) => N < D && N < l ? (O && (obb2.min.copy(U.min), obb2.max.copy(U.max), obb2.needsUpdate = !0), !0) : !1, intersectsRange: (U, O) => { if (e.boundsTree) { const N = e.boundsTree; return N.shapecast({ boundsTraverseOrder: H => obb2.distanceToBox(H), intersectsBounds: (H, F, k) => k < D && k < l, intersectsRange: (H, F) => { for (let k = H, W = H + F; k < W; k++) { const $ = N.resolveTriangleIndex(k); setTriangle(x, 3 * $, f, p), x.a.applyMatrix4(i), x.b.applyMatrix4(i), x.c.applyMatrix4(i), x.needsUpdate = !0; for (let Z = U, J = U + O; Z < J; Z++) { const se = r.resolveTriangleIndex(Z); setTriangle(_, 3 * se, d, h), _.needsUpdate = !0; const re = _.distanceToTriangle(x, b, M); if (re < D && (T.copy(b), w && w.copy(M), D = re, R = Z, P = k), re < o) return !0 } } } }) } else { const N = getTriCount(e); for (let H = 0, F = N; H < F; H++) { setTriangle(x, 3 * H, f, p), x.a.applyMatrix4(i), x.b.applyMatrix4(i), x.c.applyMatrix4(i), x.needsUpdate = !0; for (let k = U, W = U + O; k < W; k++) { const $ = r.resolveTriangleIndex(k); setTriangle(_, 3 * $, d, h), _.needsUpdate = !0; const Z = _.distanceToTriangle(x, b, M); if (Z < D && (T.copy(b), w && w.copy(M), D = Z, R = k, P = H), Z < o) return !0 } } } } }), ExtendedTrianglePool.releasePrimitive(_), ExtendedTrianglePool.releasePrimitive(x), D === 1 / 0 ? null : (s.point ? s.point.copy(T) : s.point = T.clone(), s.distance = D, s.faceIndex = R, a && (a.point ? a.point.copy(w) : a.point = w.clone(), a.point.applyMatrix4(tempMatrix), T.applyMatrix4(tempMatrix), a.distance = T.sub(a.point).length(), a.faceIndex = P), s) } function isSharedArrayBufferSupported() { return typeof SharedArrayBuffer < "u" } const _bufferStack1 = new BufferStack.constructor, _bufferStack2 = new BufferStack.constructor, _boxPool = new PrimitivePool(() => new Box3), _leftBox1 = new Box3, _rightBox1 = new Box3, _leftBox2 = new Box3, _rightBox2 = new Box3; let _active = !1; function bvhcast(r, e, i, s) { if (_active) throw new Error("MeshBVH: Recursive calls to bvhcast not supported."); _active = !0; const a = r._roots, o = e._roots; let l, c = 0, h = 0; const d = new Matrix4().copy(i).invert(); for (let p = 0, f = a.length; p < f; p++) { _bufferStack1.setBuffer(a[p]), h = 0; const _ = _boxPool.getPrimitive(); arrayToBox(0, _bufferStack1.float32Array, _), _.applyMatrix4(d); for (let x = 0, b = o.length; x < b && (_bufferStack2.setBuffer(o[x]), l = _traverse(0, 0, i, d, s, c, h, 0, 0, _), _bufferStack2.clearBuffer(), h += o[x].length, !l); x++); if (_boxPool.releasePrimitive(_), _bufferStack1.clearBuffer(), c += a[p].length, l) break } return _active = !1, l } function _traverse(r, e, i, s, a, o = 0, l = 0, c = 0, h = 0, d = null, p = !1) { let f, _; p ? (f = _bufferStack2, _ = _bufferStack1) : (f = _bufferStack1, _ = _bufferStack2); const x = f.float32Array, b = f.uint32Array, T = f.uint16Array, M = _.float32Array, w = _.uint32Array, D = _.uint16Array, R = r * 2, P = e * 2, U = IS_LEAF(R, T), O = IS_LEAF(P, D); let N = !1; if (O && U) p ? N = a(OFFSET(e, w), COUNT(e * 2, D), OFFSET(r, b), COUNT(r * 2, T), h, l + e, c, o + r) : N = a(OFFSET(r, b), COUNT(r * 2, T), OFFSET(e, w), COUNT(e * 2, D), c, o + r, h, l + e); else if (O) { const H = _boxPool.getPrimitive(); arrayToBox(e, M, H), H.applyMatrix4(i); const F = LEFT_NODE(r), k = RIGHT_NODE(r, b); arrayToBox(F, x, _leftBox1), arrayToBox(k, x, _rightBox1); const W = H.intersectsBox(_leftBox1), $ = H.intersectsBox(_rightBox1); N = W && _traverse(e, F, s, i, a, l, o, h, c + 1, H, !p) || $ && _traverse(e, k, s, i, a, l, o, h, c + 1, H, !p), _boxPool.releasePrimitive(H) } else { const H = LEFT_NODE(e), F = RIGHT_NODE(e, w); arrayToBox(H, M, _leftBox2), arrayToBox(F, M, _rightBox2); const k = d.intersectsBox(_leftBox2), W = d.intersectsBox(_rightBox2); if (k && W) N = _traverse(r, H, i, s, a, o, l, c, h + 1, d, p) || _traverse(r, F, i, s, a, o, l, c, h + 1, d, p); else if (k) if (U) N = _traverse(r, H, i, s, a, o, l, c, h + 1, d, p); else { const $ = _boxPool.getPrimitive(); $.copy(_leftBox2).applyMatrix4(i); const Z = LEFT_NODE(r), J = RIGHT_NODE(r, b); arrayToBox(Z, x, _leftBox1), arrayToBox(J, x, _rightBox1); const se = $.intersectsBox(_leftBox1), re = $.intersectsBox(_rightBox1); N = se && _traverse(H, Z, s, i, a, l, o, h, c + 1, $, !p) || re && _traverse(H, J, s, i, a, l, o, h, c + 1, $, !p), _boxPool.releasePrimitive($) } else if (W) if (U) N = _traverse(r, F, i, s, a, o, l, c, h + 1, d, p); else { const $ = _boxPool.getPrimitive(); $.copy(_rightBox2).applyMatrix4(i); const Z = LEFT_NODE(r), J = RIGHT_NODE(r, b); arrayToBox(Z, x, _leftBox1), arrayToBox(J, x, _rightBox1); const se = $.intersectsBox(_leftBox1), re = $.intersectsBox(_rightBox1); N = se && _traverse(F, Z, s, i, a, l, o, h, c + 1, $, !p) || re && _traverse(F, J, s, i, a, l, o, h, c + 1, $, !p), _boxPool.releasePrimitive($) } } return N } const obb = new OrientedBox, tempBox = new Box3, DEFAULT_OPTIONS = { strategy: CENTER, maxDepth: 40, maxLeafTris: 10, useSharedArrayBuffer: !1, setBoundingBox: !0, onProgress: null, indirect: !1, verbose: !0, range: null }; class MeshBVH { static serialize(e, i = {}) { i = { cloneBuffers: !0, ...i }; const s = e.geometry, a = e._roots, o = e._indirectBuffer, l = s.getIndex(); let c; return i.cloneBuffers ? c = { roots: a.map(h => h.slice()), index: l ? l.array.slice() : null, indirectBuffer: o ? o.slice() : null } : c = { roots: a, index: l ? l.array : null, indirectBuffer: o }, c } static deserialize(e, i, s = {}) { s = { setIndex: !0, indirect: !!e.indirectBuffer, ...s }; const { index: a, roots: o, indirectBuffer: l } = e, c = new MeshBVH(i, { ...s, [SKIP_GENERATION]: !0 }); if (c._roots = o, c._indirectBuffer = l || null, s.setIndex) { const h = i.getIndex(); if (h === null) { const d = new BufferAttribute(e.index, 1, !1); i.setIndex(d) } else h.array !== a && (h.array.set(a), h.needsUpdate = !0) } return c } get indirect() { return !!this._indirectBuffer } constructor(e, i = {}) { if (e.isBufferGeometry) { if (e.index && e.index.isInterleavedBufferAttribute) throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.") } else throw new Error("MeshBVH: Only BufferGeometries are supported."); if (i = Object.assign({ ...DEFAULT_OPTIONS, [SKIP_GENERATION]: !1 }, i), i.useSharedArrayBuffer && !isSharedArrayBufferSupported()) throw new Error("MeshBVH: SharedArrayBuffer is not available."); this.geometry = e, this._roots = null, this._indirectBuffer = null, i[SKIP_GENERATION] || (buildPackedTree(this, i), !e.boundingBox && i.setBoundingBox && (e.boundingBox = this.getBoundingBox(new Box3))), this.resolveTriangleIndex = i.indirect ? s => this._indirectBuffer[s] : s => s } refit(e = null) { return (this.indirect ? refit_indirect : refit)(this, e) } traverse(e, i = 0) { const s = this._roots[i], a = new Uint32Array(s), o = new Uint16Array(s); l(0); function l(c, h = 0) { const d = c * 2, p = o[d + 15] === IS_LEAFNODE_FLAG; if (p) { const f = a[c + 6], _ = o[d + 14]; e(h, p, new Float32Array(s, c * 4, 6), f, _) } else { const f = c + BYTES_PER_NODE / 4, _ = a[c + 6], x = a[c + 7]; e(h, p, new Float32Array(s, c * 4, 6), x) || (l(f, h + 1), l(_, h + 1)) } } } raycast(e, i = FrontSide, s = 0, a = 1 / 0) { const o = this._roots, l = this.geometry, c = [], h = i.isMaterial, d = Array.isArray(i), p = l.groups, f = h ? i.side : i, _ = this.indirect ? raycast_indirect : raycast; for (let x = 0, b = o.length; x < b; x++) { const T = d ? i[p[x].materialIndex].side : f, M = c.length; if (_(this, x, T, e, c, s, a), d) { const w = p[x].materialIndex; for (let D = M, R = c.length; D < R; D++)c[D].face.materialIndex = w } } return c } raycastFirst(e, i = FrontSide, s = 0, a = 1 / 0) { const o = this._roots, l = this.geometry, c = i.isMaterial, h = Array.isArray(i); let d = null; const p = l.groups, f = c ? i.side : i, _ = this.indirect ? raycastFirst_indirect : raycastFirst; for (let x = 0, b = o.length; x < b; x++) { const T = h ? i[p[x].materialIndex].side : f, M = _(this, x, T, e, s, a); M != null && (d == null || M.distance < d.distance) && (d = M, h && (M.face.materialIndex = p[x].materialIndex)) } return d } intersectsGeometry(e, i) { let s = !1; const a = this._roots, o = this.indirect ? intersectsGeometry_indirect : intersectsGeometry; for (let l = 0, c = a.length; l < c && (s = o(this, l, e, i), !s); l++); return s } shapecast(e) { const i = ExtendedTrianglePool.getPrimitive(), s = this.indirect ? iterateOverTriangles_indirect : iterateOverTriangles; let { boundsTraverseOrder: a, intersectsBounds: o, intersectsRange: l, intersectsTriangle: c } = e; if (l && c) { const f = l; l = (_, x, b, T, M) => f(_, x, b, T, M) ? !0 : s(_, x, this, c, b, T, i) } else l || (c ? l = (f, _, x, b) => s(f, _, this, c, x, b, i) : l = (f, _, x) => x); let h = !1, d = 0; const p = this._roots; for (let f = 0, _ = p.length; f < _; f++) { const x = p[f]; if (h = shapecast(this, f, o, l, a, d), h) break; d += x.byteLength } return ExtendedTrianglePool.releasePrimitive(i), h } bvhcast(e, i, s) { let { intersectsRanges: a, intersectsTriangles: o } = s; const l = ExtendedTrianglePool.getPrimitive(), c = this.geometry.index, h = this.geometry.attributes.position, d = this.indirect ? b => { const T = this.resolveTriangleIndex(b); setTriangle(l, T * 3, c, h) } : b => { setTriangle(l, b * 3, c, h) }, p = ExtendedTrianglePool.getPrimitive(), f = e.geometry.index, _ = e.geometry.attributes.position, x = e.indirect ? b => { const T = e.resolveTriangleIndex(b); setTriangle(p, T * 3, f, _) } : b => { setTriangle(p, b * 3, f, _) }; if (o) { const b = (T, M, w, D, R, P, U, O) => { for (let N = w, H = w + D; N < H; N++) { x(N), p.a.applyMatrix4(i), p.b.applyMatrix4(i), p.c.applyMatrix4(i), p.needsUpdate = !0; for (let F = T, k = T + M; F < k; F++)if (d(F), l.needsUpdate = !0, o(l, p, F, N, R, P, U, O)) return !0 } return !1 }; if (a) { const T = a; a = function (M, w, D, R, P, U, O, N) { return T(M, w, D, R, P, U, O, N) ? !0 : b(M, w, D, R, P, U, O, N) } } else a = b } return bvhcast(this, e, i, a) } intersectsBox(e, i) { return obb.set(e.min, e.max, i), obb.needsUpdate = !0, this.shapecast({ intersectsBounds: s => obb.intersectsBox(s), intersectsTriangle: s => obb.intersectsTriangle(s) }) } intersectsSphere(e) { return this.shapecast({ intersectsBounds: i => e.intersectsBox(i), intersectsTriangle: i => i.intersectsSphere(e) }) } closestPointToGeometry(e, i, s = {}, a = {}, o = 0, l = 1 / 0) { return (this.indirect ? closestPointToGeometry_indirect : closestPointToGeometry)(this, e, i, s, a, o, l) } closestPointToPoint(e, i = {}, s = 0, a = 1 / 0) { return closestPointToPoint(this, e, i, s, a) } getBoundingBox(e) { return e.makeEmpty(), this._roots.forEach(s => { arrayToBox(0, new Float32Array(s), tempBox), e.union(tempBox) }), e } } function convertRaycastIntersect(r, e, i) { return r === null ? null : (r.point.applyMatrix4(e.matrixWorld), r.distance = r.point.distanceTo(i.ray.origin), r.object = e, r) } const ray = new Ray, direction = new Vector3, tmpInverseMatrix = new Matrix4, origMeshRaycastFunc = Mesh.prototype.raycast, origBatchedRaycastFunc = BatchedMesh.prototype.raycast, _worldScale = new Vector3, _mesh = new Mesh, _batchIntersects = []; function acceleratedRaycast(r, e) { this.isBatchedMesh ? acceleratedBatchedMeshRaycast.call(this, r, e) : acceleratedMeshRaycast.call(this, r, e) } function acceleratedBatchedMeshRaycast(r, e) { if (this.boundsTrees) { const i = this.boundsTrees, s = this._drawInfo || this._instanceInfo, a = this._drawRanges || this._geometryInfo, o = this.matrixWorld; _mesh.material = this.material, _mesh.geometry = this.geometry; const l = _mesh.geometry.boundsTree, c = _mesh.geometry.drawRange; _mesh.geometry.boundingSphere === null && (_mesh.geometry.boundingSphere = new Sphere); for (let h = 0, d = s.length; h < d; h++) { if (!this.getVisibleAt(h)) continue; const p = s[h].geometryIndex; if (_mesh.geometry.boundsTree = i[p], this.getMatrixAt(h, _mesh.matrixWorld).premultiply(o), !_mesh.geometry.boundsTree) { this.getBoundingBoxAt(p, _mesh.geometry.boundingBox), this.getBoundingSphereAt(p, _mesh.geometry.boundingSphere); const f = a[p]; _mesh.geometry.setDrawRange(f.start, f.count) } _mesh.raycast(r, _batchIntersects); for (let f = 0, _ = _batchIntersects.length; f < _; f++) { const x = _batchIntersects[f]; x.object = this, x.batchId = h, e.push(x) } _batchIntersects.length = 0 } _mesh.geometry.boundsTree = l, _mesh.geometry.drawRange = c, _mesh.material = null, _mesh.geometry = null } else origBatchedRaycastFunc.call(this, r, e) } function acceleratedMeshRaycast(r, e) { if (this.geometry.boundsTree) { if (this.material === void 0) return; tmpInverseMatrix.copy(this.matrixWorld).invert(), ray.copy(r.ray).applyMatrix4(tmpInverseMatrix), _worldScale.setFromMatrixScale(this.matrixWorld), direction.copy(ray.direction).multiply(_worldScale); const i = direction.length(), s = r.near / i, a = r.far / i, o = this.geometry.boundsTree; if (r.firstHitOnly === !0) { const l = convertRaycastIntersect(o.raycastFirst(ray, this.material, s, a), this, r); l && e.push(l) } else { const l = o.raycast(ray, this.material, s, a); for (let c = 0, h = l.length; c < h; c++) { const d = convertRaycastIntersect(l[c], this, r); d && e.push(d) } } } else origMeshRaycastFunc.call(this, r, e) } function WorkerWrapper$1(r) { return new Worker("./assets/collisionworker-eT5h7hIA.js", { name: r == null ? void 0 : r.name }) } class collider extends Mesh { } collider.prototype.raycast = acceleratedRaycast; var Hs, os, ls, Fn, Rt, Qt, hi, Ki, jt, Qs, Ji, Ws; const $r = class $r { constructor(e, i) { pe(this, Hs, new Vector3); pe(this, os, new Spherical); pe(this, ls, new Quaternion); pe(this, Fn, new Matrix4); pe(this, Rt, new Vector3); pe(this, Qt, new Vector3); pe(this, hi, new Vector3); pe(this, Ki, new Object3D); pe(this, jt, new Line3); pe(this, Qs, new Line3); pe(this, Ji, new Box3); pe(this, Ws, new Plane); this._characters = e, this._camera = this._characters._camera, this.ready = new Promise(s => { this.isReady = s }), this._colliderMesh = null, this._geometry = null, this._collider = null, this._deltaRatioAccumulator = 0, this._deltaRatioAccumulatorSteps = 0, this._positionPrevPhysics = new Vector3, this._positionNextPhysics = new Vector3, this._accelerationPhysics = new Vector3, this._velocityPhysics = new Vector3, this._velocityVariation = 0, this._rotationPrevPhysics = 0, this._rotationNextPhysics = 0, this._substeps = typeof i.substeps == "number" ? i.substeps : 3, this._positionForce = typeof i.positionForce == "number" ? i.positionForce : .0045, this._jumpForce = typeof i.jumpForce == "number" ? i.jumpForce : .2, this._gravity = typeof i.gravity == "number" ? i.gravity : -.00981, this._directionLerp = typeof i.directionLerp == "number" ? i.directionLerp : .075, this._velPhysicsDamp = typeof i.damp == "number" ? i.damp : .92, this._velPhysicsIdleDamp = typeof i.dampIdle == "number" ? i.dampIdle : .92, this._velPhysicsDampInterpolation = 0, this._rotVelocityMin = typeof i.rotVelocityMin == "number" ? i.rotVelocityMin : .0035, this._rotVelocityMax = typeof i.rotVelocityMax == "number" ? i.rotVelocityMax : .02, this._needsToLand = !1, this._lastFloorPosition = new Vector3, this._isMoving = !1, this._jumpRequested = !1, this._moveTowardsCameraTarget = i.moveTowardsCameraTarget !== !1, this._autoStep = i.autoStep !== !1, this._isAutoStepping = !1, this._checkFalling = i.checkFalling !== !1, this._rayCaster = new Raycaster, this._rayCaster.firstHitOnly = !0, this._nearestVerticalPoint = -1, this._capsuleRadiusPercentage = typeof i.capsuleRadiusPercentage == "number" ? Math.min(i.capsuleRadiusPercentage, .45) : .2, this._charactersCapsule = { radius: .5, segment: new Line3(new Vector3(0, 0, 0), new Vector3(0, 1, 0)) }, this._floorDetectInclination = typeof i.floorDetectInclination == "number" ? Math.min(1, i.floorDetectInclination) : .8, this._fallLimitDistance = typeof i.fallLimitDistance == "number" ? Math.min(1, i.fallLimitDistance) : 10, this._isOnFloor = !0, this._prevIsOnFloor = this._isOnFloor, this._prevIsOnFloorTime = -1, this._shapecastFuncs = { intersectsBounds: s => s.intersectsBox(L(this, Ji)), intersectsTriangle: s => { const a = L(this, Rt), o = L(this, Qt), l = s.closestPointToSegment(L(this, jt), a, o); if (l < this._charactersCapsule.radius) { const c = o.equals(L(this, jt).start), h = this._charactersCapsule.radius - l, d = o.sub(a).normalize(); L(this, jt).start.addScaledVector(d, h), L(this, jt).end.addScaledVector(d, h), c && d.dot(this._characters._localObject.up) > 0 && (s.getNormal(L(this, hi)), L(this, hi).dot(this._characters._localObject.up) > this._floorDetectInclination && (this._isOnFloor = !0)) } return !1 } }, this._initializeBVH(i) } static ensureRightVector(e, i, s) { s.lengthSq() === 0 && (Math.abs(e.z) === 1 ? i.x += 1e-4 : i.z += 1e-4, i.normalize(), s.crossVectors(e, i)) } _updateCapsule(e) { const i = Math.abs(e.max.y - e.min.y), s = i * this._capsuleRadiusPercentage, a = i - s * 2; this._charactersCapsule.radius = s, this._charactersCapsule.segment.end.y = a } async _initializeBVH(e) { const i = new WorkerWrapper$1; if (i.onmessage = a => { const { serialized: o, position: l } = a.data; this._geometry = new BufferGeometry, this._geometry.setAttribute("position", new BufferAttribute(l, 3)), this._geometry.setIndex(new BufferAttribute(o.index, 1)), this._geometry.computeBoundingBox(), this._geometry.computeBoundingSphere(), this._geometry.boundsTree = MeshBVH.deserialize(o, this._geometry, { setIndex: !1 }), this._collider = new collider(this._geometry), i.terminate(), this.isReady() }, !e.colliderGeometry) throw new Error("Collider geometry not provided"); const s = typeof e.colliderGeometry == "string" ? await geometryLoader.load(e.colliderGeometry) : e.colliderGeometry; this._colliderMesh = new Mesh(s), this._colliderMesh.geometry.computeBoundingBox(), this._colliderMesh.geometry.computeBoundingSphere(), this._colliderMesh.updateMatrixWorld(!0), i.postMessage({ position: this._colliderMesh.geometry.attributes.position.array, index: this._colliderMesh.geometry.index ? this._colliderMesh.geometry.index.array : null, matrixWorld: this._colliderMesh.matrixWorld.elements }) } _update(e = 0, i = 1) { const s = this._characters._localObject; for (this._isMoving = e.length() > 1e-5, this._deltaRatioAccumulator += i, this._deltaRatioAccumulatorSteps = 0; this._deltaRatioAccumulator >= 1;) { if (this._deltaRatioAccumulator = Math.max(0, this._deltaRatioAccumulator - 1), this._deltaRatioAccumulatorSteps++, this._positionPrevPhysics.copy(this._positionNextPhysics), this._rotationPrevPhysics = this._rotationNextPhysics, this._isAutoStepping = !1, this._isMoving) { const h = this._moveTowardsCameraTarget ? this._camera.baseTarget : this._positionPrevPhysics; if (L(this, Rt).copy(this._camera.basePosition).sub(h).normalize(), L(this, Qt).crossVectors(s.up, L(this, Rt)), $r.ensureRightVector(s.up, L(this, Rt), L(this, Qt)), L(this, hi).crossVectors(L(this, Qt), s.up), L(this, Fn).lookAt(L(this, Hs), L(this, hi), s.up), L(this, ls).setFromRotationMatrix(L(this, Fn)), this._accelerationPhysics.copy(e).multiplyScalar(this._positionForce).applyQuaternion(L(this, ls)), this._autoStep && this._isOnFloor) { L(this, Rt).copy(this._accelerationPhysics).normalize(); const p = 3, f = this._charactersCapsule.radius * 2; for (let _ = 0; _ < p; _++) { const x = (_ + 1) / p * f; L(this, Qt).copy(this._positionPrevPhysics).addScaledVector(L(this, Rt), x), L(this, hi).copy(L(this, Qt)).addScaledVector(s.up, this._charactersCapsule.radius * 2), this._rayCaster.set(L(this, hi), L(this, Qt).copy(s.up).negate()); const b = this._rayCaster.intersectObject(this._collider)[0]; if (b) { const T = L(this, Ws).setFromNormalAndCoplanarPoint(s.up, this._positionPrevPhysics).distanceToPoint(b.point), M = this._charactersCapsule.radius * .1, w = this._charactersCapsule.radius * 1.5; if (T > M && T < w && b.face.normal.dot(s.up) > this._floorDetectInclination) { this._isAutoStepping = !0, L(this, Qt).copy(b.point).addScaledVector(s.up, T * .5); const D = this._accelerationPhysics.length(), R = this._positionForce * .05; this._accelerationPhysics.copy(L(this, Rt).subVectors(L(this, Qt), this._positionPrevPhysics).normalize()).multiplyScalar(D + R); break } } } } const d = this._camera.isFollowCamera ? this._camera._spherical.theta : 0; this._rotationNextPhysics = math.lerp(this._rotationNextPhysics, math.getShortestRotationAngle(this._rotationNextPhysics, L(this, os).setFromVector3(e).theta + d), this._directionLerp) } this._isOnFloor || this._accelerationPhysics.add(L(this, Rt).copy(s.up).multiplyScalar(this._gravity)), this._velocityPhysics.add(this._accelerationPhysics), this._accelerationPhysics.setScalar(0); const a = !this._isMoving && s.userData.medium === this._characters.MEDIUMS.GROUND && !this._needsToLand; this._velPhysicsDampInterpolation = a ? math.lerp(this._velPhysicsDampInterpolation, 0, .05) : 1, this._velocityPhysics.multiplyScalar(math.lerp(this._velPhysicsIdleDamp, this._velPhysicsDamp, this._velPhysicsDampInterpolation)), this._velocityPhysics.clampLength(0, this._charactersCapsule.radius * .9 * this._substeps), this._isAutoStepping || (this._isOnFloor = !1), L(this, Ki).position.copy(this._positionPrevPhysics), L(this, Ki).quaternion.copy(s.quaternion), L(this, Ki).scale.copy(s.scale); for (let h = 0; h < this._substeps; h++)this._substep(); this._positionNextPhysics.copy(L(this, Ki).position), s.velocity.add(L(this, hi).subVectors(this._positionNextPhysics, this._positionPrevPhysics)), s.velocity.multiplyScalar(this._characters._velocityCharDamp), this._velocityVariation += L(this, hi).length(), this._velocityVariation *= this._characters._velocityCharDamp; const o = s.velocity.length(), l = o < .001 ? 1 : 1 - Math.abs(L(this, Rt).copy(s.velocity).normalize().dot(s.up)); s.velocityHorizontal = o * l, s.velocityHorizontal > this._rotVelocityMin && (L(this, Rt).copy(s.velocity).applyAxisAngle(s.up, this._rotationPrevPhysics), L(this, os).setFromVector3(L(this, Rt).applyQuaternion(L(this, ls).copy(s.quaternion).invert())), this._rotationNextPhysics = math.lerp(this._rotationNextPhysics, math.getShortestRotationAngle(this._rotationNextPhysics, L(this, os).theta), this._directionLerp * math.fit(s.velocityHorizontal, this._rotVelocityMin, this._rotVelocityMax, 0, 1))); const c = this._detectJump(s); this._updateNearestVerticalPoint(c), this._checkFalling && this._positionNextPhysics.y + this._fallLimitDistance < this._geometry.boundingBox.min.y && this._snap(this._characters._initialPosition.toArray(), this._characters._initialRotation, this._characters._initialUp.toArray()) } this._updatePosition(this._deltaRatioAccumulator), this._updateRotation(this._deltaRatioAccumulator) } _updatePosition(e = 1) { this._characters._localObject.position.lerpVectors(this._positionPrevPhysics, this._positionNextPhysics, e) } _updateRotation(e = 1) { const i = this._characters._localObject, s = math.lerp(this._rotationPrevPhysics, this._rotationNextPhysics, e), a = s - i.rotationHorizontal; i.rotationHorizontal = s, L(this, Rt).set(0, 0, -1).applyQuaternion(i.quaternion), L(this, Rt).applyAxisAngle(i.up, a), L(this, Qt).crossVectors(i.up, L(this, Rt)), $r.ensureRightVector(i.up, L(this, Rt), L(this, Qt)), L(this, hi).crossVectors(L(this, Qt), i.up), L(this, Fn).lookAt(L(this, Hs), L(this, hi), i.up), i.quaternion.setFromRotationMatrix(L(this, Fn)) } _setFloorState(e = !1) { this._isOnFloor = e, this._prevIsOnFloor = e, this._characters._localObject.userData.medium = e ? this._characters.MEDIUMS.GROUND : this._characters.MEDIUMS.AIR, this._needsToLand = !e } _resetPhysics(e = !1) { this._accelerationPhysics.setScalar(0), this._velocityPhysics.setScalar(0), this._velocityVariation = 0, this._characters._localObject.velocity.setScalar(0), this._characters._localObject.velocityHorizontal = 0, this._setFloorState(e) } _snap(e = [0, 0, 0], i = 0, s = [0, 1, 0], a = !1) { this._positionPrevPhysics.fromArray(e), this._positionNextPhysics.fromArray(e), this._updatePosition(0), this._characters._localObject.up.fromArray(s).normalize(), this._rotationPrevPhysics = i, this._rotationNextPhysics = i, this._updateRotation(0), this._resetPhysics(a) } _substep() { const e = 1 / this._substeps; L(this, Rt).copy(this._velocityPhysics).multiplyScalar(e), L(this, Ki).position.add(L(this, Rt)); const i = this._performShapecast(L(this, Ki), e); this._isAutoStepping || this._velocityPhysics.addScaledVector(i, -i.dot(this._velocityPhysics)) } _performShapecast(e, i) { e.updateMatrix(), L(this, jt).copy(this._charactersCapsule.segment), L(this, jt).start.y += this._charactersCapsule.radius, L(this, jt).end.y += this._charactersCapsule.radius, L(this, jt).start.applyMatrix4(e.matrix), L(this, jt).end.applyMatrix4(e.matrix), L(this, Qs).copy(L(this, jt)), L(this, Ji).makeEmpty(), L(this, Ji).expandByPoint(L(this, jt).start), L(this, Ji).expandByPoint(L(this, jt).end), L(this, Ji).min.addScalar(-this._charactersCapsule.radius), L(this, Ji).max.addScalar(this._charactersCapsule.radius), this._geometry.boundsTree.shapecast(this._shapecastFuncs); const s = L(this, Rt); s.subVectors(L(this, jt).start, L(this, Qs).start); const a = Math.max(0, s.length() - 1e-5 * i); return s.normalize(), e.position.addScaledVector(s, a), s } _detectJump(e) { L(this, Rt).copy(this._positionNextPhysics).add(L(this, Qt).copy(e.up).multiplyScalar(.005)), L(this, Qt).copy(e.up).negate(), this._rayCaster.set(L(this, Rt), L(this, Qt)); const i = this._rayCaster.intersectObject(this._collider)[0], a = (i && typeof i.distance == "number" ? i.distance : 1 / 0) > .25, o = this._velocityVariation > .01; if (!this._isOnFloor && !o && (this._isOnFloor = !0), this._prevIsOnFloor !== this._isOnFloor) if (this._prevIsOnFloor) { const l = renderInfo.time; this._prevIsOnFloorTime === -1 ? this._prevIsOnFloorTime = l : l - this._prevIsOnFloorTime > .045 && a && (this._prevIsOnFloor = !1, this._prevIsOnFloorTime = -1, e.userData.medium = this._characters.MEDIUMS.AIR) } else { this._prevIsOnFloor = !0, e.userData.medium = this._characters.MEDIUMS.GROUND; const l = L(this, Ws).setFromNormalAndCoplanarPoint(e.up, this._positionNextPhysics).distanceToPoint(this._lastFloorPosition); (this._needsToLand && l > -.3 || l > .3) && events.emit("character_physics_land"), this._needsToLand = !1 } else this._prevIsOnFloorTime = -1; return this._prevIsOnFloor || (!a && e.userData.medium === this._characters.MEDIUMS.AIR && (e.userData.medium = this._characters.MEDIUMS.GROUND), a && e.userData.medium !== this._characters.MEDIUMS.AIR && (e.userData.medium = this._characters.MEDIUMS.AIR)), this._isOnFloor && (this._jumpRequested && (this._jumpRequested = !1, this._velocityPhysics.add(L(this, Rt).copy(e.up).multiplyScalar(this._jumpForce)), this._needsToLand = !0, events.emit("character_physics_jump")), this._lastFloorPosition.copy(this._positionNextPhysics)), i } _updateNearestVerticalPoint(e) { if (!e) { this._nearestVerticalPoint = -1; return } const i = e.face, s = this._geometry.attributes.position, a = L(this, Rt).fromBufferAttribute(s, i.a).distanceToSquared(e.point), o = L(this, Rt).fromBufferAttribute(s, i.b).distanceToSquared(e.point), l = L(this, Rt).fromBufferAttribute(s, i.c).distanceToSquared(e.point); let c = i.a; o < a && o < l && (c = i.b), l < a && l < o && (c = i.c), this._nearestVerticalPoint = c } }; Hs = new WeakMap, os = new WeakMap, ls = new WeakMap, Fn = new WeakMap, Rt = new WeakMap, Qt = new WeakMap, hi = new WeakMap, Ki = new WeakMap, jt = new WeakMap, Qs = new WeakMap, Ji = new WeakMap, Ws = new WeakMap; let collisionPhysics = $r; function WorkerWrapper(r) { return new Worker("./assets/charactergeoworker-D8pdYVWP.js", { name: r == null ? void 0 : r.name }) } var qs; const Mt = class Mt extends BatchedMesh {
    constructor(i) {
        super(Mt.MAX_CHARS, Mt.MAX_CHARS * Mt.MAX_VERTICES_PER_CHAR, Mt.MAX_CHARS * Mt.MAX_VERTICES_PER_CHAR * Mt.MAX_INDICES_PER_VERTEX, i.material || new ShaderMaterial({
            uniforms: { batchingTexture: { value: null }, batchingIdTexture: { value: null } }, vertexShader: `

                    /* BATCHING */
                    #if ! defined(GL_ANGLE_multi_draw)
                        #define gl_DrawID _gl_DrawID
                        uniform int _gl_DrawID;
                    #endif
                    uniform highp sampler2D batchingTexture;
                    uniform highp usampler2D batchingIdTexture;

                    mat4 getBatchingMatrix(const in int i) {
                        int size = textureSize(batchingTexture, 0).x;
                        int j = i * 4;
                        int x = j % size;
                        int y = j / size;
                        vec4 v1 = texelFetch(batchingTexture, ivec2(x, y), 0);
                        vec4 v2 = texelFetch(batchingTexture, ivec2(x + 1, y), 0);
                        vec4 v3 = texelFetch(batchingTexture, ivec2(x + 2, y), 0);
                        vec4 v4 = texelFetch(batchingTexture, ivec2(x + 3, y), 0);
                        return mat4(v1, v2, v3, v4);
                    }

                    float getIndirectIndex(const in int i) {
                        int size = textureSize(batchingIdTexture, 0).x;
                        int x = i % size;
                        int y = i / size;
                        return float(texelFetch(batchingIdTexture, ivec2(x, y), 0).r);
                    }

                    /* SKINNING */
                    attribute vec4 skinIndex;
                    attribute vec4 skinWeight;
                    uniform sampler2D boneTexture;
                    mat4 bindMatrix = mat4(1.0);
                    mat4 bindMatrixInverse = mat4(1.0);
                    mat4 getBoneMatrix(const in float i, const in float id) {
                        int x = int(i) * 4;
                        int y = int(id);
                        vec4 v1 = texelFetch(boneTexture, ivec2(x, y), 0);
                        vec4 v2 = texelFetch(boneTexture, ivec2(x + 1, y), 0);
                        vec4 v3 = texelFetch(boneTexture, ivec2(x + 2, y), 0);
                        vec4 v4 = texelFetch(boneTexture, ivec2(x + 3, y), 0);
                        return mat4(v1, v2, v3, v4);
                    }

                    varying vec2 vUv;

                    void main() {
                        vUv = uv;

                        float batchID = getIndirectIndex(gl_DrawID);
                        mat4 batchingMatrix = getBatchingMatrix(batchID);
                        mat4 boneMatX = getBoneMatrix(skinIndex.x, batchID);
                        mat4 boneMatY = getBoneMatrix(skinIndex.y, batchID);
                        mat4 boneMatZ = getBoneMatrix(skinIndex.z, batchID);
                        mat4 boneMatW = getBoneMatrix(skinIndex.w, batchID);

                        mat4 skinMatrix = mat4(0.0);
                        skinMatrix += skinWeight.x * boneMatX;
                        skinMatrix += skinWeight.y * boneMatY;
                        skinMatrix += skinWeight.z * boneMatZ;
                        skinMatrix += skinWeight.w * boneMatW;

                        // normal
                        vec3 objectNormal = vec4(skinMatrix * vec4(normal, 0.0)).xyz;
                        mat3 bm = mat3(batchingMatrix);
                        vec3 transformedNormal = objectNormal;
                        transformedNormal /= vec3(dot(bm[0], bm[0]), dot(bm[1], bm[1]), dot(bm[2], bm[2]));
                        transformedNormal = bm * transformedNormal;
                        transformedNormal = normalMatrix * transformedNormal;
                        vNormal = normalize(transformedNormal);

                        // position
                        vec4 skinVertex = vec4(position, 1.0);
                        vec4 skinned = vec4(0.0);
                        skinned += boneMatX * skinVertex * skinWeight.x;
                        skinned += boneMatY * skinVertex * skinWeight.y;
                        skinned += boneMatZ * skinVertex * skinWeight.z;
                        skinned += boneMatW * skinVertex * skinWeight.w;
                        vec4 mvPosition = vec4(skinned.xyz, 1.0);
                        mvPosition = batchingMatrix * mvPosition;

                        mvPosition = modelViewMatrix * mvPosition;
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `, fragmentShader: `
                    varying vec2 vUv;

                    void main() {
                        gl_FragColor = vec4(vUv, 0.0, 1.0);
                    }
                `})); pe(this, qs, new Matrix4); this._matricesTexture.needsUpdate = !0, this._indirectTexture.needsUpdate = !0, this.material.uniforms.batchingTexture && (this.material.uniforms.batchingTexture.value = this._matricesTexture), this.material.uniforms.batchingIdTexture && (this.material.uniforms.batchingIdTexture.value = this._indirectTexture), i.customDepthMaterial && (this.customDepthMaterial = i.customDepthMaterial), i.customDistanceMaterial && (this.customDistanceMaterial = i.customDistanceMaterial), this.frustumCulled = !1, this.matrixWorldAutoUpdate = !0, this.perObjectFrustumCulled = !1, this.sortObjects = !1, this.onBeforeShadow = () => { }, this.onBeforeRender = () => { }, this._animationOptions = i.animationOptions || [], this._animationsWhileInAir = i.animationsWhileInAir || !1, this._inactiveAnimations = Array.isArray(i.inactiveAnimations) ? i.inactiveAnimations : [i.inactiveAnimations || 4], this._skipBoundingVolumeModels = i.skipBoundingVolumeModels || [], this._inactiveAnimation = this._inactiveAnimations[0], this.boundingBox = new Box3, this.boundingSphere = new Sphere, this.receiveShadow = i.skinShadows !== !1, this.castShadow = this.receiveShadow; const s = math.ceilPowerOfTwo(Mt.MAX_BONES * 4), a = math.ceilPowerOfTwo(Mt.MAX_CHARS), o = new Float32Array(s * a * 4); this._boneTexture = new DataTexture(o, s, a, RGBAFormat, FloatType), this._boneTexture.needsUpdate = !0, this._geoWorker = new WorkerWrapper, this._geoWorker.id = 0, this._geoWorker.onmessage = this._receiveMergedGeo.bind(this), this._geoWorker.storage = {}, this._localModelReady = new Promise(l => { this._isLocalModelReady = l }), this._buffersToUpload = []
    } static ensureAvatarUrl(i) { let s = i.replace(".", ""); return s.indexOf("avatar") !== 0 && (s = `avatar/${s}`), s } static secureLerp(i) { return i > .9999 ? 1 : i < 1e-4 ? 0 : i } get MAX_CHARS() { return Mt.MAX_CHARS } async _initBatchedMeshes() { const { skin: i } = await this._loadModels(this._localObject); if (!i) throw new Error("Initial character geometry could not be loaded/created."); const s = new BufferGeometry; for (const o in i.geometry.attributes) { const l = i.geometry.getAttribute(o), { array: c, itemSize: h, normalized: d } = l, p = new c.constructor(Mt.MAX_VERTICES_PER_CHAR * h), f = new l.constructor(p, h, d); f.setUsage(DynamicDrawUsage), s.setAttribute(o, f) } const a = this._maxVertexCount >= 65535 ? Uint32Array : Uint16Array; s.setIndex(new BufferAttribute(new a(Mt.MAX_VERTICES_PER_CHAR * Mt.MAX_INDICES_PER_VERTEX), 1).setUsage(DynamicDrawUsage)), s.boundingBox = new Box3, s.boundingSphere = new Sphere, this._initializeGeometry(s); for (const o in this.geometry.attributes) this.geometry.attributes[o].setUsage(DynamicDrawUsage), this.geometry.attributes[o].needsUpdate = !0; this.geometry.getIndex().setUsage(DynamicDrawUsage), this.geometry.getIndex().needsUpdate = !0; for (let o = 0; o < this.maxInstanceCount; o++) { const l = this.addGeometry(s), c = this.addInstance(l); this._instanceInfo[c].active = !1, this._instanceInfo[c].visible = !1 } await this._loadBatchedGeometries(this._localObject), this._isLocalModelReady() } async _loadModels(i) { const s = i.userData; if (!s.modelFiles || !s.bonesFile || !s.animationFiles) throw new Error("Character geometry data is missing."); let a = null, o = null, l = null; if ([a, o, l] = await Promise.all([Promise.all(s.modelFiles.map(p => geometryLoader.load(`${Mt.ensureAvatarUrl(p)}.drc`, !0))), geometryLoader.load(`${Mt.ensureAvatarUrl(s.bonesFile)}.drc`, !0), Promise.all(s.animationFiles.map(p => geometryLoader.skinAnimation(`${Mt.ensureAvatarUrl(p)}.drc`, !0)))]), a.some(p => p.type === "BoxGeometry") || o.type === "BoxGeometry") return !1; const c = []; s.modelFiles.forEach((p, f) => { for (let _ = 0; _ < this._skipBoundingVolumeModels.length; _++)if (p.match(this._skipBoundingVolumeModels[_])) { c.push(f); break } }); const h = this._geoWorker.id++; this._geoWorker.storage[h] = {}, this._geoWorker.storage[h].promise = new Promise(p => { this._geoWorker.storage[h].resolve = p }), this._geoWorker.postMessage({ id: h, models: a.map(p => { const f = {}; for (const _ in p.attributes) f[_] = { array: p.attributes[_].array, itemSize: p.attributes[_].itemSize }; return f.index = { array: p.getIndex().array, itemSize: 1 }, f }), skipFromBounds: c }); const d = await this._geoWorker.storage[h].promise; return delete this._geoWorker.storage[h], { skin: createSkin(d, o), animations: l } } _receiveMergedGeo(i) { const { id: s, arrays: a, volumes: o } = i.data, l = new BufferGeometry; for (const c in a) c === "index" ? l.setIndex(new BufferAttribute(a[c].array, a[c].itemSize)) : l.setAttribute(c, new BufferAttribute(a[c].array, a[c].itemSize)); l.boundingBox = new Box3, l.boundingBox.min.fromArray(o.box.min), l.boundingBox.max.fromArray(o.box.max), l.boundingSphere = new Sphere, l.boundingSphere.center.fromArray(o.sphere.center), l.boundingSphere.radius = o.sphere.radius * 2, this._geoWorker.storage[s].resolve(l) } async _loadBatchedGeometries(i) { const s = this.getModelsID(i), a = !!i.__loadingModels; if (i.__loadingModels = s, a || i.isBeingRemoved) return; i.modelsID = s; const o = i === this._localObject; o || createTween(i.scale, { to: { x: 0, y: 0, z: 0 }, ease: "power2.out", duration: .15 }); const { skin: l, animations: c } = await this._loadModels(i); if (l && c && !i.isBeingRemoved) { const d = l.geometry; o && this._collisionPhysics._updateCapsule(d.boundingBox), this.setGeometryAt(i.batchedIndex, d); const p = [i, []]; for (const f in this.geometry.attributes) { if (!d.attributes[f]) continue; const _ = this.geometry.attributes[f].itemSize; p[1].push([f, this._geometryInfo[i.batchedIndex].vertexStart * _, d.attributes[f].count * _]) } p[1].push(["index", this._geometryInfo[i.batchedIndex].indexStart, d.getIndex().count]); for (let f = this._buffersToUpload.length - 1; f >= 0; f--)this._buffersToUpload[f][0].batchedIndex === i.batchedIndex && this._buffersToUpload.splice(f, 1); o ? this._buffersToUpload.unshift(p) : this._buffersToUpload.push(p), i.animationProps.weights = new Array(i.animationProps.weights.length).fill(0).map((f, _) => i.animationProps.weights[_] || 0), i.animationProps.mixer = new AnimationMixer(l), i.animationProps.actions = c.map((f, _) => { var b; const x = i.animationProps.mixer.clipAction(f.clone()); return x.setEffectiveTimeScale(((b = this._animationOptions[_]) == null ? void 0 : b.speed) || 1), x.play(), x.enabled = !1, x }) } const h = i.__loadingModels; if (delete i.__loadingModels, i.modelsID !== h) return this._loadBatchedGeometries(i) } _uploadBuffersPerFrame() { if (this._buffersToUpload.length === 0) return; const i = this._buffersToUpload[0], s = i[0], a = s === this._localObject, o = i[1], l = o[0], h = l[0] === "index" ? this.geometry.getIndex() : this.geometry.getAttribute(l[0]), d = a ? 1 / 0 : 512, p = Math.min(l[2], d); if (h.addUpdateRange(l[1], p), h.needsUpdate = !0, l[2] -= p, l[2] <= 0) if (o.shift(), o.length === 0) { const f = this._buffersToUpload.indexOf(i); f !== -1 && this._buffersToUpload.splice(f, 1), !a && !s.isBeingRemoved && createTween(s.scale, { to: { x: 1, y: 1, z: 1 }, ease: "power2.out", duration: .35 }) } else a && this._uploadBuffersPerFrame(); else l[1] += p } _updateAnimations(i, s = 1, a = 1) { const o = i.animationProps.weights, l = math.efit(i.velocityHorizontal, .001, .075, 0, 1); o[0] = Mt.secureLerp(math.lerp(o[0], math.fit(l, 0, 1, 1, 0), s)), o[2] = Mt.secureLerp(math.lerp(o[2], math.fit(l, 1.8, 2.1, 0, 1), a)), o[1] = 1 - o[2]; const c = 1 - o[0]; o[1] *= c, o[2] *= c; const h = i.userData.medium === this.MEDIUMS.AIR; o[3] = Mt.secureLerp(math.lerp(o[3], h ? 1 : 0, s)); const d = this._animationsWhileInAir ? !0 : !h; for (let x = 4; x < o.length; x++) { const b = d && i.userData.animation === x; o[x] = Mt.secureLerp(math.lerp(o[x], b ? 1 : 0, a)) } if (!i._inFrustumOfLocalCharacter || i._distanceToLocalCharacter > Mt.UPDATE_DISTANCE) return; const p = math.fit(i._distanceToLocalCharacter, Mt.UPDATE_DISTANCE * .1, Mt.UPDATE_DISTANCE, 0, Mt.UPDATE_DISTANCE_MULT); if (renderInfo.time - i.animationProps.lastUpdate < p || (i.animationProps.lastUpdate = renderInfo.time, !i.animationProps.mixer)) return; i.animationProps.actions.forEach((x, b) => { let T = 0; for (let D = o.length - 1; D > Math.max(2, b); D--)T += o[D]; const M = 1 - math.clamp(T, 0, 1), w = o[b] * M; x.enabled = w > 0, x.setEffectiveWeight(w) }), i.animationProps.mixer.setTime(renderInfo.time + i.animationProps.offset); const f = i.animationProps.mixer._root; f.children.forEach(x => x.updateMatrixWorld()); const _ = i.batchedIndex * this._boneTexture.image.width * 4; for (let x = 0; x < f.skeleton.bones.length; x++)L(this, qs).multiplyMatrices(f.skeleton.bones[x].matrixWorld, f.skeleton.boneInverses[x]), L(this, qs).toArray(this._boneTexture.image.data, _ + x * 16) } _updateMultiDrawAndTextures() { const i = this.geometry.getIndex().array.BYTES_PER_ELEMENT; let s = 0; for (let a = 0; a < this._instanceInfo.length; a++)if (this._instanceInfo[a].visible && this._instanceInfo[a].active) { const o = this._instanceInfo[a].geometryIndex, l = this._geometryInfo[o]; this._multiDrawStarts[s] = l.start * i, this._multiDrawCounts[s] = l.count, this._indirectTexture.image.data[s] = a, s++ } this._multiDrawCount = s, this._indirectTexture.needsUpdate = !0, this._matricesTexture.needsUpdate = !0, this._boneTexture.needsUpdate = !0 } setGeometryAt(i, s) { const a = s.getIndex(), o = this._geometryInfo[i]; if (a.count > o.reservedIndexCount || s.attributes.position.count > o.reservedVertexCount) throw new Error("BatchedMesh: Reserved space not large enough for provided geometry."); const l = o.vertexStart; o.vertexCount = s.getAttribute("position").count; for (const d in this.geometry.attributes) { const p = s.getAttribute(d), f = this.geometry.getAttribute(d); f.array.set(p.array, l * f.itemSize) } const c = this.geometry.getIndex(), h = o.indexStart; o.indexCount = s.getIndex().count; for (let d = 0; d < a.count; d++)c.setX(h + d, l + a.getX(d)); return o.start = o.indexStart, o.count = o.indexCount, o.boundingBox === null && (o.boundingBox = new Box3), o.boundingSphere === null && (o.boundingSphere = new Sphere), o.boundingBox.copy(s.boundingBox), o.boundingSphere.copy(s.boundingSphere), i } dispose() { super.dispose(), this._geoWorker.terminate(), this._boneTexture.dispose(), this._boneTexture = null }
}; qs = new WeakMap, Ke(Mt, "MAX_CHARS", 15), Ke(Mt, "MAX_VERTICES_PER_CHAR", 5 * 1e3), Ke(Mt, "MAX_INDICES_PER_VERTEX", 5), Ke(Mt, "MAX_BONES", 32), Ke(Mt, "UPDATE_DISTANCE", 75), Ke(Mt, "UPDATE_DISTANCE_MULT", .3); let characterBatchedSkinnedMesh = Mt; var blendmodes_default = `float blendAdd(in float base, in float blend) {
    return min(base + blend, 1.);
}

vec3 blendAdd(in vec3 base, in vec3 blend) {
    return min(base + blend, vec3(1.));
}

vec3 blendAdd(in vec3 base, in vec3 blend, float opacity) {
    return (blendAdd(base, blend) * opacity + base * (1. - opacity));
}

float blendAverage(in float base, in float blend) {
    return (base + blend) * .5;
}

vec3 blendAverage(in vec3 base, in vec3 blend) {
    return (base + blend) * .5;
}

vec3 blendAverage(in vec3 base, in vec3 blend, float opacity) {
    return (blendAverage(base, blend) * opacity + base * (1. - opacity));
}

float blendColorBurn(in float base, in float blend) {
    return (blend == 0.)? blend: max((1. - ((1. - base ) / blend)), 0.);
}

vec3 blendColorBurn(in vec3 base, in vec3 blend) {
    return vec3(blendColorBurn(base.r, blend.r),
                blendColorBurn(base.g, blend.g),
                blendColorBurn(base.b, blend.b));
}

vec3 blendColorBurn(in vec3 base, in vec3 blend, in float opacity) {
    return (blendColorBurn(base, blend) * opacity + base * (1. - opacity));
}

float blendColorDodge(in float base, in float blend) {
    return (blend == 1.)? blend: min( base / (1. - blend), 1.);
}

vec3 blendColorDodge(in vec3 base, in vec3 blend) {
    return vec3(blendColorDodge(base.r, blend.r),
                blendColorDodge(base.g, blend.g),
                blendColorDodge(base.b, blend.b));
}

vec3 blendColorDodge(in vec3 base, in vec3 blend, in float opacity) {
    return (blendColorDodge(base, blend) * opacity + base * (1. - opacity));
}

float blendDarken(in float base, in float blend) {
    return min(blend,base);
}

vec3 blendDarken(in vec3 base, in vec3 blend) {
    return vec3(blendDarken(base.r, blend.r),
                blendDarken(base.g, blend.g),
                blendDarken(base.b, blend.b));
}

vec3 blendDarken(in vec3 base, in vec3 blend, in float opacity) {
    return (blendDarken(base, blend) * opacity + base * (1. - opacity));
}

float blendDifference(in float base, in float blend) {
    return abs(base-blend);
}

vec3 blendDifference(in vec3 base, in vec3 blend) {
    return abs(base-blend);
}

vec3 blendDifference(in vec3 base, in vec3 blend, in float opacity) {
    return (blendDifference(base, blend) * opacity + base * (1. - opacity));
}

float blendExclusion(in float base, in float blend) {
    return base + blend - 2. * base * blend;
}

vec3 blendExclusion(in vec3 base, in vec3 blend) {
    return base + blend - 2. * base * blend;
}

vec3 blendExclusion(in vec3 base, in vec3 blend, in float opacity) {
    return (blendExclusion(base, blend) * opacity + base * (1. - opacity));
}

float blendVividLight(in float base, in float blend) {
    return (blend < .5)? blendColorBurn(base, (2.*blend)): blendColorDodge(base, (2. * (blend - .5)));
}

vec3 blendVividLight(in vec3 base, in vec3 blend) {
    return vec3(blendVividLight(base.r, blend.r),
                            blendVividLight(base.g, blend.g),
                            blendVividLight(base.b, blend.b));
}

vec3 blendVividLight(in vec3 base, in vec3 blend, in float opacity) {
    return (blendVividLight(base, blend) * opacity + base * (1. - opacity));
}

float blendHardMix(in float base, in float blend) {
    return (blendVividLight(base, blend) < .5)? 0.: 1.;
}

vec3 blendHardMix(in vec3 base, in vec3 blend) {
    return vec3(blendHardMix(base.r, blend.r),
                blendHardMix(base.g, blend.g),
                blendHardMix(base.b, blend.b));
}

vec3 blendHardMix(in vec3 base, in vec3 blend, in float opacity) {
    return (blendHardMix(base, blend) * opacity + base * (1. - opacity));
}

float blendLighten(in float base, in float blend) {
    return max(blend, base);
}

vec3 blendLighten(in vec3 base, in vec3 blend) {
    return vec3(blendLighten(base.r, blend.r),
                blendLighten(base.g, blend.g),
                blendLighten(base.b, blend.b));
}

vec3 blendLighten(in vec3 base, in vec3 blend, in float opacity) {
    return (blendLighten(base, blend) * opacity + base * (1. - opacity));
}

float blendLinearBurn(in float base, in float blend) {
  
    return max(base + blend - 1., 0.);
}

vec3 blendLinearBurn(in vec3 base, in vec3 blend) {
  
    return max(base + blend - vec3(1.), vec3(0.));
}

vec3 blendLinearBurn(in vec3 base, in vec3 blend, in float opacity) {
    return (blendLinearBurn(base, blend) * opacity + base * (1. - opacity));
}

float blendLinearDodge(in float base, in float blend) {
  
    return min(base + blend, 1.);
}

vec3 blendLinearDodge(in vec3 base, in vec3 blend) {
  
    return min(base + blend, vec3(1.));
}

vec3 blendLinearDodge(in vec3 base, in vec3 blend, in float opacity) {
    return (blendLinearDodge(base, blend) * opacity + base * (1. - opacity));
}

float blendLinearLight(in float base, in float blend) {
  return blend < .5? blendLinearBurn(base, (2. * blend)): blendLinearDodge(base, (2. * (blend- .5)));
}

vec3 blendLinearLight(in vec3 base, in vec3 blend) {
  return vec3(blendLinearLight(base.r, blend.r),
              blendLinearLight(base.g, blend.g),
              blendLinearLight(base.b, blend.b));
}

vec3 blendLinearLight(in vec3 base, in vec3 blend, in float opacity) {
    return (blendLinearLight(base, blend) * opacity + base * (1. - opacity));
}

float blendMultiply(in float base, in float blend) {
    return base * blend;
}

vec3 blendMultiply(in vec3 base, in vec3 blend) {
    return base * blend;
}

vec3 blendMultiply(in vec3 base, in vec3 blend, float opacity) {
    return (blendMultiply(base, blend) * opacity + base * (1. - opacity));
}

float blendNegation(in float base, in float blend) {
    return 1. - abs(1. - base - blend);
}

vec3 blendNegation(in vec3 base, in vec3 blend) {
    return vec3(1.) - abs(vec3(1.) - base - blend);
}

vec3 blendNegation(in vec3 base, in vec3 blend, in float opacity) {
    return (blendNegation(base, blend) * opacity + base * (1. - opacity));
}

float blendOverlay(in float base, in float blend) {
    return (base < .5)? (2.*base*blend): (1. - 2. * (1. - base) * (1. - blend));
}

vec3 blendOverlay(in vec3 base, in vec3 blend) {
    return vec3(blendOverlay(base.r, blend.r),
                blendOverlay(base.g, blend.g),
                blendOverlay(base.b, blend.b));
}

vec3 blendOverlay(in vec3 base, in vec3 blend, in float opacity) {
    return (blendOverlay(base, blend) * opacity + base * (1. - opacity));
}

float blendHardLight(in float base, in float blend) {
    return blendOverlay(blend, base);
}

vec3 blendHardLight(in vec3 base, in vec3 blend) {
    return blendOverlay(blend, base);
}

vec3 blendHardLight(in vec3 base, in vec3 blend, in float opacity) {
    return (blendHardLight(base, blend) * opacity + base * (1. - opacity));
}

float blendPhoenix(in float base, in float blend) {
    return min(base, blend) - max(base, blend) + 1.;
}

vec3 blendPhoenix(in vec3 base, in vec3 blend) {
    return min(base, blend) - max(base, blend) + vec3(1.);
}

vec3 blendPhoenix(in vec3 base, in vec3 blend, in float opacity) {
    return (blendPhoenix(base, blend) * opacity + base * (1. - opacity));
}

float blendPinLight(in float base, in float blend) {
    return (blend < .5)? blendDarken(base, (2.*blend)): blendLighten(base, (2. * (blend - .5)));
}

vec3 blendPinLight(in vec3 base, in vec3 blend) {
    return vec3(blendPinLight(base.r, blend.r),
                blendPinLight(base.g, blend.g),
                blendPinLight(base.b, blend.b));
}

vec3 blendPinLight(in vec3 base, in vec3 blend, in float opacity) {
    return (blendPinLight(base, blend) * opacity + base * (1. - opacity));
}

float blendReflect(in float base, in float blend) {
    return (blend == 1.)? blend : min(base * base / (1. - blend), 1.);
}

vec3 blendReflect(in vec3 base, in vec3 blend) {
    return vec3(blendReflect(base.r, blend.r),
                blendReflect(base.g, blend.g),
                blendReflect(base.b, blend.b));
}

vec3 blendReflect(in vec3 base, in vec3 blend, in float opacity) {
    return (blendReflect(base, blend) * opacity + base * (1. - opacity));
}

float blendGlow(in float base, in float blend) {
    return blendReflect(blend, base);
}

vec3 blendGlow(in vec3 base, in vec3 blend) {
    return blendReflect(blend, base);
}

vec3 blendGlow(in vec3 base, in vec3 blend, in float opacity) {
    return (blendGlow(base, blend) * opacity + base * (1. - opacity));
}

float blendScreen(in float base, in float blend) {
    return 1. - ((1. - base) * (1. - blend));
}

vec3 blendScreen(in vec3 base, in vec3 blend) {
    return vec3(blendScreen(base.r, blend.r),
                blendScreen(base.g, blend.g),
                blendScreen(base.b, blend.b));
}

vec3 blendScreen(in vec3 base, in vec3 blend, float opacity) {
    return (blendScreen(base, blend) * opacity + base * (1. - opacity));
}

float blendSoftLight(in float base, in float blend) {
    return (blend < .5)? (2. * base * blend + base * base * (1. - 2.*blend)): (sqrt(base) * (2. * blend - 1.) + 2. * base * (1. - blend));
}

vec3 blendSoftLight(in vec3 base, in vec3 blend) {
    return vec3(blendSoftLight(base.r, blend.r),
                blendSoftLight(base.g, blend.g),
                blendSoftLight(base.b, blend.b));
}

vec4 blendSoftLight(in vec4 base, in vec4 blend) {
    return vec4(blendSoftLight( base.r, blend.r ),
                blendSoftLight( base.g, blend.g ),
                blendSoftLight( base.b, blend.b ),
                blendSoftLight( base.a, blend.a )
    );
}

vec3 blendSoftLight(in vec3 base, in vec3 blend, in float opacity) {
    return (blendSoftLight(base, blend) * opacity + base * (1. - opacity));
}

float blendSubtract(in float base, in float blend) {
    return max(base + blend - 1., 0.);
}

vec3 blendSubtract(in vec3 base, in vec3 blend) {
    return max(base + blend - vec3(1.), vec3(0.));
}

vec3 blendSubtract(in vec3 base, in vec3 blend, in float opacity) {
    return (blendSubtract(base, blend) * opacity + base * (1. - opacity));
}`; class controlsCirlces extends Group {
    constructor(e) { super(), this.name = "PlayerControls UI", this.visible = !0, this.frustumCulled = !1, this.matrixWorldAutoUpdate = !1, this._controls = e, this._touchPosition = new Vector2, this._touchActive = 0, this._touchScale = 1, this._jumpAnimVar = { value: 0 }, this._createMoveCircle(), this._createJumpCircle() } _createMoveCircle() {
        const e = new ShaderMaterial({
            uniformsGroups: [global$1.UBO], uniforms: { tCircles: { value: textureLoader.load("controls/circles.avif") }, uInnerPos: { value: new Vector2 }, uScale: { value: 1 }, uAlpha: { value: 1 }, uSize: { value: 430 } }, vertexShader: `
                ${globalUBO_default}

                uniform float uScale;
                uniform float uSize;
                varying vec2 vUv;

                void main() {
                    vUv = uv;

                    vec3 pos = position;
                    pos.x /= aspect;
                    pos /= resolutionUI.y / (uSize * uScale);

                    gl_Position = modelMatrix * vec4(pos, 1.0);
                }
            `, fragmentShader: `
                ${blendmodes_default}

                uniform sampler2D tCircles;
                uniform vec2 uInnerPos;
                uniform float uAlpha;

                varying vec2 vUv;

                void main() {
                    vec2 bg = texture2D(tCircles, vUv).rg;
                    vec4 color = vec4(vec3(mix(vec3(0.0), vec3(1.0), bg.x)), bg.y);

                    float inner = texture2D(tCircles, vUv + uInnerPos).b;
                    color.rgb = blendScreen(color.rgb, vec3(mix(vec3(0.0), vec3(1.0), inner)));
                    color.a = max(color.a, inner * 0.6);

                    gl_FragColor = color;
                    gl_FragColor.a *= uAlpha;
                }
            `, transparent: !0, depthWrite: !1, depthTest: !1
        }); this._moveCircle = new Mesh(utils.plane, e), this._moveCircle.isCharacterControls = !0, this._moveCircle.name = "Move Circle", this._moveCircle.frustumCulled = !1, this._moveCircle.renderOrder = 99999, this._moveCircle.castShadow = !1, this._moveCircle.receiveShadow = !1, this._moveCircle.visible = !1, this.add(this._moveCircle)
    } _createJumpCircle() {
        const e = new ShaderMaterial({
            uniformsGroups: [global$1.UBO], uniforms: { uScale: { value: 1 }, uAlpha: { value: 1 } }, vertexShader: `
                ${globalUBO_default}

                uniform float uScale;
                varying vec2 vUv;

                void main() {
                    vUv = uv;

                    vec3 pos = position;
                    pos.x /= aspect;
                    pos /= resolutionUI.y / (300.0 * uScale);

                    gl_Position = modelMatrix * vec4(pos, 1.0);
                }
            `, fragmentShader: `
                uniform float uAlpha;
                varying vec2 vUv;

                void main() {
                    float dist = length(vUv - 0.5);
                    float margin = fwidth(vUv.x);
                    float d = smoothstep(0.4 + margin, 0.4, dist);

                    gl_FragColor.rgb = vec3(1.0);
                    gl_FragColor.a = 0.15 * d * uAlpha;
                }
            `, transparent: !0, depthWrite: !1, depthTest: !1
        }); this._jumpCircle = new Mesh(utils.plane, e), this._jumpCircle.isCharacterControls = !0, this._jumpCircle.name = "Jump Circle", this._jumpCircle.frustumCulled = !1, this._jumpCircle.renderOrder = 99999, this._jumpCircle.castShadow = !1, this._jumpCircle.receiveShadow = !1, this._jumpCircle.visible = !1, this.add(this._jumpCircle)
    } _update() { this._controls._characters._controlMode === "automatic" ? (this._touchActive = math.lerpFPS(this._touchActive, this._controls._touchMovingFinger === -1 ? 0 : 1, .25), this._touchScale = math.lerpFPS(this._touchScale, math.fit(this._touchActive, 0, 1, .75, 1), .25), this._moveCircle.position.copy(this._controls._automaticMovingCirclePosition11())) : (this._touchActive = math.lerpFPS(this._touchActive, this._controls._canTouch ? 1 : 0, .25), this._touchScale = math.lerpFPS(this._touchScale, math.fit(this._touchActive, 0, 1, 0, this._controls._controlTouchManualMultiplier), .25), this._moveCircle.position.copy(this._controls._manualMovingCirclePosition11())), this._touchActive < .001 ? this._touchActive = 0 : this._touchActive > .999 && (this._touchActive = 1), this._touchPosition.lerp(this._controls._touchMovingDelta, math.lerpCoefFPS(.2)), this._moveCircle.material.uniforms.uInnerPos.value.copy(this._touchPosition).multiplyScalar(.35), this._moveCircle.material.uniforms.uInnerPos.value.y *= -1, this._moveCircle.visible = this._touchActive !== 0, this._moveCircle.material.uniforms.uScale.value = this._touchScale, this._moveCircle.material.uniforms.uAlpha.value = ease("power3.out", this._touchActive), this._jumpCircle.visible = this._jumpAnimVar.value > 0, this._jumpCircle.material.uniforms.uScale.value = 1 - this._jumpAnimVar.value, this._jumpCircle.material.uniforms.uAlpha.value = ease("power3.out", this._jumpAnimVar.value) } _animateJump(e) { this._jumpCircle.position.x = e.position11.x, this._jumpCircle.position.y = e.position11.y, createTween(this._jumpAnimVar, { from: { value: 1 }, to: { value: 0 }, ease: "power2.out", duration: .5, overwrite: !0 }) }
} var cs, $t, Xr, $s; class charactersControls { constructor(e, i) { pe(this, cs, new Vector3); pe(this, $t, new Vector3); pe(this, Xr, new Vector2); pe(this, $s, new Vector2); this._characters = e, this._moveKeysPressed = [!1, !1, !1, !1], this._sprintEnabled = i.sprintEnabled || !1, this._sprintSpeed = typeof i.sprintSpeed == "number" ? i.sprintSpeed : 1.5, this._sprintPreventsJump = i.sprintPreventsJump || !1, this.__sprintPressed = !1, this._jumpRequestTimeout = null, this._jumpKeyLocked = !1, this._gamepadRequestJump = !1, this._gamepadMovingCamera = !1, this._isLeftMousePressed = !1, this._canTouch = client$1.capabilities.touch, this._touchMovingFinger = -1, this._touchCameraFinger = -1, this._touchMovingStart = new Vector2, this._touchMovingDelta = new Vector2, this._mouseToggleCb = i.mouseToggleCb || !1, this._mouseRightButtonTime = 0, this._controlTouchAmount = typeof i.controlTouchAmount == "number" ? i.controlTouchAmount : 75, this._controlTouchMarginLeft = typeof i.controlTouchMarginLeft == "number" ? i.controlTouchMarginLeft : 20, this._controlTouchMarginBottom = typeof i.controlTouchMarginBottom == "number" ? i.controlTouchMarginBottom : 25, this._controlTouchManualMultiplier = typeof i.controlTouchManualMultiplier == "number" ? i.controlTouchManualMultiplier : .75, this._controlMouseAmount = typeof i.controlMouseAmount == "number" ? i.controlMouseAmount : 200, this._circles = new controlsCirlces(this), this._boundMouseRightDown = this._mouseRightDown.bind(this), this._boundMouseRightUp = this._mouseRightUp.bind(this), this._enabled = !1 } get _sprintPressed() { return this.__sprintPressed } set _sprintPressed(e) { e !== this.__sprintPressed && (this.__sprintPressed = e, events.emit("character_controls_shift_pressed", e)) } _automaticMovingCirclePosition11() { return { x: this._touchMovingStart.x / client$1.screen.width * 2 - 1, y: this._touchMovingStart.y / client$1.screen.height * -2 + 1, z: 0 } } _manualMovingCirclePosition() { return { x: this._controlTouchAmount + this._controlTouchMarginLeft, y: client$1.screen.height - this._controlTouchAmount - this._controlTouchMarginBottom, z: 0 } } _manualMovingCirclePosition11() { return { x: (this._controlTouchAmount + this._controlTouchMarginLeft) / client$1.screen.width * 2 - 1, y: (this._controlTouchAmount + this._controlTouchMarginBottom) / client$1.screen.height * 2 - 1, z: 0 } } _onActiveChange() { (!client$1.visible || !client$1.focused) && this._endInteraction() } _onKey(e) { const i = e.type === "keydown", s = this._sprintEnabled && this._sprintPreventsJump && this._sprintPressed; switch (e.code) { case "KeyW": case "ArrowUp": this._moveKeysPressed[0] = i; break; case "KeyS": case "ArrowDown": this._moveKeysPressed[1] = i; break; case "KeyA": case "ArrowLeft": this._moveKeysPressed[2] = i; break; case "KeyD": case "ArrowRight": this._moveKeysPressed[3] = i; break; case "Space": s || this._requestJump(i); break; case "ShiftLeft": case "ShiftRight": this._sprintEnabled && (this._sprintPressed = i); break } } _requestJump(e = !1) { e ? this._jumpKeyLocked || (this._jumpKeyLocked = !0, this._characters._collisionPhysics._jumpRequested = !0, clearTimeout(this._jumpRequestTimeout), this._jumpRequestTimeout = setTimeout(() => { this._characters._collisionPhysics._jumpRequested = !1 }, 75)) : this._jumpKeyLocked = !1 } _onTouchStart(e) { if (e.input === "mouse") !this._isLeftMousePressed && e.button === 0 && (this._isLeftMousePressed = !0, this._mouseToggleCb && this._mouseToggleCb(!0), this._onTouchDrag(e)); else if (this._characters._controlMode === "automatic") this._touchMovingFinger === -1 && e.finger === 0 && (this._touchMovingFinger = e.finger, this._touchMovingStart.copy(e.position), this._onTouchDrag(e)); else { const i = this._controlTouchAmount * this._controlTouchManualMultiplier; L(this, Xr).copy(e.position).distanceTo(L(this, $s).copy(this._manualMovingCirclePosition())) < i && this._touchMovingFinger === -1 ? (this._touchMovingFinger = e.finger, this._touchMovingStart.copy(L(this, $s)), this._onTouchDrag(e)) : this._touchCameraFinger === -1 && (this._touchCameraFinger = e.finger, this._onTouchDrag(e)) } } _rotateCharactersCamera(e = 0, i = 0) { this._characters._camera.isFollowCamera && (this._characters._camera._sphericalTarget.phi += i * (this._characters._camera._sphericalVerticalMaxLimit - this._characters._camera._sphericalVerticalMinLimit), this._characters._camera._sphericalTarget.theta -= e * math.TWO_PI) } _onTouchDrag(e) { if (e.input === "mouse") { if (this._isLeftMousePressed) if (this._characters._controlMode === "automatic") { L(this, cs).copy(this._characters._localObject.position), this._characters._collisionPhysics && L(this, cs).addScaledVector(this._characters._localObject.up, this._characters._collisionPhysics._charactersCapsule.segment.end.y * .5); const i = utils.planeInteraction.setCamera(this._characters._camera).getPointPositionOnScreen(L(this, cs)); this._touchMovingDelta.set(i.x, i.y).sub(e.position), this._touchMovingDelta.divideScalar(this._controlMouseAmount).clampLength(-1, 1) } else this._rotateCharactersCamera(e.delta11.x, e.delta11.y) } else if (e.finger === this._touchMovingFinger) { const i = this._characters._controlMode === "automatic" ? 1 : this._controlTouchManualMultiplier; this._touchMovingDelta.copy(this._touchMovingStart).sub(e.position).divideScalar(this._controlTouchAmount * i).clampLength(-1, 1) } else e.finger === this._touchCameraFinger && this._rotateCharactersCamera(e.delta11.x, e.delta11.y) } _onTouchEnd(e) { e.input === "mouse" ? (this._isLeftMousePressed = !1, this._touchMovingDelta.setScalar(0), this._mouseToggleCb && this._mouseToggleCb(!1)) : e.finger === this._touchMovingFinger ? (this._touchMovingFinger = -1, this._touchMovingDelta.setScalar(0)) : e.finger === this._touchCameraFinger && (this._touchCameraFinger = -1) } _onTouchClick(e) { e.input !== "mouse" && (this._requestJump(!0), this._requestJump(!1), e.finger !== this._touchMovingFinger && this._circles._animateJump(e)) } _onTouchSprint(e = !1) { this._onKey({ type: e === !0 ? "keydown" : "keyup", code: "ShiftLeft" }) } _mouseRightDown(e) { e.button === 2 && (this._mouseRightButtonTime = renderInfo.time) } _mouseRightUp(e) { e.button === 2 && renderInfo.time - this._mouseRightButtonTime < .5 && (this._requestJump(!0), this._requestJump(!1)) } _update() { if (this._circles._update(), L(this, $t).setScalar(0), !client$1.visible) return L(this, $t); if (this._moveKeysPressed.includes(!0) && (this._moveKeysPressed[0] && (L(this, $t).z += 1), this._moveKeysPressed[1] && (L(this, $t).z -= 1), this._moveKeysPressed[2] && (L(this, $t).x += 1), this._moveKeysPressed[3] && (L(this, $t).x -= 1), L(this, $t).normalize()), L(this, $t).x += this._touchMovingDelta.x, L(this, $t).z += this._touchMovingDelta.y, this._enabled) { if (L(this, $t).x -= gamepad$1.stick1.x, L(this, $t).z -= gamepad$1.stick1.y, this._characters._controlMode === "manual") { const e = math.lerpCoefFPS(.1), i = gamepad$1.stick2.x * -.1 * e, s = gamepad$1.stick2.y * .1 * e; this._rotateCharactersCamera(i, s), this._gamepadMovingCamera = Math.abs(i) > 0 || Math.abs(s) > 0 } gamepad$1.buttons[0] === !0 ? (this._gamepadRequestJump = !0, this._requestJump(!0)) : this._gamepadRequestJump && (this._gamepadRequestJump = !1, this._requestJump(!1)) } return L(this, $t).clampLength(-1, 1), this._sprintPressed && L(this, $t).multiplyScalar(this._sprintSpeed), L(this, $t) } _endInteraction() { for (let e = 0; e < this._moveKeysPressed.length; e++)this._moveKeysPressed[e] = !1; this._requestJump(!1), this._sprintPressed = !1, this._gamepadRequestJump = !1, this._isLeftMousePressed = !1, this._touchMovingFinger = -1, this._touchMovingDelta.setScalar(0), this._touchCameraFinger = -1, this._mouseToggleCb && this._mouseToggleCb(!1) } cancelJump() { this._characters._collisionPhysics._jumpRequested = !1, setTimeout(() => { this._characters._collisionPhysics._jumpRequested = !1 }, 0) } enable() { this._enabled || (this._enabled = !0, events.on("keydown", this._onKey, this), events.on("keyup", this._onKey, this), events.on("touch_start", this._onTouchStart, this), events.on("touch_drag", this._onTouchDrag, this), events.on("touch_end", this._onTouchEnd, this), events.on("touch_click", this._onTouchClick, this), events.on("touch2_start", this._onTouchStart, this), events.on("touch2_drag", this._onTouchDrag, this), events.on("touch2_end", this._onTouchEnd, this), events.on("touch2_click", this._onTouchClick, this), events.on("character_controls_shift_press", this._onTouchSprint, this), events.on("visibility_change", this._onActiveChange, this), events.on("focus_change", this._onActiveChange, this), global$1.interactionNode.addEventListener("mousedown", this._boundMouseRightDown), global$1.interactionNode.addEventListener("mouseup", this._boundMouseRightUp), global$1.interactionNode.addEventListener("mouseout", this._boundMouseRightUp)) } disable() { this._enabled && (this._enabled = !1, events.off("keydown", this._onKey, this), events.off("keyup", this._onKey, this), events.off("touch_start", this._onTouchStart, this), events.off("touch_drag", this._onTouchDrag, this), events.off("touch_end", this._onTouchEnd, this), events.off("touch_click", this._onTouchClick, this), events.off("touch2_start", this._onTouchStart, this), events.off("touch2_drag", this._onTouchDrag, this), events.off("touch2_end", this._onTouchEnd, this), events.off("touch2_click", this._onTouchClick, this), events.off("character_controls_shift_press", this._onTouchSprint, this), events.off("visibility_change", this._onActiveChange, this), events.off("focus_change", this._onActiveChange, this), global$1.interactionNode.removeEventListener("mousedown", this._boundMouseRightDown), global$1.interactionNode.removeEventListener("mouseup", this._boundMouseRightUp), global$1.interactionNode.removeEventListener("mouseout", this._boundMouseRightUp), this._endInteraction()) } dispose() { this.disable(), this._circles.traverse(e => { var i, s, a, o, l; e.material && (e.material.uniforms && Object.values(e.material.uniforms).forEach(c => { var h, d, p; (h = c.value) != null && h._loaded && ((p = (d = c.value).dispose) == null || p.call(d)) }), (s = (i = e.material).dispose) == null || s.call(i)), (o = (a = e.geometry) == null ? void 0 : a.dispose) == null || o.call(a), (l = e.dispose) == null || l.call(e) }), this._characters = null, this._circles = null } } cs = new WeakMap, $t = new WeakMap, Xr = new WeakMap, $s = new WeakMap; var Yr, Xs, jr; class tags extends BatchedMesh {
    constructor(i, s) {
        var d; const a = typeof s.tagsMaxLetters == "number" ? s.tagsMaxLetters : 13, o = i.MAX_CHARS * a; super(i.MAX_CHARS, i.MAX_CHARS * o * 4, i.MAX_CHARS * o * 6, s.tagsMaterial || new ShaderMaterial({
            uniforms: { uColor: { value: new Color }, uFadeDistance: { value: 100 }, tMap: { value: null }, uShow: { value: 1 }, batchingTexture: { value: null }, batchingIdTexture: { value: null } }, vertexShader: `
                #if ! defined(GL_ANGLE_multi_draw)
                    #define gl_DrawID _gl_DrawID
                    uniform int _gl_DrawID;
                #endif
                uniform highp sampler2D batchingTexture;
                uniform highp usampler2D batchingIdTexture;

                vec4 getBatchingPositionScale(const in int i) {
                    int size = textureSize(batchingTexture, 0).x;
                    return texelFetch(batchingTexture, ivec2(i % size, i / size), 0);
                }

                float getIndirectIndex(const in int i) {
                    int size = textureSize(batchingIdTexture, 0).x;
                    int x = i % size;
                    int y = i / size;
                    return float(texelFetch(batchingIdTexture, ivec2(x, y), 0).r);
                }

                ${matrixutils_default}

                varying vec2 vUv;
                varying vec3 vPos;
                varying vec3 wPos;
                varying vec2 vHighPrecisionZW;
                varying float vDist;

                void main() {
                    vUv = uv;

                    vec4 posScale = getBatchingPositionScale(int(getIndirectIndex(gl_DrawID)));
                    wPos = (billboardModelMatrix(posScale.xyz) * vec4(position * posScale.w, 1.0)).xyz;
                    vPos = (viewMatrix * vec4(wPos, 1.0)).xyz;
                    vDist = distance(wPos, cameraPosition);

                    gl_Position = projectionMatrix * vec4(vPos, 1.0);
                    vHighPrecisionZW = gl_Position.zw;
                }
            `, fragmentShader: `
                layout(location = 1) out highp vec4 gInfo;

                uniform sampler2D tMap;
                uniform vec3 uColor;
                uniform float uFadeDistance;
                uniform float uShow;

                ${msdf_default}

                varying vec2 vUv;
                varying vec3 vPos;
                varying vec3 wPos;
                varying vec2 vHighPrecisionZW;
                varying float vDist;

                float sphereFade(vec3 p, float size, float amount) {
                    float h = size * 0.5;
                    return clamp(1.0 - step(amount * 1.85, length(mod(p, size) - h) / h), 0.0, 1.0);
                }

                void main() {
                    float alpha = msdfOpaque(tMap, vUv);
                    alpha *= sphereFade(wPos, 0.1, smoothstep(uFadeDistance, uFadeDistance * 0.8, vDist) * uShow);

                    if (alpha == 0.0) discard;

                    gl_FragColor = vec4(uColor, 0.0);
                    gInfo = vec4(1.0 - (0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5), vec3(0.0));
                }
            `})); pe(this, Yr, new Object3D); pe(this, Xs, new Vector3); pe(this, jr, new Vector3); const l = math.getTextureSizeParticles(this.maxInstanceCount), c = new Float32Array(l * l * 4); this._matricesTexture.dispose(), this._matricesTexture = new DataTexture(c, l, l, RGBAFormat, FloatType), this.material.uniforms.batchingTexture.value = this._matricesTexture, this.material.uniforms.batchingIdTexture.value = this._indirectTexture; const h = new BufferGeometry; h.setAttribute("position", new BufferAttribute(new Float32Array(o * 4 * 3), 3).setUsage(DynamicDrawUsage)), h.setAttribute("uv", new BufferAttribute(new Float32Array(o * 4 * 2), 2).setUsage(DynamicDrawUsage)), h.setIndex(new BufferAttribute(new Uint16Array(o * 6), 1).setUsage(DynamicDrawUsage)), this._initializeGeometry(h); for (const p in this.geometry.attributes) this.geometry.attributes[p].setUsage(DynamicDrawUsage); this.geometry.getIndex().setUsage(DynamicDrawUsage); for (let p = 0; p < this.maxInstanceCount; p++) { const f = this.addGeometry(h), _ = this.addInstance(f); this._instanceInfo[_].active = !1, this._instanceInfo[_].visible = !1 } this.isCharacterTags = !0, this.name = "tags", this.frustumCulled = !1, this.perObjectFrustumCulled = !1, this.boundingBox = new Box3, this.boundingSphere = new Sphere, this.sortObjects = !1, this.renderOrder = 1e3, this.receiveShadow = !1, this.castShadow = !1, this.matrixWorldAutoUpdate = !1, this._characters = i, this._tagsMaxLetters = a, this._totalTagsLetters = o, this._tagsMaxDistance = typeof s.tagsMaxDistance == "number" ? s.tagsMaxDistance : 20, this._tagsSkipOwn = s.tagsSkipOwn || !1, this._tagsVerticalOffset = typeof s.tagsVerticalOffset == "number" ? s.tagsVerticalOffset : .1, this._tagsLocalLast = "", this._tagsFont = s.tagsFont || "monospace", this._tagsSize = typeof s.tagsSize == "number" ? s.tagsSize : .25, this._tagsLineHeight = typeof s.tagsLineHeight == "number" ? s.tagsLineHeight : 1, this._tagsLetterSpacing = typeof s.tagsLetterSpacing == "number" ? s.tagsLetterSpacing : 0, this._tagsColor = new Color(s.tagsColor || "#ffffff"), this.material.uniforms.tMap && (this.material.uniforms.tMap.value = textureLoader.load(`../fonts/${this._tagsFont}-datatexture.ktx2`, "data")), this.material.uniforms.uFadeDistance && (this.material.uniforms.uFadeDistance.value = this._tagsMaxDistance), this.material.uniforms.uColor && this.material.uniforms.uColor.value.copy(this._tagsColor), this._setTag(((d = s.initialData) == null ? void 0 : d.tag) || ""), events.on("character_tag_set", this._setTag, this), this._characters.add(this)
    } _setTag(i = "") { let s = i.replace(/[^\x00-\x7F]/g, "").trim(); s.length > this._tagsMaxLetters && (s = `${s.slice(0, this._tagsMaxLetters - 3).trim()}...`), this._tagsLocalLast !== s && (this._tagsLocalLast = s, Promise.resolve().then(a => { this._tagsLocalLast === s && (this._characters._localObject.userData.tag = s) }).catch(a => { this._tagsLocalLast === s && (this._characters._localObject.userData.tag = "") })) } _update() { for (let i = 0; i < this.maxInstanceCount; i++)this._instanceInfo[i].active = !1, this._instanceInfo[i].visible = !1; this._characters._charactersObjects.forEach(i => { i._tagData && (this._instanceInfo[i.batchedIndex].active = !0), !(this._tagsSkipOwn && i === this._characters._localObject || !i._inFrustumOfLocalCharacter || i._distanceToLocalCharacter > this._tagsMaxDistance) && (i._tagData || (i._tagData = { lastTag: "", validGeometry: !1 }, this._instanceInfo[i.batchedIndex].active = !0), i._tagData.lastTag !== i.userData.tag && (i._tagData.lastTag = i.userData.tag, geometryLoader.msdf({ text: i._tagData.lastTag, font: this._tagsFont, size: this._tagsSize, lineHeight: this._tagsLineHeight, letterSpacing: this._tagsLetterSpacing, align: "center" }).then(s => { i._tagData.validGeometry = s.attributes.position && s.attributes.position.count > 0; const a = i.batchedIndex; this.setGeometryAt(a, s) })), i._tagData.validGeometry && (this._instanceInfo[i.batchedIndex].visible = !0, L(this, Xs).copy(i.position).add(L(this, jr).copy(i.up).multiplyScalar(this._characters._geometryInfo[i.batchedIndex].boundingSphere.radius + this._tagsVerticalOffset)), L(this, Yr).position.copy(L(this, Xs)).toArray(this._matricesTexture.image.data, i.batchedIndex * 4), this._matricesTexture.image.data[i.batchedIndex * 4 + 3] = i.scale.x)) }), this._matricesTexture.needsUpdate = !0, this._visibilityChanged = !0 } dispose() { super.dispose(), events.off("character_tag_set", this._setTag, this) }
} Yr = new WeakMap, Xs = new WeakMap, jr = new WeakMap; var Ni, Ys, js, Ks, wi, Ei, Js, Zs, er, Nn, tr, ir, nr, sr, rr, ar, On, Gn, Ia, fo; class trails {
    constructor(e, i) {
        pe(this, Gn); pe(this, Ni, new Vector3); pe(this, Ys, new Vector3); pe(this, js, new Vector3); pe(this, Ks, new Vector3); pe(this, wi, { DEFAULT: 1, LAND: 2 }); pe(this, Ei, null); pe(this, Js, 15); pe(this, Zs, .055); pe(this, er, 1 / 0); pe(this, Nn, 2); pe(this, tr, 0); pe(this, ir, .5); pe(this, nr, .5); pe(this, sr, .75); pe(this, rr, 0); pe(this, ar, .115); pe(this, On, new Map); Ke(this, "particles", null); Xe(this, Ei, e), Xe(this, Js, typeof i.trailsMaxDistance == "number" ? i.trailsMaxDistance : 15), Xe(this, Zs, typeof i.trailsMinVelocity == "number" ? i.trailsMinVelocity : .055), Xe(this, er, typeof i.trailsMaxVelocity == "number" ? i.trailsMaxVelocity : 1 / 0), Xe(this, Nn, typeof i.trailsParticlesPerCharacter == "number" ? i.trailsParticlesPerCharacter : 2), Xe(this, tr, L(this, Ei).MAX_CHARS * L(this, Nn)), Xe(this, nr, typeof i.trailsBirthRate == "number" ? i.trailsBirthRate : .5), Xe(this, ir, typeof i.trailsBirthChance == "number" ? i.trailsBirthChance : .5), Xe(this, sr, typeof i.trailsExpiration == "number" ? i.trailsExpiration : .75), Xe(this, rr, typeof i.trailsVerticalOffset == "number" ? i.trailsVerticalOffset : 0), Xe(this, ar, typeof i.trailsFootSpacing == "number" ? i.trailsFootSpacing : .115), this.particles = particlesGPU$1({
            geometry: "points", onDeath: Pe(this, Gn, fo).bind(this), count: L(this, tr), material: new ShaderMaterial({
                userData: { hotReload: "trails" }, uniformsGroups: [global$1.UBO], uniforms: { instancingIdTexture: { value: null }, tTexture1: { value: null }, tTexture2: { value: null }, tNoise: { value: textureLoader.load("trails-noise.ktx2", "linearfilter-repeat") }, uSize: { value: 300 }, uColor: { value: new Color("#7c7c7c") } }, vertexShader: `
                    #if !defined(USE_INSTANCING)
                        #define gl_InstanceID _gl_InstanceID
                        attribute int _gl_InstanceID;
                    #endif

                    uniform sampler2D tTexture1;
                    uniform sampler2D tTexture2;
                    uniform highp usampler2D instancingIdTexture;
                    uniform float uSize;

                    ${globalUBO_default}
                    ${fit_default}

                    vec4 getInfo(const in sampler2D map, const in int i) {
                        int size = textureSize(map, 0).x;
                        return texelFetch(map, ivec2(i % size, i / size), 0);
                    }

                    float getIndirectIndex(const in int i) {
                        int size = textureSize(instancingIdTexture, 0).x;
                        return float(texelFetch(instancingIdTexture, ivec2(i % size, i / size), 0).r);
                    }

                    flat varying float vScale;
                    flat varying float vRand;
                    varying vec2 vHighPrecisionZW;

                    void main() {
                        int instanceID = int(getIndirectIndex(gl_InstanceID));
                        vec4 info1 = getInfo(tTexture1, instanceID);
                        vec4 info2 = getInfo(tTexture2, instanceID);
                        vec3 offset = info1.rgb;
                        float life = info1.a;

                        vRand = fract(info2.a);
                        vScale = smoothstep(0.0, 0.4, life) * smoothstep(1.0, 0.8, life);
                        vScale *= fit(vRand, 0.0, 1.0, 0.75, 1.0);

                        vec4 wPos = vec4(offset + position * vScale, 1.0);
                        vec4 vPos = viewMatrix * wPos;
                        gl_Position = projectionMatrix * vPos;
                        vHighPrecisionZW = gl_Position.zw;

                        gl_PointSize = (uSize * vScale) / length(vPos.xyz) * (resolution.y / 1300.0);
                    }
                `, fragmentShader: `
                    layout(location = 1) out highp vec4 gInfo;

                    ${encoding_default}

                    uniform sampler2D tNoise;
                    uniform vec3 uColor;

                    flat varying float vScale;
                    flat varying float vRand;
                    varying vec2 vHighPrecisionZW;

                    void main() {
                        vec2 uv = 2.0 * gl_PointCoord.xy - 1.0;
                        float dist = length(uv);
                        float alpha = smoothstep(0.7, 0.0, dist);

                        float noise = texture(tNoise, (uv + vRand * 6.43563) * 0.3).r;
                        float mask = alpha * noise;

                        if (mask < 0.4) discard;

                        gl_FragColor = vec4(uColor, vRand);
                        gInfo = vec4(1.0 - (0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5), vec2(0.0), 1.0);
                    }
                `})
        }, {
            textures: 3, pixelsPerInstance: 3, material: new ShaderMaterial({
                uniformsGroups: [global$1.UBO], uniforms: { tSimInit: { value: null }, tTexture1: { value: null }, tTexture2: { value: null }, tTexture3: { value: null } }, vertexShader: `
                    void main() {
                        gl_Position = vec4(position, 1.0);
                    }
                `, fragmentShader: `
                    #define outPos pc_fragColor
                    uniform sampler2D tTexture1;

                    layout(location = 1) out highp vec4 outVel;
                    uniform sampler2D tTexture2;

                    layout(location = 2) out highp vec4 outData;
                    uniform sampler2D tTexture3;

                    uniform sampler2D tSimInit;

                    ${globalUBO_default}
                    ${lerpfriction_default}

                    void main() {
                        ivec2 uv = ivec2(gl_FragCoord.xy);

                        vec4 data1 = texelFetch(tTexture1, uv, 0);
                        vec4 data2 = texelFetch(tTexture2, uv, 0);
                        vec4 data3 = texelFetch(tTexture3, uv, 0);

                        vec3 position = data1.xyz;
                        float life = data1.w;
                        vec3 velocity = data2.xyz;
                        float random = data2.w;
                        vec3 up = data3.xyz;

                        // get particle id and index on emitting texture
                        int tsize = textureSize(tTexture1, 0).x;
                        int particleid = uv.y * tsize + uv.x;
                        int emitSize = textureSize(tSimInit, 0).x;
                        int indexEmitting = particleid * 3;
                        ivec2 emittinguv = ivec2(indexEmitting % emitSize, indexEmitting / emitSize);
                        vec4 simInit1 = texelFetch(tSimInit, emittinguv, 0);

                        if (simInit1.w > 0.0) {
                            // particle needs to spawn. get all info from spawn
                            vec4 simInit2 = texelFetch(tSimInit, emittinguv + ivec2(1, 0), 0);
                            vec4 simInit3 = texelFetch(tSimInit, emittinguv + ivec2(2, 0), 0);

                            position = simInit1.xyz;
                            life = simInit1.w;
                            velocity = simInit2.xyz;
                            random = simInit2.w;
                            data3 = simInit3;
                        } else if (life > 0.0) {
                            // substract life
                            life -= 0.04 * dtRatio;

                            // add gravity
                            velocity -= up * 0.0025 * dtRatio;

                            // add friction
                            velocity *= frictionFPS(0.8, dtRatio);

                            // add to position
                            position += velocity * dtRatio;
                        }

                        outPos = vec4(position, life);
                        outVel = vec4(velocity, random);
                        outData = data3;
                    }
                `})
        }), this.particles.name = "trails", this.particles.renderOrder = 1e3, this.particles.receiveShadow = !1, this.particles.castShadow = !1, L(this, Ei).add(this.particles)
    } update() { L(this, Ei)._charactersObjects.forEach((e, i) => { if (!e._inFrustumOfLocalCharacter || e._distanceToLocalCharacter > L(this, Js) || e.scale.x < 1) return; e._trailsData || (e._trailsData = { particleCnt: 0, lastBirth: 0, lastSide: -1, lastMedium: e.userData.medium }); const s = e.userData.medium === L(this, Ei).MEDIUMS.GROUND && e._trailsData.lastMedium !== L(this, Ei).MEDIUMS.GROUND; e._trailsData.lastMedium = e.userData.medium; const a = e._trailsData.particleCnt, o = e._trailsData.lastBirth; a < L(this, Nn) && (i === L(this, Ei).LOCAL_ID && s ? Pe(this, Gn, Ia).call(this, e, Math.min(2, L(this, Nn) - a), L(this, wi).LAND) : o < renderInfo.time - L(this, nr) && e.userData.medium === L(this, Ei).MEDIUMS.GROUND && e.userData.animation === 0 && e.velocityHorizontal > L(this, Zs) && e.velocityHorizontal < L(this, er) && Pe(this, Gn, Ia).call(this, e, 1, L(this, wi).DEFAULT)) }) }
} Ni = new WeakMap, Ys = new WeakMap, js = new WeakMap, Ks = new WeakMap, wi = new WeakMap, Ei = new WeakMap, Js = new WeakMap, Zs = new WeakMap, er = new WeakMap, Nn = new WeakMap, tr = new WeakMap, ir = new WeakMap, nr = new WeakMap, sr = new WeakMap, rr = new WeakMap, ar = new WeakMap, On = new WeakMap, Gn = new WeakSet, Ia = function (e, i = 1, s = L(this, wi).DEFAULT) { const a = e._trailsData; if (Math.random() > L(this, ir)) { a.lastBirth = renderInfo.time; return } L(this, Ys).set(1, 0, 0).applyQuaternion(e.quaternion), L(this, js).set(0, 0, 1).applyQuaternion(e.quaternion), L(this, Ks).set(0, 0, -1).applyQuaternion(e.quaternion); const o = L(this, rr) * (s === L(this, wi).DEFAULT ? 1 : -1.25), l = L(this, ar) * (s === L(this, wi).DEFAULT ? 1 : 1.5), c = s === L(this, wi).LAND ? -.05 : math.efit(e.velocityHorizontal, .025, .1, 0, .5), h = s === L(this, wi).DEFAULT ? math.fit(Math.random(), 0, 1, .4, .6) : .1, d = (s === L(this, wi).DEFAULT ? .1 : .025) * math.fit(e.velocityHorizontal, 0, .15, .1, 1), p = e.up; for (let f = 0; f < i; f++) { L(this, Ni).copy(e.position).addScaledVector(e.up, o); const _ = a.lastSide * -1; L(this, Ni).addScaledVector(L(this, Ys), l * _), L(this, Ni).addScaledVector(L(this, js), c); const x = L(this, Ni).toArray(); L(this, Ni).lerpVectors(p, L(this, Ks), h).normalize(), L(this, Ni).multiplyScalar(d); const b = L(this, Ni).toArray(); a.particleCnt += 1, a.lastBirth = renderInfo.time, a.lastSide = _; const T = this.particles.spawn({ expiration: L(this, sr), data: [x, 1, b, Math.random(), p.toArray(), 0] }); L(this, On).set(T, a) } }, fo = function (e) { if (!L(this, On).has(e)) return; const i = L(this, On).get(e); i.particleCnt -= 1, L(this, On).delete(e) }; var src = { exports: {} }, indexLight = { exports: {} }, indexMinimal = {}, minimal = {}, aspromise, hasRequiredAspromise; function requireAspromise() { if (hasRequiredAspromise) return aspromise; hasRequiredAspromise = 1, aspromise = r; function r(e, i) { for (var s = new Array(arguments.length - 1), a = 0, o = 2, l = !0; o < arguments.length;)s[a++] = arguments[o++]; return new Promise(function (h, d) { s[a] = function (f) { if (l) if (l = !1, f) d(f); else { for (var _ = new Array(arguments.length - 1), x = 0; x < _.length;)_[x++] = arguments[x]; h.apply(null, _) } }; try { e.apply(i || null, s) } catch (p) { l && (l = !1, d(p)) } }) } return aspromise } var base64 = {}, hasRequiredBase64; function requireBase64() { return hasRequiredBase64 || (hasRequiredBase64 = 1, function (r) { var e = r; e.length = function (c) { var h = c.length; if (!h) return 0; for (var d = 0; --h % 4 > 1 && c.charAt(h) === "=";)++d; return Math.ceil(c.length * 3) / 4 - d }; for (var i = new Array(64), s = new Array(123), a = 0; a < 64;)s[i[a] = a < 26 ? a + 65 : a < 52 ? a + 71 : a < 62 ? a - 4 : a - 59 | 43] = a++; e.encode = function (c, h, d) { for (var p = null, f = [], _ = 0, x = 0, b; h < d;) { var T = c[h++]; switch (x) { case 0: f[_++] = i[T >> 2], b = (T & 3) << 4, x = 1; break; case 1: f[_++] = i[b | T >> 4], b = (T & 15) << 2, x = 2; break; case 2: f[_++] = i[b | T >> 6], f[_++] = i[T & 63], x = 0; break }_ > 8191 && ((p || (p = [])).push(String.fromCharCode.apply(String, f)), _ = 0) } return x && (f[_++] = i[b], f[_++] = 61, x === 1 && (f[_++] = 61)), p ? (_ && p.push(String.fromCharCode.apply(String, f.slice(0, _))), p.join("")) : String.fromCharCode.apply(String, f.slice(0, _)) }; var o = "invalid encoding"; e.decode = function (c, h, d) { for (var p = d, f = 0, _, x = 0; x < c.length;) { var b = c.charCodeAt(x++); if (b === 61 && f > 1) break; if ((b = s[b]) === void 0) throw Error(o); switch (f) { case 0: _ = b, f = 1; break; case 1: h[d++] = _ << 2 | (b & 48) >> 4, _ = b, f = 2; break; case 2: h[d++] = (_ & 15) << 4 | (b & 60) >> 2, _ = b, f = 3; break; case 3: h[d++] = (_ & 3) << 6 | b, f = 0; break } } if (f === 1) throw Error(o); return d - p }, e.test = function (c) { return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(c) } }(base64)), base64 } var eventemitter, hasRequiredEventemitter; function requireEventemitter() { if (hasRequiredEventemitter) return eventemitter; hasRequiredEventemitter = 1, eventemitter = r; function r() { this._listeners = {} } return r.prototype.on = function (i, s, a) { return (this._listeners[i] || (this._listeners[i] = [])).push({ fn: s, ctx: a || this }), this }, r.prototype.off = function (i, s) { if (i === void 0) this._listeners = {}; else if (s === void 0) this._listeners[i] = []; else for (var a = this._listeners[i], o = 0; o < a.length;)a[o].fn === s ? a.splice(o, 1) : ++o; return this }, r.prototype.emit = function (i) { var s = this._listeners[i]; if (s) { for (var a = [], o = 1; o < arguments.length;)a.push(arguments[o++]); for (o = 0; o < s.length;)s[o].fn.apply(s[o++].ctx, a) } return this }, eventemitter } var float, hasRequiredFloat; function requireFloat() { if (hasRequiredFloat) return float; hasRequiredFloat = 1, float = r(r); function r(o) { return typeof Float32Array < "u" ? function () { var l = new Float32Array([-0]), c = new Uint8Array(l.buffer), h = c[3] === 128; function d(x, b, T) { l[0] = x, b[T] = c[0], b[T + 1] = c[1], b[T + 2] = c[2], b[T + 3] = c[3] } function p(x, b, T) { l[0] = x, b[T] = c[3], b[T + 1] = c[2], b[T + 2] = c[1], b[T + 3] = c[0] } o.writeFloatLE = h ? d : p, o.writeFloatBE = h ? p : d; function f(x, b) { return c[0] = x[b], c[1] = x[b + 1], c[2] = x[b + 2], c[3] = x[b + 3], l[0] } function _(x, b) { return c[3] = x[b], c[2] = x[b + 1], c[1] = x[b + 2], c[0] = x[b + 3], l[0] } o.readFloatLE = h ? f : _, o.readFloatBE = h ? _ : f }() : function () { function l(h, d, p, f) { var _ = d < 0 ? 1 : 0; if (_ && (d = -d), d === 0) h(1 / d > 0 ? 0 : 2147483648, p, f); else if (isNaN(d)) h(2143289344, p, f); else if (d > 34028234663852886e22) h((_ << 31 | 2139095040) >>> 0, p, f); else if (d < 11754943508222875e-54) h((_ << 31 | Math.round(d / 1401298464324817e-60)) >>> 0, p, f); else { var x = Math.floor(Math.log(d) / Math.LN2), b = Math.round(d * Math.pow(2, -x) * 8388608) & 8388607; h((_ << 31 | x + 127 << 23 | b) >>> 0, p, f) } } o.writeFloatLE = l.bind(null, e), o.writeFloatBE = l.bind(null, i); function c(h, d, p) { var f = h(d, p), _ = (f >> 31) * 2 + 1, x = f >>> 23 & 255, b = f & 8388607; return x === 255 ? b ? NaN : _ * (1 / 0) : x === 0 ? _ * 1401298464324817e-60 * b : _ * Math.pow(2, x - 150) * (b + 8388608) } o.readFloatLE = c.bind(null, s), o.readFloatBE = c.bind(null, a) }(), typeof Float64Array < "u" ? function () { var l = new Float64Array([-0]), c = new Uint8Array(l.buffer), h = c[7] === 128; function d(x, b, T) { l[0] = x, b[T] = c[0], b[T + 1] = c[1], b[T + 2] = c[2], b[T + 3] = c[3], b[T + 4] = c[4], b[T + 5] = c[5], b[T + 6] = c[6], b[T + 7] = c[7] } function p(x, b, T) { l[0] = x, b[T] = c[7], b[T + 1] = c[6], b[T + 2] = c[5], b[T + 3] = c[4], b[T + 4] = c[3], b[T + 5] = c[2], b[T + 6] = c[1], b[T + 7] = c[0] } o.writeDoubleLE = h ? d : p, o.writeDoubleBE = h ? p : d; function f(x, b) { return c[0] = x[b], c[1] = x[b + 1], c[2] = x[b + 2], c[3] = x[b + 3], c[4] = x[b + 4], c[5] = x[b + 5], c[6] = x[b + 6], c[7] = x[b + 7], l[0] } function _(x, b) { return c[7] = x[b], c[6] = x[b + 1], c[5] = x[b + 2], c[4] = x[b + 3], c[3] = x[b + 4], c[2] = x[b + 5], c[1] = x[b + 6], c[0] = x[b + 7], l[0] } o.readDoubleLE = h ? f : _, o.readDoubleBE = h ? _ : f }() : function () { function l(h, d, p, f, _, x) { var b = f < 0 ? 1 : 0; if (b && (f = -f), f === 0) h(0, _, x + d), h(1 / f > 0 ? 0 : 2147483648, _, x + p); else if (isNaN(f)) h(0, _, x + d), h(2146959360, _, x + p); else if (f > 17976931348623157e292) h(0, _, x + d), h((b << 31 | 2146435072) >>> 0, _, x + p); else { var T; if (f < 22250738585072014e-324) T = f / 5e-324, h(T >>> 0, _, x + d), h((b << 31 | T / 4294967296) >>> 0, _, x + p); else { var M = Math.floor(Math.log(f) / Math.LN2); M === 1024 && (M = 1023), T = f * Math.pow(2, -M), h(T * 4503599627370496 >>> 0, _, x + d), h((b << 31 | M + 1023 << 20 | T * 1048576 & 1048575) >>> 0, _, x + p) } } } o.writeDoubleLE = l.bind(null, e, 0, 4), o.writeDoubleBE = l.bind(null, i, 4, 0); function c(h, d, p, f, _) { var x = h(f, _ + d), b = h(f, _ + p), T = (b >> 31) * 2 + 1, M = b >>> 20 & 2047, w = 4294967296 * (b & 1048575) + x; return M === 2047 ? w ? NaN : T * (1 / 0) : M === 0 ? T * 5e-324 * w : T * Math.pow(2, M - 1075) * (w + 4503599627370496) } o.readDoubleLE = c.bind(null, s, 0, 4), o.readDoubleBE = c.bind(null, a, 4, 0) }(), o } function e(o, l, c) { l[c] = o & 255, l[c + 1] = o >>> 8 & 255, l[c + 2] = o >>> 16 & 255, l[c + 3] = o >>> 24 } function i(o, l, c) { l[c] = o >>> 24, l[c + 1] = o >>> 16 & 255, l[c + 2] = o >>> 8 & 255, l[c + 3] = o & 255 } function s(o, l) { return (o[l] | o[l + 1] << 8 | o[l + 2] << 16 | o[l + 3] << 24) >>> 0 } function a(o, l) { return (o[l] << 24 | o[l + 1] << 16 | o[l + 2] << 8 | o[l + 3]) >>> 0 } return float } var inquire_1, hasRequiredInquire; function requireInquire() { if (hasRequiredInquire) return inquire_1; hasRequiredInquire = 1, inquire_1 = inquire; function inquire(moduleName) { try { var mod = eval("quire".replace(/^/, "re"))(moduleName); if (mod && (mod.length || Object.keys(mod).length)) return mod } catch (r) { } return null } return inquire_1 } var utf8 = {}, hasRequiredUtf8; function requireUtf8() { return hasRequiredUtf8 || (hasRequiredUtf8 = 1, function (r) { var e = r; e.length = function (s) { for (var a = 0, o = 0, l = 0; l < s.length; ++l)o = s.charCodeAt(l), o < 128 ? a += 1 : o < 2048 ? a += 2 : (o & 64512) === 55296 && (s.charCodeAt(l + 1) & 64512) === 56320 ? (++l, a += 4) : a += 3; return a }, e.read = function (s, a, o) { var l = o - a; if (l < 1) return ""; for (var c = null, h = [], d = 0, p; a < o;)p = s[a++], p < 128 ? h[d++] = p : p > 191 && p < 224 ? h[d++] = (p & 31) << 6 | s[a++] & 63 : p > 239 && p < 365 ? (p = ((p & 7) << 18 | (s[a++] & 63) << 12 | (s[a++] & 63) << 6 | s[a++] & 63) - 65536, h[d++] = 55296 + (p >> 10), h[d++] = 56320 + (p & 1023)) : h[d++] = (p & 15) << 12 | (s[a++] & 63) << 6 | s[a++] & 63, d > 8191 && ((c || (c = [])).push(String.fromCharCode.apply(String, h)), d = 0); return c ? (d && c.push(String.fromCharCode.apply(String, h.slice(0, d))), c.join("")) : String.fromCharCode.apply(String, h.slice(0, d)) }, e.write = function (s, a, o) { for (var l = o, c, h, d = 0; d < s.length; ++d)c = s.charCodeAt(d), c < 128 ? a[o++] = c : c < 2048 ? (a[o++] = c >> 6 | 192, a[o++] = c & 63 | 128) : (c & 64512) === 55296 && ((h = s.charCodeAt(d + 1)) & 64512) === 56320 ? (c = 65536 + ((c & 1023) << 10) + (h & 1023), ++d, a[o++] = c >> 18 | 240, a[o++] = c >> 12 & 63 | 128, a[o++] = c >> 6 & 63 | 128, a[o++] = c & 63 | 128) : (a[o++] = c >> 12 | 224, a[o++] = c >> 6 & 63 | 128, a[o++] = c & 63 | 128); return o - l } }(utf8)), utf8 } var pool_1, hasRequiredPool; function requirePool() { if (hasRequiredPool) return pool_1; hasRequiredPool = 1, pool_1 = r; function r(e, i, s) { var a = s || 8192, o = a >>> 1, l = null, c = a; return function (d) { if (d < 1 || d > o) return e(d); c + d > a && (l = e(a), c = 0); var p = i.call(l, c, c += d); return c & 7 && (c = (c | 7) + 1), p } } return pool_1 } var longbits, hasRequiredLongbits; function requireLongbits() { if (hasRequiredLongbits) return longbits; hasRequiredLongbits = 1, longbits = e; var r = requireMinimal(); function e(o, l) { this.lo = o >>> 0, this.hi = l >>> 0 } var i = e.zero = new e(0, 0); i.toNumber = function () { return 0 }, i.zzEncode = i.zzDecode = function () { return this }, i.length = function () { return 1 }; var s = e.zeroHash = "\0\0\0\0\0\0\0\0"; e.fromNumber = function (l) { if (l === 0) return i; var c = l < 0; c && (l = -l); var h = l >>> 0, d = (l - h) / 4294967296 >>> 0; return c && (d = ~d >>> 0, h = ~h >>> 0, ++h > 4294967295 && (h = 0, ++d > 4294967295 && (d = 0))), new e(h, d) }, e.from = function (l) { if (typeof l == "number") return e.fromNumber(l); if (r.isString(l)) if (r.Long) l = r.Long.fromString(l); else return e.fromNumber(parseInt(l, 10)); return l.low || l.high ? new e(l.low >>> 0, l.high >>> 0) : i }, e.prototype.toNumber = function (l) { if (!l && this.hi >>> 31) { var c = ~this.lo + 1 >>> 0, h = ~this.hi >>> 0; return c || (h = h + 1 >>> 0), -(c + h * 4294967296) } return this.lo + this.hi * 4294967296 }, e.prototype.toLong = function (l) { return r.Long ? new r.Long(this.lo | 0, this.hi | 0, !!l) : { low: this.lo | 0, high: this.hi | 0, unsigned: !!l } }; var a = String.prototype.charCodeAt; return e.fromHash = function (l) { return l === s ? i : new e((a.call(l, 0) | a.call(l, 1) << 8 | a.call(l, 2) << 16 | a.call(l, 3) << 24) >>> 0, (a.call(l, 4) | a.call(l, 5) << 8 | a.call(l, 6) << 16 | a.call(l, 7) << 24) >>> 0) }, e.prototype.toHash = function () { return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24) }, e.prototype.zzEncode = function () { var l = this.hi >> 31; return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ l) >>> 0, this.lo = (this.lo << 1 ^ l) >>> 0, this }, e.prototype.zzDecode = function () { var l = -(this.lo & 1); return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ l) >>> 0, this.hi = (this.hi >>> 1 ^ l) >>> 0, this }, e.prototype.length = function () { var l = this.lo, c = (this.lo >>> 28 | this.hi << 4) >>> 0, h = this.hi >>> 24; return h === 0 ? c === 0 ? l < 16384 ? l < 128 ? 1 : 2 : l < 2097152 ? 3 : 4 : c < 16384 ? c < 128 ? 5 : 6 : c < 2097152 ? 7 : 8 : h < 128 ? 9 : 10 }, longbits } var hasRequiredMinimal; function requireMinimal() { return hasRequiredMinimal || (hasRequiredMinimal = 1, function (r) { var e = r; e.asPromise = requireAspromise(), e.base64 = requireBase64(), e.EventEmitter = requireEventemitter(), e.float = requireFloat(), e.inquire = requireInquire(), e.utf8 = requireUtf8(), e.pool = requirePool(), e.LongBits = requireLongbits(), e.isNode = !!(typeof commonjsGlobal < "u" && commonjsGlobal && commonjsGlobal.process && commonjsGlobal.process.versions && commonjsGlobal.process.versions.node), e.global = e.isNode && commonjsGlobal || typeof window < "u" && window || typeof self < "u" && self || minimal, e.emptyArray = Object.freeze ? Object.freeze([]) : [], e.emptyObject = Object.freeze ? Object.freeze({}) : {}, e.isInteger = Number.isInteger || function (o) { return typeof o == "number" && isFinite(o) && Math.floor(o) === o }, e.isString = function (o) { return typeof o == "string" || o instanceof String }, e.isObject = function (o) { return o && typeof o == "object" }, e.isset = e.isSet = function (o, l) { var c = o[l]; return c != null && o.hasOwnProperty(l) ? typeof c != "object" || (Array.isArray(c) ? c.length : Object.keys(c).length) > 0 : !1 }, e.Buffer = function () { try { var a = e.inquire("buffer").Buffer; return a.prototype.utf8Write ? a : null } catch { return null } }(), e._Buffer_from = null, e._Buffer_allocUnsafe = null, e.newBuffer = function (o) { return typeof o == "number" ? e.Buffer ? e._Buffer_allocUnsafe(o) : new e.Array(o) : e.Buffer ? e._Buffer_from(o) : typeof Uint8Array > "u" ? o : new Uint8Array(o) }, e.Array = typeof Uint8Array < "u" ? Uint8Array : Array, e.Long = e.global.dcodeIO && e.global.dcodeIO.Long || e.global.Long || e.inquire("long"), e.key2Re = /^true|false|0|1$/, e.key32Re = /^-?(?:0|[1-9][0-9]*)$/, e.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, e.longToHash = function (o) { return o ? e.LongBits.from(o).toHash() : e.LongBits.zeroHash }, e.longFromHash = function (o, l) { var c = e.LongBits.fromHash(o); return e.Long ? e.Long.fromBits(c.lo, c.hi, l) : c.toNumber(!!l) }; function i(a, o, l) { for (var c = Object.keys(o), h = 0; h < c.length; ++h)(a[c[h]] === void 0 || !l) && (a[c[h]] = o[c[h]]); return a } e.merge = i, e.lcFirst = function (o) { return o.charAt(0).toLowerCase() + o.substring(1) }; function s(a) { function o(l, c) { if (!(this instanceof o)) return new o(l, c); Object.defineProperty(this, "message", { get: function () { return l } }), Error.captureStackTrace ? Error.captureStackTrace(this, o) : Object.defineProperty(this, "stack", { value: new Error().stack || "" }), c && i(this, c) } return o.prototype = Object.create(Error.prototype, { constructor: { value: o, writable: !0, enumerable: !1, configurable: !0 }, name: { get: function () { return a }, set: void 0, enumerable: !1, configurable: !0 }, toString: { value: function () { return this.name + ": " + this.message }, writable: !0, enumerable: !1, configurable: !0 } }), o } e.newError = s, e.ProtocolError = s("ProtocolError"), e.oneOfGetter = function (o) { for (var l = {}, c = 0; c < o.length; ++c)l[o[c]] = 1; return function () { for (var h = Object.keys(this), d = h.length - 1; d > -1; --d)if (l[h[d]] === 1 && this[h[d]] !== void 0 && this[h[d]] !== null) return h[d] } }, e.oneOfSetter = function (o) { return function (l) { for (var c = 0; c < o.length; ++c)o[c] !== l && delete this[o[c]] } }, e.toJSONOptions = { longs: String, enums: String, bytes: String, json: !0 }, e._configure = function () { var a = e.Buffer; if (!a) { e._Buffer_from = e._Buffer_allocUnsafe = null; return } e._Buffer_from = a.from !== Uint8Array.from && a.from || function (l, c) { return new a(l, c) }, e._Buffer_allocUnsafe = a.allocUnsafe || function (l) { return new a(l) } } }(minimal)), minimal } var writer, hasRequiredWriter; function requireWriter() { if (hasRequiredWriter) return writer; hasRequiredWriter = 1, writer = h; var r = requireMinimal(), e, i = r.LongBits, s = r.base64, a = r.utf8; function o(M, w, D) { this.fn = M, this.len = w, this.next = void 0, this.val = D } function l() { } function c(M) { this.head = M.head, this.tail = M.tail, this.len = M.len, this.next = M.states } function h() { this.len = 0, this.head = new o(l, 0, 0), this.tail = this.head, this.states = null } var d = function () { return r.Buffer ? function () { return (h.create = function () { return new e })() } : function () { return new h } }; h.create = d(), h.alloc = function (w) { return new r.Array(w) }, r.Array !== Array && (h.alloc = r.pool(h.alloc, r.Array.prototype.subarray)), h.prototype._push = function (w, D, R) { return this.tail = this.tail.next = new o(w, D, R), this.len += D, this }; function p(M, w, D) { w[D] = M & 255 } function f(M, w, D) { for (; M > 127;)w[D++] = M & 127 | 128, M >>>= 7; w[D] = M } function _(M, w) { this.len = M, this.next = void 0, this.val = w } _.prototype = Object.create(o.prototype), _.prototype.fn = f, h.prototype.uint32 = function (w) { return this.len += (this.tail = this.tail.next = new _((w = w >>> 0) < 128 ? 1 : w < 16384 ? 2 : w < 2097152 ? 3 : w < 268435456 ? 4 : 5, w)).len, this }, h.prototype.int32 = function (w) { return w < 0 ? this._push(x, 10, i.fromNumber(w)) : this.uint32(w) }, h.prototype.sint32 = function (w) { return this.uint32((w << 1 ^ w >> 31) >>> 0) }; function x(M, w, D) { for (; M.hi;)w[D++] = M.lo & 127 | 128, M.lo = (M.lo >>> 7 | M.hi << 25) >>> 0, M.hi >>>= 7; for (; M.lo > 127;)w[D++] = M.lo & 127 | 128, M.lo = M.lo >>> 7; w[D++] = M.lo } h.prototype.uint64 = function (w) { var D = i.from(w); return this._push(x, D.length(), D) }, h.prototype.int64 = h.prototype.uint64, h.prototype.sint64 = function (w) { var D = i.from(w).zzEncode(); return this._push(x, D.length(), D) }, h.prototype.bool = function (w) { return this._push(p, 1, w ? 1 : 0) }; function b(M, w, D) { w[D] = M & 255, w[D + 1] = M >>> 8 & 255, w[D + 2] = M >>> 16 & 255, w[D + 3] = M >>> 24 } h.prototype.fixed32 = function (w) { return this._push(b, 4, w >>> 0) }, h.prototype.sfixed32 = h.prototype.fixed32, h.prototype.fixed64 = function (w) { var D = i.from(w); return this._push(b, 4, D.lo)._push(b, 4, D.hi) }, h.prototype.sfixed64 = h.prototype.fixed64, h.prototype.float = function (w) { return this._push(r.float.writeFloatLE, 4, w) }, h.prototype.double = function (w) { return this._push(r.float.writeDoubleLE, 8, w) }; var T = r.Array.prototype.set ? function (w, D, R) { D.set(w, R) } : function (w, D, R) { for (var P = 0; P < w.length; ++P)D[R + P] = w[P] }; return h.prototype.bytes = function (w) { var D = w.length >>> 0; if (!D) return this._push(p, 1, 0); if (r.isString(w)) { var R = h.alloc(D = s.length(w)); s.decode(w, R, 0), w = R } return this.uint32(D)._push(T, D, w) }, h.prototype.string = function (w) { var D = a.length(w); return D ? this.uint32(D)._push(a.write, D, w) : this._push(p, 1, 0) }, h.prototype.fork = function () { return this.states = new c(this), this.head = this.tail = new o(l, 0, 0), this.len = 0, this }, h.prototype.reset = function () { return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new o(l, 0, 0), this.len = 0), this }, h.prototype.ldelim = function () { var w = this.head, D = this.tail, R = this.len; return this.reset().uint32(R), R && (this.tail.next = w.next, this.tail = D, this.len += R), this }, h.prototype.finish = function () { for (var w = this.head.next, D = this.constructor.alloc(this.len), R = 0; w;)w.fn(w.val, D, R), R += w.len, w = w.next; return D }, h._configure = function (M) { e = M, h.create = d(), e._configure() }, writer } var writer_buffer, hasRequiredWriter_buffer; function requireWriter_buffer() { if (hasRequiredWriter_buffer) return writer_buffer; hasRequiredWriter_buffer = 1, writer_buffer = i; var r = requireWriter(); (i.prototype = Object.create(r.prototype)).constructor = i; var e = requireMinimal(); function i() { r.call(this) } i._configure = function () { i.alloc = e._Buffer_allocUnsafe, i.writeBytesBuffer = e.Buffer && e.Buffer.prototype instanceof Uint8Array && e.Buffer.prototype.set.name === "set" ? function (o, l, c) { l.set(o, c) } : function (o, l, c) { if (o.copy) o.copy(l, c, 0, o.length); else for (var h = 0; h < o.length;)l[c++] = o[h++] } }, i.prototype.bytes = function (o) { e.isString(o) && (o = e._Buffer_from(o, "base64")); var l = o.length >>> 0; return this.uint32(l), l && this._push(i.writeBytesBuffer, l, o), this }; function s(a, o, l) { a.length < 40 ? e.utf8.write(a, o, l) : o.utf8Write ? o.utf8Write(a, l) : o.write(a, l) } return i.prototype.string = function (o) { var l = e.Buffer.byteLength(o); return this.uint32(l), l && this._push(s, l, o), this }, i._configure(), writer_buffer } var reader, hasRequiredReader; function requireReader() { if (hasRequiredReader) return reader; hasRequiredReader = 1, reader = o; var r = requireMinimal(), e, i = r.LongBits, s = r.utf8; function a(f, _) { return RangeError("index out of range: " + f.pos + " + " + (_ || 1) + " > " + f.len) } function o(f) { this.buf = f, this.pos = 0, this.len = f.length } var l = typeof Uint8Array < "u" ? function (_) { if (_ instanceof Uint8Array || Array.isArray(_)) return new o(_); throw Error("illegal buffer") } : function (_) { if (Array.isArray(_)) return new o(_); throw Error("illegal buffer") }, c = function () { return r.Buffer ? function (x) { return (o.create = function (T) { return r.Buffer.isBuffer(T) ? new e(T) : l(T) })(x) } : l }; o.create = c(), o.prototype._slice = r.Array.prototype.subarray || r.Array.prototype.slice, o.prototype.uint32 = function () { var _ = 4294967295; return function () { if (_ = (this.buf[this.pos] & 127) >>> 0, this.buf[this.pos++] < 128 || (_ = (_ | (this.buf[this.pos] & 127) << 7) >>> 0, this.buf[this.pos++] < 128) || (_ = (_ | (this.buf[this.pos] & 127) << 14) >>> 0, this.buf[this.pos++] < 128) || (_ = (_ | (this.buf[this.pos] & 127) << 21) >>> 0, this.buf[this.pos++] < 128) || (_ = (_ | (this.buf[this.pos] & 15) << 28) >>> 0, this.buf[this.pos++] < 128)) return _; if ((this.pos += 5) > this.len) throw this.pos = this.len, a(this, 10); return _ } }(), o.prototype.int32 = function () { return this.uint32() | 0 }, o.prototype.sint32 = function () { var _ = this.uint32(); return _ >>> 1 ^ -(_ & 1) | 0 }; function h() { var f = new i(0, 0), _ = 0; if (this.len - this.pos > 4) { for (; _ < 4; ++_)if (f.lo = (f.lo | (this.buf[this.pos] & 127) << _ * 7) >>> 0, this.buf[this.pos++] < 128) return f; if (f.lo = (f.lo | (this.buf[this.pos] & 127) << 28) >>> 0, f.hi = (f.hi | (this.buf[this.pos] & 127) >> 4) >>> 0, this.buf[this.pos++] < 128) return f; _ = 0 } else { for (; _ < 3; ++_) { if (this.pos >= this.len) throw a(this); if (f.lo = (f.lo | (this.buf[this.pos] & 127) << _ * 7) >>> 0, this.buf[this.pos++] < 128) return f } return f.lo = (f.lo | (this.buf[this.pos++] & 127) << _ * 7) >>> 0, f } if (this.len - this.pos > 4) { for (; _ < 5; ++_)if (f.hi = (f.hi | (this.buf[this.pos] & 127) << _ * 7 + 3) >>> 0, this.buf[this.pos++] < 128) return f } else for (; _ < 5; ++_) { if (this.pos >= this.len) throw a(this); if (f.hi = (f.hi | (this.buf[this.pos] & 127) << _ * 7 + 3) >>> 0, this.buf[this.pos++] < 128) return f } throw Error("invalid varint encoding") } o.prototype.bool = function () { return this.uint32() !== 0 }; function d(f, _) { return (f[_ - 4] | f[_ - 3] << 8 | f[_ - 2] << 16 | f[_ - 1] << 24) >>> 0 } o.prototype.fixed32 = function () { if (this.pos + 4 > this.len) throw a(this, 4); return d(this.buf, this.pos += 4) }, o.prototype.sfixed32 = function () { if (this.pos + 4 > this.len) throw a(this, 4); return d(this.buf, this.pos += 4) | 0 }; function p() { if (this.pos + 8 > this.len) throw a(this, 8); return new i(d(this.buf, this.pos += 4), d(this.buf, this.pos += 4)) } return o.prototype.float = function () { if (this.pos + 4 > this.len) throw a(this, 4); var _ = r.float.readFloatLE(this.buf, this.pos); return this.pos += 4, _ }, o.prototype.double = function () { if (this.pos + 8 > this.len) throw a(this, 4); var _ = r.float.readDoubleLE(this.buf, this.pos); return this.pos += 8, _ }, o.prototype.bytes = function () { var _ = this.uint32(), x = this.pos, b = this.pos + _; if (b > this.len) throw a(this, _); if (this.pos += _, Array.isArray(this.buf)) return this.buf.slice(x, b); if (x === b) { var T = r.Buffer; return T ? T.alloc(0) : new this.buf.constructor(0) } return this._slice.call(this.buf, x, b) }, o.prototype.string = function () { var _ = this.bytes(); return s.read(_, 0, _.length) }, o.prototype.skip = function (_) { if (typeof _ == "number") { if (this.pos + _ > this.len) throw a(this, _); this.pos += _ } else do if (this.pos >= this.len) throw a(this); while (this.buf[this.pos++] & 128); return this }, o.prototype.skipType = function (f) { switch (f) { case 0: this.skip(); break; case 1: this.skip(8); break; case 2: this.skip(this.uint32()); break; case 3: for (; (f = this.uint32() & 7) !== 4;)this.skipType(f); break; case 5: this.skip(4); break; default: throw Error("invalid wire type " + f + " at offset " + this.pos) }return this }, o._configure = function (f) { e = f, o.create = c(), e._configure(); var _ = r.Long ? "toLong" : "toNumber"; r.merge(o.prototype, { int64: function () { return h.call(this)[_](!1) }, uint64: function () { return h.call(this)[_](!0) }, sint64: function () { return h.call(this).zzDecode()[_](!1) }, fixed64: function () { return p.call(this)[_](!0) }, sfixed64: function () { return p.call(this)[_](!1) } }) }, reader } var reader_buffer, hasRequiredReader_buffer; function requireReader_buffer() { if (hasRequiredReader_buffer) return reader_buffer; hasRequiredReader_buffer = 1, reader_buffer = i; var r = requireReader(); (i.prototype = Object.create(r.prototype)).constructor = i; var e = requireMinimal(); function i(s) { r.call(this, s) } return i._configure = function () { e.Buffer && (i.prototype._slice = e.Buffer.prototype.slice) }, i.prototype.string = function () { var a = this.uint32(); return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + a, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + a, this.len)) }, i._configure(), reader_buffer } var rpc = {}, service$1, hasRequiredService$1; function requireService$1() { if (hasRequiredService$1) return service$1; hasRequiredService$1 = 1, service$1 = e; var r = requireMinimal(); (e.prototype = Object.create(r.EventEmitter.prototype)).constructor = e; function e(i, s, a) { if (typeof i != "function") throw TypeError("rpcImpl must be a function"); r.EventEmitter.call(this), this.rpcImpl = i, this.requestDelimited = !!s, this.responseDelimited = !!a } return e.prototype.rpcCall = function i(s, a, o, l, c) { if (!l) throw TypeError("request must be specified"); var h = this; if (!c) return r.asPromise(i, h, s, a, o, l); if (!h.rpcImpl) { setTimeout(function () { c(Error("already ended")) }, 0); return } try { return h.rpcImpl(s, a[h.requestDelimited ? "encodeDelimited" : "encode"](l).finish(), function (p, f) { if (p) return h.emit("error", p, s), c(p); if (f === null) { h.end(!0); return } if (!(f instanceof o)) try { f = o[h.responseDelimited ? "decodeDelimited" : "decode"](f) } catch (_) { return h.emit("error", _, s), c(_) } return h.emit("data", f, s), c(null, f) }) } catch (d) { h.emit("error", d, s), setTimeout(function () { c(d) }, 0); return } }, e.prototype.end = function (s) { return this.rpcImpl && (s || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit("end").off()), this }, service$1 } var hasRequiredRpc; function requireRpc() { return hasRequiredRpc || (hasRequiredRpc = 1, function (r) { var e = r; e.Service = requireService$1() }(rpc)), rpc } var roots, hasRequiredRoots; function requireRoots() { return hasRequiredRoots || (hasRequiredRoots = 1, roots = {}), roots } var hasRequiredIndexMinimal; function requireIndexMinimal() { return hasRequiredIndexMinimal || (hasRequiredIndexMinimal = 1, function (r) { var e = r; e.build = "minimal", e.Writer = requireWriter(), e.BufferWriter = requireWriter_buffer(), e.Reader = requireReader(), e.BufferReader = requireReader_buffer(), e.util = requireMinimal(), e.rpc = requireRpc(), e.roots = requireRoots(), e.configure = i; function i() { e.util._configure(), e.Writer._configure(e.BufferWriter), e.Reader._configure(e.BufferReader) } i() }(indexMinimal)), indexMinimal } var types = {}, util = { exports: {} }, codegen_1, hasRequiredCodegen; function requireCodegen() {
    if (hasRequiredCodegen) return codegen_1; hasRequiredCodegen = 1, codegen_1 = r; function r(e, i) {
        typeof e == "string" && (i = e, e = void 0); var s = []; function a(l) { if (typeof l != "string") { var c = o(); if (r.verbose && console.log("codegen: " + c), c = "return " + c, l) { for (var h = Object.keys(l), d = new Array(h.length + 1), p = new Array(h.length), f = 0; f < h.length;)d[f] = h[f], p[f] = l[h[f++]]; return d[f] = c, Function.apply(null, d).apply(null, p) } return Function(c)() } for (var _ = new Array(arguments.length - 1), x = 0; x < _.length;)_[x] = arguments[++x]; if (x = 0, l = l.replace(/%([%dfijs])/g, function (T, M) { var w = _[x++]; switch (M) { case "d": case "f": return String(Number(w)); case "i": return String(Math.floor(w)); case "j": return JSON.stringify(w); case "s": return String(w) }return "%" }), x !== _.length) throw Error("parameter count mismatch"); return s.push(l), a } function o(l) {
            return "function " + (l || i || "") + "(" + (e && e.join(",") || "") + `){
  `+ s.join(`
  `) + `
}`} return a.toString = o, a
    } return r.verbose = !1, codegen_1
} var fetch_1, hasRequiredFetch; function requireFetch() { if (hasRequiredFetch) return fetch_1; hasRequiredFetch = 1, fetch_1 = s; var r = requireAspromise(), e = requireInquire(), i = e("fs"); function s(a, o, l) { return typeof o == "function" ? (l = o, o = {}) : o || (o = {}), l ? !o.xhr && i && i.readFile ? i.readFile(a, function (h, d) { return h && typeof XMLHttpRequest < "u" ? s.xhr(a, o, l) : h ? l(h) : l(null, o.binary ? d : d.toString("utf8")) }) : s.xhr(a, o, l) : r(s, this, a, o) } return s.xhr = function (o, l, c) { var h = new XMLHttpRequest; h.onreadystatechange = function () { if (h.readyState === 4) { if (h.status !== 0 && h.status !== 200) return c(Error("status " + h.status)); if (l.binary) { var p = h.response; if (!p) { p = []; for (var f = 0; f < h.responseText.length; ++f)p.push(h.responseText.charCodeAt(f) & 255) } return c(null, typeof Uint8Array < "u" ? new Uint8Array(p) : p) } return c(null, h.responseText) } }, l.binary && ("overrideMimeType" in h && h.overrideMimeType("text/plain; charset=x-user-defined"), h.responseType = "arraybuffer"), h.open("GET", o), h.send() }, fetch_1 } var path = {}, hasRequiredPath; function requirePath() { return hasRequiredPath || (hasRequiredPath = 1, function (r) { var e = r, i = e.isAbsolute = function (o) { return /^(?:\/|\w+:)/.test(o) }, s = e.normalize = function (o) { o = o.replace(/\\/g, "/").replace(/\/{2,}/g, "/"); var l = o.split("/"), c = i(o), h = ""; c && (h = l.shift() + "/"); for (var d = 0; d < l.length;)l[d] === ".." ? d > 0 && l[d - 1] !== ".." ? l.splice(--d, 2) : c ? l.splice(d, 1) : ++d : l[d] === "." ? l.splice(d, 1) : ++d; return h + l.join("/") }; e.resolve = function (o, l, c) { return c || (l = s(l)), i(l) ? l : (c || (o = s(o)), (o = o.replace(/(?:\/|^)[^/]+$/, "")).length ? s(o + "/" + l) : l) } }(path)), path } var namespace, hasRequiredNamespace; function requireNamespace() { if (hasRequiredNamespace) return namespace; hasRequiredNamespace = 1, namespace = h; var r = requireObject(); ((h.prototype = Object.create(r.prototype)).constructor = h).className = "Namespace"; var e = requireField(), i = requireUtil(), s = requireOneof(), a, o, l; h.fromJSON = function (f, _) { return new h(f, _.options).addJSON(_.nested) }; function c(p, f) { if (p && p.length) { for (var _ = {}, x = 0; x < p.length; ++x)_[p[x].name] = p[x].toJSON(f); return _ } } h.arrayToJSON = c, h.isReservedId = function (f, _) { if (f) { for (var x = 0; x < f.length; ++x)if (typeof f[x] != "string" && f[x][0] <= _ && f[x][1] > _) return !0 } return !1 }, h.isReservedName = function (f, _) { if (f) { for (var x = 0; x < f.length; ++x)if (f[x] === _) return !0 } return !1 }; function h(p, f) { r.call(this, p, f), this.nested = void 0, this._nestedArray = null, this._lookupCache = {}, this._needsRecursiveFeatureResolution = !0, this._needsRecursiveResolve = !0 } function d(p) { p._nestedArray = null, p._lookupCache = {}; for (var f = p; f = f.parent;)f._lookupCache = {}; return p } return Object.defineProperty(h.prototype, "nestedArray", { get: function () { return this._nestedArray || (this._nestedArray = i.toArray(this.nested)) } }), h.prototype.toJSON = function (f) { return i.toObject(["options", this.options, "nested", c(this.nestedArray, f)]) }, h.prototype.addJSON = function (f) { var _ = this; if (f) for (var x = Object.keys(f), b = 0, T; b < x.length; ++b)T = f[x[b]], _.add((T.fields !== void 0 ? a.fromJSON : T.values !== void 0 ? l.fromJSON : T.methods !== void 0 ? o.fromJSON : T.id !== void 0 ? e.fromJSON : h.fromJSON)(x[b], T)); return this }, h.prototype.get = function (f) { return this.nested && this.nested[f] || null }, h.prototype.getEnum = function (f) { if (this.nested && this.nested[f] instanceof l) return this.nested[f].values; throw Error("no such enum: " + f) }, h.prototype.add = function (f) { if (!(f instanceof e && f.extend !== void 0 || f instanceof a || f instanceof s || f instanceof l || f instanceof o || f instanceof h)) throw TypeError("object must be a valid nested object"); if (!this.nested) this.nested = {}; else { var _ = this.get(f.name); if (_) if (_ instanceof h && f instanceof h && !(_ instanceof a || _ instanceof o)) { for (var x = _.nestedArray, b = 0; b < x.length; ++b)f.add(x[b]); this.remove(_), this.nested || (this.nested = {}), f.setOptions(_.options, !0) } else throw Error("duplicate name '" + f.name + "' in " + this) } this.nested[f.name] = f, this instanceof a || this instanceof o || this instanceof l || this instanceof e || f._edition || (f._edition = f._defaultEdition), this._needsRecursiveFeatureResolution = !0, this._needsRecursiveResolve = !0; for (var T = this; T = T.parent;)T._needsRecursiveFeatureResolution = !0, T._needsRecursiveResolve = !0; return f.onAdd(this), d(this) }, h.prototype.remove = function (f) { if (!(f instanceof r)) throw TypeError("object must be a ReflectionObject"); if (f.parent !== this) throw Error(f + " is not a member of " + this); return delete this.nested[f.name], Object.keys(this.nested).length || (this.nested = void 0), f.onRemove(this), d(this) }, h.prototype.define = function (f, _) { if (i.isString(f)) f = f.split("."); else if (!Array.isArray(f)) throw TypeError("illegal path"); if (f && f.length && f[0] === "") throw Error("path must be relative"); for (var x = this; f.length > 0;) { var b = f.shift(); if (x.nested && x.nested[b]) { if (x = x.nested[b], !(x instanceof h)) throw Error("path conflicts with non-namespace objects") } else x.add(x = new h(b)) } return _ && x.addJSON(_), x }, h.prototype.resolveAll = function () { if (!this._needsRecursiveResolve) return this; this._resolveFeaturesRecursive(this._edition); var f = this.nestedArray, _ = 0; for (this.resolve(); _ < f.length;)f[_] instanceof h ? f[_++].resolveAll() : f[_++].resolve(); return this._needsRecursiveResolve = !1, this }, h.prototype._resolveFeaturesRecursive = function (f) { return this._needsRecursiveFeatureResolution ? (this._needsRecursiveFeatureResolution = !1, f = this._edition || f, r.prototype._resolveFeaturesRecursive.call(this, f), this.nestedArray.forEach(_ => { _._resolveFeaturesRecursive(f) }), this) : this }, h.prototype.lookup = function (f, _, x) { if (typeof _ == "boolean" ? (x = _, _ = void 0) : _ && !Array.isArray(_) && (_ = [_]), i.isString(f) && f.length) { if (f === ".") return this.root; f = f.split(".") } else if (!f.length) return this; var b = f.join("."); if (f[0] === "") return this.root.lookup(f.slice(1), _); var T = this.root._fullyQualifiedObjects && this.root._fullyQualifiedObjects["." + b]; if (T && (!_ || _.indexOf(T.constructor) > -1) || (T = this._lookupImpl(f, b), T && (!_ || _.indexOf(T.constructor) > -1))) return T; if (x) return null; for (var M = this; M.parent;) { if (T = M.parent._lookupImpl(f, b), T && (!_ || _.indexOf(T.constructor) > -1)) return T; M = M.parent } return null }, h.prototype._lookupImpl = function (f, _) { if (Object.prototype.hasOwnProperty.call(this._lookupCache, _)) return this._lookupCache[_]; var x = this.get(f[0]), b = null; if (x) f.length === 1 ? b = x : x instanceof h && (f = f.slice(1), b = x._lookupImpl(f, f.join("."))); else for (var T = 0; T < this.nestedArray.length; ++T)this._nestedArray[T] instanceof h && (x = this._nestedArray[T]._lookupImpl(f, _)) && (b = x); return this._lookupCache[_] = b, b }, h.prototype.lookupType = function (f) { var _ = this.lookup(f, [a]); if (!_) throw Error("no such type: " + f); return _ }, h.prototype.lookupEnum = function (f) { var _ = this.lookup(f, [l]); if (!_) throw Error("no such Enum '" + f + "' in " + this); return _ }, h.prototype.lookupTypeOrEnum = function (f) { var _ = this.lookup(f, [a, l]); if (!_) throw Error("no such Type or Enum '" + f + "' in " + this); return _ }, h.prototype.lookupService = function (f) { var _ = this.lookup(f, [o]); if (!_) throw Error("no such Service '" + f + "' in " + this); return _ }, h._configure = function (p, f, _) { a = p, o = f, l = _ }, namespace } var mapfield, hasRequiredMapfield; function requireMapfield() { if (hasRequiredMapfield) return mapfield; hasRequiredMapfield = 1, mapfield = s; var r = requireField(); ((s.prototype = Object.create(r.prototype)).constructor = s).className = "MapField"; var e = requireTypes(), i = requireUtil(); function s(a, o, l, c, h, d) { if (r.call(this, a, o, c, void 0, void 0, h, d), !i.isString(l)) throw TypeError("keyType must be a string"); this.keyType = l, this.resolvedKeyType = null, this.map = !0 } return s.fromJSON = function (o, l) { return new s(o, l.id, l.keyType, l.type, l.options, l.comment) }, s.prototype.toJSON = function (o) { var l = o ? !!o.keepComments : !1; return i.toObject(["keyType", this.keyType, "type", this.type, "id", this.id, "extend", this.extend, "options", this.options, "comment", l ? this.comment : void 0]) }, s.prototype.resolve = function () { if (this.resolved) return this; if (e.mapKey[this.keyType] === void 0) throw Error("invalid key type: " + this.keyType); return r.prototype.resolve.call(this) }, s.d = function (o, l, c) { return typeof c == "function" ? c = i.decorateType(c).name : c && typeof c == "object" && (c = i.decorateEnum(c).name), function (d, p) { i.decorateType(d.constructor).add(new s(p, o, l, c)) } }, mapfield } var method, hasRequiredMethod; function requireMethod() { if (hasRequiredMethod) return method; hasRequiredMethod = 1, method = i; var r = requireObject(); ((i.prototype = Object.create(r.prototype)).constructor = i).className = "Method"; var e = requireUtil(); function i(s, a, o, l, c, h, d, p, f) { if (e.isObject(c) ? (d = c, c = h = void 0) : e.isObject(h) && (d = h, h = void 0), !(a === void 0 || e.isString(a))) throw TypeError("type must be a string"); if (!e.isString(o)) throw TypeError("requestType must be a string"); if (!e.isString(l)) throw TypeError("responseType must be a string"); r.call(this, s, d), this.type = a || "rpc", this.requestType = o, this.requestStream = c ? !0 : void 0, this.responseType = l, this.responseStream = h ? !0 : void 0, this.resolvedRequestType = null, this.resolvedResponseType = null, this.comment = p, this.parsedOptions = f } return i.fromJSON = function (a, o) { return new i(a, o.type, o.requestType, o.responseType, o.requestStream, o.responseStream, o.options, o.comment, o.parsedOptions) }, i.prototype.toJSON = function (a) { var o = a ? !!a.keepComments : !1; return e.toObject(["type", this.type !== "rpc" && this.type || void 0, "requestType", this.requestType, "requestStream", this.requestStream, "responseType", this.responseType, "responseStream", this.responseStream, "options", this.options, "comment", o ? this.comment : void 0, "parsedOptions", this.parsedOptions]) }, i.prototype.resolve = function () { return this.resolved ? this : (this.resolvedRequestType = this.parent.lookupType(this.requestType), this.resolvedResponseType = this.parent.lookupType(this.responseType), r.prototype.resolve.call(this)) }, method } var service, hasRequiredService; function requireService() { if (hasRequiredService) return service; hasRequiredService = 1, service = a; var r = requireNamespace(); ((a.prototype = Object.create(r.prototype)).constructor = a).className = "Service"; var e = requireMethod(), i = requireUtil(), s = requireRpc(); function a(l, c) { r.call(this, l, c), this.methods = {}, this._methodsArray = null } a.fromJSON = function (c, h) { var d = new a(c, h.options); if (h.methods) for (var p = Object.keys(h.methods), f = 0; f < p.length; ++f)d.add(e.fromJSON(p[f], h.methods[p[f]])); return h.nested && d.addJSON(h.nested), h.edition && (d._edition = h.edition), d.comment = h.comment, d._defaultEdition = "proto3", d }, a.prototype.toJSON = function (c) { var h = r.prototype.toJSON.call(this, c), d = c ? !!c.keepComments : !1; return i.toObject(["edition", this._editionToJSON(), "options", h && h.options || void 0, "methods", r.arrayToJSON(this.methodsArray, c) || {}, "nested", h && h.nested || void 0, "comment", d ? this.comment : void 0]) }, Object.defineProperty(a.prototype, "methodsArray", { get: function () { return this._methodsArray || (this._methodsArray = i.toArray(this.methods)) } }); function o(l) { return l._methodsArray = null, l } return a.prototype.get = function (c) { return this.methods[c] || r.prototype.get.call(this, c) }, a.prototype.resolveAll = function () { if (!this._needsRecursiveResolve) return this; r.prototype.resolve.call(this); for (var c = this.methodsArray, h = 0; h < c.length; ++h)c[h].resolve(); return this }, a.prototype._resolveFeaturesRecursive = function (c) { return this._needsRecursiveFeatureResolution ? (c = this._edition || c, r.prototype._resolveFeaturesRecursive.call(this, c), this.methodsArray.forEach(h => { h._resolveFeaturesRecursive(c) }), this) : this }, a.prototype.add = function (c) { if (this.get(c.name)) throw Error("duplicate name '" + c.name + "' in " + this); return c instanceof e ? (this.methods[c.name] = c, c.parent = this, o(this)) : r.prototype.add.call(this, c) }, a.prototype.remove = function (c) { if (c instanceof e) { if (this.methods[c.name] !== c) throw Error(c + " is not a member of " + this); return delete this.methods[c.name], c.parent = null, o(this) } return r.prototype.remove.call(this, c) }, a.prototype.create = function (c, h, d) { for (var p = new s.Service(c, h, d), f = 0, _; f < this.methodsArray.length; ++f) { var x = i.lcFirst((_ = this._methodsArray[f]).resolve().name).replace(/[^$\w_]/g, ""); p[x] = i.codegen(["r", "c"], i.isReserved(x) ? x + "_" : x)("return this.rpcCall(m,q,s,r,c)")({ m: _, q: _.resolvedRequestType.ctor, s: _.resolvedResponseType.ctor }) } return p }, service } var message, hasRequiredMessage; function requireMessage() { if (hasRequiredMessage) return message; hasRequiredMessage = 1, message = e; var r = requireMinimal(); function e(i) { if (i) for (var s = Object.keys(i), a = 0; a < s.length; ++a)this[s[a]] = i[s[a]] } return e.create = function (s) { return this.$type.create(s) }, e.encode = function (s, a) { return this.$type.encode(s, a) }, e.encodeDelimited = function (s, a) { return this.$type.encodeDelimited(s, a) }, e.decode = function (s) { return this.$type.decode(s) }, e.decodeDelimited = function (s) { return this.$type.decodeDelimited(s) }, e.verify = function (s) { return this.$type.verify(s) }, e.fromObject = function (s) { return this.$type.fromObject(s) }, e.toObject = function (s, a) { return this.$type.toObject(s, a) }, e.prototype.toJSON = function () { return this.$type.toObject(this, r.toJSONOptions) }, message } var decoder_1, hasRequiredDecoder; function requireDecoder() { if (hasRequiredDecoder) return decoder_1; hasRequiredDecoder = 1, decoder_1 = a; var r = require_enum(), e = requireTypes(), i = requireUtil(); function s(o) { return "missing required '" + o.name + "'" } function a(o) { for (var l = i.codegen(["r", "l", "e"], o.name + "$decode")("if(!(r instanceof Reader))")("r=Reader.create(r)")("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (o.fieldsArray.filter(function (_) { return _.map }).length ? ",k,value" : ""))("while(r.pos<c){")("var t=r.uint32()")("if(t===e)")("break")("switch(t>>>3){"), c = 0; c < o.fieldsArray.length; ++c) { var h = o._fieldsArray[c].resolve(), d = h.resolvedType instanceof r ? "int32" : h.type, p = "m" + i.safeProp(h.name); l("case %i: {", h.id), h.map ? (l("if(%s===util.emptyObject)", p)("%s={}", p)("var c2 = r.uint32()+r.pos"), e.defaults[h.keyType] !== void 0 ? l("k=%j", e.defaults[h.keyType]) : l("k=null"), e.defaults[d] !== void 0 ? l("value=%j", e.defaults[d]) : l("value=null"), l("while(r.pos<c2){")("var tag2=r.uint32()")("switch(tag2>>>3){")("case 1: k=r.%s(); break", h.keyType)("case 2:"), e.basic[d] === void 0 ? l("value=types[%i].decode(r,r.uint32())", c) : l("value=r.%s()", d), l("break")("default:")("r.skipType(tag2&7)")("break")("}")("}"), e.long[h.keyType] !== void 0 ? l('%s[typeof k==="object"?util.longToHash(k):k]=value', p) : l("%s[k]=value", p)) : h.repeated ? (l("if(!(%s&&%s.length))", p, p)("%s=[]", p), e.packed[d] !== void 0 && l("if((t&7)===2){")("var c2=r.uint32()+r.pos")("while(r.pos<c2)")("%s.push(r.%s())", p, d)("}else"), e.basic[d] === void 0 ? l(h.delimited ? "%s.push(types[%i].decode(r,undefined,((t&~7)|4)))" : "%s.push(types[%i].decode(r,r.uint32()))", p, c) : l("%s.push(r.%s())", p, d)) : e.basic[d] === void 0 ? l(h.delimited ? "%s=types[%i].decode(r,undefined,((t&~7)|4))" : "%s=types[%i].decode(r,r.uint32())", p, c) : l("%s=r.%s()", p, d), l("break")("}") } for (l("default:")("r.skipType(t&7)")("break")("}")("}"), c = 0; c < o._fieldsArray.length; ++c) { var f = o._fieldsArray[c]; f.required && l("if(!m.hasOwnProperty(%j))", f.name)("throw util.ProtocolError(%j,{instance:m})", s(f)) } return l("return m") } return decoder_1 } var verifier_1, hasRequiredVerifier; function requireVerifier() { if (hasRequiredVerifier) return verifier_1; hasRequiredVerifier = 1, verifier_1 = o; var r = require_enum(), e = requireUtil(); function i(l, c) { return l.name + ": " + c + (l.repeated && c !== "array" ? "[]" : l.map && c !== "object" ? "{k:" + l.keyType + "}" : "") + " expected" } function s(l, c, h, d) { if (c.resolvedType) if (c.resolvedType instanceof r) { l("switch(%s){", d)("default:")("return%j", i(c, "enum value")); for (var p = Object.keys(c.resolvedType.values), f = 0; f < p.length; ++f)l("case %i:", c.resolvedType.values[p[f]]); l("break")("}") } else l("{")("var e=types[%i].verify(%s);", h, d)("if(e)")("return%j+e", c.name + ".")("}"); else switch (c.type) { case "int32": case "uint32": case "sint32": case "fixed32": case "sfixed32": l("if(!util.isInteger(%s))", d)("return%j", i(c, "integer")); break; case "int64": case "uint64": case "sint64": case "fixed64": case "sfixed64": l("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", d, d, d, d)("return%j", i(c, "integer|Long")); break; case "float": case "double": l('if(typeof %s!=="number")', d)("return%j", i(c, "number")); break; case "bool": l('if(typeof %s!=="boolean")', d)("return%j", i(c, "boolean")); break; case "string": l("if(!util.isString(%s))", d)("return%j", i(c, "string")); break; case "bytes": l('if(!(%s&&typeof %s.length==="number"||util.isString(%s)))', d, d, d)("return%j", i(c, "buffer")); break }return l } function a(l, c, h) { switch (c.keyType) { case "int32": case "uint32": case "sint32": case "fixed32": case "sfixed32": l("if(!util.key32Re.test(%s))", h)("return%j", i(c, "integer key")); break; case "int64": case "uint64": case "sint64": case "fixed64": case "sfixed64": l("if(!util.key64Re.test(%s))", h)("return%j", i(c, "integer|Long key")); break; case "bool": l("if(!util.key2Re.test(%s))", h)("return%j", i(c, "boolean key")); break }return l } function o(l) { var c = e.codegen(["m"], l.name + "$verify")('if(typeof m!=="object"||m===null)')("return%j", "object expected"), h = l.oneofsArray, d = {}; h.length && c("var p={}"); for (var p = 0; p < l.fieldsArray.length; ++p) { var f = l._fieldsArray[p].resolve(), _ = "m" + e.safeProp(f.name); if (f.optional && c("if(%s!=null&&m.hasOwnProperty(%j)){", _, f.name), f.map) c("if(!util.isObject(%s))", _)("return%j", i(f, "object"))("var k=Object.keys(%s)", _)("for(var i=0;i<k.length;++i){"), a(c, f, "k[i]"), s(c, f, p, _ + "[k[i]]")("}"); else if (f.repeated) c("if(!Array.isArray(%s))", _)("return%j", i(f, "array"))("for(var i=0;i<%s.length;++i){", _), s(c, f, p, _ + "[i]")("}"); else { if (f.partOf) { var x = e.safeProp(f.partOf.name); d[f.partOf.name] === 1 && c("if(p%s===1)", x)("return%j", f.partOf.name + ": multiple values"), d[f.partOf.name] = 1, c("p%s=1", x) } s(c, f, p, _) } f.optional && c("}") } return c("return null") } return verifier_1 } var converter = {}, hasRequiredConverter; function requireConverter() { return hasRequiredConverter || (hasRequiredConverter = 1, function (r) { var e = r, i = require_enum(), s = requireUtil(); function a(l, c, h, d) { var p = !1; if (c.resolvedType) if (c.resolvedType instanceof i) { l("switch(d%s){", d); for (var f = c.resolvedType.values, _ = Object.keys(f), x = 0; x < _.length; ++x)f[_[x]] === c.typeDefault && !p && (l("default:")('if(typeof(d%s)==="number"){m%s=d%s;break}', d, d, d), c.repeated || l("break"), p = !0), l("case%j:", _[x])("case %i:", f[_[x]])("m%s=%j", d, f[_[x]])("break"); l("}") } else l('if(typeof d%s!=="object")', d)("throw TypeError(%j)", c.fullName + ": object expected")("m%s=types[%i].fromObject(d%s)", d, h, d); else { var b = !1; switch (c.type) { case "double": case "float": l("m%s=Number(d%s)", d, d); break; case "uint32": case "fixed32": l("m%s=d%s>>>0", d, d); break; case "int32": case "sint32": case "sfixed32": l("m%s=d%s|0", d, d); break; case "uint64": b = !0; case "int64": case "sint64": case "fixed64": case "sfixed64": l("if(util.Long)")("(m%s=util.Long.fromValue(d%s)).unsigned=%j", d, d, b)('else if(typeof d%s==="string")', d)("m%s=parseInt(d%s,10)", d, d)('else if(typeof d%s==="number")', d)("m%s=d%s", d, d)('else if(typeof d%s==="object")', d)("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", d, d, d, b ? "true" : ""); break; case "bytes": l('if(typeof d%s==="string")', d)("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", d, d, d)("else if(d%s.length >= 0)", d)("m%s=d%s", d, d); break; case "string": l("m%s=String(d%s)", d, d); break; case "bool": l("m%s=Boolean(d%s)", d, d); break } } return l } e.fromObject = function (c) { var h = c.fieldsArray, d = s.codegen(["d"], c.name + "$fromObject")("if(d instanceof this.ctor)")("return d"); if (!h.length) return d("return new this.ctor"); d("var m=new this.ctor"); for (var p = 0; p < h.length; ++p) { var f = h[p].resolve(), _ = s.safeProp(f.name); f.map ? (d("if(d%s){", _)('if(typeof d%s!=="object")', _)("throw TypeError(%j)", f.fullName + ": object expected")("m%s={}", _)("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", _), a(d, f, p, _ + "[ks[i]]")("}")("}")) : f.repeated ? (d("if(d%s){", _)("if(!Array.isArray(d%s))", _)("throw TypeError(%j)", f.fullName + ": array expected")("m%s=[]", _)("for(var i=0;i<d%s.length;++i){", _), a(d, f, p, _ + "[i]")("}")("}")) : (f.resolvedType instanceof i || d("if(d%s!=null){", _), a(d, f, p, _), f.resolvedType instanceof i || d("}")) } return d("return m") }; function o(l, c, h, d) { if (c.resolvedType) c.resolvedType instanceof i ? l("d%s=o.enums===String?(types[%i].values[m%s]===undefined?m%s:types[%i].values[m%s]):m%s", d, h, d, d, h, d, d) : l("d%s=types[%i].toObject(m%s,o)", d, h, d); else { var p = !1; switch (c.type) { case "double": case "float": l("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", d, d, d, d); break; case "uint64": p = !0; case "int64": case "sint64": case "fixed64": case "sfixed64": l('if(typeof m%s==="number")', d)("d%s=o.longs===String?String(m%s):m%s", d, d, d)("else")("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s", d, d, d, d, p ? "true" : "", d); break; case "bytes": l("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s", d, d, d, d, d); break; default: l("d%s=m%s", d, d); break } } return l } e.toObject = function (c) { var h = c.fieldsArray.slice().sort(s.compareFieldsById); if (!h.length) return s.codegen()("return {}"); for (var d = s.codegen(["m", "o"], c.name + "$toObject")("if(!o)")("o={}")("var d={}"), p = [], f = [], _ = [], x = 0; x < h.length; ++x)h[x].partOf || (h[x].resolve().repeated ? p : h[x].map ? f : _).push(h[x]); if (p.length) { for (d("if(o.arrays||o.defaults){"), x = 0; x < p.length; ++x)d("d%s=[]", s.safeProp(p[x].name)); d("}") } if (f.length) { for (d("if(o.objects||o.defaults){"), x = 0; x < f.length; ++x)d("d%s={}", s.safeProp(f[x].name)); d("}") } if (_.length) { for (d("if(o.defaults){"), x = 0; x < _.length; ++x) { var b = _[x], T = s.safeProp(b.name); if (b.resolvedType instanceof i) d("d%s=o.enums===String?%j:%j", T, b.resolvedType.valuesById[b.typeDefault], b.typeDefault); else if (b.long) d("if(util.Long){")("var n=new util.Long(%i,%i,%j)", b.typeDefault.low, b.typeDefault.high, b.typeDefault.unsigned)("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", T)("}else")("d%s=o.longs===String?%j:%i", T, b.typeDefault.toString(), b.typeDefault.toNumber()); else if (b.bytes) { var M = "[" + Array.prototype.slice.call(b.typeDefault).join(",") + "]"; d("if(o.bytes===String)d%s=%j", T, String.fromCharCode.apply(String, b.typeDefault))("else{")("d%s=%s", T, M)("if(o.bytes!==Array)d%s=util.newBuffer(d%s)", T, T)("}") } else d("d%s=%j", T, b.typeDefault) } d("}") } var w = !1; for (x = 0; x < h.length; ++x) { var b = h[x], D = c._fieldsArray.indexOf(b), T = s.safeProp(b.name); b.map ? (w || (w = !0, d("var ks2")), d("if(m%s&&(ks2=Object.keys(m%s)).length){", T, T)("d%s={}", T)("for(var j=0;j<ks2.length;++j){"), o(d, b, D, T + "[ks2[j]]")("}")) : b.repeated ? (d("if(m%s&&m%s.length){", T, T)("d%s=[]", T)("for(var j=0;j<m%s.length;++j){", T), o(d, b, D, T + "[j]")("}")) : (d("if(m%s!=null&&m.hasOwnProperty(%j)){", T, b.name), o(d, b, D, T), b.partOf && d("if(o.oneofs)")("d%s=%j", s.safeProp(b.partOf.name), b.name)), d("}") } return d("return d") } }(converter)), converter } var wrappers = {}, hasRequiredWrappers; function requireWrappers() { return hasRequiredWrappers || (hasRequiredWrappers = 1, function (r) { var e = r, i = requireMessage(); e[".google.protobuf.Any"] = { fromObject: function (s) { if (s && s["@type"]) { var a = s["@type"].substring(s["@type"].lastIndexOf("/") + 1), o = this.lookup(a); if (o) { var l = s["@type"].charAt(0) === "." ? s["@type"].slice(1) : s["@type"]; return l.indexOf("/") === -1 && (l = "/" + l), this.create({ type_url: l, value: o.encode(o.fromObject(s)).finish() }) } } return this.fromObject(s) }, toObject: function (s, a) { var o = "type.googleapis.com/", l = "", c = ""; if (a && a.json && s.type_url && s.value) { c = s.type_url.substring(s.type_url.lastIndexOf("/") + 1), l = s.type_url.substring(0, s.type_url.lastIndexOf("/") + 1); var h = this.lookup(c); h && (s = h.decode(s.value)) } if (!(s instanceof this.ctor) && s instanceof i) { var d = s.$type.toObject(s, a), p = s.$type.fullName[0] === "." ? s.$type.fullName.slice(1) : s.$type.fullName; return l === "" && (l = o), c = l + p, d["@type"] = c, d } return this.toObject(s, a) } } }(wrappers)), wrappers } var type, hasRequiredType; function requireType() { if (hasRequiredType) return type; hasRequiredType = 1, type = T; var r = requireNamespace(); ((T.prototype = Object.create(r.prototype)).constructor = T).className = "Type"; var e = require_enum(), i = requireOneof(), s = requireField(), a = requireMapfield(), o = requireService(), l = requireMessage(), c = requireReader(), h = requireWriter(), d = requireUtil(), p = requireEncoder(), f = requireDecoder(), _ = requireVerifier(), x = requireConverter(), b = requireWrappers(); function T(w, D) { r.call(this, w, D), this.fields = {}, this.oneofs = void 0, this.extensions = void 0, this.reserved = void 0, this.group = void 0, this._fieldsById = null, this._fieldsArray = null, this._oneofsArray = null, this._ctor = null } Object.defineProperties(T.prototype, { fieldsById: { get: function () { if (this._fieldsById) return this._fieldsById; this._fieldsById = {}; for (var w = Object.keys(this.fields), D = 0; D < w.length; ++D) { var R = this.fields[w[D]], P = R.id; if (this._fieldsById[P]) throw Error("duplicate id " + P + " in " + this); this._fieldsById[P] = R } return this._fieldsById } }, fieldsArray: { get: function () { return this._fieldsArray || (this._fieldsArray = d.toArray(this.fields)) } }, oneofsArray: { get: function () { return this._oneofsArray || (this._oneofsArray = d.toArray(this.oneofs)) } }, ctor: { get: function () { return this._ctor || (this.ctor = T.generateConstructor(this)()) }, set: function (w) { var D = w.prototype; D instanceof l || ((w.prototype = new l).constructor = w, d.merge(w.prototype, D)), w.$type = w.prototype.$type = this, d.merge(w, l, !0), this._ctor = w; for (var R = 0; R < this.fieldsArray.length; ++R)this._fieldsArray[R].resolve(); var P = {}; for (R = 0; R < this.oneofsArray.length; ++R)P[this._oneofsArray[R].resolve().name] = { get: d.oneOfGetter(this._oneofsArray[R].oneof), set: d.oneOfSetter(this._oneofsArray[R].oneof) }; R && Object.defineProperties(w.prototype, P) } } }), T.generateConstructor = function (D) { for (var R = d.codegen(["p"], D.name), P = 0, U; P < D.fieldsArray.length; ++P)(U = D._fieldsArray[P]).map ? R("this%s={}", d.safeProp(U.name)) : U.repeated && R("this%s=[]", d.safeProp(U.name)); return R("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)")("this[ks[i]]=p[ks[i]]") }; function M(w) { return w._fieldsById = w._fieldsArray = w._oneofsArray = null, delete w.encode, delete w.decode, delete w.verify, w } return T.fromJSON = function (D, R) { var P = new T(D, R.options); P.extensions = R.extensions, P.reserved = R.reserved; for (var U = Object.keys(R.fields), O = 0; O < U.length; ++O)P.add((typeof R.fields[U[O]].keyType < "u" ? a.fromJSON : s.fromJSON)(U[O], R.fields[U[O]])); if (R.oneofs) for (U = Object.keys(R.oneofs), O = 0; O < U.length; ++O)P.add(i.fromJSON(U[O], R.oneofs[U[O]])); if (R.nested) for (U = Object.keys(R.nested), O = 0; O < U.length; ++O) { var N = R.nested[U[O]]; P.add((N.id !== void 0 ? s.fromJSON : N.fields !== void 0 ? T.fromJSON : N.values !== void 0 ? e.fromJSON : N.methods !== void 0 ? o.fromJSON : r.fromJSON)(U[O], N)) } return R.extensions && R.extensions.length && (P.extensions = R.extensions), R.reserved && R.reserved.length && (P.reserved = R.reserved), R.group && (P.group = !0), R.comment && (P.comment = R.comment), R.edition && (P._edition = R.edition), P._defaultEdition = "proto3", P }, T.prototype.toJSON = function (D) { var R = r.prototype.toJSON.call(this, D), P = D ? !!D.keepComments : !1; return d.toObject(["edition", this._editionToJSON(), "options", R && R.options || void 0, "oneofs", r.arrayToJSON(this.oneofsArray, D), "fields", r.arrayToJSON(this.fieldsArray.filter(function (U) { return !U.declaringField }), D) || {}, "extensions", this.extensions && this.extensions.length ? this.extensions : void 0, "reserved", this.reserved && this.reserved.length ? this.reserved : void 0, "group", this.group || void 0, "nested", R && R.nested || void 0, "comment", P ? this.comment : void 0]) }, T.prototype.resolveAll = function () { if (!this._needsRecursiveResolve) return this; r.prototype.resolveAll.call(this); var D = this.oneofsArray; for (P = 0; P < D.length;)D[P++].resolve(); for (var R = this.fieldsArray, P = 0; P < R.length;)R[P++].resolve(); return this }, T.prototype._resolveFeaturesRecursive = function (D) { return this._needsRecursiveFeatureResolution ? (D = this._edition || D, r.prototype._resolveFeaturesRecursive.call(this, D), this.oneofsArray.forEach(R => { R._resolveFeatures(D) }), this.fieldsArray.forEach(R => { R._resolveFeatures(D) }), this) : this }, T.prototype.get = function (D) { return this.fields[D] || this.oneofs && this.oneofs[D] || this.nested && this.nested[D] || null }, T.prototype.add = function (D) { if (this.get(D.name)) throw Error("duplicate name '" + D.name + "' in " + this); if (D instanceof s && D.extend === void 0) { if (this._fieldsById ? this._fieldsById[D.id] : this.fieldsById[D.id]) throw Error("duplicate id " + D.id + " in " + this); if (this.isReservedId(D.id)) throw Error("id " + D.id + " is reserved in " + this); if (this.isReservedName(D.name)) throw Error("name '" + D.name + "' is reserved in " + this); return D.parent && D.parent.remove(D), this.fields[D.name] = D, D.message = this, D.onAdd(this), M(this) } return D instanceof i ? (this.oneofs || (this.oneofs = {}), this.oneofs[D.name] = D, D.onAdd(this), M(this)) : r.prototype.add.call(this, D) }, T.prototype.remove = function (D) { if (D instanceof s && D.extend === void 0) { if (!this.fields || this.fields[D.name] !== D) throw Error(D + " is not a member of " + this); return delete this.fields[D.name], D.parent = null, D.onRemove(this), M(this) } if (D instanceof i) { if (!this.oneofs || this.oneofs[D.name] !== D) throw Error(D + " is not a member of " + this); return delete this.oneofs[D.name], D.parent = null, D.onRemove(this), M(this) } return r.prototype.remove.call(this, D) }, T.prototype.isReservedId = function (D) { return r.isReservedId(this.reserved, D) }, T.prototype.isReservedName = function (D) { return r.isReservedName(this.reserved, D) }, T.prototype.create = function (D) { return new this.ctor(D) }, T.prototype.setup = function () { for (var D = this.fullName, R = [], P = 0; P < this.fieldsArray.length; ++P)R.push(this._fieldsArray[P].resolve().resolvedType); this.encode = p(this)({ Writer: h, types: R, util: d }), this.decode = f(this)({ Reader: c, types: R, util: d }), this.verify = _(this)({ types: R, util: d }), this.fromObject = x.fromObject(this)({ types: R, util: d }), this.toObject = x.toObject(this)({ types: R, util: d }); var U = b[D]; if (U) { var O = Object.create(this); O.fromObject = this.fromObject, this.fromObject = U.fromObject.bind(O), O.toObject = this.toObject, this.toObject = U.toObject.bind(O) } return this }, T.prototype.encode = function (D, R) { return this.setup().encode(D, R) }, T.prototype.encodeDelimited = function (D, R) { return this.encode(D, R && R.len ? R.fork() : R).ldelim() }, T.prototype.decode = function (D, R) { return this.setup().decode(D, R) }, T.prototype.decodeDelimited = function (D) { return D instanceof c || (D = c.create(D)), this.decode(D, D.uint32()) }, T.prototype.verify = function (D) { return this.setup().verify(D) }, T.prototype.fromObject = function (D) { return this.setup().fromObject(D) }, T.prototype.toObject = function (D, R) { return this.setup().toObject(D, R) }, T.d = function (D) { return function (P) { d.decorateType(P, D) } }, type } var root$2, hasRequiredRoot; function requireRoot() { if (hasRequiredRoot) return root$2; hasRequiredRoot = 1, root$2 = h; var r = requireNamespace(); ((h.prototype = Object.create(r.prototype)).constructor = h).className = "Root"; var e = requireField(), i = require_enum(), s = requireOneof(), a = requireUtil(), o, l, c; function h(_) { r.call(this, "", _), this.deferred = [], this.files = [], this._edition = "proto2", this._fullyQualifiedObjects = {} } h.fromJSON = function (x, b) { return b || (b = new h), x.options && b.setOptions(x.options), b.addJSON(x.nested).resolveAll() }, h.prototype.resolvePath = a.path.resolve, h.prototype.fetch = a.fetch; function d() { } h.prototype.load = function _(x, b, T) { typeof b == "function" && (T = b, b = void 0); var M = this; if (!T) return a.asPromise(_, M, x, b); var w = T === d; function D(F, k) { if (T) { if (w) throw F; k && k.resolveAll(); var W = T; T = null, W(F, k) } } function R(F) { var k = F.lastIndexOf("google/protobuf/"); if (k > -1) { var W = F.substring(k); if (W in c) return W } return null } function P(F, k) { try { if (a.isString(k) && k.charAt(0) === "{" && (k = JSON.parse(k)), !a.isString(k)) M.setOptions(k.options).addJSON(k.nested); else { l.filename = F; var W = l(k, M, b), $, Z = 0; if (W.imports) for (; Z < W.imports.length; ++Z)($ = R(W.imports[Z]) || M.resolvePath(F, W.imports[Z])) && U($); if (W.weakImports) for (Z = 0; Z < W.weakImports.length; ++Z)($ = R(W.weakImports[Z]) || M.resolvePath(F, W.weakImports[Z])) && U($, !0) } } catch (J) { D(J) } !w && !O && D(null, M) } function U(F, k) { if (F = R(F) || F, !(M.files.indexOf(F) > -1)) { if (M.files.push(F), F in c) { w ? P(F, c[F]) : (++O, setTimeout(function () { --O, P(F, c[F]) })); return } if (w) { var W; try { W = a.fs.readFileSync(F).toString("utf8") } catch ($) { k || D($); return } P(F, W) } else ++O, M.fetch(F, function ($, Z) { if (--O, !!T) { if ($) { k ? O || D(null, M) : D($); return } P(F, Z) } }) } } var O = 0; a.isString(x) && (x = [x]); for (var N = 0, H; N < x.length; ++N)(H = M.resolvePath("", x[N])) && U(H); return w ? (M.resolveAll(), M) : (O || D(null, M), M) }, h.prototype.loadSync = function (x, b) { if (!a.isNode) throw Error("not supported"); return this.load(x, b, d) }, h.prototype.resolveAll = function () { if (!this._needsRecursiveResolve) return this; if (this.deferred.length) throw Error("unresolvable extensions: " + this.deferred.map(function (x) { return "'extend " + x.extend + "' in " + x.parent.fullName }).join(", ")); return r.prototype.resolveAll.call(this) }; var p = /^[A-Z]/; function f(_, x) { var b = x.parent.lookup(x.extend); if (b) { var T = new e(x.fullName, x.id, x.type, x.rule, void 0, x.options); return b.get(T.name) || (T.declaringField = x, x.extensionField = T, b.add(T)), !0 } return !1 } return h.prototype._handleAdd = function (x) { if (x instanceof e) x.extend !== void 0 && !x.extensionField && (f(this, x) || this.deferred.push(x)); else if (x instanceof i) p.test(x.name) && (x.parent[x.name] = x.values); else if (!(x instanceof s)) { if (x instanceof o) for (var b = 0; b < this.deferred.length;)f(this, this.deferred[b]) ? this.deferred.splice(b, 1) : ++b; for (var T = 0; T < x.nestedArray.length; ++T)this._handleAdd(x._nestedArray[T]); p.test(x.name) && (x.parent[x.name] = x) } (x instanceof o || x instanceof i || x instanceof e) && (this._fullyQualifiedObjects[x.fullName] = x) }, h.prototype._handleRemove = function (x) { if (x instanceof e) { if (x.extend !== void 0) if (x.extensionField) x.extensionField.parent.remove(x.extensionField), x.extensionField = null; else { var b = this.deferred.indexOf(x); b > -1 && this.deferred.splice(b, 1) } } else if (x instanceof i) p.test(x.name) && delete x.parent[x.name]; else if (x instanceof r) { for (var T = 0; T < x.nestedArray.length; ++T)this._handleRemove(x._nestedArray[T]); p.test(x.name) && delete x.parent[x.name] } delete this._fullyQualifiedObjects[x.fullName] }, h._configure = function (_, x, b) { o = _, l = x, c = b }, root$2 } var hasRequiredUtil; function requireUtil() { if (hasRequiredUtil) return util.exports; hasRequiredUtil = 1; var r = util.exports = requireMinimal(), e = requireRoots(), i, s; r.codegen = requireCodegen(), r.fetch = requireFetch(), r.path = requirePath(), r.fs = r.inquire("fs"), r.toArray = function (d) { if (d) { for (var p = Object.keys(d), f = new Array(p.length), _ = 0; _ < p.length;)f[_] = d[p[_++]]; return f } return [] }, r.toObject = function (d) { for (var p = {}, f = 0; f < d.length;) { var _ = d[f++], x = d[f++]; x !== void 0 && (p[_] = x) } return p }; var a = /\\/g, o = /"/g; r.isReserved = function (d) { return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(d) }, r.safeProp = function (d) { return !/^[$\w_]+$/.test(d) || r.isReserved(d) ? '["' + d.replace(a, "\\\\").replace(o, '\\"') + '"]' : "." + d }, r.ucFirst = function (d) { return d.charAt(0).toUpperCase() + d.substring(1) }; var l = /_([a-z])/g; r.camelCase = function (d) { return d.substring(0, 1) + d.substring(1).replace(l, function (p, f) { return f.toUpperCase() }) }, r.compareFieldsById = function (d, p) { return d.id - p.id }, r.decorateType = function (d, p) { if (d.$type) return p && d.$type.name !== p && (r.decorateRoot.remove(d.$type), d.$type.name = p, r.decorateRoot.add(d.$type)), d.$type; i || (i = requireType()); var f = new i(p || d.name); return r.decorateRoot.add(f), f.ctor = d, Object.defineProperty(d, "$type", { value: f, enumerable: !1 }), Object.defineProperty(d.prototype, "$type", { value: f, enumerable: !1 }), f }; var c = 0; return r.decorateEnum = function (d) { if (d.$type) return d.$type; s || (s = require_enum()); var p = new s("Enum" + c++, d); return r.decorateRoot.add(p), Object.defineProperty(d, "$type", { value: p, enumerable: !1 }), p }, r.setProperty = function (d, p, f, _) { function x(b, T, M) { var w = T.shift(); if (w === "__proto__" || w === "prototype") return b; if (T.length > 0) b[w] = x(b[w] || {}, T, M); else { var D = b[w]; if (D && _) return b; D && (M = [].concat(D).concat(M)), b[w] = M } return b } if (typeof d != "object") throw TypeError("dst must be an object"); if (!p) throw TypeError("path must be specified"); return p = p.split("."), x(d, p, f) }, Object.defineProperty(r, "decorateRoot", { get: function () { return e.decorated || (e.decorated = new (requireRoot())) } }), util.exports } var hasRequiredTypes; function requireTypes() { return hasRequiredTypes || (hasRequiredTypes = 1, function (r) { var e = r, i = requireUtil(), s = ["double", "float", "int32", "uint32", "sint32", "fixed32", "sfixed32", "int64", "uint64", "sint64", "fixed64", "sfixed64", "bool", "string", "bytes"]; function a(o, l) { var c = 0, h = {}; for (l |= 0; c < o.length;)h[s[c + l]] = o[c++]; return h } e.basic = a([1, 5, 0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0, 2, 2]), e.defaults = a([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, !1, "", i.emptyArray, null]), e.long = a([0, 0, 0, 1, 1], 7), e.mapKey = a([0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0, 2], 2), e.packed = a([1, 5, 0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0]) }(types)), types } var field, hasRequiredField; function requireField() { if (hasRequiredField) return field; hasRequiredField = 1, field = l; var r = requireObject(); ((l.prototype = Object.create(r.prototype)).constructor = l).className = "Field"; var e = require_enum(), i = requireTypes(), s = requireUtil(), a, o = /^required|optional|repeated$/; l.fromJSON = function (h, d) { var p = new l(h, d.id, d.type, d.rule, d.extend, d.options, d.comment); return d.edition && (p._edition = d.edition), p._defaultEdition = "proto3", p }; function l(c, h, d, p, f, _, x) { if (s.isObject(p) ? (x = f, _ = p, p = f = void 0) : s.isObject(f) && (x = _, _ = f, f = void 0), r.call(this, c, _), !s.isInteger(h) || h < 0) throw TypeError("id must be a non-negative integer"); if (!s.isString(d)) throw TypeError("type must be a string"); if (p !== void 0 && !o.test(p = p.toString().toLowerCase())) throw TypeError("rule must be a string rule"); if (f !== void 0 && !s.isString(f)) throw TypeError("extend must be a string"); p === "proto3_optional" && (p = "optional"), this.rule = p && p !== "optional" ? p : void 0, this.type = d, this.id = h, this.extend = f || void 0, this.repeated = p === "repeated", this.map = !1, this.message = null, this.partOf = null, this.typeDefault = null, this.defaultValue = null, this.long = s.Long ? i.long[d] !== void 0 : !1, this.bytes = d === "bytes", this.resolvedType = null, this.extensionField = null, this.declaringField = null, this.comment = x } return Object.defineProperty(l.prototype, "required", { get: function () { return this._features.field_presence === "LEGACY_REQUIRED" } }), Object.defineProperty(l.prototype, "optional", { get: function () { return !this.required } }), Object.defineProperty(l.prototype, "delimited", { get: function () { return this.resolvedType instanceof a && this._features.message_encoding === "DELIMITED" } }), Object.defineProperty(l.prototype, "packed", { get: function () { return this._features.repeated_field_encoding === "PACKED" } }), Object.defineProperty(l.prototype, "hasPresence", { get: function () { return this.repeated || this.map ? !1 : this.partOf || this.declaringField || this.extensionField || this._features.field_presence !== "IMPLICIT" } }), l.prototype.setOption = function (h, d, p) { return r.prototype.setOption.call(this, h, d, p) }, l.prototype.toJSON = function (h) { var d = h ? !!h.keepComments : !1; return s.toObject(["edition", this._editionToJSON(), "rule", this.rule !== "optional" && this.rule || void 0, "type", this.type, "id", this.id, "extend", this.extend, "options", this.options, "comment", d ? this.comment : void 0]) }, l.prototype.resolve = function () { if (this.resolved) return this; if ((this.typeDefault = i.defaults[this.type]) === void 0 ? (this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type), this.resolvedType instanceof a ? this.typeDefault = null : this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]]) : this.options && this.options.proto3_optional && (this.typeDefault = null), this.options && this.options.default != null && (this.typeDefault = this.options.default, this.resolvedType instanceof e && typeof this.typeDefault == "string" && (this.typeDefault = this.resolvedType.values[this.typeDefault])), this.options && (this.options.packed !== void 0 && this.resolvedType && !(this.resolvedType instanceof e) && delete this.options.packed, Object.keys(this.options).length || (this.options = void 0)), this.long) this.typeDefault = s.Long.fromNumber(this.typeDefault, this.type.charAt(0) === "u"), Object.freeze && Object.freeze(this.typeDefault); else if (this.bytes && typeof this.typeDefault == "string") { var h; s.base64.test(this.typeDefault) ? s.base64.decode(this.typeDefault, h = s.newBuffer(s.base64.length(this.typeDefault)), 0) : s.utf8.write(this.typeDefault, h = s.newBuffer(s.utf8.length(this.typeDefault)), 0), this.typeDefault = h } return this.map ? this.defaultValue = s.emptyObject : this.repeated ? this.defaultValue = s.emptyArray : this.defaultValue = this.typeDefault, this.parent instanceof a && (this.parent.ctor.prototype[this.name] = this.defaultValue), r.prototype.resolve.call(this) }, l.prototype._inferLegacyProtoFeatures = function (h) { if (h !== "proto2" && h !== "proto3") return {}; var d = {}; if (this.rule === "required" && (d.field_presence = "LEGACY_REQUIRED"), this.parent && i.defaults[this.type] === void 0) { var p = this.parent.get(this.type.split(".").pop()); p && p instanceof a && p.group && (d.message_encoding = "DELIMITED") } return this.getOption("packed") === !0 ? d.repeated_field_encoding = "PACKED" : this.getOption("packed") === !1 && (d.repeated_field_encoding = "EXPANDED"), d }, l.prototype._resolveFeatures = function (h) { return r.prototype._resolveFeatures.call(this, this._edition || h) }, l.d = function (h, d, p, f) { return typeof d == "function" ? d = s.decorateType(d).name : d && typeof d == "object" && (d = s.decorateEnum(d).name), function (x, b) { s.decorateType(x.constructor).add(new l(b, h, d, p, { default: f })) } }, l._configure = function (h) { a = h }, field } var oneof, hasRequiredOneof; function requireOneof() { if (hasRequiredOneof) return oneof; hasRequiredOneof = 1, oneof = s; var r = requireObject(); ((s.prototype = Object.create(r.prototype)).constructor = s).className = "OneOf"; var e = requireField(), i = requireUtil(); function s(o, l, c, h) { if (Array.isArray(l) || (c = l, l = void 0), r.call(this, o, c), !(l === void 0 || Array.isArray(l))) throw TypeError("fieldNames must be an Array"); this.oneof = l || [], this.fieldsArray = [], this.comment = h } s.fromJSON = function (l, c) { return new s(l, c.oneof, c.options, c.comment) }, s.prototype.toJSON = function (l) { var c = l ? !!l.keepComments : !1; return i.toObject(["options", this.options, "oneof", this.oneof, "comment", c ? this.comment : void 0]) }; function a(o) { if (o.parent) for (var l = 0; l < o.fieldsArray.length; ++l)o.fieldsArray[l].parent || o.parent.add(o.fieldsArray[l]) } return s.prototype.add = function (l) { if (!(l instanceof e)) throw TypeError("field must be a Field"); return l.parent && l.parent !== this.parent && l.parent.remove(l), this.oneof.push(l.name), this.fieldsArray.push(l), l.partOf = this, a(this), this }, s.prototype.remove = function (l) { if (!(l instanceof e)) throw TypeError("field must be a Field"); var c = this.fieldsArray.indexOf(l); if (c < 0) throw Error(l + " is not a member of " + this); return this.fieldsArray.splice(c, 1), c = this.oneof.indexOf(l.name), c > -1 && this.oneof.splice(c, 1), l.partOf = null, this }, s.prototype.onAdd = function (l) { r.prototype.onAdd.call(this, l); for (var c = this, h = 0; h < this.oneof.length; ++h) { var d = l.get(this.oneof[h]); d && !d.partOf && (d.partOf = c, c.fieldsArray.push(d)) } a(this) }, s.prototype.onRemove = function (l) { for (var c = 0, h; c < this.fieldsArray.length; ++c)(h = this.fieldsArray[c]).parent && h.parent.remove(h); r.prototype.onRemove.call(this, l) }, Object.defineProperty(s.prototype, "isProto3Optional", { get: function () { if (this.fieldsArray == null || this.fieldsArray.length !== 1) return !1; var o = this.fieldsArray[0]; return o.options != null && o.options.proto3_optional === !0 } }), s.d = function () { for (var l = new Array(arguments.length), c = 0; c < arguments.length;)l[c] = arguments[c++]; return function (d, p) { i.decorateType(d.constructor).add(new s(p, l)), Object.defineProperty(d, p, { get: i.oneOfGetter(l), set: i.oneOfSetter(l) }) } }, oneof } var object, hasRequiredObject; function requireObject() { if (hasRequiredObject) return object; hasRequiredObject = 1, object = l, l.className = "ReflectionObject"; const r = requireOneof(); var e = requireUtil(), i, s = { enum_type: "OPEN", field_presence: "EXPLICIT", json_format: "ALLOW", message_encoding: "LENGTH_PREFIXED", repeated_field_encoding: "PACKED", utf8_validation: "VERIFY" }, a = { enum_type: "CLOSED", field_presence: "EXPLICIT", json_format: "LEGACY_BEST_EFFORT", message_encoding: "LENGTH_PREFIXED", repeated_field_encoding: "EXPANDED", utf8_validation: "NONE" }, o = { enum_type: "OPEN", field_presence: "IMPLICIT", json_format: "ALLOW", message_encoding: "LENGTH_PREFIXED", repeated_field_encoding: "PACKED", utf8_validation: "VERIFY" }; function l(c, h) { if (!e.isString(c)) throw TypeError("name must be a string"); if (h && !e.isObject(h)) throw TypeError("options must be an object"); this.options = h, this.parsedOptions = null, this.name = c, this._edition = null, this._defaultEdition = "proto2", this._features = {}, this._featuresResolved = !1, this.parent = null, this.resolved = !1, this.comment = null, this.filename = null } return Object.defineProperties(l.prototype, { root: { get: function () { for (var c = this; c.parent !== null;)c = c.parent; return c } }, fullName: { get: function () { for (var c = [this.name], h = this.parent; h;)c.unshift(h.name), h = h.parent; return c.join(".") } } }), l.prototype.toJSON = function () { throw Error() }, l.prototype.onAdd = function (h) { this.parent && this.parent !== h && this.parent.remove(this), this.parent = h, this.resolved = !1; var d = h.root; d instanceof i && d._handleAdd(this) }, l.prototype.onRemove = function (h) { var d = h.root; d instanceof i && d._handleRemove(this), this.parent = null, this.resolved = !1 }, l.prototype.resolve = function () { return this.resolved ? this : (this.root instanceof i && (this.resolved = !0), this) }, l.prototype._resolveFeaturesRecursive = function (h) { return this._resolveFeatures(this._edition || h) }, l.prototype._resolveFeatures = function (h) { if (!this._featuresResolved) { var d = {}; if (!h) throw new Error("Unknown edition for " + this.fullName); var p = Object.assign(this.options ? Object.assign({}, this.options.features) : {}, this._inferLegacyProtoFeatures(h)); if (this._edition) { if (h === "proto2") d = Object.assign({}, a); else if (h === "proto3") d = Object.assign({}, o); else if (h === "2023") d = Object.assign({}, s); else throw new Error("Unknown edition: " + h); this._features = Object.assign(d, p || {}), this._featuresResolved = !0; return } if (this.partOf instanceof r) { var f = Object.assign({}, this.partOf._features); this._features = Object.assign(f, p || {}) } else if (!this.declaringField) if (this.parent) { var _ = Object.assign({}, this.parent._features); this._features = Object.assign(_, p || {}) } else throw new Error("Unable to find a parent for " + this.fullName); this.extensionField && (this.extensionField._features = this._features), this._featuresResolved = !0 } }, l.prototype._inferLegacyProtoFeatures = function () { return {} }, l.prototype.getOption = function (h) { if (this.options) return this.options[h] }, l.prototype.setOption = function (h, d, p) { return this.options || (this.options = {}), /^features\./.test(h) ? e.setProperty(this.options, h, d, p) : (!p || this.options[h] === void 0) && (this.getOption(h) !== d && (this.resolved = !1), this.options[h] = d), this }, l.prototype.setParsedOption = function (h, d, p) { this.parsedOptions || (this.parsedOptions = []); var f = this.parsedOptions; if (p) { var _ = f.find(function (T) { return Object.prototype.hasOwnProperty.call(T, h) }); if (_) { var x = _[h]; e.setProperty(x, p, d) } else _ = {}, _[h] = e.setProperty({}, p, d), f.push(_) } else { var b = {}; b[h] = d, f.push(b) } return this }, l.prototype.setOptions = function (h, d) { if (h) for (var p = Object.keys(h), f = 0; f < p.length; ++f)this.setOption(p[f], h[p[f]], d); return this }, l.prototype.toString = function () { var h = this.constructor.className, d = this.fullName; return d.length ? h + " " + d : h }, l.prototype._editionToJSON = function () { if (!(!this._edition || this._edition === "proto3")) return this._edition }, l._configure = function (c) { i = c }, object } var _enum, hasRequired_enum; function require_enum() { if (hasRequired_enum) return _enum; hasRequired_enum = 1, _enum = s; var r = requireObject(); ((s.prototype = Object.create(r.prototype)).constructor = s).className = "Enum"; var e = requireNamespace(), i = requireUtil(); function s(a, o, l, c, h, d) { if (r.call(this, a, l), o && typeof o != "object") throw TypeError("values must be an object"); if (this.valuesById = {}, this.values = Object.create(this.valuesById), this.comment = c, this.comments = h || {}, this.valuesOptions = d, this._valuesFeatures = {}, this.reserved = void 0, o) for (var p = Object.keys(o), f = 0; f < p.length; ++f)typeof o[p[f]] == "number" && (this.valuesById[this.values[p[f]] = o[p[f]]] = p[f]) } return s.prototype._resolveFeatures = function (o) { return o = this._edition || o, r.prototype._resolveFeatures.call(this, o), Object.keys(this.values).forEach(l => { var c = Object.assign({}, this._features); this._valuesFeatures[l] = Object.assign(c, this.valuesOptions && this.valuesOptions[l] && this.valuesOptions[l].features) }), this }, s.fromJSON = function (o, l) { var c = new s(o, l.values, l.options, l.comment, l.comments); return c.reserved = l.reserved, l.edition && (c._edition = l.edition), c._defaultEdition = "proto3", c }, s.prototype.toJSON = function (o) { var l = o ? !!o.keepComments : !1; return i.toObject(["edition", this._editionToJSON(), "options", this.options, "valuesOptions", this.valuesOptions, "values", this.values, "reserved", this.reserved && this.reserved.length ? this.reserved : void 0, "comment", l ? this.comment : void 0, "comments", l ? this.comments : void 0]) }, s.prototype.add = function (o, l, c, h) { if (!i.isString(o)) throw TypeError("name must be a string"); if (!i.isInteger(l)) throw TypeError("id must be an integer"); if (this.values[o] !== void 0) throw Error("duplicate name '" + o + "' in " + this); if (this.isReservedId(l)) throw Error("id " + l + " is reserved in " + this); if (this.isReservedName(o)) throw Error("name '" + o + "' is reserved in " + this); if (this.valuesById[l] !== void 0) { if (!(this.options && this.options.allow_alias)) throw Error("duplicate id " + l + " in " + this); this.values[o] = l } else this.valuesById[this.values[o] = l] = o; return h && (this.valuesOptions === void 0 && (this.valuesOptions = {}), this.valuesOptions[o] = h || null), this.comments[o] = c || null, this }, s.prototype.remove = function (o) { if (!i.isString(o)) throw TypeError("name must be a string"); var l = this.values[o]; if (l == null) throw Error("name '" + o + "' does not exist in " + this); return delete this.valuesById[l], delete this.values[o], delete this.comments[o], this.valuesOptions && delete this.valuesOptions[o], this }, s.prototype.isReservedId = function (o) { return e.isReservedId(this.reserved, o) }, s.prototype.isReservedName = function (o) { return e.isReservedName(this.reserved, o) }, _enum } var encoder_1, hasRequiredEncoder; function requireEncoder() { if (hasRequiredEncoder) return encoder_1; hasRequiredEncoder = 1, encoder_1 = a; var r = require_enum(), e = requireTypes(), i = requireUtil(); function s(o, l, c, h) { return l.delimited ? o("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", c, h, (l.id << 3 | 3) >>> 0, (l.id << 3 | 4) >>> 0) : o("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", c, h, (l.id << 3 | 2) >>> 0) } function a(o) { for (var l = i.codegen(["m", "w"], o.name + "$encode")("if(!w)")("w=Writer.create()"), c, h, d = o.fieldsArray.slice().sort(i.compareFieldsById), c = 0; c < d.length; ++c) { var p = d[c].resolve(), f = o._fieldsArray.indexOf(p), _ = p.resolvedType instanceof r ? "int32" : p.type, x = e.basic[_]; h = "m" + i.safeProp(p.name), p.map ? (l("if(%s!=null&&Object.hasOwnProperty.call(m,%j)){", h, p.name)("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", h)("w.uint32(%i).fork().uint32(%i).%s(ks[i])", (p.id << 3 | 2) >>> 0, 8 | e.mapKey[p.keyType], p.keyType), x === void 0 ? l("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", f, h) : l(".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | x, _, h), l("}")("}")) : p.repeated ? (l("if(%s!=null&&%s.length){", h, h), p.packed && e.packed[_] !== void 0 ? l("w.uint32(%i).fork()", (p.id << 3 | 2) >>> 0)("for(var i=0;i<%s.length;++i)", h)("w.%s(%s[i])", _, h)("w.ldelim()") : (l("for(var i=0;i<%s.length;++i)", h), x === void 0 ? s(l, p, f, h + "[i]") : l("w.uint32(%i).%s(%s[i])", (p.id << 3 | x) >>> 0, _, h)), l("}")) : (p.optional && l("if(%s!=null&&Object.hasOwnProperty.call(m,%j))", h, p.name), x === void 0 ? s(l, p, f, h) : l("w.uint32(%i).%s(%s)", (p.id << 3 | x) >>> 0, _, h)) } return l("return w") } return encoder_1 } var hasRequiredIndexLight; function requireIndexLight() { if (hasRequiredIndexLight) return indexLight.exports; hasRequiredIndexLight = 1; var r = indexLight.exports = requireIndexMinimal(); r.build = "light"; function e(s, a, o) { return typeof a == "function" ? (o = a, a = new r.Root) : a || (a = new r.Root), a.load(s, o) } r.load = e; function i(s, a) { return a || (a = new r.Root), a.loadSync(s) } return r.loadSync = i, r.encoder = requireEncoder(), r.decoder = requireDecoder(), r.verifier = requireVerifier(), r.converter = requireConverter(), r.ReflectionObject = requireObject(), r.Namespace = requireNamespace(), r.Root = requireRoot(), r.Enum = require_enum(), r.Type = requireType(), r.Field = requireField(), r.OneOf = requireOneof(), r.MapField = requireMapfield(), r.Service = requireService(), r.Method = requireMethod(), r.Message = requireMessage(), r.wrappers = requireWrappers(), r.types = requireTypes(), r.util = requireUtil(), r.ReflectionObject._configure(r.Root), r.Namespace._configure(r.Type, r.Service, r.Enum), r.Root._configure(r.Type), r.Field._configure(r.Type), indexLight.exports } var tokenize_1, hasRequiredTokenize; function requireTokenize() {
    if (hasRequiredTokenize) return tokenize_1; hasRequiredTokenize = 1, tokenize_1 = p; var r = /[\s{}=;:[\],'"()<>]/g, e = /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g, i = /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g, s = /^ *[*/]+ */, a = /^\s*\*?\/*/, o = /\n/g, l = /\s/, c = /\\(.?)/g, h = {
        0: "\0", r: "\r", n: `
`, t: "	"
    }; function d(f) { return f.replace(c, function (_, x) { switch (x) { case "\\": case "": return x; default: return h[x] || "" } }) } p.unescape = d; function p(f, _) {
        f = f.toString(); var x = 0, b = f.length, T = 1, M = 0, w = {}, D = [], R = null; function P(se) { return Error("illegal " + se + " (line " + T + ")") } function U() { var se = R === "'" ? i : e; se.lastIndex = x - 1; var re = se.exec(f); if (!re) throw P("string"); return x = se.lastIndex, W(R), R = null, d(re[1]) } function O(se) { return f.charAt(se) } function N(se, re, ce) {
            var ee = { type: f.charAt(se++), lineEmpty: !1, leading: ce }, Me; _ ? Me = 2 : Me = 3; var Ee = se - Me, Ue; do if (--Ee < 0 || (Ue = f.charAt(Ee)) === `
`) { ee.lineEmpty = !0; break } while (Ue === " " || Ue === "	"); for (var nt = f.substring(se, re).split(o), mt = 0; mt < nt.length; ++mt)nt[mt] = nt[mt].replace(_ ? a : s, "").trim(); ee.text = nt.join(`
`).trim(), w[T] = ee, M = T
        } function H(se) { var re = F(se), ce = f.substring(se, re), ee = /^\s*\/\//.test(ce); return ee } function F(se) {
            for (var re = se; re < b && O(re) !== `
`;)re++; return re
        } function k() {
            if (D.length > 0) return D.shift(); if (R) return U(); var se, re, ce, ee, Me, Ee = x === 0; do {
                if (x === b) return null; for (se = !1; l.test(ce = O(x));)if (ce === `
`&& (Ee = !0, ++T), ++x === b) return null; if (O(x) === "/") {
                    if (++x === b) throw P("comment"); if (O(x) === "/") if (_) { if (ee = x, Me = !1, H(x - 1)) { Me = !0; do if (x = F(x), x === b || (x++, !Ee)) break; while (H(x)) } else x = Math.min(b, F(x) + 1); Me && (N(ee, x, Ee), Ee = !0), T++, se = !0 } else {
                        for (Me = O(ee = x + 1) === "/"; O(++x) !== `
`;)if (x === b) return null; ++x, Me && (N(ee, x - 1, Ee), Ee = !0), ++T, se = !0
                    } else if ((ce = O(x)) === "*") {
                        ee = x + 1, Me = _ || O(ee) === "*"; do {
                            if (ce === `
`&& ++T, ++x === b) throw P("comment"); re = ce, ce = O(x)
                        } while (re !== "*" || ce !== "/"); ++x, Me && (N(ee, x - 2, Ee), Ee = !0), se = !0
                    } else return "/"
                }
            } while (se); var Ue = x; r.lastIndex = 0; var nt = r.test(O(Ue++)); if (!nt) for (; Ue < b && !r.test(O(Ue));)++Ue; var mt = f.substring(x, x = Ue); return (mt === '"' || mt === "'") && (R = mt), mt
        } function W(se) { D.push(se) } function $() { if (!D.length) { var se = k(); if (se === null) return null; W(se) } return D[0] } function Z(se, re) { var ce = $(), ee = ce === se; if (ee) return k(), !0; if (!re) throw P("token '" + ce + "', '" + se + "' expected"); return !1 } function J(se) { var re = null, ce; return se === void 0 ? (ce = w[T - 1], delete w[T - 1], ce && (_ || ce.type === "*" || ce.lineEmpty) && (re = ce.leading ? ce.text : null)) : (M < se && $(), ce = w[se], delete w[se], ce && !ce.lineEmpty && (_ || ce.type === "/") && (re = ce.leading ? null : ce.text)), re } return Object.defineProperty({ next: k, peek: $, push: W, skip: Z, cmnt: J }, "line", { get: function () { return T } })
    } return tokenize_1
} var parse_1, hasRequiredParse; function requireParse() { if (hasRequiredParse) return parse_1; hasRequiredParse = 1, parse_1 = U, U.filename = null, U.defaults = { keepCase: !1 }; var r = requireTokenize(), e = requireRoot(), i = requireType(), s = requireField(), a = requireMapfield(), o = requireOneof(), l = require_enum(), c = requireService(), h = requireMethod(), d = requireObject(), p = requireTypes(), f = requireUtil(), _ = /^[1-9][0-9]*$/, x = /^-?[1-9][0-9]*$/, b = /^0[x][0-9a-fA-F]+$/, T = /^-?0[x][0-9a-fA-F]+$/, M = /^0[0-7]+$/, w = /^-?0[0-7]+$/, D = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/, R = /^[a-zA-Z_][a-zA-Z_0-9]*$/, P = /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\.[a-zA-Z_][a-zA-Z_0-9]*)*$/; function U(O, N, H) { N instanceof e || (H = N, N = new e), H || (H = U.defaults); var F = H.preferTrailingComment || !1, k = r(O, H.alternateCommentMode || !1), W = k.next, $ = k.push, Z = k.peek, J = k.skip, se = k.cmnt, re = !0, ce, ee, Me, Ee = "proto2", Ue = N, nt = [], mt = {}, ve = H.keepCase ? function (le) { return le } : f.camelCase; function ne() { nt.forEach(le => { le._edition = Ee, Object.keys(mt).forEach(xe => { le.getOption(xe) === void 0 && le.setOption(xe, mt[xe], !0) }) }) } function z(le, xe, be) { var Ce = U.filename; return be || (U.filename = null), Error("illegal " + (xe || "token") + " '" + le + "' (" + (Ce ? Ce + ", " : "") + "line " + k.line + ")") } function V() { var le = [], xe; do { if ((xe = W()) !== '"' && xe !== "'") throw z(xe); le.push(W()), J(xe), xe = Z() } while (xe === '"' || xe === "'"); return le.join("") } function _e(le) { var xe = W(); switch (xe) { case "'": case '"': return $(xe), V(); case "true": case "TRUE": return !0; case "false": case "FALSE": return !1 }try { return fe(xe, !0) } catch { if (P.test(xe)) return xe; throw z(xe, "value") } } function Le(le, xe) { var be, Ce; do if (xe && ((be = Z()) === '"' || be === "'")) { var Ve = V(); if (le.push(Ve), Ee >= 2023) throw z(Ve, "id") } else try { le.push([Ce = Fe(W()), J("to", !0) ? Fe(W()) : Ce]) } catch (Ne) { if (xe && P.test(be) && Ee >= 2023) le.push(be); else throw Ne } while (J(",", !0)); var ie = { options: void 0 }; ie.setOption = function (Ne, Ye) { this.options === void 0 && (this.options = {}), this.options[Ne] = Ye }, Ie(ie, function (Ye) { if (Ye === "option") he(ie, Ye), J(";"); else throw z(Ye) }, function () { ot(ie) }) } function fe(le, xe) { var be = 1; switch (le.charAt(0) === "-" && (be = -1, le = le.substring(1)), le) { case "inf": case "INF": case "Inf": return be * (1 / 0); case "nan": case "NAN": case "Nan": case "NaN": return NaN; case "0": return 0 }if (_.test(le)) return be * parseInt(le, 10); if (b.test(le)) return be * parseInt(le, 16); if (M.test(le)) return be * parseInt(le, 8); if (D.test(le)) return be * parseFloat(le); throw z(le, "number", xe) } function Fe(le, xe) { switch (le) { case "max": case "MAX": case "Max": return 536870911; case "0": return 0 }if (!xe && le.charAt(0) === "-") throw z(le, "id"); if (x.test(le)) return parseInt(le, 10); if (T.test(le)) return parseInt(le, 16); if (w.test(le)) return parseInt(le, 8); throw z(le, "id") } function st() { if (ce !== void 0) throw z("package"); if (ce = W(), !P.test(ce)) throw z(ce, "name"); Ue = Ue.define(ce), J(";") } function j() { var le = Z(), xe; switch (le) { case "weak": xe = Me || (Me = []), W(); break; case "public": W(); default: xe = ee || (ee = []); break }le = V(), J(";"), xe.push(le) } function Be() { if (J("="), Ee = V(), Ee < 2023) throw z(Ee, "syntax"); J(";") } function Re() { if (J("="), Ee = V(), !["2023"].includes(Ee)) throw z(Ee, "edition"); J(";") } function Oe(le, xe) { switch (xe) { case "option": return he(le, xe), J(";"), !0; case "message": return oe(le, xe), !0; case "enum": return K(le, xe), !0; case "service": return tt(le, xe), !0; case "extend": return ft(le, xe), !0 }return !1 } function Ie(le, xe, be) { var Ce = k.line; if (le && (typeof le.comment != "string" && (le.comment = se()), le.filename = U.filename), J("{", !0)) { for (var Ve; (Ve = W()) !== "}";)xe(Ve); J(";", !0) } else be && be(), J(";"), le && (typeof le.comment != "string" || F) && (le.comment = se(Ce) || le.comment) } function oe(le, xe) { if (!R.test(xe = W())) throw z(xe, "type name"); var be = new i(xe); Ie(be, function (Ve) { if (!Oe(be, Ve)) switch (Ve) { case "map": vt(be); break; case "required": if (Ee !== "proto2") throw z(Ve); case "repeated": Y(be, Ve); break; case "optional": if (Ee === "proto3") Y(be, "proto3_optional"); else { if (Ee !== "proto2") throw z(Ve); Y(be, "optional") } break; case "oneof": St(be, Ve); break; case "extensions": Le(be.extensions || (be.extensions = [])); break; case "reserved": Le(be.reserved || (be.reserved = []), !0); break; default: if (Ee === "proto2" || !P.test(Ve)) throw z(Ve); $(Ve), Y(be, "optional"); break } }), le.add(be), le === Ue && nt.push(be) } function Y(le, xe, be) { var Ce = W(); if (Ce === "group") { $e(le, xe); return } for (; Ce.endsWith(".") || Z().startsWith(".");)Ce += W(); if (!P.test(Ce)) throw z(Ce, "type"); var Ve = W(); if (!R.test(Ve)) throw z(Ve, "name"); Ve = ve(Ve), J("="); var ie = new s(Ve, Fe(W()), Ce, xe, be); if (Ie(ie, function (rt) { if (rt === "option") he(ie, rt), J(";"); else throw z(rt) }, function () { ot(ie) }), xe === "proto3_optional") { var Ne = new o("_" + Ve); ie.setOption("proto3_optional", !0), Ne.add(ie), le.add(Ne) } else le.add(ie); le === Ue && nt.push(ie) } function $e(le, xe) { if (Ee >= 2023) throw z("group"); var be = W(); if (!R.test(be)) throw z(be, "name"); var Ce = f.lcFirst(be); be === Ce && (be = f.ucFirst(be)), J("="); var Ve = Fe(W()), ie = new i(be); ie.group = !0; var Ne = new s(Ce, Ve, be, xe); Ne.filename = U.filename, Ie(ie, function (rt) { switch (rt) { case "option": he(ie, rt), J(";"); break; case "required": case "repeated": Y(ie, rt); break; case "optional": Ee === "proto3" ? Y(ie, "proto3_optional") : Y(ie, "optional"); break; case "message": oe(ie, rt); break; case "enum": K(ie, rt); break; case "reserved": Le(ie.reserved || (ie.reserved = []), !0); break; default: throw z(rt) } }), le.add(ie).add(Ne) } function vt(le) { J("<"); var xe = W(); if (p.mapKey[xe] === void 0) throw z(xe, "type"); J(","); var be = W(); if (!P.test(be)) throw z(be, "type"); J(">"); var Ce = W(); if (!R.test(Ce)) throw z(Ce, "name"); J("="); var Ve = new a(ve(Ce), Fe(W()), xe, be); Ie(Ve, function (Ne) { if (Ne === "option") he(Ve, Ne), J(";"); else throw z(Ne) }, function () { ot(Ve) }), le.add(Ve) } function St(le, xe) { if (!R.test(xe = W())) throw z(xe, "name"); var be = new o(ve(xe)); Ie(be, function (Ve) { Ve === "option" ? (he(be, Ve), J(";")) : ($(Ve), Y(be, "optional")) }), le.add(be) } function K(le, xe) { if (!R.test(xe = W())) throw z(xe, "name"); var be = new l(xe); Ie(be, function (Ve) { switch (Ve) { case "option": he(be, Ve), J(";"); break; case "reserved": Le(be.reserved || (be.reserved = []), !0), be.reserved === void 0 && (be.reserved = []); break; default: G(be, Ve) } }), le.add(be), le === Ue && nt.push(be) } function G(le, xe) { if (!R.test(xe)) throw z(xe, "name"); J("="); var be = Fe(W(), !0), Ce = { options: void 0 }; Ce.getOption = function (Ve) { return this.options[Ve] }, Ce.setOption = function (Ve, ie) { d.prototype.setOption.call(Ce, Ve, ie) }, Ce.setParsedOption = function () { }, Ie(Ce, function (ie) { if (ie === "option") he(Ce, ie), J(";"); else throw z(ie) }, function () { ot(Ce) }), le.add(xe, be, Ce.comment, Ce.parsedOptions || Ce.options) } function he(le, xe) { var be, Ce, Ve = !0; for (xe === "option" && (xe = W()); xe !== "=";) { if (xe === "(") { var ie = W(); J(")"), xe = "(" + ie + ")" } if (Ve) { if (Ve = !1, xe.includes(".") && !xe.includes("(")) { var Ne = xe.split("."); be = Ne[0] + ".", xe = Ne[1]; continue } be = xe } else Ce = Ce ? Ce += xe : xe; xe = W() } var Ye = Ce ? be.concat(Ce) : be, rt = De(le, Ye); Ce = Ce && Ce[0] === "." ? Ce.slice(1) : Ce, be = be && be[be.length - 1] === "." ? be.slice(0, -1) : be, Te(le, be, rt, Ce) } function De(le, xe) { if (J("{", !0)) { for (var be = {}; !J("}", !0);) { if (!R.test(ze = W())) throw z(ze, "name"); if (ze === null) throw z(ze, "end of input"); var Ce, Ve = ze; if (J(":", !0), Z() === "{") Ce = De(le, xe + "." + ze); else if (Z() === "[") { Ce = []; var ie; if (J("[", !0)) { do ie = _e(), Ce.push(ie); while (J(",", !0)); J("]"), typeof ie < "u" && Ge(le, xe + "." + ze, ie) } } else Ce = _e(), Ge(le, xe + "." + ze, Ce); var Ne = be[Ve]; Ne && (Ce = [].concat(Ne).concat(Ce)), be[Ve] = Ce, J(",", !0), J(";", !0) } return be } var Ye = _e(); return Ge(le, xe, Ye), Ye } function Ge(le, xe, be) { if (Ue === le && /^features\./.test(xe)) { mt[xe] = be; return } le.setOption && le.setOption(xe, be) } function Te(le, xe, be, Ce) { le.setParsedOption && le.setParsedOption(xe, be, Ce) } function ot(le) { if (J("[", !0)) { do he(le, "option"); while (J(",", !0)); J("]") } return le } function tt(le, xe) { if (!R.test(xe = W())) throw z(xe, "service name"); var be = new c(xe); Ie(be, function (Ve) { if (!Oe(be, Ve)) if (Ve === "rpc") ut(be, Ve); else throw z(Ve) }), le.add(be), le === Ue && nt.push(be) } function ut(le, xe) { var be = se(), Ce = xe; if (!R.test(xe = W())) throw z(xe, "name"); var Ve = xe, ie, Ne, Ye, rt; if (J("("), J("stream", !0) && (Ne = !0), !P.test(xe = W()) || (ie = xe, J(")"), J("returns"), J("("), J("stream", !0) && (rt = !0), !P.test(xe = W()))) throw z(xe); Ye = xe, J(")"); var je = new h(Ve, Ce, ie, Ye, Ne, rt); je.comment = be, Ie(je, function (ct) { if (ct === "option") he(je, ct), J(";"); else throw z(ct) }), le.add(je) } function ft(le, xe) { if (!P.test(xe = W())) throw z(xe, "reference"); var be = xe; Ie(null, function (Ve) { switch (Ve) { case "required": case "repeated": Y(le, Ve, be); break; case "optional": Ee === "proto3" ? Y(le, "proto3_optional", be) : Y(le, "optional", be); break; default: if (Ee === "proto2" || !P.test(Ve)) throw z(Ve); $(Ve), Y(le, "optional", be); break } }) } for (var ze; (ze = W()) !== null;)switch (ze) { case "package": if (!re) throw z(ze); st(); break; case "import": if (!re) throw z(ze); j(); break; case "syntax": if (!re) throw z(ze); Be(); break; case "edition": if (!re) throw z(ze); Re(); break; case "option": he(Ue, ze), J(";", !0); break; default: if (Oe(Ue, ze)) { re = !1; continue } throw z(ze) }return ne(), U.filename = null, { package: ce, imports: ee, weakImports: Me, root: N } } return parse_1 } var common_1, hasRequiredCommon; function requireCommon() { if (hasRequiredCommon) return common_1; hasRequiredCommon = 1, common_1 = e; var r = /\/|\./; function e(s, a) { r.test(s) || (s = "google/protobuf/" + s + ".proto", a = { nested: { google: { nested: { protobuf: { nested: a } } } } }), e[s] = a } e("any", { Any: { fields: { type_url: { type: "string", id: 1 }, value: { type: "bytes", id: 2 } } } }); var i; return e("duration", { Duration: i = { fields: { seconds: { type: "int64", id: 1 }, nanos: { type: "int32", id: 2 } } } }), e("timestamp", { Timestamp: i }), e("empty", { Empty: { fields: {} } }), e("struct", { Struct: { fields: { fields: { keyType: "string", type: "Value", id: 1 } } }, Value: { oneofs: { kind: { oneof: ["nullValue", "numberValue", "stringValue", "boolValue", "structValue", "listValue"] } }, fields: { nullValue: { type: "NullValue", id: 1 }, numberValue: { type: "double", id: 2 }, stringValue: { type: "string", id: 3 }, boolValue: { type: "bool", id: 4 }, structValue: { type: "Struct", id: 5 }, listValue: { type: "ListValue", id: 6 } } }, NullValue: { values: { NULL_VALUE: 0 } }, ListValue: { fields: { values: { rule: "repeated", type: "Value", id: 1 } } } }), e("wrappers", { DoubleValue: { fields: { value: { type: "double", id: 1 } } }, FloatValue: { fields: { value: { type: "float", id: 1 } } }, Int64Value: { fields: { value: { type: "int64", id: 1 } } }, UInt64Value: { fields: { value: { type: "uint64", id: 1 } } }, Int32Value: { fields: { value: { type: "int32", id: 1 } } }, UInt32Value: { fields: { value: { type: "uint32", id: 1 } } }, BoolValue: { fields: { value: { type: "bool", id: 1 } } }, StringValue: { fields: { value: { type: "string", id: 1 } } }, BytesValue: { fields: { value: { type: "bytes", id: 1 } } } }), e("field_mask", { FieldMask: { fields: { paths: { rule: "repeated", type: "string", id: 1 } } } }), e.get = function (a) { return e[a] || null }, common_1 } var hasRequiredSrc; function requireSrc() { if (hasRequiredSrc) return src.exports; hasRequiredSrc = 1; var r = src.exports = requireIndexLight(); return r.build = "full", r.tokenize = requireTokenize(), r.parse = requireParse(), r.common = requireCommon(), r.Root._configure(r.Type, r.parse, r.common), src.exports } var protobufjs, hasRequiredProtobufjs; function requireProtobufjs() { return hasRequiredProtobufjs || (hasRequiredProtobufjs = 1, protobufjs = requireSrc()), protobufjs } var protobufjsExports = requireProtobufjs(); const protobuf = getDefaultExportFromCjs(protobufjsExports), TYPEMAP = { number: "double", string: "string", boolean: "bool" }; function inferJSON(r = "JsonData", e = {}, i = {}) {
    const s = []; return Object.keys(e).forEach((a, o) => { const l = e[a], c = typeof l, h = l instanceof Array && l.length > 0; let d = h ? TYPEMAP[typeof l[0]] : TYPEMAP[c]; if (a in i && (d = i[a]), c === "number" || c === "string" || c === "boolean") return s.push(`    ${d} ${a} = ${o + 1};`); if (h) return s.push(`    repeated ${d} ${a} = ${o + 1};`) }), `syntax = "proto3";

message ${r} {
${s.join(`
`)}
}`} function createMessage(r, e, i) { const s = inferJSON(r, e, i), a = new protobuf.Root; return protobuf.parse(s, a), a.lookupType(r) } const decoder = new TextDecoder, noop = () => { }; class MicroRealmConnection { constructor({ servers: e = ["ws://localhost:3005"], roomPrefix: i = "default", roomRequested: s = "", data: a = {}, dataTypes: o = {}, updateRate: l = 35, pingRate: c = 20, clientsLimit: h = 1 / 0, autoConnect: d = !0, addClient: p = noop, removeClient: f = noop, removeAllClients: _ = noop, onRoomJoined: x = noop, onConnect: b = noop, onData: T = noop, onDisconnect: M = noop } = {}) { this._socketCreated = !1, this._servers = typeof e == "string" ? [e] : e, this._serverFirstConnection = !0, this._serverIndex = 0, this._serverPing = 20, this._serverTimeDiff = 0, this._roomPrefix = i, this._roomRequested = s, this._updateRate = l, this._pingRate = c, this._data = a, this._prevData = JSON.stringify(this._data), this._protoMsg = createMessage("RealmData", this._data, o), this._protoMsgFields = Object.keys(this._protoMsg.fields).length, this._clients = new Map, this._clientsLimit = h, this._localID = null, this._localIDLength = 0, this._removeAllClients = _, this._addClient = p, this._removeClient = f, this._onRoomJoined = x, this._onConnect = b, this._onData = T, this._onDisconnect = M, this._connected = !1, this._boundOpen = this._open.bind(this), this._boundMessage = this._message.bind(this), this._boundClose = this._close.bind(this), this._boundPing = this._ping.bind(this), this._boundRelay = this._relay.bind(this), this._pingInterval = null, this._relayInterval = null, this._retryInterval = null, events.on("microrealm_join_room", this._requestRoom, this), events.on("visibility_change", this._forceConnectionState, this), d && this._createSocket() } _createSocket() { this._socket = new WebSocket(this._servers[this._serverIndex], "permessage-deflate"), this._socket.binaryType = "arraybuffer", this._socket.onopen = this._boundOpen, this._socket.onmessage = this._boundMessage, this._socket.onerror = this._boundClose, this._socket.onclose = this._boundClose, this._socketCreated = !0 } _forceConnectionState(e) { this._close(!1), this._socketCreated && e && this._createSocket() } _open() { this._serverFirstConnection = !1, this._connected = !0, this._onConnect() } _close(e) { this._socketCreated && (["onopen", "onmessage", "onclose", "onerror"].forEach(i => { this._socket[i] = null }), clearInterval(this._pingInterval), clearInterval(this._relayInterval), clearInterval(this._retryInterval), this._socket.close(), this._connected && (this._connected = !1, this._onDisconnect(), events.emit("microrealm_disconnected", this._roomRequested)), e !== !1 && (this._serverFirstConnection ? (this._serverIndex = (this._serverIndex + 1) % this._servers.length, this._retryInterval = setInterval(() => { clearInterval(this._retryInterval), this._createSocket() }, 1e3)) : this._retryInterval = setInterval(() => { Object.keys(this._retrieveChangedData()).length > 0 && (clearInterval(this._retryInterval), this._createSocket()) }, 1e3))) } _message(e) { try { if (typeof e.data != "string") { const s = decoder.decode(e.data.slice(0, this._localIDLength)), a = this._protoMsg.decode(new Uint8Array(e.data.slice(this._localIDLength))), o = Object.keys(a), l = this._clients.get(s); if (l) o.forEach(c => { a[c] instanceof Array && a[c].length === 0 || (l[c] = a[c]) }); else { if (this._clients.size >= this._clientsLimit || (this._relay(!0), o.reduce((h, d) => a[d] instanceof Array && a[d].length === 0 ? h : h + 1, 0) !== this._protoMsgFields)) return; this._clients.set(s, a), this._addClient(s, a) } return } const i = JSON.parse(e.data); if (i.PONG && typeof i.PONG == "number") { const s = Date.now(); this._serverPing = Math.max(0, (s - i.PONG) * .5), this._serverTimeDiff = s - (i.t || s) - this._serverPing } else if (i.id && typeof i.id == "string") this._localID = i.id, this._localIDLength = this._localID.length, this._requestRoom(this._roomRequested); else if (i.r && typeof i.r == "string") this._removeAllClients(), this._clients.clear(), this._roomRequested = i.r, clearInterval(this._pingInterval), this._pingInterval = setInterval(this._boundPing, this._pingRate * 1e3), clearInterval(this._relayInterval), this._relayInterval = setInterval(this._boundRelay, this._updateRate), this._ping(), this._relay(!0), this._onRoomJoined(this._roomRequested), events.emit("microrealm_connected", this._roomRequested); else if (i.data) this._onData(i.data); else if (i.leave && typeof i.leave == "string") { if (!this._clients.has(i.leave)) return; this._clients.delete(i.leave), this._removeClient(i.leave) } } catch { } } _ping() { this._sendJson({ ping: Date.now() }) } _requestRoom(e = "") { this._roomRequested = e, this._sendJson({ r: [this._roomPrefix, this._roomRequested] }) } _retrieveChangedData() { const e = JSON.parse(this._prevData), i = {}; return Object.keys(this._data).forEach(s => { JSON.stringify(e[s]) !== JSON.stringify(this._data[s]) && (i[s] = this._data[s]) }), i } _relay(e = !1) { if (e) this._prevData = JSON.stringify(this._data), this._sendRelayedData(JSON.parse(this._prevData)); else { const i = this._retrieveChangedData(); if (Object.keys(i).length === 0) return; this._prevData = JSON.stringify(this._data), this._sendRelayedData(i) } } _sendJson(e) { this._connected && this._socket.send(JSON.stringify(e)) } _sendRelayedData(e) { if (!this._connected) return; const i = this._protoMsg.verify(e); if (i) return console.warn("websocket data error", i); const s = this._protoMsg.create(e), a = this._protoMsg.encode(s).finish(); this._socket.send(a) } dispose() { events.off("microrealm_join_room", this._requestRoom, this), events.off("visibility_change", this._forceConnectionState, this), this._close(!1) } } var ki, vi, or, lr, Kr, kn, cr, hr; let characters$1 = (ki = class extends characterBatchedSkinnedMesh { constructor(i = {}) { super(i); pe(this, vi, new Vector3); pe(this, or, new Vector3); pe(this, lr, new Vector3); pe(this, Kr, new Euler); pe(this, kn, new Quaternion); pe(this, cr, new Frustum); pe(this, hr, new Matrix4); Ke(this, "LOCAL_ID", "local"); Ke(this, "requestInteraction", miscutils.debounce(() => { if (this._interactingElement !== null) return; const i = []; this._scene.traverse(s => { !s.isWorldSecret && !s.isWorldNPC && !s.isCustomInteraction || !s._isClose || !s._clickInteraction || i.push(s) }), i.sort((s, a) => s._distanceToCharacter - a._distanceToCharacter), i.length > 0 && (i[0]._clickInteracted = !0) }, 100)); this.isWorldCharacters = !0, this.name = "Characters", this._scene = i.scene, this._camera = this._scene.camera, this._localObject = new Object3D; const s = JSON.parse(JSON.stringify({ ...ki.INITIAL_DATA, ...i.initialData || {} })); Object.assign(this._localObject, { batchedIndex: 0, boundingSphere: new Sphere, rotationHorizontal: 0, velocity: new Vector3, velocityHorizontal: 0, modelsID: "", animationProps: { offset: Math.random() * 100, weights: new Array(s.animationFiles.length).fill(0).map((a, o) => o === 0 ? 1 : 0), mixer: null, actions: [], lastUpdate: 0 }, networkEvents: [], userData: s }), Object.defineProperty(this._localObject.userData, "networkEvent", { enumerable: !0, get: () => "", set: () => { } }), this._charactersObjects = new Map, this._charactersObjects.set(this.LOCAL_ID, this._localObject), this._initialPosition = new Vector3, this._initialRotation = 0, this._initialUp = new Vector3, this._canInteract = !0, this._interactingElement = null, this._interactingElementLast = null, this._interactingElementChanged = !1, this._positionCharLerp = typeof i.positionCharLerp == "number" ? i.positionCharLerp : .4, this._rotationCharLerp = typeof i.rotationCharLerp == "number" ? i.rotationCharLerp : .4, this._animationCharLerp = typeof i.animationCharLerp == "number" ? i.animationCharLerp : .1, this._animationSprintLerp = typeof i.animationSprintLerp == "number" ? i.animationSprintLerp : .25, this._velocityCharDamp = typeof i.velocityDamp == "number" ? i.velocityDamp : .7, this._positionDeltaLimitSnap = typeof i.positionDeltaLimitSnap == "number" ? i.positionDeltaLimitSnap : 10, this._customDataUpdate = i.customDataUpdate, this._customAttribUpdate = i.customAttribUpdate, this._inactive = !1, this._inactiveTime = (typeof i.inactiveTime == "number" ? i.inactiveTime : 60) * 1e3, this._inactiveMilliseconds = 0, this._controls = new charactersControls(this, i), this._controlMode = i.controlMode || "automatic", this._controlAutomaticInfluence = typeof i.controlAutomaticInfluence == "number" ? i.controlAutomaticInfluence : .5, this._collisionPhysics = new collisionPhysics(this, { ...i }), this._tags = i.tags ? new tags(this, i) : null, this._trails = i.trails ? new trails(this, i) : null, this.ready = new Promise(a => { this._isReady = a }), Promise.all([this._localModelReady, this._collisionPhysics.ready]).then(() => { this.setInitialPosition(i.initialPosition, i.initialRadius, i.initialRotation, i.initialUp), this._camera.isFollowCamera && this._camera.follow({ mesh: this, ...i }), i.offline || (this._connection = new MicroRealmConnection({ data: { ...JSON.parse(JSON.stringify(this._localObject.userData)), p: this._localObject.position.toArray(), r: this._localObject.rotation.toArray().slice(0, 3), networkEvent: "" }, dataTypes: { p: "float", r: "float", medium: "uint32", animation: "uint32", bonesFile: "string", modelFiles: "string", animationFiles: "string", tag: "string", networkEvent: "string", ...i.initialDataTypes || {} }, servers: ["ws://localhost:3005"], ...i, clientsLimit: characterBatchedSkinnedMesh.MAX_CHARS - 1, addClient: (a, o) => { this._addCharacter(a, o) }, removeClient: a => { this._removeCharacter(a) }, removeAllClients: () => { this._removeAllCharacters() } }), Object.defineProperty(this._connection._data, "networkEvent", { enumerable: !0, get: () => "", set: () => { } })), this._isReady() }), this._charactersUpdate = !1, Promise.all([this._scene.uploaded, this.ready]).then(() => { this._charactersUpdate = !0, ["material", "customDepthMaterial", "customDistanceMaterial"].forEach(a => { var o, l, c, h, d, p; (l = (o = this[a]) == null ? void 0 : o.uniforms) != null && l.batchingTexture && (this[a].uniforms.batchingTexture.value = this._matricesTexture), (h = (c = this[a]) == null ? void 0 : c.uniforms) != null && h.batchingIdTexture && (this[a].uniforms.batchingIdTexture.value = this._indirectTexture), (p = (d = this[a]) == null ? void 0 : d.uniforms) != null && p.boneTexture && (this[a].uniforms.boneTexture.value = this._boneTexture) }) }), this._initBatchedMeshes() } get interactingElement() { return this._interactingElement } set interactingElement(i = null) { this._interactingElement !== i && (this._interactingElementLast = this._interactingElement, this._interactingElement = i, this._interactingElementChanged = !0) } get MEDIUMS() { return ki.MEDIUMS } getModelsID(i) { return JSON.stringify(i.userData.bonesFile) + JSON.stringify(i.userData.modelFiles) + JSON.stringify(i.userData.animationFiles) } _setInactive() { this._inactive || (this._inactive = !0, this._inactiveAnimation = this._inactiveAnimations[Math.floor(Math.random() * this._inactiveAnimations.length)], this._localObject.userData.animation = this._inactiveAnimation) } _setActive() { this._inactiveMilliseconds = 0, this._inactive && (this._inactive = !1, this._localObject.userData.animation = 0) } _update() { var x, b; if (!this._charactersUpdate) return; const i = renderInfo.delta, s = math.deltaRatio(), a = math.lerpCoefFPS(this._positionCharLerp), o = math.lerpCoefFPS(this._rotationCharLerp), l = math.lerpCoefFPS(this._animationCharLerp), c = math.lerpCoefFPS(this._animationSprintLerp); this._collisionPhysics._update(this._controls._update(), s), this._localObject.velocity.manhattanLength() < 1e-5 && this._interactingElement === null ? (this._inactiveMilliseconds += i, this._inactiveMilliseconds > this._inactiveTime && this._localObject.userData.animation === 0 && this._setInactive()) : this._setActive(), this._connection && (this._connection._data.p = this._localObject.position.toArray().map(T => +Number(T).toFixed(2)), this._connection._data.r = this._localObject.rotation.toArray().slice(0, 3).map(T => +Number(T).toFixed(2)), Object.keys(this._localObject.userData).forEach(T => this._connection._data[T] = this._localObject.userData[T]), this._customDataUpdate && this._customDataUpdate(this._localObject.userData, this._connection._data)); const h = i > 2e3, d = h ? 0 : 1, p = h ? 1 : a, f = h ? 1 : o; this._camera.isPerspectiveCamera && (L(this, hr).multiplyMatrices(this._camera.projectionMatrix, this._camera.matrixWorldInverse), L(this, cr).setFromProjectionMatrix(L(this, hr))); for (let T = 0; T < this.maxInstanceCount; T++)this._instanceInfo[T].active = !1, this._instanceInfo[T].visible = !1; let _ = !1; this._charactersObjects.forEach((T, M) => { var D, R; const w = T.batchedIndex; if (this._instanceInfo[w].active = !0, w > 0) { const P = (D = this._connection) == null ? void 0 : D._clients.get(M); let U = !1; if (P) { let H = this._collisionPhysics._deltaRatioAccumulatorSteps; for (; H > 0;)H--, Object.keys(P).forEach(F => { if (F === "p") { if (P[F].length !== 3) return; T.prevPosition.copy(T.nextPosition), T.nextPosition.fromArray(P[F]), U = U || T.nextPosition.distanceTo(T.prevPosition) > this._positionDeltaLimitSnap, T.velocity.add(L(this, lr).subVectors(T.nextPosition, T.prevPosition)), T.velocity.multiplyScalar(this._velocityCharDamp), T.velocity.multiplyScalar(d * (U ? 0 : 1)); const k = T.velocity.length(), W = k < .001, $ = W ? 1 : 1 - Math.abs(L(this, vi).copy(T.velocity).normalize().dot(T.up)), Z = k * d * $; T.velocityHorizontal = W ? Z : math.lerp(T.velocityHorizontal, Z, .125) } else if (F === "r") { if (P[F].length !== 3) return; T.prevRotation.copy(T.nextRotation), T.nextRotation.setFromEuler(L(this, Kr).fromArray(P[F])) } else H === 0 && (T.userData[F] = P[F]) }) } L(this, vi).lerpVectors(T.prevPosition, T.nextPosition, this._collisionPhysics._deltaRatioAccumulator), L(this, kn).slerpQuaternions(T.prevRotation, T.nextRotation, this._collisionPhysics._deltaRatioAccumulator); const O = U ? 1 : p, N = U ? 1 : f; T.targetPosition.lerp(L(this, vi), O), T.position.lerp(T.targetPosition, O), T.targetRotation.slerp(L(this, kn), N), T.quaternion.slerp(T.targetRotation, N), T.up.set(0, 1, 0).applyQuaternion(T.quaternion) } for (T.updateMatrixWorld(), T.boundingSphere.copy(this._geometryInfo[w].boundingSphere).applyMatrix4(T.matrix), T._inFrustumOfLocalCharacter = w === 0 || L(this, cr).intersectsSphere(T.boundingSphere), T._distanceToLocalCharacter = w === 0 ? 0 : T.position.distanceTo(this._localObject.position), this._updateAnimations(T, l, c), T._inFrustumOfLocalCharacter && (this._instanceInfo[w].visible = !0, !_ && T._distanceToLocalCharacter < characterBatchedSkinnedMesh.UPDATE_DISTANCE && T.modelsID !== this.getModelsID(T) && (_ = !0, this._loadBatchedGeometries(T)), (R = this._customAttribUpdate) == null || R.call(this, { object: T, index: w, id: M, lerp: l, lerp2: c }), T.matrix.toArray(this._matricesTexture.image.data, w * 16)); T.networkEvents.length > 0;)events.emit("character_network_event", { object: T, index: w, id: M, event: T.networkEvents.shift() }) }), this._uploadBuffersPerFrame(), this._updateMultiDrawAndTextures(), this._interactingElementChanged = !1, (x = this._tags) == null || x._update(), (b = this._trails) == null || b.update() } _addCharacter(i, s) { const a = new Set; this._charactersObjects.forEach(h => { a.add(h.batchedIndex) }); let o = -1; for (let h = 1; h < this.maxInstanceCount; h++)if (!a.has(h)) { o = h; break } if (o === -1) return; const l = new Object3D; Object.assign(l, { batchedIndex: o, boundingSphere: new Sphere, prevPosition: new Vector3, nextPosition: new Vector3, targetPosition: new Vector3, prevRotation: new Quaternion, nextRotation: new Quaternion, targetRotation: new Quaternion, velocity: new Vector3, velocityHorizontal: 0, isBeingRemoved: !1, modelsID: "", animationProps: { offset: Math.random() * 100, weights: [], mixer: null, actions: [], lastUpdate: 0 }, networkEvents: [] }); const c = s.networkEvent || ""; Object.defineProperty(l.userData, "networkEvent", { enumerable: !0, get: () => "", set: () => { } }), Object.defineProperty(s, "networkEvent", { enumerable: !0, get: () => "", set: h => { !h || typeof h != "string" || l.networkEvents.push(h) } }), s.networkEvent = c, Object.keys(s).forEach(h => { if (h === "p") { if (s[h].length !== 3) return; l.position.fromArray(s.p), l.prevPosition.copy(l.position), l.nextPosition.copy(l.position), l.targetPosition.copy(l.position) } else if (h === "r") { if (s[h].length !== 3) return; l.rotation.fromArray(s.r), l.prevRotation.copy(l.quaternion), l.nextRotation.copy(l.quaternion), l.targetRotation.copy(l.quaternion), l.up.set(0, 1, 0).applyQuaternion(l.quaternion) } else l.userData[h] = s[h] }), l.animationProps.weights = new Array(l.userData.animationFiles.length).fill(0).map((h, d) => d === 0 ? 1 : 0), l.scale.setScalar(0), this._charactersObjects.set(i, l) } _removeCharacter(i) { if (!this._charactersObjects.has(i)) return; const s = this._charactersObjects.get(i), a = `${i}-removing`; this._charactersObjects.delete(i), this._charactersObjects.set(a, s), s.userData.tag && (s.userData.tag = ""), s.isBeingRemoved = !0, createTween(s.scale, { to: { x: 0, y: 0, z: 0 }, ease: "power2.out", duration: .15, onComplete: () => { this._charactersObjects.delete(a) } }) } _removeAllCharacters() { this._charactersObjects.clear(), this._charactersObjects.set(this.LOCAL_ID, this._localObject) } _emitNetworkEvent(i = "") { var s; !i || typeof i != "string" || (this._localObject.networkEvents.push(i), (s = this._connection) != null && s._connected && this._connection._sendRelayedData({ networkEvent: i })) } setInitialPosition(i = [0, 0, 0], s = 2, a = 0, o = [0, 1, 0]) { if (!this._collisionPhysics._collider) return; this._initialUp.fromArray(o).normalize(); const l = Math.random() * s, c = Math.random() * Math.PI * 2; L(this, kn).setFromUnitVectors(L(this, vi).set(0, 1, 0), this._initialUp), L(this, vi).set(l * Math.cos(c), 0, l * Math.sin(c)).applyQuaternion(L(this, kn)), L(this, or).fromArray(i).add(L(this, vi)); const h = Math.max(.5, this._collisionPhysics._charactersCapsule.segment.end.y + this._collisionPhysics._charactersCapsule.radius * 2); L(this, vi).copy(L(this, or)).addScaledVector(this._initialUp, h), this._collisionPhysics._rayCaster.set(L(this, vi), L(this, lr).copy(this._initialUp).negate()); const d = this._collisionPhysics._rayCaster.intersectObject(this._collisionPhysics._collider)[0]; if (d) this._initialPosition.copy(d.point); else { const p = this._collisionPhysics._geometry.boundsTree.closestPointToPoint(L(this, vi).fromArray(i)); this._initialPosition.copy(p.point) } this._initialRotation = a, this._collisionPhysics._snap(this._initialPosition.toArray(), this._initialRotation, this._initialUp.toArray(), !0) } setControlMode(i) { i !== this._controlMode && (this._controlMode = i, this._camera.isFollowCamera && this._camera._sphericalTarget.copy(this._camera._spherical)) } setModels({ bonesFile: i = "", modelFiles: s = [], animationFiles: a = [] }) { i && (this._localObject.userData.bonesFile = `avatar/${i}`), s.length > 0 && (this._localObject.userData.modelFiles = s.map(o => `avatar/${o}`)), a.length > 0 && (this._localObject.userData.animationFiles = a.map(o => `avatar/${o}`)) } dispose() { var i; (i = this._connection) == null || i.dispose(), this._connection = null, this._controls.dispose(), this._controls = null, this._collisionPhysics.geometry && (this._collisionPhysics.geometry.boundsTree = null, this._collisionPhysics.geometry.dispose()), super.dispose(), this._camera = null, this._scene = null, this.geometry = null } }, vi = new WeakMap, or = new WeakMap, lr = new WeakMap, Kr = new WeakMap, kn = new WeakMap, cr = new WeakMap, hr = new WeakMap, Ke(ki, "MEDIUMS", { GROUND: 0, AIR: 1, WATER: 2 }), Ke(ki, "INITIAL_DATA", { medium: ki.MEDIUMS.GROUND, animation: 0, bonesFile: "avatar/avatar-bones", modelFiles: ["avatar/avatar"], animationFiles: ["avatar/avatar-idle", "avatar/avatar-run", "avatar/avatar-air"], tag: "", networkEvent: "" }), ki); function clone(r) { const e = new Map, i = new Map, s = r.clone(); return parallelTraverse(r, s, function (a, o) { e.set(o, a), i.set(a, o) }), s.traverse(function (a) { if (!a.isSkinnedMesh) return; const o = a, l = e.get(a), c = l.skeleton.bones; o.skeleton = l.skeleton.clone(), o.bindMatrix.copy(l.bindMatrix), o.skeleton.bones = c.map(function (h) { return i.get(h) }), o.bind(o.skeleton, o.bindMatrix) }), s } function parallelTraverse(r, e, i) { i(r, e); for (let s = 0; s < r.children.length; s++)parallelTraverse(r.children[s], e.children[s], i) } class NPCSkinnedMesh extends SkinnedMesh { static createAction({ mixer: e, animation: i, options: s = {}, enabled: a = !1 } = {}) { const o = e.clipAction(i.clone()); return o.setEffectiveTimeScale(s.speed || 1), o.setEffectiveWeight(a ? 1 : 0), o.weight = 1, a ? o.play() : o.enabled = !1, o } constructor({ skin: e, material: i, depthMaterial: s, animations: a = [], animationsOptions: o = [] } = {}) { const l = clone(e); super(l.geometry, i), this.customDepthMaterial = s, l.skeleton._originalUpdate = l.skeleton.update, l.skeleton.update = () => { }, l.children.forEach(c => this.add(c)), this.bind(l.skeleton), this.skeleton.computeBoneTexture(), this._mixer = new AnimationMixer(this), this._mixerOffset = Math.random() * 100, this._actions = {}, this._activeAction = null, this._lastUpdate = -Math.random(), ["idle", "talk", "idleTalk", "walk"].forEach((c, h) => { if (!a[h]) return; const d = !this._activeAction; this._actions[c] = NPCSkinnedMesh.createAction({ mixer: this._mixer, animation: a[h], options: o[h] || {}, enabled: d }), d && (this._activeAction = this._actions[c]) }), this._mixer.setTime(renderInfo.time + this._mixerOffset), this.updateMatrixWorld() } updateMatrixWorld() { if (!this._actions.idle || !this._actions.talk) return; let e = this._activeAction; if (this._talking ? this._talkAnimationPlaying ? e = this._actions.talk : e = this._actions.idleTalk : this._isClose && (this._alwaysFaceCharacter || this._characters.interactingElement === this) ? e = this._actions.idle : this._curve ? e = this._actions.walk : e = this._actions.idle, this._activeAction !== e) { let i = .5; (this._activeAction === this._actions.talk || e === this._actions.talk) && (i = 1), this._activeAction._scheduleFading(i * 2, this._activeAction.getEffectiveWeight(), 0), e.enabled = !0, e._scheduleFading(i, e.getEffectiveWeight(), 1).play(), this._activeAction = e } this.updateMatrix(), this.matrixWorld.copy(this.matrix), this.children.forEach(i => { i.isBone || i.updateMatrixWorld() }) } onBeforeRender() { if (miscutils.hasRunThisFrame(this.skeleton)) return; const e = math.fit(this._distanceToCharacter, characterBatchedSkinnedMesh.UPDATE_DISTANCE * .1, characterBatchedSkinnedMesh.UPDATE_DISTANCE, 0, characterBatchedSkinnedMesh.UPDATE_DISTANCE_MULT); renderInfo.time - this._lastUpdate < e || (this._lastUpdate = renderInfo.time, this._mixer.setTime(renderInfo.time + this._mixerOffset), this.children.forEach(i => { i.isBone && i.updateMatrixWorld() }), this.bindMatrixInverse.copy(this.matrixWorld).invert(), this.skeleton._originalUpdate()) } } function createMaterial$1(r) {
    return new ShaderMaterial({
        uniformsGroups: [global$1.UBO], uniforms: { uColor1: { value: new Color }, uColor2: { value: new Color }, tBand: { value: null }, tCurve: { value: null }, uShowDistance: { value: 1 }, uScale: { value: 1 }, uShow: { value: 1 }, uPulse: { value: 0 }, uWiggleDir: { value: new Vector3(0, 1, 0) } }, vertexShader: `
            ${globalUBO_default}
            ${matrixutils_default}
            ${slugvs_default}

            varying vec2 vUv;
            varying vec2 vHighPrecisionZW;

            uniform float uShowDistance;
            uniform float uScale;
            uniform float uShow;
            uniform float uPulse;
            uniform vec3 uWiggleDir;

            void main() {
                vUv = uv;

                vec3 pos = SlugVS();
                vec3 wPos = (modelMatrix * vec4(pos, 1.0)).xyz;

                float scale = smoothstep(uShowDistance, uShowDistance * 0.8, distance(wPos, cameraPosition)) * uScale * uShow;
                scale = mix(scale, scale * 1.2, uPulse);

                pos *= scale;
                pos += uWiggleDir * (0.05 + 0.05 * sin(time * 4.0));

                gl_Position = projectionMatrix * viewMatrix * billboardModelMatrix() * vec4(pos, 1.0);
                vHighPrecisionZW = gl_Position.zw;
            }
        `, fragmentShader: `
            layout(location = 1) out highp vec4 gInfo;

            ${slugfs_default}

            varying vec2 vUv;
            varying vec2 vHighPrecisionZW;

            uniform sampler2D tCurve;
            uniform usampler2D tBand;
            uniform vec3 uColor1;
            uniform vec3 uColor2;

            void main() {
                vec4 color = RenderSlug(tCurve, tBand, vTexCoord, vColor, vBanding, vGlyph);
                if (color.w * vColor.w < 0.001) discard;

                gl_FragColor = vec4(color.rgb, 0.0);
                gInfo = vec4(1.0 - (0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5), vec3(0.0));
            }
        `})
} var ur; class topIcon extends Group { constructor({ object: i = null, iconFiles: s = [], color1: a = "#f5fdff", color2: o = "#a7c3fb", colorHighlight: l = "#47ebcf", sizeActive: c = .35, sizeInactive: h = .35, center: d = "bottom", offset: p = [0, .1, 0], wiggleDirection: f = [0, 1, 0], materialGenerator: _ = createMaterial$1 } = {}) { super(); pe(this, ur, new Vector3); this.name = `icon - ${i.name}`, this.visible = !1, this.ready = miscutils.deferred(), this._object = i, this._iconFiles = s, this._sizeActive = c, this._sizeInactive = h, this._center = d, this._offset = new Vector3().fromArray(p), this._wiggleDirection = new Vector3().fromArray(f), this._materialGenerator = _, this._color1 = new Color(a), this._color2 = new Color(o), this._colorHighlight = new Color(l), this._colorTarget = this._color2.clone(), this._active = !0, this._visibilityDistance = 20, this._isClose = !1, this._show = 1, this._hasUpdatedOnce = !1, this._createIcons() } async _createIcons() { var o, l, c, h; const i = this._iconFiles.map(d => Promise.all([glyphLoader.loadTexture(d, "band"), glyphLoader.loadTexture(d, "curve"), glyphLoader.loadGeometry(d, { size: 1 })])), [s, a] = await Promise.all(i);[s[2], a[2]].forEach((d, p) => { this._center === "bottom" ? d.translate(0, d.boundingBox.max.y, 0) : this._center === "up" && d.translate(0, d.boundingBox.min.y, 0); const f = p === 0 ? this._sizeInactive : this._sizeActive; d.scale(f, f, f) }), this._inactiveIcon = new Mesh(s[2], this._materialGenerator("inactive")), this._inactiveIcon.name = "inactive", this._inactiveIcon.originalScale = this._inactiveIcon.scale.clone(), (o = this._inactiveIcon.material.uniforms.uColor1) == null || o.value.copy(this._color1), (l = this._inactiveIcon.material.uniforms.uColor2) == null || l.value.copy(this._color2), this._inactiveIcon.material.uniforms.tBand.value = s[0], this._inactiveIcon.material.uniforms.tCurve.value = s[1], this._inactiveIcon.material.uniforms.uShowDistance.value = this._visibilityDistance, this._inactiveIcon.material.uniforms.uWiggleDir.value.copy(this._wiggleDirection), this.add(this._inactiveIcon), this._activeIcon = new Mesh(a[2], this._materialGenerator("active")), this._activeIcon.name = "active", this._activeIcon.visible = !1, this._activeIcon.originalScale = this._activeIcon.scale.clone(), (c = this._activeIcon.material.uniforms.uColor1) == null || c.value.copy(this._color1), (h = this._activeIcon.material.uniforms.uColor2) == null || h.value.copy(this._color2), this._activeIcon.material.uniforms.tBand.value = a[0], this._activeIcon.material.uniforms.tCurve.value = a[1], this._activeIcon.material.uniforms.uShowDistance.value = this._visibilityDistance, this._inactiveIcon.material.uniforms.uWiggleDir.value.copy(this._wiggleDirection), this._activeIcon.material.uniforms.uScale.value = 0, this.add(this._activeIcon), this._object.add(this), this.ready.resolve() } pulse() { [this._activeIcon, this._inactiveIcon].forEach(i => { i.material.uniforms.uPulse && createTween(i.material.uniforms.uPulse, { to: { value: 1 }, duration: .15, ease: "power2.out", onComplete: () => { createTween(i.material.uniforms.uPulse, { to: { value: 0 }, duration: .2, ease: "power2.out" }) } }) }) } updateMatrixWorld(i) { var o, l; if (miscutils.hasRunThisFrame(this)) return; if (!this._hasUpdatedOnce || !this._object.isWorldSecret) { this._hasUpdatedOnce = !0; const c = this._object.geometry || this._object._bboxMesh.geometry; this.position.set(0, Math.abs(c.boundingBox.min.y) + Math.abs(c.boundingBox.max.y), 0).add(this._offset), super.updateMatrixWorld(i), (this._object.isWorldSecret ? this._object._secretMesh : this._object).getWorldPosition(L(this, ur)) } if (this.visible = this._active && this._object._scene.camera.position.distanceTo(L(this, ur)) < this._visibilityDistance, this._isClose !== this._object._isClose) { this._isClose = this._object._isClose; const c = this._isClose ? "_inactiveIcon" : "_activeIcon", h = this._isClose ? "_activeIcon" : "_inactiveIcon"; createTween(this[h].material.uniforms.uScale, { to: { value: 0 } }), createTween(this[c].material.uniforms.uScale, { to: { value: 0 }, duration: .2, ease: "power2.out", onComplete: () => { this[c].visible = !1, this[h].visible = !0, createTween(this[h].material.uniforms.uScale, { to: { value: 1 }, duration: .5, ease: "elastic.out(1, 0.75)" }) } }), events.emit("topicon_change", { object: this._object, visible: this.visible, isClose: this._isClose, questEnabled: !!this._object._questEnabled }) } let s = !1; this._object.isWorldNPC ? (this._object._talking || !this._object._textsObjectRef.length) && (s = !0) : this._object.isWorldSecret ? (!this._object._canBeDiscovered || this._object._discovered) && (s = !0) : typeof this._object._inactiveState == "boolean" && (s = this._object._inactiveState), this._show = math.lerpFPS(this._show, s ? 0 : 1, .2), this._inactiveIcon.material.uniforms.uShow.value = this._show, this._activeIcon.material.uniforms.uShow.value = this._show; const a = math.lerpCoefFPS(.05); (o = this._inactiveIcon.material.uniforms.uColor2) == null || o.value.lerp(this._colorTarget, a), (l = this._activeIcon.material.uniforms.uColor2) == null || l.value.lerp(this._colorTarget, a) } } ur = new WeakMap; const bubbleGeo = new BufferGeometry; bubbleGeo.setAttribute("position", new BufferAttribute(new Float32Array([-.5, 1, 0, .5, 1, 0, -.5, 0, 0, .5, 0, 0, -.07, 0, 0, 0, -.07, 0, .07, 0, 0]), 3)); bubbleGeo.setAttribute("uv", new BufferAttribute(new Float32Array([0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]), 2)); bubbleGeo.setAttribute("pointer", new BufferAttribute(new Float32Array([0, 0, 0, 0, 1, 1, 1]), 1)); bubbleGeo.setIndex([3, 1, 0, 4, 5, 6, 0, 2, 3]); class bubble extends Group {
    constructor({ npc: e = null, text: i = "placeholder text", index: s = 0, options: a = {} } = {}) { super(), this.name = `Bubble ${s}`, this._npc = e, this._text = i, this._textLengthWithoutTags = meshText.getTextWithoutTags(i).length, this._index = s, this._options = a, this._hiding = !1, this.visible = !1, this.frustumCulled = !1, this._createBubble() } _createBubble() {
        var o; const e = typeof this._options.bubbleMaterialGenerator == "function" ? this._options.bubbleMaterialGenerator : null, i = this._options.bubbleMaterialGeneratorArgs || void 0; this._bubble = new Mesh(bubbleGeo, (e == null ? void 0 : e(i)) || new ShaderMaterial({
            uniforms: { uSize: { value: new Vector2(1, 1) }, uColor: { value: new Color("#ffffff") } }, vertexShader: `
                attribute float pointer;

                ${matrixutils_default}

                uniform vec2 uSize;

                varying vec2 vUv;
                flat varying float vPointer;
                varying vec2 vHighPrecisionZW;

                void main() {
                    vUv = uv;
                    vPointer = pointer;

                    vec3 pos = position;
                    if (pointer < 0.5) pos.xy *= uSize;
                    pos.y += 0.07; // compensate for pointer
                    pos.z -= 0.1; // move behind of texts

                    gl_Position = projectionMatrix * viewMatrix * billboardModelMatrix() * vec4(pos, 1.0);
                    vHighPrecisionZW = gl_Position.zw;
                }
            `, fragmentShader: `
                layout(location = 1) out highp vec4 gInfo;

                uniform vec2 uSize;
                uniform vec3 uColor;

                varying vec2 vUv;
                flat varying float vPointer;
                varying vec2 vHighPrecisionZW;

                float sdRoundedBox(vec2 p, vec2 b, float r) {
                    vec2 q = abs(p) - b + r;
                    return min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r;
                }

                void main() {
                    if (vPointer < 0.5) {
                        vec2 aspectMult = mix(vec2(uSize.x / uSize.y, 1.0), vec2(1.0, uSize.y / uSize.x), step(uSize.x, uSize.y));
                        float shape = sdRoundedBox((vUv - 0.5) * aspectMult, vec2(0.5) * aspectMult, 0.1 / min(uSize.x, uSize.y));
                        if (shape > 0.001) discard;
                    }

                    gl_FragColor = vec4(uColor, 0.0);
                    gInfo = vec4(1.0 - (0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5), vec3(0.0));
                }
            `})), this._bubble.name = "bubble background", this._bubble.frustumCulled = !1, this._bubble.scale.setScalar(0), this.add(this._bubble); const s = typeof this._options.textMaterialGenerator == "function" ? this._options.textMaterialGenerator : null, a = this._options.textMaterialGeneratorArgs || void 0; this._textMesh = new meshText({ font: "REM-Medium.font", text: this._text, size: .15, align: "left", width: 2, letterSpacing: 0, lineHeight: .85, ...((o = this._options) == null ? void 0 : o.textOptions) || {} }, (s == null ? void 0 : s(a)) || void 0), this._textMesh.name = "bubble text", this._textMesh.frustumCulled = !1, this.add(this._textMesh), this._textMesh.ready.then(() => this._updateBubbleSizes())
    } _updateBubbleSizes() { var h, d, p, f, _, x; const e = this._options.marginX || .175, i = this._options.marginY || .1, s = this._textMesh.size.x, a = this._textMesh.size.y + this._textMesh.lineSize, o = (d = (h = this._bubble.material) == null ? void 0 : h.uniforms) == null ? void 0 : d.uSize; o && (o.value.set(s, a), o.value.x += e * 2, o.value.y += i * 2); const l = (f = (p = this._textMesh.material) == null ? void 0 : p.uniforms) == null ? void 0 : f.uSize, c = (x = (_ = this._textMesh.material) == null ? void 0 : _.uniforms) == null ? void 0 : x.uMargins; l && l.value.set(s, a), c && c.value.set(e, i) } show(e) { var s; if (this.visible) return; const i = (s = this._textMesh.material) == null ? void 0 : s.uniforms; this._updateBubbleSizes(), this._hiding = !1, this.visible = !0, events.emit("npc_bubble_show", { object: this._npc, npc: this._npc._id, text: this._text, index: this._index }), createTween(this._bubble.scale, { to: { x: 1, y: 1, z: 1 }, duration: .65, ease: "elastic.out(1, 1)" }), i != null && i.uAlpha && createTween(i.uAlpha, { to: { value: 1 } }), i != null && i.uAnimationProgress && (createTween(i.uAnimationProgress, { to: { value: 0 } }), createTween(i.uAnimationProgress, { from: { value: 0 }, to: { value: 1 }, delay: .35, duration: Math.max(1, e * this._textLengthWithoutTags) * .3, overwrite: !1, ease: "none", onStart: () => { events.emit("npc_bubble_text_starts", { object: this._npc, npc: this._npc._id, text: this._text, index: this._index }) }, onComplete: () => { events.emit("npc_bubble_text_ends", { object: this._npc, npc: this._npc._id, text: this._text, index: this._index }) } })) } hide(e = !1) { var a; const i = (a = this._textMesh.material) == null ? void 0 : a.uniforms; if (e) { this._hiding = !1, this.visible = !1, i != null && i.uAlpha && createTween(i.uAlpha, { to: { value: 0 } }), createTween(this._bubble.scale, { to: { x: 0, y: 0, z: 0 } }); return } if (this._hiding || !this.visible) return; this._hiding = !0, this.visible = !0; const s = { object: this._npc, npc: this._npc._id, text: this._text, index: this._index }; events.emit("npc_bubble_hide", s), i != null && i.uAlpha && createTween(i.uAlpha, { to: { value: 0 }, duration: .075, ease: "none" }), createTween(this._bubble.scale, { to: { x: 0, y: 0, z: 0 }, delay: .075, duration: .2, ease: "sine.in", onComplete: () => { this._hiding = !1, this.visible = !1, events.emit("npc_bubble_hidden", s) } }) } dispose() { var e, i, s, a, o, l, c, h; this._bubble.geometry.dispose(), this._bubble.material.dispose(), this._textMesh.geometry.dispose(), (a = (s = (i = (e = this._textMesh.material.uniforms) == null ? void 0 : e.tCurve) == null ? void 0 : i.value) == null ? void 0 : s.dispose) == null || a.call(s), (h = (c = (l = (o = this._textMesh.material.uniforms) == null ? void 0 : o.tBand) == null ? void 0 : l.value) == null ? void 0 : c.dispose) == null || h.call(c), this._textMesh.material.dispose() }
} const _v0$d = new Vector3, _v1$8 = new Vector3, _m0$2 = new Matrix4, Lt = class Lt extends NPCSkinnedMesh { static calculateDirection(e, i, s) { Lt.vDir0.copy(i), Lt.vDir0.lengthSq() === 0 && (Lt.vDir0.z = 1), Lt.vDir0.normalize(), Lt.vDir1.crossVectors(e.up, Lt.vDir0), Lt.vDir1.lengthSq() === 0 && (Math.abs(e.up.z) === 1 ? Lt.vDir0.x += 1e-4 : Lt.vDir0.z += 1e-4, Lt.vDir0.normalize(), Lt.vDir1.crossVectors(e.up, Lt.vDir0)), Lt.vDir0.crossVectors(Lt.vDir1, e.up), _m0$2.set(Lt.vDir1.x, e.up.x, Lt.vDir0.x, 0, Lt.vDir1.y, e.up.y, Lt.vDir0.y, 0, Lt.vDir1.z, e.up.z, Lt.vDir0.z, 0, 0, 0, 0, 1), s.setFromRotationMatrix(_m0$2) } constructor({ id: e = "npc_0", scene: i, skin: s, material: a, depthMaterial: o = new MeshDepthMaterial({ depthPacking: RGBADepthPacking }), animations: l = [], animationsOptions: c = [], visibilityThreshold: h = 50, talkEnabled: d = !0, talkDistance: p = 3, talkFacingPlayer: f = !0, alwaysFaceCharacter: _ = !1, texts: x = ["Hello, I am a NPC.", "Ya pryamo seychas s toboy govoryu, bratan."], textsBubbles: b = !1, textsBubblesOptions: T = {}, textsBubblesOffset: M = [0, 0, 0], textsReset: w = !1, textsRepeatLast: D = !0, textsSpeed: R = 10, textsOpenTime: P = .75, textsCloseTime: U = .75, textsAutoClose: O = !0, clickInteraction: N = !1, hitboxOffset: H = .75, hoverCursor: F = !1, icon: k = !1, iconFiles: W = [], iconOptions: $ = {}, curve: Z = null, curveSpeed: J = 1, curveProgress: se = 0, curveSpeedAnimationWeight: re = 1, extraData: ce = {} } = {}) { var ee, Me, Ee; if (!i || !s || !a) throw new Error("NPCs require a scene, skin and material"); if (super({ skin: s, material: a, depthMaterial: o, animations: l, animationsOptions: c }), this.isWorldNPC = !0, this.name = `NPC-${e}`, this._id = e, this._scene = i, this._characters = null, this._scene.uploaded.then(() => { this._scene.traverse(Ue => { Ue.isWorldCharacters && (this._characters = Ue, this._originalQuaternion.copy(this.quaternion), this._targetQuaternion.copy(this.quaternion), this._targetPosition.copy(this.position)) }) }), this._visibilityThreshold = h, this._talkEnabled = d, this._talkDistance = p, this._talkFacingPlayer = f, this._alwaysFaceCharacter = _, this._talking = !1, this._talkNeedsToStart = !0, this._talkingDone = !1, this._hasUpdatedOnce = !1, this._talkAnimationPlaying = !1, this._curve = Z && Z.length ? Z[0] : null, this._curveProgress = se % 1, this._curveProgressMultiplier = 1 / (((Ee = (Me = (ee = this._curve) == null ? void 0 : ee.curve) == null ? void 0 : Me.getLength) == null ? void 0 : Ee.call(Me)) || 1) * .001575, this._curveSpeed = J, this._curveSpeedAnimationWeight = 1 / re * .11, this._targetPosition = new Vector3, this._distanceToCharacter = 1 / 0, this._isClose = !1, this._originalQuaternion = new Quaternion, this._targetQuaternion = new Quaternion, this.geometry.computeBoundingBox(), this.geometry.computeBoundingSphere(), this.computeBoundingBox(), this.computeBoundingSphere(), this.boundingSphere.radius += H, this._texts = [...x], this._textsCurrent = 0, this._textsObjectRef = this._texts, this._extraData = ce, this._textsBubbles = b, this._textsBubblesEnabled = this._textsBubbles, this._textsBubblesShown = !1, this._textsBubblesOptions = T, this._textsBubbleGroup = new Group, this._textsBubbleGroup.name = "Text Bubbles Cnt", this._textsBubbleGroupOffset = new Vector3().fromArray(M), this.add(this._textsBubbleGroup), this._textsStart = -1, this._textsEnd = -1, this._textsSpeed = 1 / R, this._textsOpenTime = P, this._textsCloseTime = U, this._textsCloseRequested = !1, this._textsReset = w, this._textsRepeatLast = D, this._textsAutoClose = O, this._questEnabled = !1, this._questTextPreviousCurrent = 0, this._questStepExtraData = {}, this._icon = k ? new topIcon({ object: this, iconFiles: W, ...$ }) : null, this._clickInteractionEnabled = !1, this._clickInteraction = null, this._clickInteracted = !1, N) { const Ue = nt => { if (nt.event.input === "mouse") { if (nt.action !== "touch_start") return } else if (nt.action !== "click") return; this._characters && this._characters._canInteract && (this._characters._camera.isFollowCamera && this._characters._camera.overwriteAmount > 0 || (this._clickInteracted = !0, this._characters._controls.cancelJump())) }; this._clickInteraction = new meshInteraction({ meshes: [this], camera: this._scene.camera, performant: !0, performantMode: "bounding_sphere", hoverCursor: F, onHover: nt => { !this._icon || nt.action !== "hover_in" || this._icon.pulse() }, onTouch: Ue, onClick: Ue }), this._clickInteractionEnabled = !0 } this.ready = miscutils.deferred(), this.setTexts(this._texts, this._textsCurrent, !1, !0), events.on("quest_enable_id", this._onQuestEnable, this), events.on("quest_disable_id", this._onQuestDisable, this), events.on("npc_force_next_dialog", this._forceNextDialog, this), events.on("npc_force_close_dialog", this._forceCloseDialog, this) } updateMatrixWorld() { const e = this._characters, i = e == null ? void 0 : e._localObject; if (!(e != null && e._charactersUpdate) || miscutils.hasRunThisFrame(this)) return; this._distanceToCharacter = i.position.distanceTo(this.position), this._isClose = this._distanceToCharacter < this._talkDistance && this._textsObjectRef.length > 0, this._clickInteractionEnabled && (this._isClose ? e._controls._enabled ? this._clickInteraction.enable() : this._clickInteraction.disable() : (this._clickInteraction.disable(), this._clickInteracted = !1)), this._isClose && (this._alwaysFaceCharacter || e.interactingElement === this) ? this._talkFacingPlayer && Lt.calculateDirection(this, _v0$d.subVectors(i.position, this.position), this._targetQuaternion) : this._curve ? (_v0$d.copy(this._targetPosition), this._curveProgress = (this._curveProgress + renderInfo.delta * this._curveProgressMultiplier * this._curveSpeed) % 1, this._curve.curve.getPointAt(this._curveProgress, this._targetPosition), Lt.calculateDirection(this, _v1$8.subVectors(this._targetPosition, _v0$d), this._targetQuaternion)) : this._targetQuaternion.copy(this._originalQuaternion), this._hasUpdatedOnce ? (this.position.lerp(this._targetPosition, math.lerpCoefFPS(.1)), this.quaternion.slerp(this._targetQuaternion, math.lerpCoefFPS(.04))) : (this._hasUpdatedOnce = !0, this.position.copy(this._targetPosition), this.quaternion.copy(this._targetQuaternion)), this.visible = this._distanceToCharacter < this._visibilityThreshold, this._clickInteractionEnabled && (this._talkingDone || e.interactingElement !== null && e.interactingElement !== this) && (this._clickInteracted = !1), this._resetTalkingDone(); let s = this._talkEnabled && this.visible && this._isClose && !this._talkingDone; if (s && this._clickInteractionEnabled && !this._clickInteracted && (s = !1), s ? e.interactingElement || (e.interactingElement = this) : e.interactingElement === this && !this._textsBubblesShown && (e.interactingElement = null), this._talking = s && e.interactingElement === this, this._talking) if (this._textsStart === -1) this._textsEnd === -1 && (this._talkNeedsToStart && (this._talkNeedsToStart = !1, events.emit("quest_step_texts_check", this), (this._textsCurrent < this._textsObjectRef.length - 1 || this._textsReset) && (this._textsCurrent = 0)), this._textsCloseRequested = !1, this._openText(), this._updateTalkAnimation(!0)); else { const a = this._textsObjectRef[this._textsCurrent]; let o = -1 / 0; typeof a == "string" && (o = meshText.getTextWithoutTags(a).length * this._textsSpeed, o = Math.max(1, o)); const l = renderInfo.time - this._textsStart - this._textsOpenTime; l > o && this._updateTalkAnimation(!1); let c = 1 / 0; this._textsCloseRequested ? c = -1 / 0 : this._textsAutoClose && (c = o), l > c && (this._textsEnd === -1 ? (this._closeText(), this._textsCurrent === this._textsObjectRef.length - 1 ? (this._talkingDone = !0, events.emit("npc_dialog_finished", this._id), events.emit("quest_step_check", this)) : this._textsCurrent++) : this._textsEnd + this._textsCloseTime < renderInfo.time && (this._textsStart = -1, this._textsEnd = -1)) } else this._closeTextIfNeeded(), this._talkNeedsToStart = !0; this._updateBubblesState(), this.visible && super.updateMatrixWorld() } _resetTalkingDone() { this._talkingDone && (!this._textsRepeatLast && !this._textsReset || (!this._isClose || this._clickInteractionEnabled) && (this._talkingDone = !1)) } _onQuestEnable(e) { e === this._id && (this._questEnabled = !0, this._texts === this._textsObjectRef && (this._questTextPreviousCurrent = this._textsCurrent), this._textsObjectRef.length === 0 && this.setTexts(["-"]), this._icon && this._icon._colorTarget.copy(this._icon._colorHighlight)) } _onQuestDisable(e) { e === this._id && (this._questEnabled = !1, this._textsObjectRef !== this._texts && this.setTexts(this._texts, this._questTextPreviousCurrent), this._questTextPreviousCurrent = 0, this._questStepExtraData = {}, this._icon && this._icon._colorTarget.copy(this._icon._color2)) } _forceNextDialog(e) { e !== this._id || !this._characters || (this._textsCloseRequested = !0) } _forceCloseDialog(e) { e !== this._id || !this._characters || (this._textsCurrent === this._textsObjectRef.length - 1 ? this._forceNextDialog(e) : this._talkingDone = !0) } _closeText() { this._textsCloseRequested = !0, this._textsEnd = renderInfo.time, events.emit("npc_dialog_close", this._id), this._updateTalkAnimation(!1) } _closeTextIfNeeded() { this._textsStart !== -1 && this._textsEnd === -1 && (this._closeText(), events.emit("npc_dialog_interrupted", this._id)) } _openText() { this._textsStart = renderInfo.time, events.emit("npc_dialog_open", this._id, this._textsObjectRef[this._textsCurrent], this._extraData, { currentText: this._textsCurrent, totalTexts: this._textsObjectRef.length, bubblesEnabled: this._textsBubblesEnabled, stepExtraData: this._questStepExtraData }) } _updateTalkAnimation(e = !1) { this._talkAnimationPlaying !== e && (this._talkAnimationPlaying = e, events.emit("npc_talk_update", { id: this._id, object: this, talking: e })) } _disposeTextsBubbles() { this._textsBubbleGroup.children.forEach(e => { var i; return (i = e.dispose) == null ? void 0 : i.call(e) }), this._textsBubbleGroup.clear(), this._textsBubblesShown = !1 } _createBubbles() { if (!this._textsBubbles) return; const e = []; return this._textsObjectRef.forEach((i, s) => { const a = typeof i == "string" ? new bubble({ npc: this, text: i, options: this._textsBubblesOptions, index: s }) : new Group; a.visible = !1, this._textsBubbleGroup.add(a), e.push(a._textMesh.ready) }), Promise.all(e) } _updateBubblesState() { !this._textsBubbles || !this._textsBubblesEnabled || (this._textsBubbleGroup.position.set(0, this.boundingSphere.radius + .2, 0).add(this._textsBubbleGroupOffset), this._textsBubblesShown = !1, this._textsBubbleGroup.children.forEach((e, i) => { var s, a; i === this._textsCurrent && this._textsStart !== -1 && this._textsEnd === -1 ? (s = e.show) == null || s.call(e, this._textsSpeed) : (a = e.hide) == null || a.call(e), e.visible && (this._textsBubblesShown = !0) })) } async setTexts(e, i = 0, s = !1, a = !1) { this._textsObjectRef = e, this._textsCurrent = i, s && (this._texts = e); const o = []; this._textsBubbles && a && (this._disposeTextsBubbles(), o.push(this._createBubbles())), this._icon && o.push(this._icon.ready), await Promise.all(o), this.ready.resolve() } disableBubbles() { if (!this._textsBubbles) throw new Error("Create the NPC with bubbles to be able to disable them"); this._textsBubblesEnabled = !1, this._textsBubblesShown = !1, this._textsBubbleGroup.children.forEach((e, i) => { var s; return (s = e.hide) == null ? void 0 : s.call(e, !0) }) } enableBubbles() { if (!this._textsBubbles) throw new Error("Create the NPC with bubbles to be able to enable them"); this._textsBubblesEnabled = !0 } disableClickInteraction() { if (!this._clickInteraction) throw new Error("Create the NPC with click interaction to be able to disable it"); this._resetTalkingDone(), this._clickInteraction.disable(), this._clickInteracted = !1, this._clickInteractionEnabled = !1 } enableClickInteraction() { if (!this._clickInteraction) throw new Error("Create the NPC with click interaction to be able to enable it"); this._resetTalkingDone(), this._clickInteraction.enable(), this._clickInteracted = !1, this._clickInteractionEnabled = !0 } dispose() { var e, i, s, a, o; events.off("quest_enable_id", this._onQuestEnable, this), events.off("quest_disable_id", this._onQuestDisable, this), events.off("npc_force_next_dialog", this._forceNextDialog, this), events.off("npc_force_close_dialog", this._forceCloseDialog, this), this._closeTextIfNeeded(), this._disposeTextsBubbles(), (i = (e = this._clickInteraction) == null ? void 0 : e.dispose) == null || i.call(e), (o = (a = (s = this._curve) == null ? void 0 : s.geometry) == null ? void 0 : a.dispose) == null || o.call(a), this.skeleton.dispose() } }; Ke(Lt, "vDir0", new Vector3), Ke(Lt, "vDir1", new Vector3); let NPC = Lt; class quest { constructor({ id: e = "quest_0", steps: i = [], finalEvents: s = [], recreateNPCBubbles: a = !1 } = {}) { if (!i || !i.length) throw new Error("Quests must have at least one step"); this._id = e, this._steps = i.map((o, l) => ({ id: o.id || `${this._id}_${l}`, optional: o.optional || !1, ordered: o.ordered || !1, minimumTimeSinceLastStep: o.minimumTimeSinceLastStep || -1, completed: o.completed || !1, text: o.text || !1, texts: o.texts || !1, extraData: o.extraData || {}, _enabled: !1 })), this._finalEvents = s, this._recreateNPCBubbles = a, this._lastTimeUpdateStep = 0, this._isQuestCompleted() ? this._finishQuest(!1) : (this._ensureElementsEnabled(), events.on("quest_step_texts_check", this._onQuestTexts, this), events.on("quest_step_check", this._onQuestStep, this)), this._initialized = !0 } _isQuestCompleted(e = this._steps.length) { const i = e === this._steps.length ? !0 : this._steps[e].ordered; let s = !0; for (let a = 0; a < e; a++)if (!(this._steps[a].completed || this._steps[a].optional) && (this._steps[a].ordered || i)) { s = !1; break } return s } _enableStep(e) { e._enabled || (e._enabled = !0, events.emit("quest_enable_id", e.id, e.extraData)) } _ensureElementsEnabled() { let e = !1; for (let i = 0; i < this._steps.length; i++) { const s = this._steps[i]; if (s.completed || s.optional && !s.ordered) { this._enableStep(s); continue } if (!e && (this._enableStep(s), !s.optional)) { if (s.ordered) e = !0; else for (let a = i + 1; a < this._steps.length; a++)if (!this._steps[a].completed) { this._steps[a].ordered && (e = !0); break } } } } _onQuestStep(e) { const i = typeof e == "string" ? e : e._id; for (let s = 0; s < this._steps.length; s++) { const a = this._steps[s]; if (i === a.id && !a.completed) { renderInfo.time - this._lastTimeUpdateStep > a.minimumTimeSinceLastStep && (a.optional && !a.ordered || this._isQuestCompleted(s)) && (this._lastTimeUpdateStep = renderInfo.time, a.completed = !0, events.emit("quest_step_completed", this._id, i, s, a.extraData)); break } } this._isQuestCompleted() ? this._finishQuest() : this._ensureElementsEnabled() } _finishQuest(e = !0) { this._steps.forEach(i => { events.emit("quest_disable_id", i.id, i.extraData) }), this.dispose(), e && events.emit("quest_completed", this._id), this._finalEvents.forEach(i => { i && events.emit(i) }) } _onQuestTexts(e) { for (let i = 0; i < this._steps.length; i++) { const s = this._steps[i]; if (e._id === s.id && !s.completed) { this._isQuestCompleted(i) && (e.isWorldSecret && s.text && s.text.length > 0 ? e._textRef = s.text : e.isWorldNPC && (s.texts && s.texts.length > 0 && e.setTexts(s.texts, 0, !1, this._recreateNPCBubbles), s.extraData && (e._questStepExtraData = s.extraData))); break } } } dispose() { this._steps = [], events.off("quest_step_texts_check", this._onQuestTexts, this), events.off("quest_step_check", this._onQuestStep, this) } } const questData = { quests: [{ id: "quest-employee", description: "Nepriyatnosti na rabote", steps: [{ id: "office-worker-2", ordered: !0, optional: !1, texts: ["Slava bogu, ty zdes! Ya otpravil pismo nachalniku, no nuzhno vernut ego, poka on ne prochital...", "On zhivyot v dome na Svetlogorskom obryve. Kak dumaesh, on uzhe prochital?"], extraData: { uiTitle: "Next Up", uiIcon: "ui/quests/house.icon", uiText: "Find the red cliff house and get the letter back", uiColor: "#c25959" } }, { id: "boss", ordered: !0, optional: !1, texts: ["Odin iz sotrudnikov napisal eto? Ne mozhet byt... eto... prosto...", "...voskhititelno. On realno menya zhzhyot. Mozhet, iz nego vyydet khoroshiy rukovoditel...", "Mozhesh vernut emu etu zapisku? On rabotaet na Ostrove Kanta."], extraData: { uiTitle: "Package Received", uiIcon: "ui/quests/officeworker.icon", uiText: "OTVEZI MENEDZhERU V DOM SOVETOV'S NOTE TO THE OFFICE WORKER IN THE MAIN SQUARE", uiColor: "#c25959", receiveModel: "deliveries/note.drc" } }, { id: "office-worker-2", ordered: !0, optional: !1, texts: ["I'Menya... povyshayut?", "Ogo, kto by mog podumat, chto torgovlya kontrabandoy tak pomogaet v zhizni."], extraData: { uiTitle: "Completed", uiIcon: "ui/quests/complete.icon", uiText: "POZDRAVLYaEM! ESchYo ODNA USPEShNAYa DOSTAVKA V KALININGRADE!", uiColor: "#c25959" } }] }, { id: "quest-caveman", description: "Chelovek, pryachuschiysya ot chego-to", steps: [{ id: "caveman", ordered: !0, optional: !1, texts: ["Privet! Ne mog by ty otnesti etu otkrytku moey zhene? Ona prodayot tsvety na rybnom rynke.", "Ya by sam otnyos, no... em... koleno podvodit v poslednee vremya..."], extraData: { uiTitle: "Package Received", uiIcon: "ui/quests/flowerlady.icon", uiText: "OTVEZI YaNTARSchIKU NA KOSU'S POSTCARD TO THE WOMAN IN THE MAIN SQUARE", uiColor: "#f3c258", receiveModel: "deliveries/postcard.drc" } }, { id: "flower-lady", ordered: !0, optional: !1, texts: ["O, otkrytka ot muzha!", "He'seychas zakupaetsya sanktsionkoy v Polshe!", "Slushay, mezhdu nami, on zhivyot v peschere v Kurshskoy kose... Nadeyus, krizis srednego vozrasta skoro proydyot...", "Ne mog by ty otnesti emu chistye veschi? Ne govori, chto ot menya. Skazhi, chto on vyigral kilo yantarya."], extraData: { uiTitle: "Package Received", uiIcon: "ui/quests/cave.icon", uiText: "OTNESI ChISTUYu ODEZhDU YaNTARSchIKU V PESchERE", uiColor: "#f3c258", receiveModel: "deliveries/clothes.drc" } }, { id: "caveman", ordered: !0, optional: !1, texts: ["Ogo, eschyo odin kusok yantarya?", "Kak raz vovremya, a u menya uzhe poslednee ispodnee ostalos."], extraData: { uiTitle: "Completed", uiIcon: "ui/quests/complete.icon", uiText: "POZDRAVLYaEM! ESchYo ODNA USPEShNAYa DOSTAVKA V KALININGRADE!", uiColor: "#f3c258" } }] }, { id: "quest-scientists", description: "Uchyonye i pereputannye posylki", steps: [{ id: "factory-worker-a", ordered: !0, optional: !1, texts: ["Mozhesh pomoch? U nas nekhvatka kadrov, i para posylok sluchayno ushla v Polshu po oshibke...", "Naydi Professora Immanuila i uznay, ne prikhodili li emu posylki. On zhivyot u podnozhiya gornogo zamka."], extraData: { uiTitle: "Next Up", uiIcon: "ui/quests/frieb.icon", uiText: "FIND DOCTOR FRIEB AT THE BASE OF THE MOUNTAIN TEMPLE", uiColor: "#66BDE6" } }, { id: "male-scientist", ordered: !0, optional: !1, texts: ['Hello! Yes, I opened some mail by mistake earlier. A "analiz gravitatsionnykh dannykh planety", or something...', "Menya, navernoe, pereputali s Doktorom Frebi (ili Kantom?) iz Doma Sovetov...", "...podozhdite, eto znachit MOY ZAKAZ otpravili Doktoru Frebi? O net!!!", "Ya... em... vsyo ravno vsyo pereputal... Skazhi ey, chto mne eto bolshe ne nuzhno..."], extraData: { uiTitle: "Package Received", uiIcon: "ui/quests/frebi.icon", uiText: "TAKE THE GRAVITY DATA ANALYSIS TO DOCTOR FREBI, AT CAPITAL CORP", uiColor: "#66BDE6", receiveModel: "deliveries/samplebox.drc" } }, { id: "female-scientist", ordered: !0, optional: !1, texts: ["O, ty iz sluzhby dostavki? Kak raz khotel pogovorit s kem-nibud iz vas...", "Znaesh, pochemu ya poluchil 63 upakovki shprot? Eto chto, v Viktoriyu dolzhno bylo idti?", "Ne znaesh nichego ob etom? Nu ladno. Spasibo za posylku."], extraData: { uiTitle: "Completed", uiIcon: "ui/quests/complete.icon", uiText: "POZDRAVLYaEM! ESchYo ODNA USPEShNAYa DOSTAVKA V KALININGRADE!", uiColor: "#66BDE6" } }] }, { id: "quest-temple", description: "Dar gornomu khramu", steps: [{ id: "oldwoman", ordered: !0, optional: !1, texts: ["Prostite, ne mogli by vy otnesti eto podnoshenie v gornyy khram?", "Mne uzhe tyazhelo podnimatsya na dyunu samomu."], extraData: { uiTitle: "Package Received", uiIcon: "ui/quests/temple.icon", uiText: "OTVEZI BABUShKE V ZELENOGRADSK'S OFFERING TO THE MOUNTAIN TEMPLE", uiColor: "#8cc48c", receiveModel: "deliveries/offering.drc" } }, { id: "mountainman", ordered: !0, optional: !1, texts: ["O, pirozhki i sake?", "Moya lyubimaya stroganina."], extraData: { uiTitle: "Completed", uiIcon: "ui/quests/complete.icon", uiText: "POZDRAVLYaEM! ESchYo ODNA USPEShNAYa DOSTAVKA V KALININGRADE!", uiColor: "#8cc48c" } }] }, { id: "quest-musician", description: "Zapiska, zateryannaya v more", steps: [{ id: "diver", ordered: !0, optional: !1, texts: ["Smotri! Ya nyryal za yantarem u Svetlogorska i nashel eti konteynery v peske.", "V odnom iz nikh bylo pismo. Nemnogo namoklo, no ya razobral imya Deyv naverkhu.", "Bezumie, da? Ya znayu odnogo Denisa. Dumaesh, eto on?", "He'navernoe, u Pregoli, esli khochesh otnesti emu."], extraData: { uiTitle: "Package Received", uiIcon: "ui/quests/musician.icon", uiText: "OTNESI TAYNOE PISMO DENISU NA PREGOLYu", uiColor: "#de794e", receiveModel: "deliveries/letterwet.drc" } }, { id: "musician", ordered: !0, optional: !1, texts: ["Pismo mne? So dna Baltiyskogo morya? Ya zhe sam ego i napisal!", "Let'posmotrim, chto ya sebe napisal togda...", '"Dorogoy Buduschiy Deyv..."', '"Treniruysya kazhdyy den..."', '"Pobolshe solntsa..."', '"Beregi volosy, pust rastut kak dyuny na Kurshskoy kose."', "Nu...", "...dvoe iz tryokh  neplokhoy rezultat."], extraData: { uiTitle: "Completed", uiIcon: "ui/quests/complete.icon", uiText: "POZDRAVLYaEM! ESchYo ODNA USPEShNAYa DOSTAVKA V KALININGRADE!", uiColor: "#de794e" } }] }] }, QUESTINFO = {}; questData.quests.forEach(r => { QUESTINFO[r.id] = { text: r.description, steps: r.steps.map(e => e.completed === !0) } }); let progress = client$1.localStorage.questProgress || {}; const initialKeys = Object.keys(progress); function reset() { progress = {}, Object.keys(QUESTINFO).forEach(r => { progress[r] = QUESTINFO[r].steps.map(() => !1) }) } function save() { client$1.localStorage.questProgress = progress } function areAllQuestsCompleted() { let r = !0; for (const e in progress) { for (let i = 0; i < progress[e].length; i++)if (!progress[e][i]) { r = !1; break } if (!r) break } return r } if (initialKeys.length === 0) reset(); else { for (let r = 0; r < initialKeys.length; r++) { const e = initialKeys[r], i = progress[e], s = QUESTINFO[e]; if (!Array.isArray(i) || !s || i.length !== s.steps.length) { console.warn(`Quest ${e} state does not match the quest info state! Resetting quest progress.`), reset(); break } } areAllQuestsCompleted() && reset(), Object.keys(QUESTINFO).forEach(r => { if (!progress[r]) return; const e = progress[r]; for (let i = 0; i < e.length; i++) { QUESTINFO[r].steps[i] = e[i]; const s = questData.quests.find(a => a.id === r); s.steps[i].completed = e[i] } }) } let anyStepInitiated = !1; Object.keys(QUESTINFO).forEach(r => { anyStepInitiated || QUESTINFO[r].steps.some(e => e === !0) && (anyStepInitiated = !0) }); save(); class questsController { constructor(e) { this.scene = e, this.npcs = e.npcs, this.secrets = e.secrets, events.on("quest_enable_id", this.onQuestEnable, this), events.on("quest_disable_id", this.onQuestDisable, this), events.on("quest_step_completed", this.onQuestStepCompleted, this), events.on("quest_completed", this.onQuestCompleted, this), this.init() } init() { this.quests = [], questData.quests.forEach((e, i) => { const s = new quest({ id: e.id, steps: e.steps }); this.quests.push(s), !s._isQuestCompleted() && s._steps.forEach(a => { var o, l; if (a.completed) { if (a.texts !== !1 && ((o = this.npcs) != null && o.length)) { const c = this.npcs.find(h => h.mesh._id === a.id); c && c.mesh.setTexts(a.texts, a.texts.length - 1) } else if (a.text !== !1 && ((l = this.secrets) != null && l.length)) { const c = this.secrets.find(h => h._id === a.id && !h._discovered); c && c._triggerDiscovery(!1) } } }) }) } onQuestEnable(e) { const i = this.npcs.find(s => s.mesh._id === e); i && i.disableBubbles() } onQuestDisable(e) { const i = this.npcs.find(s => s.mesh._id === e); i && i.enableBubbles() } onQuestStepCompleted(e, i, s, a) { if (!QUESTINFO[e]) return console.warn(`Quest ${e} not found!`); QUESTINFO[e].steps[s] = !0, progress[e][s] = !0; const o = s === QUESTINFO[e].steps.length - 1, l = s === 0 || o, c = areAllQuestsCompleted(); events.emit("quest_info_checklist_update", l, c), save(), c ? miscutils.wait(1).then(() => { events.emit("end_screen_show") }) : a && a.uiTitle && a.uiIcon && a.uiText && a.uiColor && events.emit("quest_box_display_after_step", a.uiTitle, a.uiIcon, a.uiText, a.uiColor, o), a && a.receiveModel && events.emit("quest_receive_model", a.receiveModel), o && miscutils.wait(.9).then(() => { events.emit("webgl_play_audio", "quest-complete") }) } onQuestCompleted(e) { } } function material(r = {}) {
    const e = UniformsUtils.merge([UniformsLib.common, UniformsLib.lights, { uColor: { value: new Color("#F6CF5F") }, uColor2: { value: new Color("#BD8A42") }, tNoise: { value: null }, uSeed: { value: Math.random() }, uHover: { value: 0 } }]); return e.tNoise.value = textureLoader.load("clouds_noise_64.ktx2", "srgb-repeat"), new ShaderMaterial({
        userData: { hotReload: "button" }, uniformsGroups: [global$1.UBO], uniforms: e, vertexShader: `
            ${globalUBO_default}
            ${rotate_default}

            attribute int vertid;
            varying vec3 vNormal;
            varying vec2 vUv;
            varying vec2 vHighPrecisionZW;

            uniform float uSeed;
            uniform float uHover;

            vec3 hash31(float p) {
                vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));
                p3 += dot(p3, p3.yzx+33.33);
                return fract((p3.xxy+p3.yzz)*p3.zyx);
            }

            void main() {
                vUv = uv;
                vNormal = normalize(normalMatrix * normal);

                // random stepped rotation animation
                float t = floor(time * 3.0);
                vec3 axis = normalize(hash31(t) * 2.0 - 1.0);
                float angle = 0.02;

                vec4 pos = vec4(position, 1.0);
                float seed = fract((uSeed) * 54.32 + float(vertid) * 31.2344);
                vec3 dir = normalize(position.xyz);
                pos.xyz += dir * seed * 0.3;
                pos.xyz *= 1.0 + 0.05 * uHover;

                pos = rotation3D(axis, angle) * pos;

                // ignore view matrix to lock title in position
                gl_Position = projectionMatrix * modelViewMatrix * pos;
                vHighPrecisionZW = gl_Position.zw;
            }
        `, fragmentShader: `
            layout(location = 1) out highp vec4 gInfo;

            ${globalUBO_default}
            ${encoding_default}

            varying vec3 vNormal;
            varying vec2 vUv;
            varying vec2 vHighPrecisionZW;

            uniform sampler2D tNoise;
            uniform vec3 uColor;
            uniform vec3 uColor2;

            void main() {
                vec4 noise = texture(tNoise, vUv * 1.0);

                float outlineContribution = step(0.2, noise.r);
                float surfaceId = 0.34242;

                float facing = abs(dot(normalize(vNormal), normalize(vec3(0.0, 0.0, 1.0))));
                vec3 color = mix(uColor, uColor2, 1.0 - smoothstep(0.2, 0.8, facing));

                gl_FragColor = vec4(color, 1.0);
                gInfo = vec4(1.0 - (0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5), encodeNormalSpheremap(normalize(vNormal)), outlineContribution);
            }
        `})
} var eases_default = `#ifndef PI
#define PI 3.141592653589793
#endif

#ifndef HALF_PI
#define HALF_PI 1.5707963267948966
#endif

float backIn(float t) {
    return pow(t, 3.) - t * sin(t * PI);
}

float backOut(float t) {
    return 1.0 - backIn(1.0 - t);
}

float backInOut(float t) {
    float f = t < 0.5
        ? 2.0 * t
        : 1.0 - (2.0 * t - 1.0);

    float g = backIn(f);

    return t < 0.5
        ? 0.5 * g
        : 0.5 * (1.0 - g) + 0.5;
}

float bounceOut(float t) {
    const float a = 4.0 / 11.0;
    const float b = 8.0 / 11.0;
    const float c = 9.0 / 10.0;

    const float ca = 4356.0 / 361.0;
    const float cb = 35442.0 / 1805.0;
    const float cc = 16061.0 / 1805.0;

    float t2 = t * t;

    return t < a
        ? 7.5625 * t2
        : t < b
            ? 9.075 * t2 - 9.9 * t + 3.4
            : t < c
            ? ca * t2 - cb * t + cc
            : 10.8 * t * t - 20.52 * t + 10.72;
}

float bounceIn(float t) {
    return 1.0 - bounceOut(1.0 - t);
}

float bounceInOut(float t) {
    return t < 0.5
        ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0))
        : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;
}

float circularIn(float t) {
    return 1.0 - sqrt(1.0 - t * t);
}

float circularOut(float t) {
    return sqrt((2.0 - t) * t);
}

float circularInOut(float t) {
    return t < 0.5
        ? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t))
        : 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);
}

float cubicIn(float t) {
    return t * t * t;
}

float cubicOut(float t) {
    float f = t - 1.0;
    return f * f * f + 1.0;
}

float cubicInOut(float t) {
    return t < 0.5
        ? 4.0 * t * t * t
        : 0.5 * -pow(2.0 - 2.0 * t, 3.0) + 1.0;
}

float elasticIn(float t) {
    return sin(13.0 * t * HALF_PI) * pow(2.0, 10.0 * (t - 1.0));
}

float elasticOut(float t) {
    return sin(-13.0 * (t + 1.0) * HALF_PI) * pow(2.0, -10.0 * t) + 1.0;
}

float elasticInOut(float t) {
    return t < 0.5
        ? 0.5 * sin(+13.0 * HALF_PI * 2.0 * t) * pow(2.0, 10.0 * (2.0 * t - 1.0))
        : 0.5 * sin(-13.0 * HALF_PI * ((2.0 * t - 1.0) + 1.0)) * pow(2.0, -10.0 * (2.0 * t - 1.0)) + 1.0;
}

float expoIn(float t) {
    return t == 0.0 ? t : pow(2.0, 10.0 * (t - 1.0));
}

float expoOut(float t) {
    return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);
}

float expoInOut(float t) {
    return t == 0.0 || t == 1.0
        ? t
        : t < 0.5
            ? +0.5 * pow(2.0, (20.0 * t) - 10.0)
            : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;
}

float linear(float t) {
     return t;
}

float quadraticIn(float t) {
    return t * t;
}

float quadraticOut(float t) {
    return -t * (t - 2.0);
}

float quadraticInOut(float t) {
    float p = 2.0 * t * t;
    return t < 0.5 ? p : -p + (4.0 * t) - 1.0;
}

float quarticIn(float t) {
    return pow(t, 4.0);
}

float quarticOut(float t) {
    return pow(1.0 - t, 3.0) * (t - 1.0) + 1.0;
}

float quarticInOut(float t) {
    return t < 0.5
        ? +8.0 * pow(t, 4.0)
        : -8.0 * pow(1.0 - t, 4.0) + 1.0;
}

float quinticIn(float t) {
    return pow(t, 5.0);
}

float quinticOut(float t) {
    return 1.0 - pow(1.0 - t, 5.0);
}

float quinticInOut(float t) {
    return t < 0.5
        ? +16.0 * pow(t, 5.0)
        : -0.5 * pow(2.0 - 2.0 * t, 5.0) + 1.0;
}

float sineIn(float t) {
    return sin((t - 1.0) * HALF_PI) + 1.0;
}

float sineOut(float t) {
    return sin(t * HALF_PI);
}

float sineInOut(float t) {
    return -0.5 * (cos(PI * t) - 1.0);
}

#define power0(t) linear(t)
#define power1In(t) quadraticIn(t)
#define power1Out(t) quadraticOut(t)
#define power1InOut(t) quadraticInOut(t)
#define power2In(t) cubicIn(t)
#define power2Out(t) cubicOut(t)
#define power2InOut(t) cubicInOut(t)
#define power3In(t) quarticIn(t)
#define power3Out(t) quarticOut(t)
#define power3InOut(t) quarticInOut(t)
#define power4In(t) quinticIn(t)
#define power4Out(t) quinticOut(t)
#define power4InOut(t) quinticInOut(t)`, transformUV_default = `vec2 rotateUV(vec2 uv, float rotation, vec2 mid) {
    float c = cos(rotation);
    float s = sin(rotation);
    return vec2(
        c * (uv.x - mid.x) + s * (uv.y - mid.y) + mid.x,
        c * (uv.y - mid.y) - s * (uv.x - mid.x) + mid.y
    );
}

vec2 rotateUV(vec2 uv, float rotation, float mid) {
    return rotateUV(uv, rotation, vec2(mid));
}

vec2 rotateUV(vec2 uv, float rotation) {
    return rotateUV(uv, rotation, vec2(0.5));
}

vec2 scaleUV(vec2 uv, float scale, vec2 mid) {
    uv -= mid;
    uv *= 1.0 / scale;
    uv += mid;
    return uv;
}

vec2 scaleUV(vec2 uv, float scale, float mid) {
    return scaleUV(uv, scale, vec2(mid));
}

vec2 scaleUV(vec2 uv, float scale) {
    return scaleUV(uv, scale, vec2(0.5));
}

vec2 barrelDistortion(vec2 uv, vec2 center, float amt) {
    vec2 cc = uv - center;
    float dist = dot(cc, cc);
    return uv + cc * dist * amt;
}

vec2 barrelDistortion(vec2 uv, float amt) {
    return barrelDistortion(uv, vec2(0.5), amt);
}`; function textMaterial(r = {}) {
    return new ShaderMaterial({
        userData: { hotReload: "button text" }, uniformsGroups: [global$1.UBO], uniforms: { tCurve: { value: r.curveTexture }, tBand: { value: r.bandTexture }, uSeed: { value: Math.random() }, uShow: { value: 1 }, uHide: { value: 0 }, uHover: { value: 0 } }, vertexShader: `
            attribute vec3 centr;
            attribute vec2 textWeights;

            uniform float uShow;
            uniform float uHide;
            uniform float uHover;

            flat varying vec3 vCentr;
            varying vec2 vHighPrecisionZW;

            ${globalUBO_default}
            ${falloff_default}
            ${slugvs_default}
            ${eases_default}
            ${rotate_default}

            vec3 hash31(float p) {
                vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));
                p3 += dot(p3, p3.yzx+33.33);
                return fract((p3.xxy+p3.yzz)*p3.zyx);
            }

            float hash13(vec3 p3) {
                p3  = fract(p3 * .1031);
                p3 += dot(p3, p3.zyx + 31.32);
                return fract((p3.x + p3.y) * p3.z);
            }

            vec2 hash23(vec3 p3) {
                p3 = fract(p3 * vec3(.1031, .1030, .0973));
                p3 += dot(p3, p3.yzx+33.33);
                return fract((p3.xx+p3.yz)*p3.zy);
            }

            void main() {
                vCentr = centr;
                vec3 pos = SlugVS();

                float seed = fract(hash13(centr));

                // animation
                if (uShow < 1.0 || uHide > 0.0) {
                    // show
                    float stepsShow = floor(3.0 + seed * 2.0);
                    float trShow = floor(falloff(textWeights.y, 0.0, 1.0, 1.5, uShow) * stepsShow) / stepsShow;
                    float trHide = floor(falloff(textWeights.y, 0.0, 1.0, 1.5, uHide) * stepsShow) / stepsShow;
                    vTexCoord += vec2(0.0, 1.0) * (1.0 - trShow);
                    vTexCoord -= vec2(0.0, 1.0) * trHide;
                }

                // random stepped rotation animation
                float t = floor(time * 3.0);
                vec3 axis = normalize(hash31(t) * 2.0 - 1.0);
                float angle = 0.02;

                vec4 pos2 = vec4(pos, 1.0);
                pos2.xyz *= 1.0 - 0.05 * uHover;
                pos2 = rotation3D(axis, angle) * pos2;

                gl_Position = projectionMatrix * modelViewMatrix * pos2;
                vHighPrecisionZW = gl_Position.zw;
            }
        `, fragmentShader: `
            layout(location = 1) out highp vec4 gInfo;

            uniform sampler2D tCurve;
            uniform usampler2D tBand;

            flat varying vec3 vCentr;
            varying vec2 vHighPrecisionZW;

            ${globalUBO_default}
            ${slugfs_default}
            ${transformUV_default}

            void main() {
                // animation

                vec2 uv = vTexCoord;
                vec4 color = RenderSlug(tCurve, tBand, uv, vColor, vBanding, vGlyph);

                if (color.w * vColor.w < 0.01) discard;

                // skip outline
                gl_FragColor = vec4(color.xyz, 0.34242);
                gInfo = vec4(1.0 - (0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5), vec2(0.0), 0.0);
            }
        `, depthWrite: !1
    })
} const _v0$c = new Vector3, _v1$7 = new Vector3, _v2$1 = new Vector3, _m0$1 = new Matrix4; class button { constructor(e) { this.scene = e, this.ready = miscutils.deferred(), this.font = "heading.font", this.baseOffset = 0, this.hoverRotation = 0, this.rotation = { value: 0 }, this.animRotation = { value: 0 }, this.finalRotation = { value: 0 }, this.baseScale = 1, this.scaleMultiplier = { value: 1 }, this.updateCamPosition = !0, this.camPosition = new Vector3, this.init() } async init() { const [e, i, s] = await Promise.all([geometryLoader.load("planets/present/intro/button.drc"), glyphLoader.loadTexture(this.font, "band"), glyphLoader.loadTexture(this.font, "curve")]); this.mesh = new Mesh(e, material({})), this.mesh.name = "Button", this.mesh.frustumCulled = !1, this.text = new meshText({ font: this.font, small: !1, text: anyStepInitiated ? "VOYTI " : "NAChAT", size: 1, width: 20, letterSpacing: .01, lineHeight: 1.1, color: "#F8F8F8", align: "center", shadow: !0, shadowX: .06, shadowY: .06, shadowColor: "#7A5E0D" }, textMaterial({ bandTexture: i, curveTexture: s })), this.text.name = "Button text", this.text.frustumCulled = !1, await this.text.ready, this.groupAnim = new Group, this.groupAnim.name = "Button Animation Group", this.groupAnim.add(this.mesh), this.groupAnim.add(this.text), this.group = new Group, this.group.name = "Button Group", this.group.add(this.groupAnim), this.scene.add(this.group), this.scene.beforeRenderCbs.push(this.update.bind(this)), this.interaction = new meshInteraction({ meshes: [this.mesh], camera: this.scene.camera, onHover: this.hover, onTouch: this.touch, onClick: this.click, hoverCursor: !0, ctx: this }), this.ready.resolve() } hover(e) { if (e.action === "hover_in") { if (this.mesh.material.uniforms.uSeed.value = Math.random(), e.event.input !== "mouse") return; createTween(this.mesh.material.uniforms.uHover, { to: { value: 1 }, duration: .07, ease: "none", onComplete: () => { this.mesh.material.uniforms.uSeed.value = Math.random(), createTween(this.mesh.material.uniforms.uHover, { to: { value: 0 } }) } }), createTween(this.text.material.uniforms.uHover, { to: { value: 1 }, duration: .07, ease: "none", onComplete: () => { createTween(this.text.material.uniforms.uHover, { to: { value: 0 } }) } }), events.emit("webgl_play_audio", "hover2"); return } const i = Math.sign(e.event.delta11.y); i !== 0 && (this.hoverRotation -= Math.PI * .5 * i, createTween(this.rotation, { to: { value: this.hoverRotation }, duration: 1.5, ease: "elastic.out(1, 0.9)" }), createTween(this.text.material.uniforms.uShow, { to: { value: 1 } }), createTween(this.text.material.uniforms.uHide, { to: { value: 1 }, duration: .05, ease: "none", onComplete: () => { createTween(this.text.material.uniforms.uHide, { to: { value: 0 }, delay: .14 }), createTween(this.text.material.uniforms.uShow, { from: { value: 0 }, to: { value: 1 }, delay: .14, duration: .2, ease: "none" }) } }), events.emit("webgl_play_audio", "button-turn")) } touch(e) { const i = e.action === "touch_start"; i ? createTween(this.scaleMultiplier, { to: { value: .95 }, duration: .02, ease: "none" }) : createTween(this.scaleMultiplier, { to: { value: 1 }, duration: .02, ease: "none" }), events.emit("webgl_play_audio", `click${i ? 2 : 3}`) } click(e) { events.emit("switch_to_present_scene") } update() { if (this.scene.___disposed) return; const e = this.scene.camera; this.updateCamPosition && this.camPosition.copy(e.position), _v0$c.copy(e.target).sub(this.camPosition).normalize(), _v1$7.copy(this.camPosition).addScaledVector(_v0$c, 45), this.group.position.copy(_v1$7), _v0$c.subVectors(this.camPosition, e.target), _v0$c.lengthSq() === 0 && (_v0$c.z = 1), _v0$c.normalize(), _v1$7.crossVectors(e.up, _v0$c), _v1$7.lengthSq() === 0 && (Math.abs(e.up.z) === 1 ? _v0$c.x += 1e-4 : _v0$c.z += 1e-4, _v0$c.normalize(), _v1$7.crossVectors(e.up, _v0$c)), _v1$7.normalize(), _v2$1.crossVectors(_v0$c, _v1$7), this.finalRotation.value = this.rotation.value + this.animRotation.value, this.mesh.rotation.set(this.finalRotation.value, 0, 0); const i = this.baseScale * this.scaleMultiplier.value; this.group.scale.setScalar(i), this.group.position.addScaledVector(_v2$1, this.baseOffset), this.group.quaternion.setFromRotationMatrix(_m0$1.lookAt(this.camPosition, e.target, _v0$c.set(0, 1, 0))), this.group.updateMatrixWorld() } playInAnimation(e = 0) { this.groupAnim.scale.setScalar(0), createTween(this.groupAnim.scale, { to: { x: 1, y: 1, z: 1 }, duration: 3.25, delay: e, ease: "elastic.out(1, 0.9)" }), this.groupAnim.rotation.x = Math.PI * -1, createTween(this.groupAnim.rotation, { to: { x: 0 }, duration: 3.25, delay: e, ease: "elastic.out(1, 0.5)" }) } spinOut() { createTween(this.groupAnim.rotation, { to: { x: this.groupAnim.rotation.x + Math.PI * -2 }, duration: 1.5, delay: 0, ease: "inOut1" }), createDelayedCall(.3, () => { events.emit("webgl_play_audio", "button-out") }) } playOutAnimation(e = 0) { this.updateCamPosition = !1 } resize() { this.text.scale.setScalar(1.4), this.text.position.set(0, -.25 * 1.4, 1.2), this.baseScale = this.scene.mobileLayout ? 1.5 : 1, this.baseOffset = this.scene.mobileLayout ? -16 : -13.5 } } const _v0$b = new Vector3, _m0 = new Matrix4, _q0$3 = new Quaternion; class introScene extends scene { constructor(e, i = {}) { super({ orbit: !0 }), this.mainController = e, this.mobileLayout = !1, this._init() } async _init() { await Promise.all([this.setupCamera(), this.setupPostProcessing()]), this.planetGroup = new Group, this.planetGroup.name = "Planet Group", this.add(this.planetGroup), await Promise.all([{ objClass: planet$1, name: "planet" }, { objClass: sky$1, name: "sky" }, { objClass: birds, name: "birds", options: { count: 15, groups: 5, curve: "birds/curve-1.drc", bird: "birds/1.drc" } }, { objClass: cables$1, name: "cables" }, { objClass: waterfall, name: "waterfall" }, { objClass: atmosphere, name: "atmosphere" }, { objClass: title$1, name: "title" }, { objClass: particles, name: "particles" }, { objClass: galaxies, name: "galaxies" }, { objClass: button, name: "button" }].map(({ objClass: e, name: i, options: s = {} }) => (this[i] = new e(this, s), this[i].ready))), this.setupLights(), this._resize(), events.on("resize", this._resize, this), this.beforeRenderCbs.push(this.update.bind(this)), client$1.devScene && (this.playInAnimation(), this.debug(), window._scene = this, window._camera = this.camera), this.isReady() } setupCamera() { this.camera.basePosition.set(0, 0, -120), this.camera.baseTarget.set(0, -2.5, 0), this.camera.lerpRotate = 1, this.camera.lerpZoom = 1, this.camera.lerpPan = 1, this._outRotation = { value: 0 }, this.camera.displacement.position.set(0, 0), this.camera.displacement.target.set(-.01, -.0075), this.camera.displacement.rotation = .01, this.camera.lerpPosition = 1, this.camera.lerpTarget = .02, this.camera.lerpRotation = .05, this.camera.autoRotate = !0, client$1.devScene || (this.camera.enablePan = !1, this.camera.enableZoom = !1, this.camera.enableRotate = !1), this.camera.near = 2, this.camera.far = 1e3, this.camera.updateProjectionMatrix() } setupPostProcessing() { return new Promise(e => { setTimeout(() => { addPostProcessing$1(this, this.composer), e() }, 0) }) } setupLights() { this.light = new DirectionalLight(16777215, 1), this.light.position.set(100, 100, 0), this.light._originalPosition = this.light.position.clone(), this.light.castShadow = !0, this.light.shadow.mapSize.width = 1024, this.light.shadow.mapSize.height = 1024, this.light.shadow.camera.near = 50, this.light.shadow.camera.far = 180, this.light.shadow.bias = .002, this.light.shadow.normalBias = .3; const e = 100; this.light.shadow.camera.left = -100, this.light.shadow.camera.right = e, this.light.shadow.camera.top = e, this.light.shadow.camera.bottom = -100, this.light.shadow.camera.zoom = 3.25, this.light.shadow.camera.updateProjectionMatrix(), this.add(this.light) } _resize() { this.___disposed || (this.mobileLayout = client$1.screen.w < client$1.screen.h && client$1.screen.w < 700, this.camera.zoom = this.mobileLayout ? .8 : 1, this.camera.updateProjectionMatrix(), [this.button, this.title].forEach(e => e.resize())) } update() { this.___disposed || (this.camera.quaternion.setFromRotationMatrix(_m0.lookAt(this.camera.position, this.camera.target, this.camera.up)), _q0$3.setFromAxisAngle(_v0$b.subVectors(this.camera.position, this.camera.target).normalize(), this._outRotation.value), this.camera.quaternion.premultiply(_q0$3), this.camera.updateMatrixWorld()) } async playInAnimation() { this.planetGroup.position.y = -80, createTween(this.planetGroup.position, { to: { x: 0, y: 0, z: 0 }, duration: 2.25, delay: .2, ease: "inOut1", onUpdate: () => { this.light.position.copy(this.light._originalPosition), this.light.position.y += this.planetGroup.position.y, this.light.target.position.y = this.planetGroup.position.y, this.light.target.updateMatrixWorld() } }), this.planetGroup.scale.setScalar(.3), createTween(this.planetGroup.scale, { to: { x: 1, y: 1, z: 1 }, duration: 6.3, delay: .2, ease: "inOut3" }); const i = Math.PI * .35; this.planetGroup.rotation.y = i - Math.PI * 1.5, createTween(this.planetGroup.rotation, { to: { y: i }, delay: .2 + .15, duration: 5.65, ease: "inOut3" }), createTween(this.planetGroup.rotation, { from: { x: -Math.PI * 1 }, to: { x: 0 }, delay: .2, duration: 2, ease: "inOut1" }), this.atmosphere.playInAnimation(.2 + 1.25), this.birds.playInAnimation(.2 + 2.5), this.title.playInAnimation(.2 + 2.15), this.particles.playInAnimation(.2 + .3), this.galaxies.playInAnimation(.2 + 2), this.button.playInAnimation(.2 + 3.1), createDelayedCall(.16, () => { events.emit("webgl_play_audio", "whoosh") }), createDelayedCall(1.8, () => { events.emit("webgl_play_audio", "whoosh") }), createDelayedCall(2.5, () => { events.emit("webgl_play_audio", "intro-letters") }), createDelayedCall(3.45, () => { events.emit("webgl_play_audio", "button-turn") }), await miscutils.wait(3), this.title.interaction.enable(), this.title.hoveredObj = null, this.button.interaction.enable() } async playOutAnimation() { this.button.interaction.disable(), this.title.interaction.disable(), this.button.spinOut(0), await miscutils.wait(.2), createTween(this.camera, { to: { autoRotateSpeed: 0 }, duration: 1, ease: "power2.inOut", onUpdate: () => { this.___disposed || (this.camera.touchAmount = this.camera.autoRotateSpeed) } }), createTween(this.camera._sphericalTarget, { to: { theta: this.camera._sphericalTarget.theta - Math.PI * .25, phi: 1.7 }, duration: 2.5, ease: "tweaked" }), createTween(this.camera._sphericalTarget, { to: { radius: 40 }, duration: 2.75, delay: .4, ease: "inOut1" }), createTween(this._outRotation, { to: { value: Math.PI * -.25 }, duration: 3.35, delay: .2, ease: "inOut1" }), this.button.playOutAnimation(0), this.title.playOutAnimation(0), createDelayedCall(1, () => { events.emit("webgl_play_audio", "whoosh") }) } dispose() { this.___disposed = !0, events.off("resize", this._resize, this), super.dispose() } } class waterPass { constructor({ scene: e } = {}) { this.originalScene = e, this.scene = new Scene, this.camera = new PerspectiveCamera, this.rt = new WebGLRenderTarget(2, 2, { type: HalfFloatType }), global$1.renderer.webgl.initRenderTarget(this.rt), this.multiplePass = null, this.resize(), events.on("resize", this.resize, this) } resize() { const e = global$1.uniforms.resolution.value; this.rt.setSize(e.x, e.y) } render() { const e = global$1.renderer.webgl, i = this.multiplePass.renderTarget.depthTexture; this.scene.traverse(s => { var a, o, l, c; s !== this.scene && ((o = (a = s == null ? void 0 : s.material) == null ? void 0 : a.uniforms) != null && o.tScene && (s.material.uniforms.tScene.value = this.multiplePass.renderTarget.textures[0]), (c = (l = s == null ? void 0 : s.material) == null ? void 0 : l.uniforms) != null && c.tSceneInfo && (s.material.uniforms.tSceneInfo.value = this.multiplePass.renderTarget.textures[1])) }), this.rt.depthTexture = null, e.setRenderTarget(this.rt), e.setClearAlpha(0), e.clear(), e.setRenderTarget(null), this.rt.depthTexture = i, e.setRenderTarget(this.rt), this.camera.copy(this.originalScene.camera), this.camera.updateProjectionMatrix(), this.camera.updateMatrixWorld(), e.render(this.scene, this.camera, this.rt), this.rt.depthTexture = null, this.multiplePass.renderTarget.depthTexture = i } } const customUniforms = { planet: { uOutlineFade: { value: new Vector2(5, 80) }, uOutlineThickness: { value: 1 }, uOutlineColor: { value: new Color("#363a3c") }, uInfoRange: { value: new Vector3(1e-4, 2e-4, .1) }, uInfoMinScale: { value: .6 }, uDepthRange: { value: new Vector3(1e-4, .01001, .1) }, uNormalRange: { value: new Vector3(.4, .5, .3) }, uOutlineScale: { value: 1 }, uSmoothMargin: { value: .2 } } }; class outlines extends ShaderMaterial {
    constructor(e) {
        super({
            uniformsGroups: [global$1.UBO], uniforms: { tDiffuse: { value: null }, tInfo: { value: null }, tWater: { value: null }, uCameraNear: { value: e.camera.near, ignore: !0 }, uCameraFar: { value: e.camera.far, ignore: !0 }, tLUT: { value: textureLoader.load("lut.ktx2", "luttetrahedral") }, uLUTIntensity: { value: 1 }, uOutlineFade: { value: new Vector2 }, uOutlineThickness: { value: 0 }, uOutlineColor: { value: new Color(11406340) }, uInfoRange: { value: new Vector3 }, uInfoMinScale: { value: 0 }, uDepthRange: { value: new Vector3 }, uNormalRange: { value: new Vector3 }, uOutlineScale: { value: 0 }, uSmoothMargin: { value: 0 } }, vertexShader: `
                ${globalUBO_default}

                varying vec2 vUv;

                void main() {
                    vUv = uv;
                    gl_Position = vec4(position, 1.0);
                }
            `, fragmentShader: `
                ${globalUBO_default}

                uniform sampler2D tDiffuse;
                uniform sampler2D tInfo;
                uniform sampler2D tWater;

                uniform float uCameraNear;
                uniform float uCameraFar;

                uniform vec2 uOutlineDepth;

                uniform vec2 uOutlineFade;
                uniform float uOutlineThickness;
                uniform vec3 uOutlineColor;
                uniform float uOutlineScale;

                uniform vec3 uInfoRange;
                uniform vec3 uDepthRange;
                uniform vec3 uNormalRange;
                uniform float uSmoothMargin;
                uniform float uInfoMinScale;

                ${lut_default}
                uniform sampler3D tLUT;
                uniform float uLUTIntensity;

                varying vec2 vUv;

                ${fit_default}
                ${depth_default}
                ${encoding_default}
                ${custom_default}


                void main() {
                    vec2 uv = vUv;
                    float aspect = resolution.x / resolution.y;

                    // get scene color
                    vec4 scene = texture2D(tDiffuse, vUv);
                    vec3 sceneColor = scene.rgb;

                    // get water information
                    vec4 water = texture2D(tWater, uv);
                    float isWater = max(0.0, sign(water.a));

                    // add the color of the water on top of the scene
                    sceneColor = mix(sceneColor, water.rgb, isWater);

                    // compensate outline scale with resolution
                    float resScale = min(1.0, resolution.y / 1300.0) * uOutlineScale;

                    // get outline value
                    float centerDepth = 0.0;
                    float nearestDepth = 0.0;
                    float outlineValue = outline(tDiffuse, tInfo, vUv, uOutlineThickness, resScale, uInfoRange, uDepthRange, uNormalRange, uSmoothMargin, uInfoMinScale, uOutlineFade, vec2(uCameraNear, uCameraFar), nearestDepth, centerDepth);

                    // get the pixels where the outline is under water
                    float waterDepth = getLinearDepth(1.0 - water.a, uCameraNear, uCameraFar);
                    float outlineUnderWater = isWater;
                    if (nearestDepth < waterDepth) outlineUnderWater = 0.0;

                    // calculate the outline color
                    vec3 aboveOutlineColor = uOutlineColor;
                    vec3 underwaterOutlineColor = sceneColor; // mix(sceneColor, uOutlineColor, 0.3);
                    vec3 outlineColor = mix(aboveOutlineColor, underwaterOutlineColor, outlineUnderWater);

                    // add the outline to the scene
                    sceneColor = mix(sceneColor, outlineColor, outlineValue);

                    // add color correction
                    sceneColor = apply3DLUTTetrahedral(sceneColor, tLUT, uLUTIntensity);


                    // fluid debug
                    // gl_FragColor = vec4(vec3(texture(tSim, vUv).rgb), 1.0);

                    // outline debug
                    // gl_FragColor = vec4(vec3(outlineValue), 1.0); // debug

                    gl_FragColor = vec4(sceneColor, 1.0);
                }
            `})
    }
} function adjustOutlinesUniforms(r, e) { const i = e.passes[0].finalPasses[0]; i.uniforms.uCameraNear.value = r.camera.near, i.uniforms.uCameraFar.value = r.camera.far; const s = customUniforms[r.name] || customUniforms.planet; Object.keys(s).forEach(a => { typeof i.uniforms[a].value == "number" ? i.uniforms[a].value = s[a].value : i.uniforms[a].value.copy(s[a].value) }) } function addPostProcessing(r, e) { const i = new waterPass({ scene: r }); r.waterPass = i, r.waterScene = i.scene, r._subscenes = [i.scene]; const s = new MultipleRenderPass({ scene: r, rtCount: 2, rtOptions: { depthBuffer: !0 }, clearColor: new Color("#000000"), clearAlpha: global$1.renderer.clearAlpha, onAfterMultiRender: () => { i.render() }, finalMaterials: [new outlines(r)] }); s.renderTarget.depthTexture = new DepthTexture, i.multiplePass = s, e.passes.splice(0, 1), e.addPass(s), e === global$1.composer && (global$1.renderPass = s); const a = s.renderTarget.textures; a[0].name = "color", a[1].name = "info", s.finalPasses[0].uniforms.tInfo.value = a[1], s.finalPasses[0].uniforms.tWater.value = i.rt.texture, adjustOutlinesUniforms(r, e), e === global$1.composer && (s.finalPasses[0]._fsQuad._mesh.name = "Big Triangle", gui$1.add(s.finalPasses[0]._fsQuad._mesh, "post-outline")); const o = new RenderPass$1(new Scene, new OrthographicCamera(-1, 1, 1, -1, 0, 1)); o.clear = !1, r.__controlsPass = o, e.insertPass(o, 1) } const introData = { name: "DOSTAVSchIK", color: "#66BDE6", voice: "quest" }, introTexts = ["Opyat prospal... Ladno, pora razvozit posylki po Kaliningradu.", "Pyat adresov  ne tak uzh mnogo. Razberyomsya.", "Nu, poekhali. Yantarnyy kray ne zhdyot."]; async function introDialogue() { for (let r = 0; r < introTexts.length; r++) { const e = miscutils.deferred(); events.once("npc_force_next_dialog", i => { e.resolve() }), events.emit("npc_dialog_open", "intro_sequence", introTexts[r], introData, {}), await e, events.emit("npc_dialog_close", "intro_sequence"), await miscutils.wait(.3) } events.emit("npc_dialog_finished", "intro_sequence") } const _v0$a = new Vector3, EMOJI_MAP = { 1: 2, 2: 0, 3: 1, 4: 8, 5: 5, 6: 6, 7: 7, 8: 9, 9: 3, 0: 4 }; let emojis$1 = class {
    constructor({ scene: e, characters: i } = {}) { this.scene = e, this.characters = i, this.ready = miscutils.deferred(), this.numEmojis = 10, this.maxDistance = 20, this.rateLimit = .35, this.init() } async init() {
        this.mesh = new batchedGPU({
            maxInstanceCount: 64, maxVertexCount: 300, maxIndexCount: 4, material: new ShaderMaterial({
                name: "emojis", lights: !0, userData: { hotReload: "emojis" }, uniformsGroups: [global$1.UBO], uniforms: { ...UniformsUtils.clone(UniformsLib.common), ...UniformsUtils.clone(UniformsLib.lights), batchingTexture: { value: null }, batchingIdTexture: { value: null }, tTexture1: { value: null }, tTexture2: { value: null }, tTexture3: { value: null }, tAtlas: { value: textureLoader.load("atlas.png", "srgb-nearest") }, ...fogUniforms }, vertexShader: `
                /* BATCHING */
                #if ! defined(GL_ANGLE_multi_draw)
                    #define gl_DrawID _gl_DrawID
                    uniform int _gl_DrawID;
                #endif

                attribute int emoji;
                attribute float surfaceId;

                ${matrixutils_default}
                ${rotate_default}
                ${globalUBO_default}

                uniform sampler2D tTexture1;
                uniform sampler2D tTexture2;
                uniform sampler2D tTexture3;

                uniform highp usampler2D batchingIdTexture;

                vec4 getInfo(const in sampler2D map, const in int i) {
                    int size = textureSize(map, 0).x;
                    return texelFetch(map, ivec2(i % size, i / size), 0);
                }

                float getIndirectIndex(const in int i) {
                    int size = textureSize(batchingIdTexture, 0).x;
                    return float(texelFetch(batchingIdTexture, ivec2(i % size, i / size), 0).r);
                }

                varying vec2 vUv;
                varying vec3 lPos;
                varying vec4 vPos;
                varying vec3 vNormal;
                flat varying vec3 vLightDir;
                flat varying float vScale;
                flat varying float vRand;
                flat varying float vSurfaceId;
                varying vec2 vHighPrecisionZW;

                // for light direction
                struct DirectionalLight {
                    vec3 direction;
                    vec3 color;
                };
                uniform DirectionalLight directionalLights[ 1 ];

                // for shadows
                #include <shadowmap_pars_vertex>
                vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
                    return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
                }

                void main() {
                    vUv = uv;
                    lPos = position;
                    vSurfaceId = surfaceId;

                    vLightDir = vec3(0.0);
                    #if NUM_DIR_LIGHTS > 0
                        vLightDir = normalize(directionalLights[0].direction);
                    #endif

                    int batchID = int(getIndirectIndex(gl_DrawID));
                    vec4 info1 = getInfo(tTexture1, batchID);
                    vec3 offset = info1.rgb;
                    float life = info1.a;

                    vec4 info2 = getInfo(tTexture2, batchID);
                    vRand = info2.a;

                    vec4 info3 = getInfo(tTexture3, batchID);
                    vec3 up = info3.rgb;

                    // tweak scale based on life
                    vScale = smoothstep(0.0, 0.15, life) * smoothstep(1.0, 0.7, life);

                    // rotate position according to the planet
                    mat4 planetRot = getMatrixRotation(viewMatrix);
                    vec3 pos = (vec4(position, 1.0) * planetRot).xyz;

                    // rotate around up vector
                    mat4 rot = rotation3D(up, time * 1.5 + (vRand + float(emoji)) * 32.2432);

                    // calculate world position and normal
                    vec3 wPos = offset + (rot * vec4(pos * vScale, 1.0)).xyz;
                    vNormal = normalize(normalMatrix * (rot * (vec4(normal, 0.0) * planetRot)).xyz);

                    vPos = viewMatrix * vec4(wPos, 1.0);

                    gl_Position = projectionMatrix * vPos;
                    vHighPrecisionZW = gl_Position.zw;

                    // this requires worldPosition and transformedNormal
                    vec3 transformedNormal = vNormal;
                    vec4 worldPosition = vec4(wPos, 1.0);
                    #include <shadowmap_vertex>
                }
            `, fragmentShader: `
                layout(location = 1) out highp vec4 gInfo;

                ${encoding_default}
                ${colorutils_default}
                ${sinenoise_default}
                ${fog_default}

                uniform sampler2D tEmojis;
                uniform sampler2D tAtlas;

                varying vec2 vUv;
                varying vec3 lPos;
                varying vec4 vPos;
                varying vec3 vNormal;
                flat varying vec3 vLightDir;
                flat varying float vScale;
                flat varying float vRand;
                flat varying float vSurfaceId;
                varying vec2 vHighPrecisionZW;

                // for shadows
                #include <packing>
                #include <shadowmap_pars_fragment>

                void main() {

                    vec3 geometryNormal = normalize(vNormal);
                    float light = dot(geometryNormal, normalize(vLightDir));

                    // shadow
                    float shadow = 0.0;
                    #if defined(USE_SHADOWMAP) && NUM_DIR_LIGHT_SHADOWS > 0
                        DirectionalLightShadow directionalLightShadow;
                        directionalLightShadow = directionalLightShadows[0];
                        shadow = getShadow(
                            directionalShadowMap[0],
                            directionalLightShadow.shadowMapSize,
                            directionalLightShadow.shadowIntensity,
                            directionalLightShadow.shadowBias,
                            directionalLightShadow.shadowRadius,
                            vDirectionalShadowCoord[0]
                        );
                    #endif

                    light = min(light, shadow);

                    // set color
                    vec3 color = texture2D(tAtlas, vUv).rgb;
                    vec3 colorShadow = rgb2hsv(color);
                    colorShadow.r -= 0.02;
                    colorShadow.b *= 0.5;
                    colorShadow = hsv2rgb(colorShadow);
                    float shadowCut = smoothstep(0.2, 0.4, light);
                    color = mix(colorShadow, color, shadowCut);

                    addFog(color, vPos.z);

                    gl_FragColor = vec4(color, vSurfaceId);

                    float outlineNoise = sinenoise1(lPos * 25.0 + vec3(3.324, 34.2, 56.343) * vRand) * 0.5 + 0.5;
                    float contribution = step(0.3, outlineNoise);
                    gInfo = vec4(1.0 - (0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5), encodeNormalSpheremap(geometryNormal), contribution);
                }
            `})
        }, { textures: 3 }), this.mesh.customDepthMaterial = new ShaderMaterial({
            uniforms: { batchingTexture: { value: null }, batchingIdTexture: { value: null }, tTexture1: { value: null }, tTexture2: { value: null }, tTexture3: { value: null } }, vertexShader: `
                /* BATCHING */
                #if ! defined(GL_ANGLE_multi_draw)
                    #define gl_DrawID _gl_DrawID
                    uniform int _gl_DrawID;
                #endif

                ${matrixutils_default}
                ${rotate_default}
                ${globalUBO_default}

                attribute int emoji;

                uniform sampler2D tTexture1;
                uniform sampler2D tTexture2;
                uniform sampler2D tTexture3;

                uniform highp usampler2D batchingIdTexture;

                vec4 getInfo(const in sampler2D map, const in int i) {
                    int size = textureSize(map, 0).x;
                    return texelFetch(map, ivec2(i % size, i / size), 0);
                }

                float getIndirectIndex(const in int i) {
                    int size = textureSize(batchingIdTexture, 0).x;
                    return float(texelFetch(batchingIdTexture, ivec2(i % size, i / size), 0).r);
                }

                varying vec2 vHighPrecisionZW;

                void main() {
                    int batchID = int(getIndirectIndex(gl_DrawID));
                    vec4 info1 = getInfo(tTexture1, batchID);
                    vec3 offset = info1.rgb;
                    float life = info1.a;

                    vec4 info2 = getInfo(tTexture2, batchID);
                    float randd = info2.a;

                    vec4 info3 = getInfo(tTexture3, batchID);
                    vec3 up = info3.rgb;

                    // tweak scale based on life
                    float scale = smoothstep(0.0, 0.15, life) * smoothstep(1.0, 0.7, life);

                    // rotate position according to the planet
                    mat4 planetRot = getMatrixRotation(viewMatrix);
                    vec3 pos = (vec4(position, 1.0) * planetRot).xyz;

                    // rotate around up vector
                    mat4 rot = rotation3D(up, time * 1.5 + (randd + float(emoji)) * 32.2432);

                    // calculate world position and normal
                    vec3 wPos = offset + (rot * vec4(pos * scale, 1.0)).xyz;

                    gl_Position = projectionMatrix * viewMatrix * vec4(wPos, 1.0);
                    vHighPrecisionZW = gl_Position.zw;
                }
            `, fragmentShader: `
                #include <packing>
                varying vec2 vHighPrecisionZW;
                void main() {
                    float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
                    gl_FragColor = packDepthToRGBA( fragCoordZ );
                }
            `}), this.mesh.name = "Emojis", this.mesh.castShadow = !0, this.mesh.receiveShadow = !0; const e = this.mesh.customDepthMaterial.uniforms, i = this.mesh.material.uniforms; this.scene.beforeRenderCbs.push(() => { e.batchingTexture.value = i.batchingTexture.value, e.batchingIdTexture.value = i.batchingIdTexture.value, e.tTexture1.value = i.tTexture1.value, e.tTexture2.value = i.tTexture2.value, e.tTexture3.value = i.tTexture3.value }), (await Promise.all(Array.from({ length: this.numEmojis }, (a, o) => geometryLoader.load(`emojis/${o + 1}.drc`)))).forEach((a, o) => { const l = a.clone(); l.setAttribute("emoji", new BufferAttribute(new Int32Array(new Array(l.attributes.position.count).fill(o)), 1)), this.mesh.addGeometry(l) }), this.scene.add(this.mesh), events.on("character_emoji_display", this.onCharacterEmojiDisplay, this), events.on("character_network_event", this.onCharacterNetworkEvent, this), events.on("keydown", this.onKeyDown, this), this.ready.resolve()
    } onKeyDown(e) { const i = parseInt(e.key); isNaN(i) || i < 0 || i > this.numEmojis || typeof EMOJI_MAP[i] == "number" && events.emit("character_emoji_display", EMOJI_MAP[i]) } onCharacterEmojiDisplay(e = 0) { typeof e != "number" || e < 0 || this.characters._emitNetworkEvent(`emoji:${e}`) } onCharacterNetworkEvent({ object: e, index: i, id: s, event: a }) { if (!a.startsWith("emoji")) return; const o = a.split(":"); if (o.length !== 2) return; const l = parseInt(o[1]); if (typeof l != "number" || l < 0 || l >= this.numEmojis || !e || !e.position) return; const c = e.position.distanceTo(this.characters._localObject.position); if (c > this.maxDistance || (e.__lastEmojiShown || (e.__lastEmojiShown = -1), renderInfo.time - e.__lastEmojiShown < this.rateLimit) || (e.__lastEmojiShown = renderInfo.time, e.scale.x < 1)) return; const h = math.mix(.8, 1, Math.random()), d = _v0$a.copy(e.position).addScaledVector(e.up, e.boundingSphere.radius * 1.05).toArray(); e === this.characters._localObject && this.characters._setActive(); const p = 3; c < p && (events.emit("webgl_play_audio", `emoji-starts${Math.floor(Math.random() * 3) + 1}`), createDelayedCall(1.4 * h, () => { _v0$a.fromArray(d).distanceTo(this.characters._localObject.position) < p && events.emit("webgl_play_audio", `emoji-ends${Math.floor(Math.random() * 3) + 1}`) })), this.mesh.spawn({ geometryID: l, expiration: 2, data: [d, h, _v0$a.copy(e.up).multiplyScalar(.02).toArray(), Math.random(), e.up.toArray()] }) } dispose() { events.off("character_emoji_display", this.onCharacterEmojiDisplay, this), events.off("character_network_event", this.onCharacterNetworkEvent, this) }
}; function baseMaterial(r = {}) { const e = {}, i = new ShaderMaterial({ name: "base", defines: e, uniformsGroups: [global$1.UBO], uniforms: UniformsUtils.clone(uniforms), vertexShader: vertex, fragmentShader: fragment, lights: !0 }); return e.USE_UV = !0, i.uniforms.tColors.value = textureLoader.load("atlas.png", "srgb-nearest"), i.uniforms.tNoise.value = textureLoader.load("noise-simplex-layered-pixellated-highq.ktx2", "linearfilter-repeat"), i.uniforms.tNoiseTerrain.value = textureLoader.load("noises-terrain.ktx2", "linearfilter-repeat"), (r.isTerrain || r.frontShadow) && (e.IS_TERRAIN = !0, i.shadowSide = FrontSide), r.isCharacters && (e.IS_CHARACTER = 1, e.USE_SKINNING = 1, e.HARD_CUT_SHADOW = !0, i.shadowSide = FrontSide, i.uniforms.boneTexture = { value: null }, i.uniforms.batchingTexture = { value: null }, i.uniforms.batchingIdTexture = { value: null }, i.uniforms.uWetHeight = { value: 0 }, i.uniforms.tEye = { value: textureLoader.load("mainchar-eye-highq.ktx2", "repeat") }), r.isNPC && (e.IS_NPC = 1, e.HARD_CUT_SHADOW = !0, i.uniforms.tEye = { value: textureLoader.load("eye-highq.ktx2", "repeat") }, i.uniforms.uNPCSeed = { value: Math.random() }, i.uniforms.tMouth = { value: textureLoader.load("mouth-highq.ktx2", "repeat") }, i.uniforms.uMouthColor = { value: new Color("#2f1013") }, i.uniforms.uIsTalking = { value: 0 }), (r.isCharacters || r.isNPC) && (i.uniforms.uSkinColor = { value: new Color("#ebced0") }), r.isGive && (e.IS_GIVE = 1), i } const _v0$9 = new Vector3, _v1$6 = new Vector3, _v2 = new Vector3, _q0$2 = new Quaternion; class emojis { constructor({ scene: e, characters: i } = {}) { this.scene = e, this.characters = i, this.giveModels = {}, this.animation = { value: 0 }, this.ready = miscutils.deferred(), this.init() } async init() { const e = new Set; questData.quests.forEach(i => { i.steps.forEach(s => { var a, o, l, c; (a = s.extraData) != null && a.giveModel && e.add((o = s.extraData) == null ? void 0 : o.giveModel), (l = s.extraData) != null && l.receiveModel && e.add((c = s.extraData) == null ? void 0 : c.receiveModel) }) }), await Promise.all(Array.from(e).map(i => geometryLoader.load(i).then(s => { this.giveModels[i] = s }))), this.mesh = new Mesh(this.giveModels[Object.keys(this.giveModels)[0]], new baseMaterial({ isGive: !0 })), this.mesh.frustumCulled = !1, this.mesh.name = "Give Object", this.mesh.visible = !1, this.mesh.castShadow = !0, this.mesh.receiveShadow = !0, this.mesh.matrixAutoUpdate = !1, events.on("quest_receive_model", this.receive, this), events.on("quest_give_model", this.give, this), this.scene.add(this.mesh), this.ready.resolve() } receive(e) { this.show(e, "receive") } give(e) { this.show(e, "give") } show(e, i = "receive") { if (!this.giveModels[e]) return; this.mesh.geometry = this.giveModels[e]; const s = this.characters._localObject; _v1$6.copy(s.position), _v1$6.addScaledVector(s.up, 1), _v1$6.add(_v2.set(-.1, 0, .9).applyQuaternion(s.quaternion)); const a = _v1$6.toArray(); createTween(this.animation, { from: { value: 0 }, to: { value: 1 }, duration: i === "give" ? .5 : 1.15, ease: "sine.inOut", onStart: () => { this.mesh.visible = !0 }, onUpdate: () => { _v0$9.copy(s.position), _v0$9.addScaledVector(s.up, .8), _v0$9.add(_v1$6.set(-.1, 0, .1).applyQuaternion(s.quaternion)), _v1$6.fromArray(a), i === "receive" ? this.mesh.position.lerpVectors(_v1$6, _v0$9, this.animation.value) : this.mesh.position.lerpVectors(_v0$9, _v1$6, this.animation.value); const o = math.parabola(this.animation.value, 1) * .15; this.mesh.position.addScaledVector(s.up, o); const l = math.fit(this.animation.value, 0, .1, 0, 1) * math.fit(this.animation.value, .9, 1, 1, 0); this.mesh.scale.setScalar(l), this.mesh.quaternion.copy(s.quaternion), this.mesh.quaternion.premultiply(_q0$2.setFromAxisAngle(s.up, renderInfo.time * 3)), this.mesh.updateMatrix() }, onComplete: () => { this.mesh.visible = !1 } }) } dispose() { events.off("quest_receive_model", this.receive, this), events.off("quest_give_model", this.give, this) } } class audio { constructor({ scene: e, characters: i } = {}) { this.scene = e, this.characters = i, this.ambianceSpheres = { forest: { sphere: new Sphere(new Vector3(-13.4694, -14.7504, 1.36152), 15.4), margin: 4 }, city: { sphere: new Sphere(new Vector3(27.6687, 13.6836, 8.14707), 27.5), margin: 10 }, beach: { sphere: new Sphere(new Vector3(-11.8381, 12.2255, -1.87004), 12), margin: 3.5 }, factory: { sphere: new Sphere(new Vector3(-2.06543, 2.01072, -32.7937), 22.5), margin: 5 }, waterfalls: { sphere: new Sphere(new Vector3(11.2153, -18.8393, -9.09714), 12), margin: 2 }, temple: { sphere: new Sphere(new Vector3(-7.21651, 34.6679, -5.4496), 10), margin: 3 } }, this.volumes = { walk: 0, walkWater: 0, ambiances: { forest: 0, city: 0, beach: 0, factory: 0, waterfalls: 0, temple: 0 } }, this.scene.beforeRenderCbs.push(this.update.bind(this)), events.on("character_physics_jump", this._playJump, this), events.on("character_physics_land", this._playLand, this) } update() { const e = this.characters._localObject, i = e.userData.medium === this.characters.MEDIUMS.GROUND ? 1 : 0, a = math.clamp(e.animationProps.weights[1] + e.animationProps.weights[2], 0, 1) * i > .5 ? 1 : 0; this.volumes.walk = math.lerpFPS(this.volumes.walk, a, .25); const l = e.position.length() < 22 ? 1 : 0; this.volumes.walkWater = math.lerpFPS(this.volumes.walkWater, a * l, .25); const c = Math.max(0, this.volumes.walk - this.volumes.walkWater), h = this.volumes.walkWater; events.emit("webgl_set_audio_volume", "footsteps", c * .2), events.emit("webgl_set_audio_volume", "footsteps-water", h * .2); const d = Object.keys(this.ambianceSpheres); let p = "", f = 0; for (let x = 0; x < d.length; x++) { const b = d[x], T = this.ambianceSpheres[b].sphere, M = e.position.distanceTo(T.center), w = math.fit(M, T.radius, Math.max(0, T.radius - this.ambianceSpheres[b].margin), 0, 1); if (w > 0) { p = b, f = w; break } } const _ = Object.keys(this.volumes.ambiances); _.forEach(x => { this.volumes.ambiances[x] = 0 }), p && (this.volumes.ambiances[p] = f), events.emit("webgl_set_audio_volume", "ambiance-base", .5), _.forEach(x => { events.emit("webgl_set_audio_volume", `ambiance-${x}`, this.volumes.ambiances[x] * .5) }) } _playJump() { events.emit("webgl_play_audio", "jump") } _playLand() { events.emit("webgl_play_audio", "land") } dispose() { events.off("character_physics_jump", this._playJump, this), events.off("character_physics_land", this._playLand, this) } } function depthCharsMaterial(r = {}) {
    const e = new MeshDepthMaterial({ depthPacking: RGBADepthPacking }); return e.onBeforeCompile = (i, s) => {
        e.uniforms = i.uniforms, i.uniforms.boneTexture = { value: null }, i.uniforms.batchingTexture = { value: null }, i.uniforms.batchingIdTexture = { value: null }, i.uniforms.uShowChars = { value: 1 }, i.vertexShader = i.vertexShader.replace("#include <skinning_pars_vertex>", `
            varying vec3 wPos;

            #define USE_SKINNING 1

            #ifdef USE_SKINNING
                attribute vec4 skinIndex;
                attribute vec4 skinWeight;
                uniform sampler2D boneTexture;
                mat4 bindMatrix = mat4(1.0);
                mat4 bindMatrixInverse = mat4(1.0);
                mat4 getBoneMatrix(const in float i, const in float id) {
                    int x = int(i) * 4;
                    int y = int(id);
                    vec4 v1 = texelFetch(boneTexture, ivec2(x, y), 0);
                    vec4 v2 = texelFetch(boneTexture, ivec2(x + 1, y), 0);
                    vec4 v3 = texelFetch(boneTexture, ivec2(x + 2, y), 0);
                    vec4 v4 = texelFetch(boneTexture, ivec2(x + 3, y), 0);
                    return mat4(v1, v2, v3, v4);
                }
            #endif
        `), i.vertexShader = i.vertexShader.replace("#include <batching_vertex>", `
            #ifdef USE_BATCHING
                float batchID = getIndirectIndex(gl_DrawID);
                mat4 batchingMatrix = getBatchingMatrix(batchID);
            #endif
        `), i.vertexShader = i.vertexShader.replace("#include <skinbase_vertex>", `
            #ifdef USE_SKINNING
                mat4 boneMatX = getBoneMatrix(skinIndex.x, batchID);
                mat4 boneMatY = getBoneMatrix(skinIndex.y, batchID);
                mat4 boneMatZ = getBoneMatrix(skinIndex.z, batchID);
                mat4 boneMatW = getBoneMatrix(skinIndex.w, batchID);
            #endif
        `), i.vertexShader = i.vertexShader.replace("#include <project_vertex>", `
            wPos = (modelMatrix * vec4(transformed, 1.0)).xyz;
            #include <project_vertex>
        `), i.fragmentShader = i.fragmentShader.replace("#include <clipping_planes_pars_fragment>", `
            #include <clipping_planes_pars_fragment>
            varying vec3 wPos;
            uniform float uShowChars;

            float sphereFade(vec3 p, float size, float amount) {
                float h = size * 0.5;
                return clamp(1.0 - step(amount * 1.85, length(mod(p, size) - h) / h), 0.0, 1.0);
            }
        `), i.fragmentShader = i.fragmentShader.replace("#include <clipping_planes_fragment>", `
            #include <clipping_planes_fragment>
            if (uShowChars < 1.0) {
                float showAmount = sphereFade(wPos, 0.15, uShowChars);
                if (showAmount < 0.001) discard;
            }
        `)
    }, e
} const _v0$8 = new Vector3, _v1$5 = new Vector3, _q0$1 = new Quaternion, _s0 = new Spherical, _o0 = new Object3D, DEFAULT_FILES = { bonesFile: "avatar/avatar-bones", modelFiles: ["avatar/accessories/base"], animationFiles: ["avatar/avatar-idle", "avatar/avatar-run", "avatar/avatar-sprint", "avatar/avatar-air", "avatar/avatar-afk1", "avatar/avatar-afk2", "avatar/avatar-afk3"] }, ACCESSORIES = { base: ["base"], hair: ["hair1", "hair2", "hair3", "hair4", "hair5", "hair6", "hair7"], top: ["top1", "top2", "top3", "top4", "top5", "top6", "top7", "top8", "top9"], bottom: ["bottom1", "bottom2", "bottom3", "bottom4", "bottom5", "bottom6", "bottom7"], shoes: ["shoes1", "shoes2", "shoes3", "shoes4", "shoes5", "shoes6", "shoes7"] }; function getRandomAccessories() { return Object.keys(ACCESSORIES).map(e => { const i = ACCESSORIES[e], s = Math.floor(Math.random() * i.length); return i[s] }) } function validateAndSaveAccessories(r) { const e = Object.keys(ACCESSORIES), i = new Array(e.length).fill(!1); for (let a = 0; a < r.length; a++) { const o = r[a]; if (o) for (let l = 0; l < e.length; l++) { const c = e[l]; if (ACCESSORIES[c].includes(o) && a === l) { i[l] = !0; break } } } let s = r; return i.some(a => !a) && (s = getRandomAccessories()), client$1.localStorage.modelFiles = s, s.map(a => `accessories/${a}`) } class characters { constructor(e, i) { this.scene = e, this.options = i, this.ready = new Promise(s => { this.isReady = s }), this.isCameraLocked = !1, this.init() } async init() { var a, o, l, c; this.maintainUnlockRotation = !0; const e = ((o = (a = this.scene.mainController) == null ? void 0 : a.state) == null ? void 0 : o.control) === "manual", i = ""; DEFAULT_FILES.modelFiles = validateAndSaveAccessories(client$1.localStorage.modelFiles || getRandomAccessories()).map(h => `avatar/${h}`), this.mesh = new characters$1({ scene: this.scene, material: baseMaterial({ isCharacters: !0 }), customDepthMaterial: depthCharsMaterial(), initialData: { ...DEFAULT_FILES, tag: ((c = (l = this.scene.mainController) == null ? void 0 : l.state) == null ? void 0 : c.tag) || "Unnamed" }, initialDataTypes: {}, animationOptions: [{ speed: 1 }, { speed: 1.1 }, { speed: 1.1 }, { speed: 1 }, { speed: 1 }], animationSprintLerp: .05, inactiveAnimations: [4, 5, 6], inactiveTime: 30, colliderGeometry: this.scene.characterInitialOptions.collider, capsuleRadiusPercentage: .2, floorDetectInclination: .7, jumpForce: .15, positionForce: .005, gravity: -.00981, damp: .92, dampIdle: .65, autoStep: !0, sprintEnabled: !0, sprintSpeed: 1.3, interactKeyEnabled: !1, initialPosition: this.scene.characterInitialOptions.initialPosition, initialRotation: this.scene.characterInitialOptions.initialRotation, initialRadius: this.scene.characterInitialOptions.initialRadius, initialUp: _v0$8.fromArray(this.scene.characterInitialOptions.initialPosition).normalize().toArray(), controlMode: e ? "manual" : "automatic", relativeCameraPosition: this.scene.characterInitialOptions.relativeCameraPosition, relativeCameraOffset: this.scene.characterInitialOptions.relativeCameraOffset, offline: !1, autoConnect: !1, servers: ["wss://multiplayer-server-76608060529.us-central1.run.app"], roomPrefix: this.scene.characterInitialOptions.roomPrefix, roomRequested: i, tags: !1, tagsFont: "REM-Medium", trails: !0, trailsFootSpacing: .1, customAttribUpdate: ({ object: h, index: d, id: p, lerp: f } = {}) => { }, onRoomJoined: h => { }, onConnect: () => { }, onDisconnect: () => { }, onData: h => { console.log("data received:", h) } }); const s = []; Object.keys(ACCESSORIES).forEach(h => { ACCESSORIES[h].forEach(p => s.push(geometryLoader.load(`avatar/accessories/${p}.drc`, !0))) }), await Promise.all([this.mesh.ready, Promise.all(s)]), this.give = new emojis({ scene: this.scene, characters: this.mesh }), this.emojis = new emojis$1({ scene: this.scene, characters: this.mesh }), await Promise.all([this.give.ready, this.emojis.ready]), this.scene.beforeRenderCbs.push(() => { this.mesh._localObject.position.lengthSq() < 1e-4 ? this.mesh._localObject.up.set(0, 1, 0) : this.mesh._localObject.up.copy(this.mesh._localObject.position).normalize(), this.mesh._interactingElementChanged && (this.isCameraLockingInteractingElement() ? this.lockCameraObject() : this.unlockCamera()), this.mesh._update(), events.emit("character_broadcast_position", this.mesh._localObject.position.toArray()); const h = this.mesh._localObject.position.length(), d = Math.max(0, 22 - h), p = this.mesh.material.uniforms.uWetHeight; p.value < d ? p.value = d : p.value = Math.max(0, p.value - 2e-4 * renderInfo.ratio) }), this.audio = new audio({ scene: this.scene, characters: this.mesh }), this.scene.add(this.mesh), this.scene.ready.then(() => { var h; (h = this.scene.__controlsPass) == null || h.scene.add(this.mesh._controls._circles) }), events.on("character_accessories_set", this.setAccessories, this), this.isReady() } isCameraLockingInteractingElement() { const e = this.mesh.interactingElement; let i = !1; return e && (e === "intro" || e === "self" || e.isWorldNPC && !e._textsBubblesEnabled) && (i = !0), i } setAccessories(e = []) { if (!e.length) throw new Error("No files provided to set accessories"); const i = validateAndSaveAccessories(["base", ...e]); this.mesh.setModels({ modelFiles: i }), events.emit("webgl_play_audio", "clothes") } enableControls(e) { e ? this.mesh._controls.enable() : this.mesh._controls.disable(), this.mesh._localObject.userData.animation = 0 } enable() { this.isCameraLockingInteractingElement() || this.enableControls(!0) } disable() { this.enableControls(!1) } lockCameraObject() { if (!this.mesh._camera.isFollowCamera) return; this.isCameraLocked = !0, this.maintainUnlockRotation = !0, this.enableControls(!1); const e = this.mesh.interactingElement === "intro", i = this.mesh.interactingElement === "self", s = this.mesh.interactingElement.isWorldNPC, a = e || i ? this.mesh._localObject : this.mesh.interactingElement, o = this.mesh._localObject.position.toArray(), l = this.mesh._localObject.rotationHorizontal, c = this.mesh._localObject.up.toArray(); this.mesh._collisionPhysics._snap(o, l, c, !0); let h = [0, 0, 0], d = 2, p = Math.PI / 2, f = 0, _ = l; const x = this.mesh._camera.touchAmount; if (e) { this.maintainUnlockRotation = !1, a.getWorldPosition(_v0$8), _v0$8.addScaledVector(a.up, 1.15), h = _v0$8.toArray(), d = 2.5, p = Math.PI * .475, f = math.getShortestRotationAngle(l, l - Math.PI * .9); const b = .15; this.mesh._camera.setFollowOverwrite({ target: h, radius: d, phi: p, theta: f }), createTween(this.mesh._camera, { to: { overwriteAmount: 1 }, duration: 2.5, ease: "inOut1", onUpdate: () => { this.mesh.interactingElement && (this.mesh._camera.touchAmount = math.lerp(x, b, this.mesh._camera.overwriteAmount), this.mesh._collisionPhysics._snap(o, l, c, !0)) } }) } else if (i) { a.getWorldPosition(_v0$8), _v0$8.addScaledVector(this.mesh._localObject.up, 1), h = _v0$8.toArray(), d = 3.5, p = Math.PI * .5; const b = 8, T = Math.PI * 2 / b, M = d * 1.25, w = .15; let D = 0; for (let P = 0; P < b; P++) { const U = P * T - Math.PI * w; _v1$5.set(0, 0, 1).applyQuaternion(this.mesh._localObject.quaternion), _v1$5.applyAxisAngle(this.mesh._localObject.up, U), this.mesh._collisionPhysics._rayCaster.set(_v0$8, _v1$5); const O = this.mesh._collisionPhysics._rayCaster.intersectObject(this.mesh._collisionPhysics._collider); if (O.length === 0 || O[0].distance > M) { D = U; break } } D > 0 ? (f = math.getShortestRotationAngle(l, l + Math.PI + D), _ = math.getShortestRotationAngle(_, f - Math.PI * (1 - w))) : (f = math.getShortestRotationAngle(l, l + Math.PI * (1 - w)), _ = l); const R = .35; this.mesh._camera.setFollowOverwrite({ target: h, radius: d, phi: p, theta: f }), createTween(this.mesh._camera, { to: { overwriteAmount: 1 }, duration: 1.5, ease: "inOut1", onUpdate: () => { this.mesh.interactingElement && (this.mesh._camera.touchAmount = math.lerp(x, R, this.mesh._camera.overwriteAmount), this.mesh._collisionPhysics._snap(o, math.lerp(l, _, this.mesh._camera.overwriteAmount), c, !0)) } }) } else if (s) { _v0$8.copy(a._targetPosition), _v0$8.addScaledVector(a.up, a.geometry.boundingSphere.radius * 2 - .5), _v1$5.fromArray(a.__wrapper.options.lookatOffset), _v1$5.applyQuaternion(a._targetQuaternion), _v0$8.add(_v1$5), h = _v0$8.toArray(), d = 2.5, p = Math.PI * .45, _v0$8.subVectors(a._targetPosition, this.mesh._localObject.position); const b = _v0$8.length(); _v0$8.normalize(); const T = this.mesh._collisionPhysics._charactersCapsule.radius * 1.1, M = .7 + T, w = Math.max(M, 1.25 - T); let D = o; if (b < M || b > w) { _v0$8.negate(), _v1$5.fromArray(h), this.mesh._collisionPhysics._rayCaster.set(_v1$5, _v0$8); const O = this.mesh._collisionPhysics._rayCaster.intersectObject(this.mesh._collisionPhysics._collider); if (O.length > 0 && O[0].distance < w) { const H = _v0$8.copy(O[0].point).sub(_v1$5).length(); _v1$5.addScaledVector(_v0$8.normalize(), Math.max(0, H - T)) } else _v1$5.addScaledVector(_v0$8, math.clamp(b, M, w)); this.mesh._collisionPhysics._rayCaster.set(_v1$5, _v0$8.copy(_v1$5).normalize().negate()); const N = this.mesh._collisionPhysics._rayCaster.intersectObject(this.mesh._collisionPhysics._collider); N.length > 0 && (D = N[0].point.toArray(), _v0$8.subVectors(a._targetPosition, N[0].point).normalize()) } _v0$8.applyAxisAngle(this.mesh._localObject.up, this.mesh._localObject.rotationHorizontal), _v0$8.applyQuaternion(_q0$1.copy(this.mesh._localObject.quaternion).invert()); const R = _s0.setFromVector3(_v0$8).theta; _ = math.getShortestRotationAngle(l, R); const P = .4; if (a._talkFacingPlayer) f = math.getShortestRotationAngle(this.mesh._camera._sphericalTarget.theta, R + P); else { _v0$8.set(0, 0, -1).applyQuaternion(a._targetQuaternion), _v0$8.applyAxisAngle(this.mesh._localObject.up, this.mesh._localObject.rotationHorizontal), _v0$8.applyQuaternion(_q0$1.copy(this.mesh._localObject.quaternion).invert()); const O = _s0.setFromVector3(_v0$8).theta; f = math.getShortestRotationAngle(this.mesh._camera._sphericalTarget.theta, O + P); const N = math.makeAnglePositive(_), H = math.getShortestRotationAngle(N, f); Math.abs(N - H) < .6 && (f = math.getShortestRotationAngle(f, f - P * 2)) } const U = .1; this.mesh._camera.setFollowOverwrite({ target: h, radius: d, phi: p, theta: f }), createTween(this.mesh._camera, { duration: 1.3, ease: "inOut1", to: { overwriteAmount: 1 }, onStart: () => { }, onUpdate: () => { if (!this.mesh.interactingElement) return; this.mesh._camera.touchAmount = math.lerp(x, U, this.mesh._camera.overwriteAmount); const O = _v0$8.fromArray(o).lerp(_v1$5.fromArray(D), this.mesh._camera.overwriteAmount).toArray(), N = _v0$8.fromArray(O).normalize().toArray(), H = math.lerp(l, _, this.mesh._camera.overwriteAmount); this.mesh._collisionPhysics._snap(O, H, N, !0), _o0.position.copy(this.mesh._localObject.position), _o0.quaternion.copy(this.mesh._localObject.quaternion), _o0.scale.copy(this.mesh._localObject.scale), _o0.up.copy(this.mesh._localObject.up); for (let F = 0, k = 2; F < k; F++)this.mesh._collisionPhysics._performShapecast(_o0, 1 / k); this.mesh._collisionPhysics._snap(_o0.position.toArray(), H, _v0$8.copy(_o0.position).normalize().toArray(), !0) } }) } events.emit("webgl_play_audio", "zoom-in") } unlockCamera() { if (!this.mesh._camera.isFollowCamera || !this.isCameraLocked) return; this.isCameraLocked = !1, this.mesh.visible = !0, this.maintainUnlockRotation && this.mesh._camera.overwriteAmount === 1 && (this.scene.camera._sphericalTarget.theta = this.scene.camera.overwriteSpherical.theta, this.scene.camera._spherical.theta = this.scene.camera._sphericalTarget.theta), this.enableControls(!0); const e = this.maintainUnlockRotation ? 1.25 : 2.25; createTween(this.mesh._camera, { to: { overwriteAmount: 0, touchAmount: 1 }, duration: e, ease: "inOut1" }), events.emit("webgl_play_audio", "zoom-off") } dispose() { var e, i; this.disable(), (e = this.give) == null || e.dispose(), (i = this.emojis) == null || i.dispose(), events.off("character_accessories_set", this.setAccessories, this) } } const _v0$7 = new Vector3, _v1$4 = new Vector3, _s$4 = new Sphere, _matrix = new Matrix4, _frustum = new Frustum; function fillEmptyLODs(r, e) { const i = r[0], s = new BufferGeometry; for (const o in i.attributes) { const l = i.getAttribute(o), { array: c, itemSize: h, normalized: d } = l, p = new l.constructor(new c.constructor(0), h, d); s.setAttribute(o, p) } const a = i.getIndex(); for (s.setIndex(new a.constructor(new a.array.constructor(0), 1)); r.length < e;)for (let o = 0; o < r.length; o++)if (r[o].userData.batchId !== o) { const l = s.clone(); l.userData = { batchId: o }, r.splice(o, 0, l); break } } class terrain { constructor(e, i) { this.scene = e, this.options = i, this.extraLODs = 0, this.lowMemory = !!client$1.lowMemoryDevice, this.DOT_THRESHOLD = .45, this.LOD1_THRESHOLD = 6, this.LOD2_THRESHOLD = 12, this.LOD3_THRESHOLD = this.lowMemory ? 1 / 0 : 20, this.ready = new Promise(s => { this.isReady = s }), this.init() } async init() { const e = Array.from({ length: this.options.chunks }, (_, x) => x); let i = null, s = null, a = null, o = null, l = null; this.lowMemory ? (i = await Promise.all([await Promise.all(e.map(_ => geometryLoader.batched(`planets/${this.scene.terrainOptions.terrain}/low/full_${_}.drc`))), await Promise.all(e.map(_ => geometryLoader.batched(`planets/${this.scene.terrainOptions.terrain}/low/full-lod-1_${_}.drc`))), await Promise.all(e.map(_ => geometryLoader.batched(`planets/${this.scene.terrainOptions.terrain}/low/full-lod-3_${_}.drc`)))]), s = i[0].flat(), a = i[1].flat(), o = i[2].flat()) : (i = await Promise.all([await Promise.all(e.map(_ => geometryLoader.batched(`planets/${this.scene.terrainOptions.terrain}/full_${_}.drc`))), await Promise.all(e.map(_ => geometryLoader.batched(`planets/${this.scene.terrainOptions.terrain}/full-lod-1_${_}.drc`))), await Promise.all(e.map(_ => geometryLoader.batched(`planets/${this.scene.terrainOptions.terrain}/full-lod-2_${_}.drc`))), await Promise.all(e.map(_ => geometryLoader.batched(`planets/${this.scene.terrainOptions.terrain}/full-lod-3_${_}.drc`)))]), s = i[0].flat(), a = i[1].flat(), o = i[2].flat(), l = i[3].flat()); const c = Math.max((s == null ? void 0 : s.length) || 0, (a == null ? void 0 : a.length) || 0, (o == null ? void 0 : o.length) || 0, (l == null ? void 0 : l.length) || 0); s && s.length < c && fillEmptyLODs(s, c), a && a.length < c && fillEmptyLODs(a, c), o && o.length < c && fillEmptyLODs(o, c), l && l.length < c && fillEmptyLODs(l, c); const h = s.length, d = s.reduce((_, x) => _ + x.attributes.position.count, 0), p = s.reduce((_, x) => _ + x.index.count, 0); this.mesh = new BatchedMesh(h, d, p, new baseMaterial({ isTerrain: !0, ...this.options.materialArgs })), this.mesh.name = "planet-chunks-LOD-0", this.mesh.sortObjects = !1, this.mesh.receiveShadow = !0, this.mesh.castShadow = !0, this.mesh.frustumCulled = !1, this.mesh.perObjectFrustumCulled = !1, s.forEach((_, x) => { this.mesh.addInstance(this.mesh.addGeometry(_)) }), this.mesh.__onBeforeRender = this.mesh.onBeforeRender, this.mesh.onBeforeRender = () => { }, this.scene.add(this.mesh), this.mesh.onBeforeRender = this.update.bind(this); const f = [a, o]; l && f.push(l), f.forEach((_, x) => { this.extraLODs++; const b = _.length, T = _.reduce((D, R) => D + R.attributes.position.count, 0), M = _.reduce((D, R) => D + R.index.count, 0); this[`mesh${x + 1}`] = new BatchedMesh(b, T, M, new baseMaterial({ isTerrain: !0, ...this.options.materialArgs })); const w = this[`mesh${x + 1}`]; w.name = `planet-chunks-LOD-${x + 1}`, w.sortObjects = !1, w.receiveShadow = !0, w.castShadow = !0, w.frustumCulled = !1, w.perObjectFrustumCulled = !1, _.forEach((D, R) => { w.addInstance(w.addGeometry(D)) }), w.__onBeforeRender = w.onBeforeRender, w.onBeforeRender = () => { }, this.scene.add(w) }), this.isReady() } update(e, i, s, a, o) { var h; if (!((h = this.scene.characters) != null && h.mesh)) return; _matrix.multiplyMatrices(s.projectionMatrix, s.matrixWorldInverse).multiply(this.mesh.matrixWorld), _frustum.setFromProjectionMatrix(_matrix, e.coordinateSystem); const l = this.scene.characters.mesh._localObject, c = l.position.length(); for (let d = 0; d < this.mesh._instanceInfo.length; d++) { this.mesh._instanceInfo[d].visible = !1; for (let b = 0; b < this.extraLODs; b++)this[`mesh${b + 1}`]._instanceInfo[d].visible = !1; this.mesh.getBoundingSphereAt(d, _s$4), this.mesh._instanceInfo[d].__culled = !_frustum.intersectsSphere(_s$4), _v0$7.copy(l.position).sub(_s$4.center).normalize(); const p = _s$4.center.distanceTo(l.position), f = Math.min(p, _s$4.radius); _v1$4.copy(_s$4.center).addScaledVector(_v0$7, f), this.mesh._instanceInfo[d].__distanceToCharacter = l.position.distanceTo(_v1$4); const _ = Math.abs(_s$4.center.length() - c), x = Math.min(p, _s$4.radius + _); _v1$4.copy(_s$4.center).addScaledVector(_v0$7, x), _v0$7.copy(l.position).divideScalar(c || 1), this.mesh._instanceInfo[d].__dotCharacter = _v0$7.dot(_v1$4.normalize()) } for (let d = 0; d < this.mesh._instanceInfo.length; d++)if (this.mesh._instanceInfo[d].__dotCharacter < this.DOT_THRESHOLD || this.mesh._instanceInfo[d].__culled) { this.mesh._instanceInfo[d].visible = !1; for (let f = 0; f < this.extraLODs; f++)this[`mesh${f + 1}`]._instanceInfo[d].visible = !1 } else { const f = this.mesh._instanceInfo[d].__distanceToCharacter <= this.LOD1_THRESHOLD, _ = !f && this.mesh._instanceInfo[d].__distanceToCharacter <= this.LOD2_THRESHOLD, x = !f && !_ && this.mesh._instanceInfo[d].__distanceToCharacter <= this.LOD3_THRESHOLD, b = !f && !_ && !x; this.mesh._instanceInfo[d].visible = f, [_, x, b].forEach((T, M) => { M < this.extraLODs && (this[`mesh${M + 1}`]._instanceInfo[d].visible = T) }) } this.mesh._visibilityChanged = !0, this.mesh.__onBeforeRender(e, i, s, this.mesh.geometry, this.mesh.material); for (let d = 0; d < this.extraLODs; d++) { const p = this[`mesh${d + 1}`]; p._visibilityChanged = !0, p.__onBeforeRender(e, i, s, p.geometry, p.material) } } } const _v0$6 = new Vector3; class planet extends scene { constructor(e, i = {}) { super({ customCamera: followCamera$1 }), this.mainController = e, this.terrainOptions = { terrain: i.terrain || "present", chunks: 10 }, this.characterInitialOptions = { initialPosition: i.charPosition || [-10, 36, 14], initialRotation: i.charRotation || 0, initialRadius: i.charRadius || 2, relativeCameraPosition: new Vector3(0, 1, 5), relativeCameraOffset: new Vector3(-.65, 0, 1), collider: null, roomPrefix: i.roomPrefix || "planets-default" }, this.lightOptions = { cmsOptions: i.cmsOptions || ["#ffffff", 3], csmPositionOffset: i.csmPositionOffset || new Spherical(100, Math.PI * .2, Math.PI * -.25), csmForwardOffset: i.csmForwardOffset || 6 }, this._planetID = i.planet, this.quests = [], this._init() } async _init() { await Promise.all([this.loadHitMesh(), this.setupCamera(), this.setupPostProcessing()]); const e = [["characters", characters, this.characterInitialOptions], ["terrain", terrain, this.terrainOptions]]; await Promise.all(e.map(i => (this[i[0]] = new i[1](this, i[2]), this[i[0]].ready))), await Promise.all([this.init(), this.camera.isFollowCamera ? await miscutils.wait(this.camera, "_followedMesh") : Promise.resolve()]), this.setupLights(), this.waterScene && global$1.renderer.webgl.compileAsync(this.waterScene, this.waterScene.camera), this._resize(), events.on("resize", this._resize, this), events.on("topicon_change", this.playIconSound, this), events.on("npc_bubble_text_starts", this.npcBubbleStarts, this), events.on("npc_bubble_text_ends", this.npcBubbleEnds, this), events.on("npc_bubble_show", this.npcBubbleShow, this), events.on("npc_bubble_hide", this.npcBubbleHide, this), this.initQuests(), client$1.devScene && (this.playInAnimation(), this.debug(), window._scene = this, window._camera = this.camera, window._characters = this.characters), this.isReady() } async loadHitMesh() { const i = Array.from({ length: 5 }, (a, o) => o), s = await Promise.all(i.map(a => geometryLoader.load(`planets/present/hitmesh_${a}.drc`))); this.characterInitialOptions.collider = mergeGeometries(s) } setupCamera() { this.camera.shake.set(.07, .07, .02), this.camera.shakeSpeed.setScalar(.2), this.camera.near = .2, this.camera.far = 175, this.camera.updateProjectionMatrix() } setupPostProcessing() { return new Promise(e => { setTimeout(() => { addPostProcessing(this, this.composer), e() }, 0) }) } setupLights() { const e = new followCSM({ csm: !1, scene: this, castShadow: !0, shadowMapSize: client$1.iphone ? 1024 : 2400, shadowSize: 24, color: this.lightOptions.cmsOptions[0], intensity: this.lightOptions.cmsOptions[1], positionOffset: this.lightOptions.csmPositionOffset, forwardOffset: this.lightOptions.csmForwardOffset }); e.shadow.normalBias = .07, e.shadow.bias = -1e-4, this.directionalLight = e, this.add(e) } async init() { } async initQuests() { } async playInAnimation() { if (this.camera.isFollowCamera) { const e = this.camera._cameraCollisions, i = this.camera.touchAmount; this.camera._cameraCollisions = !1, this.camera.touchAmount = 0, this.birds && (this.birds.mesh.material.uniforms.uShow.value = 0), this.birds2 && (this.birds2.mesh.material.uniforms.uShow.value = 0); const s = !this.anyStepInitiated, a = { value: 1 }, c = createTween(a, { to: { value: 0 }, ease: s ? "power1.out" : "inOut1", duration: s ? 2 : 3.25, onStart: () => { this.camera.overwriteAmount = 1 }, onUpdate: () => { _v0$6.copy(this.camera._followedMeshTarget).normalize(), this.camera.overwriteTarget.copy(this.camera._followedMeshTarget).addScaledVector(_v0$6, 2 * a.value), this.camera.overwriteSpherical.radius = math.mix(this.camera._spherical.radius, 12, a.value), this.camera.overwriteSpherical.phi = this.camera._spherical.phi, this.camera.overwriteSpherical.theta = this.camera._spherical.theta }, onComplete: () => { this.camera.overwriteAmount = 0, this.camera._cameraCollisions = e, this.birds && createTween(this.birds.mesh.material.uniforms.uShow, { to: { value: 1 }, duration: 2 }), this.birds2 && createTween(this.birds2.mesh.material.uniforms.uShow, { to: { value: 1 }, duration: 2 }) } }); createDelayedCall(.3, () => { events.emit("webgl_play_audio", "whoosh") }), s && !client$1.devScene ? (await c, this.characters.mesh.interactingElement = "intro", await miscutils.wait(1), await introDialogue(), this.characters.mesh.interactingElement = null, this.characters.mesh._connection._createSocket()) : (createTween(this.camera, { to: { touchAmount: i }, duration: 4 }), this.characters.mesh._connection._createSocket(), await createDelayedCall(2, () => { this.characters.enable() }), events.emit("ui_show_sideicons")) } } _resize() { this.camera._followedMesh && (client$1.screen.w > client$1.screen.h ? (this.camera.setOffset([-.65, 0, 1], !1), this.camera._cameraTargetLocalLerp = .0125, this.camera.displacement.position.set(-.075, -.05), this.camera.zoom = client$1.iphone ? client$1.screen.aspectRatio : 1) : (this.camera.setOffset([-.25, 0, .5], !1), this.camera._cameraTargetLocalLerp = .03, this.camera.displacement.position.set(0, 0), this.camera.zoom = 1), this.camera.updateProjectionMatrix()) } playIconSound({ object: e, visible: i, isClose: s }) { !(e != null && e.isWorldNPC) || !i || (s ? events.emit("webgl_play_positional", "bubble-starts", e, .1, .2, !0) : events.emit("webgl_play_positional", "bubble-ends", e, .1, .1, !0)) } npcBubbleShow({ object: e }) { e != null && e.isWorldNPC && events.emit("webgl_play_positional", "bubble-starts", e, .1, 0, !0) } npcBubbleHide({ object: e }) { e != null && e.isWorldNPC && (events.emit("webgl_play_positional", "bubble-ends", e, .1, .1, !0), this.npcBubbleEnds({ object: e })) } npcBubbleStarts({ object: e }) { var o; if (!(e != null && e.isWorldNPC) || !e.__wrapper) return; const i = e.__wrapper, a = `dialogue-${((o = i.options.extraData) == null ? void 0 : o.voice) || "male1"}`; events.emit("webgl_play_positional", a, i.mesh) } npcBubbleEnds({ object: e }) { var o; if (!(e != null && e.isWorldNPC) || !e.__wrapper) return; const i = e.__wrapper, a = `dialogue-${((o = i.options.extraData) == null ? void 0 : o.voice) || "male1"}`; events.emit("webgl_stop_positional", a, i.mesh) } playOutAnimation() { this.characters.dispose() } } function bubbleMaterialGenerator() {
    const r = new ShaderMaterial({
        uniforms: { uSize: { value: new Vector2(1, 1) }, uColor: { value: new Color("#ffffff") }, uRand: { value: Math.random() } }, vertexShader: `
            attribute float pointer;

            ${matrixutils_default}

            uniform vec2 uSize;

            varying vec2 vUv;
            varying vec3 vLocalPos;
            flat varying float vPointer;
            varying vec2 vHighPrecisionZW;

            void main() {
                vUv = uv;
                vPointer = pointer;

                vec3 pos = position;
                if (pointer < 0.5) pos.xy *= uSize; // big part
                else pos.xy *= 0.7; // smaller pointer

                pos.y += 0.04; // compensate for pointer
                pos.z -= 0.005; // move behind of texts

                vLocalPos = pos;

                gl_Position = projectionMatrix * viewMatrix * billboardModelMatrix() * vec4(pos, 1.0);
                vHighPrecisionZW = gl_Position.zw;
            }
        `, fragmentShader: `
            layout(location = 1) out highp vec4 gInfo;

            uniform vec2 uSize;
            uniform vec3 uColor;
            uniform float uRand;

            ${sinenoise_default}

            varying vec2 vUv;
            varying vec3 vLocalPos;
            flat varying float vPointer;
            varying vec2 vHighPrecisionZW;

            float sdRoundedBox(vec2 p, vec2 b, float r) {
                vec2 q = abs(p) - b + r;
                return min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r;
            }

            void main() {
                if (vPointer < 0.5) {
                    vec2 aspectMult = mix(vec2(uSize.x / uSize.y, 1.0), vec2(1.0, uSize.y / uSize.x), step(uSize.x, uSize.y));
                    float shape = sdRoundedBox((vUv - 0.5) * aspectMult, vec2(0.5) * aspectMult, 0.025 / min(uSize.x, uSize.y));
                    if (shape > 0.001) discard;
                }

                float noise = sinenoise1(vec3(vLocalPos.xy * 15.0 + uRand * vec2(2.43, 4.453), uRand * 15.342));
                float onlineContribution = step(-0.3, noise);

                gl_FragColor = vec4(uColor, uRand);
                gInfo = vec4(1.0 - (0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5), vec2(0.0), onlineContribution);
            }
        `}); return () => r
} function textMaterialGenerator() {
    const r = new ShaderMaterial({
        defines: { ANIMATION_MASK: 1 }, uniformsGroups: [global$1.UBO], uniforms: { tCurve: { value: null }, tBand: { value: null }, uAnimationOrder: { value: 0 }, uAnimationDirection: { value: new Vector2(0, 1) }, uAnimationMargin: { value: .5 }, uAnimationProgress: { value: 0 }, uSize: { value: new Vector2 }, uMargins: { value: new Vector2 }, uSeed: { value: Math.random() }, uAlpha: { value: 1 } }, vertexShader: `
            attribute vec3 centr;
            attribute vec2 textWeights;

            uniform float uAnimationProgress;

            uniform vec2 uSize;
            uniform vec2 uMargins;
            uniform float uAlpha;

            flat varying vec3 vCentr;
            varying vec2 vHighPrecisionZW;

            ${falloff_default}
            ${matrixutils_default}
            ${globalUBO_default}
            ${slugvs_default}
            ${eases_default}

            float hash13(vec3 p3) {
                p3  = fract(p3 * .1031);
                p3 += dot(p3, p3.zyx + 31.32);
                return fract((p3.x + p3.y) * p3.z);
            }

            vec2 hash23(vec3 p3) {
                p3 = fract(p3 * vec3(.1031, .1030, .0973));
                p3 += dot(p3, p3.yzx+33.33);
                return fract((p3.xx+p3.yz)*p3.zy);
            }

            void main() {
                vCentr = centr;

                vec3 pos = SlugVS();
                float seed = fract(hash13(centr));

                // animation
                float show = uAnimationProgress;
                float hide = 1.0 - uAlpha;

                if (show < 1.0 || hide > 0.0) {
                    // show
                    float stepsShow = floor(3.0 + seed * 2.0);
                    float trShow = floor(falloff(textWeights.y, 0.0, 1.0, 0.1, show) * stepsShow) / stepsShow;
                    vTexCoord += vec2(0.0, 1.0) * (1.0 - trShow);

                    // hide
                    float stepsHide = floor(1.0 + seed * 2.0);
                    float trHide = 1.0 - floor(hide * (stepsHide + 1.0)) / (stepsHide + 1.0);
                    pos -= centr;
                    pos *= trHide;
                    pos += centr;
                }

                // wiggle
                float steppedTime = floor(time * 1.6 * mix(fract(seed), 0.8, 1.0) + seed * 15.3423) / 7.0;
                vec2 offset = (hash23(centr + vec3(steppedTime, 0.0, 0.0)) * 2.0 - 1.0) * 0.0025;
                pos.xy += offset;

                // offset text to center it
                pos.x -= uSize.x * 0.5;
                pos.y -= 0.055; // compensate for pointer
                pos.y += uSize.y + uMargins.y; // compensate for font size and bottom margin

                gl_Position = projectionMatrix * viewMatrix * billboardModelMatrix() * vec4(pos, 1.0);
                vHighPrecisionZW = gl_Position.zw;
            }
        `, fragmentShader: `
            layout(location = 1) out highp vec4 gInfo;

            uniform sampler2D tCurve;
            uniform usampler2D tBand;

            ${slugfs_default}
            ${globalUBO_default}

            varying vec2 vHighPrecisionZW;
            flat varying vec3 vCentr;

            void main() {
                vec2 uv = vTexCoord;
                vec4 color = RenderSlug(tCurve, tBand, uv, vColor, vBanding, vGlyph);

                gl_FragColor = vec4(color.xyz, color.w * vColor.w);

                gInfo = vec4(1.0 - (0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5), vec3(0.0));
            }
        `, transparent: !0, depthWrite: !0, blending: CustomBlending, blendSrc: SrcAlphaFactor, blendSrcAlpha: ZeroFactor, blendDstAlpha: OneFactor
    }); return ({ bandTexture: e = null, curveTexture: i = null } = {}) => (r.uniforms.tBand.value = e, r.uniforms.tCurve.value = i, r)
} var parabolas_default = `float parabola(float x, float k) {
    return pow(4.0 * x * (1.0 - x), k);
}

float pcurve(float x, float a, float b) {
    float k = pow(a + b, a + b) / (pow(a, a) * pow(b, b));
    return k * pow(x, a) * pow(1.0 - x, b);
}`; function createIconMaterial(r) {
    return new ShaderMaterial({
        userData: { hotReload: "npc-icon" }, uniformsGroups: [global$1.UBO], uniforms: { uColor1: { value: new Color }, uColor2: { value: new Color }, tBand: { value: null }, tCurve: { value: null }, uShowDistance: { value: 1 }, uScale: { value: 1 }, uShow: { value: 1 }, uPulse: { value: 0 }, uActive: { value: r === "active" ? 1 : 0 }, uWiggleDir: { value: new Vector3(0, 1, 0) }, uRand: { value: Math.random() } }, vertexShader: `
            ${globalUBO_default}
            ${matrixutils_default}
            ${slugvs_default}

            varying vec2 vUv;
            varying vec3 vLocalPos;
            varying vec2 vHighPrecisionZW;

            uniform float uShowDistance;
            uniform float uScale;
            uniform float uShow;
            uniform float uPulse;
            uniform vec3 uWiggleDir;

            void main() {
                vUv = uv;

                vec3 pos = SlugVS();
                vLocalPos = pos;
                vec3 wPos = (modelMatrix * vec4(pos, 1.0)).xyz;

                float scale = smoothstep(uShowDistance, uShowDistance * 0.8, distance(wPos, cameraPosition)) * uScale * uShow;
                scale = mix(scale, scale * 1.2, uPulse);

                pos *= scale;
                pos += uWiggleDir * (0.05 + 0.05 * sin(time * 4.0));

                gl_Position = projectionMatrix * viewMatrix * billboardModelMatrix() * vec4(pos, 1.0);
                vHighPrecisionZW = gl_Position.zw;
            }
        `, fragmentShader: `
            layout(location = 1) out highp vec4 gInfo;

            ${slugfs_default}
            ${sinenoise_default}
            ${globalUBO_default}
            ${parabolas_default}
            ${fit_default}

            varying vec2 vUv;
            varying vec3 vLocalPos;
            varying vec2 vHighPrecisionZW;

            uniform sampler2D tCurve;
            uniform usampler2D tBand;
            uniform vec3 uColor1;
            uniform vec3 uColor2;
            uniform float uRand;

            uniform int uActive;

            void main() {
                vec4 color = RenderSlug(tCurve, tBand, vTexCoord, vColor, vBanding, vGlyph);
                if (color.w * vColor.w < 0.001) discard;

                float onlineContribution = 1.0;
                float rand = uRand;

                if (uActive == 1) {
                    // draw the 3 dots
                    vec2 uv = vUv;

                    uv -= 0.5;
                    uv *= vec2(1.217, 1.0); // fix aspect

                    // add noise in the outline only if active
                    float noise = sinenoise1(vec3(vLocalPos.xy * 15.0 + uRand * vec2(2.43, 4.453), uRand * 15.342));
                    onlineContribution = step(-0.3, noise);

                    // dots
                    const float offsetDist = 0.285;
                    const vec2 offsets[3] = vec2[3](vec2(0.0, 0.0), vec2(-offsetDist, 0.0), vec2(offsetDist, 0.0));
                    vec2 offset;
                    vec2 pos1;
                    float dist1;
                    float cut1;
                    #pragma unroll_loop_start
                    for (int i = 0; i < 3; i++) {
                        offset = offsets[i];
                        pos1 = uv + offset;
                        pos1.y -= parabola(fit(fract(time * 0.5 + uRand + offset.x * 0.15), 0.7, 1.0, 0.0, 1.0), 3.0) * 0.15;
                        dist1 = length(pos1);
                        cut1 = step(0.085, dist1);
                        color.rgb = mix(uColor2, color.rgb, cut1);
                        rand = mix(fract(rand + 2.4235), rand, cut1);
                        onlineContribution = mix(1.0, onlineContribution, cut1);
                    }
                    #pragma unroll_loop_end
                }

                gl_FragColor = vec4(color.rgb, rand);
                gInfo = vec4(1.0 - (0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5), vec2(0.0), onlineContribution);
            }
        `})
} class npc { constructor(e, i = {}) { var s, a; this.scene = e, this.ready = miscutils.deferred(), this.options = { id: `${math.uid()}`, modelURL: null, bonesURL: null, animations: [], curve: null, curveSpeed: 1, curveProgress: 0, curveSpeedAnimationWeight: 1, alwaysFaceCharacter: !0, talkEnabled: !0, talkFacingPlayer: !0, talkDistance: 2.5, position: [0, 0, 0], rotation: [0, 0, 0], visibilityThreshold: 30, texts: ["privet", "how are you?"], textsBubbles: !0, textsBubblesOffset: [0, 0, 0], textsBubblesOptions: { bubbleMaterialGenerator: bubbleMaterialGenerator(), textMaterialGenerator: textMaterialGenerator(), textMaterialGeneratorArgs: {}, textOptions: { font: "UglyDave-Alternates-optimized.font", size: .12, color: "#1f1f1f", align: "left", width: 1.25, letterSpacing: -.02, lineHeight: 1 }, marginX: .125, marginY: .09 }, textsRepeatLast: !0, textsReset: !0, textsAutoClose: !0, textsSpeed: 35, textsCloseTime: .3, clickInteraction: !0, hoverCursor: !0, hitboxOffset: .2, icon: !1, iconFiles: ["ui/npc-icons/inactive.icon", "ui/npc-icons/active.icon"], iconOptions: { sizeActive: .28, sizeInactive: .12, color2: ((s = i.extraData) == null ? void 0 : s.color) || "#75B9B5", colorHighlight: ((a = i.extraData) == null ? void 0 : a.color) || "#75B9B5", materialGenerator: createIconMaterial }, iconOffset: [0, .1, 0], extraData: { name: "Neznakomets" }, lookatOffset: [0, 0, 0], ...i }, this.options.talkEnabled || (this.options.talkFacingPlayer = !1, this.options.alwaysFaceCharacter = !1, this.options.texts = [""], this.options.textsBubbles = !1, this.options.clickInteraction = !1), this.init() } async init() { const [e, i, s, a, o] = await Promise.all([geometryLoader.skin(this.options.modelURL, this.options.bonesURL), Promise.all(this.options.animations.map(h => geometryLoader.skinAnimation(h))), this.options.curve ? geometryLoader.curves(this.options.curve) : null, glyphLoader.loadTexture(this.options.textsBubblesOptions.textOptions.font, "curve"), glyphLoader.loadTexture(this.options.textsBubblesOptions.textOptions.font, "band")]); this.options.textsBubblesOptions.textMaterialGeneratorArgs.curveTexture = a, this.options.textsBubblesOptions.textMaterialGeneratorArgs.bandTexture = o; const l = baseMaterial({ isNPC: !0, NPC_DISTANCE: this.options.visibilityThreshold }); this.mesh = new NPC({ id: this.options.id, skin: e, material: l, scene: this.scene, talkEnabled: this.options.talkEnabled, talkDistance: this.options.talkDistance, talkFacingPlayer: this.options.talkFacingPlayer, animations: i, animationsOptions: this.options.animationsOptions, curve: s || null, curveSpeed: this.options.curveSpeed, curveProgress: this.options.curveProgress, curveSpeedAnimationWeight: this.options.curveSpeedAnimationWeight, visibilityThreshold: this.options.visibilityThreshold, textsBubbles: this.options.textsBubbles, textsBubblesOffset: this.options.textsBubblesOffset, textsBubblesOptions: this.options.textsBubblesOptions, texts: this.options.texts.map(h => h.toUpperCase()), textsRepeatLast: this.options.textsRepeatLast, textsReset: this.options.textsReset, textsAutoClose: this.options.textsAutoClose, textsSpeed: this.options.textsSpeed, textsCloseTime: this.options.textsCloseTime, alwaysFaceCharacter: this.options.alwaysFaceCharacter, clickInteraction: this.options.clickInteraction, clickInteractionCamera: this.scene.camera, hoverCursor: this.options.hoverCursor, hitboxOffset: this.options.hitboxOffset, extraData: this.options.extraData, icon: this.options.icon, iconFiles: this.options.iconFiles, iconOptions: { ...this.options.iconOptions, offset: this.options.iconOffset } }), this.mesh.position.fromArray(this.options.position), this.mesh.rotation.fromArray(this.options.rotation), this.mesh.castShadow = !0, this.mesh.receiveShadow = !0, this.mesh.__wrapper = this; const c = () => { this.mesh.up.copy(this.mesh.position).normalize() }; c(), this.scene.beforeRenderCbs.push(c), this.enableBubbles(), events.on("npc_talk_update", this.talkUpdate, this), this.scene.add(this.mesh), await this.mesh.ready, this.ready.resolve() } enableBubbles() { this.mesh && (this.mesh._textsBubbles && this.mesh.enableBubbles(), this.mesh._clickInteraction && this.mesh.disableClickInteraction(), this.mesh._forceCloseDialog(this.mesh._id), this.mesh._textsAutoClose = !0, this.mesh._textsReset = !0, this.mesh._talkingDone = !0, this.scene.characters.mesh.interactingElement === this.mesh && (this.scene.characters.mesh.interactingElement = null, this.scene.characters.unlockCamera()), this.mesh._textsSpeed = 1 / 15, this.mesh._textsCloseTime = .4, this.mesh._icon && (this.mesh._icon._active = !1)) } disableBubbles() { this.mesh && (this.mesh._textsBubbles && this.mesh.disableBubbles(), this.mesh._clickInteraction && this.mesh.enableClickInteraction(), this.mesh._forceCloseDialog(this.mesh._id), this.mesh._textsAutoClose = !1, this.mesh._textsReset = !1, this.mesh._talkingDone = !0, this.mesh._textsSpeed = 1 / 35, this.mesh._textsCloseTime = .3, this.mesh._icon && (this.mesh._icon._active = !0)) } talkUpdate({ id: e, talking: i }) { this.mesh._id === e && (this.mesh.material.uniforms.uIsTalking.value = i ? 1 : 0) } } const _q0 = new Quaternion, _q1 = new Quaternion, _v0$5 = new Vector3; class sky {
    constructor(e, i = {}) { this.scene = e, this.options = i, this.lastRotation = new Quaternion, this.currentRotation = new Quaternion().setFromAxisAngle(_v0$5.set(0, 0, 1), Math.PI * .5), this.PARALLAX_AMOUNT = .9, this.ready = new Promise(s => { this.isReady = s }), this.init() } init() {
        this.mesh = new Mesh(new SphereGeometry(55, 32, 32), new ShaderMaterial({
            userData: { hotReload: "sky" }, uniformsGroups: [global$1.UBO], uniforms: { uColor1: { value: new Color("#75bdc3") }, uColor2: { value: new Color("#9fe2e0") }, uColor3: { value: new Color("#b9ebea") }, tCloudNoise: { value: textureLoader.load("clouds_noise_512.ktx2", "srgb-repeat") } }, vertexShader: `
                varying vec2 vHighPrecisionZW;
                varying vec2 vUv;
                void main() {
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    vHighPrecisionZW = gl_Position.zw;
                    vUv = uv;
                }
            `, fragmentShader: `
                ${globalUBO_default}

                layout(location = 1) out highp vec4 gInfo;

                varying vec2 vHighPrecisionZW;
                varying vec2 vUv;
                uniform sampler2D tCloudNoise;
                uniform vec3 uColor1;
                uniform vec3 uColor2;
                uniform vec3 uColor3;

                void main() {
                    vec2 screenUv = gl_FragCoord.xy / resolution;

                    float t = time * 0.0005;

                    vec2 uv = vUv * 1.0;

                    // main cloud shape
                    float noise = texture2D(tCloudNoise, uv * vec2(1.0, 2.0) + vec2(t)).r;
                    noise *= texture2D(tCloudNoise, uv * vec2(1.0, 2.0)).r;

                    // hide weirdness at poles
                    noise *= smoothstep(0.1, 0.2, 1.0 - abs(vUv.y - 0.5) * 2.0);

                    // if (noise < 0.15) discard;

                    float blend = step(0.27, noise);
                    float id = mix(0.01, 1.0, blend);
                    vec3 cloudColor = mix(uColor3, uColor2, screenUv.y);
                    vec3 color = mix(uColor1, cloudColor, blend);

                    gl_FragColor = vec4(color, id);
                    gInfo = vec4(1.0 - (0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5), vec2(0.0), 1.0);
                }
            `, side: BackSide
        })), this.mesh.name = "sky", this.mesh.rotation.x = 1, this.scene.add(this.mesh), this.isReady()
    } update() { const e = this.scene.characters.mesh._localObject; _q0.copy(e.quaternion).premultiply(_q1.setFromAxisAngle(e.up, Math.PI - e.rotationHorizontal)), this.mesh.quaternion.copy(_q0), _q1.copy(_q0).invert().multiply(this.lastRotation), this.lastRotation.copy(_q0), _q0.copy(this.currentRotation).premultiply(_q1), this.currentRotation.slerp(_q0, this.PARALLAX_AMOUNT), this.mesh.quaternion.multiply(this.currentRotation) }
} var bicubic_default = `float w0(float a) { return (1.0 / 6.0) * (a * (a * (-a + 3.0) - 3.0) + 1.0); }
float w1(float a) { return (1.0 / 6.0) * (a * a * (3.0 * a - 6.0) + 4.0); }
float w2(float a) { return (1.0 / 6.0) * (a * (a * (-3.0 * a + 3.0) + 3.0) + 1.0); }
float w3(float a) { return (1.0 / 6.0) * (a * a * a); }
float g0(float a) { return w0(a) + w1(a); }
float g1(float a) { return w2(a) + w3(a); }
float h0(float a) { return -1.0 + w1(a) / (w0(a) + w1(a)); }
float h1(float a) { return 1.0 + w3(a) / (w2(a) + w3(a)); }

vec4 bicubic(sampler2D tex, vec2 uv, vec4 texelSize) {
	uv = uv * texelSize.zw + 0.5;
	vec2 iuv = floor(uv);
	vec2 fuv = fract(uv);
    float g0x = g0(fuv.x);
    float g1x = g1(fuv.x);
    float h0x = h0(fuv.x);
    float h1x = h1(fuv.x);
    float h0y = h0(fuv.y);
    float h1y = h1(fuv.y);
	vec2 p0 = (vec2(iuv.x + h0x, iuv.y + h0y) - 0.5) * texelSize.xy;
	vec2 p1 = (vec2(iuv.x + h1x, iuv.y + h0y) - 0.5) * texelSize.xy;
	vec2 p2 = (vec2(iuv.x + h0x, iuv.y + h1y) - 0.5) * texelSize.xy;
	vec2 p3 = (vec2(iuv.x + h1x, iuv.y + h1y) - 0.5) * texelSize.xy;

    return g0(fuv.y) * (g0x * texture(tex, p0) + g1x * texture(tex, p1)) +
           g1(fuv.y) * (g0x * texture(tex, p2) + g1x * texture(tex, p3));
}

vec4 bicubic(sampler2D tex, vec2 uv, vec4 texelSize, float lod) {
	uv = uv * texelSize.zw + 0.5;
	vec2 iuv = floor(uv);
    vec2 fuv = fract(uv);
    float g0x = g0(fuv.x);
    float g1x = g1(fuv.x);
    float h0x = h0(fuv.x);
    float h1x = h1(fuv.x);
    float h0y = h0(fuv.y);
    float h1y = h1(fuv.y);
    vec2 p0 = (vec2(iuv.x + h0x, iuv.y + h0y) - 0.5) * texelSize.xy;
    vec2 p1 = (vec2(iuv.x + h1x, iuv.y + h0y) - 0.5) * texelSize.xy;
    vec2 p2 = (vec2(iuv.x + h0x, iuv.y + h1y) - 0.5) * texelSize.xy;
    vec2 p3 = (vec2(iuv.x + h1x, iuv.y + h1y) - 0.5) * texelSize.xy;
	return g0(fuv.y) * (g0x * textureLod(tex, p0, lod) + g1x * textureLod(tex, p1, lod)) +
		   g1(fuv.y) * (g0x * textureLod(tex, p2, lod) + g1x * textureLod(tex, p3, lod));
}

vec4 textureBicubic(sampler2D map, vec2 uv) {
	vec2 fullSize = vec2(textureSize(map, 0));
    vec2 fullSizeInv = 1.0 / fullSize;
	return bicubic(map, uv, vec4(fullSizeInv, fullSize));
}

vec4 textureBicubic(sampler2D map, vec2 uv, float lod) {
	vec2 fLodSize = vec2(textureSize(map, int(lod)));
	vec2 cLodSize = vec2(textureSize(map, int(lod + 1.0)));
	vec2 fLodSizeInv = 1.0 / fLodSize;
	vec2 cLodSizeInv = 1.0 / cLodSize;
	vec4 fSample = bicubic(map, uv, vec4(fLodSizeInv, fLodSize), floor(lod));
	vec4 cSample = bicubic(map, uv, vec4(cLodSizeInv, cLodSize), ceil(lod));
	return mix(fSample, cSample, fract(lod));
}`; const _v0$4 = new Vector3, _v1$3 = new Vector3, _s$3 = new Sphere, DOT_THRESHOLD = .4; class water {
    constructor(e, i = {}) { this.scene = e, this.options = i, this.ready = new Promise(s => { this.isReady = s }), this.init() } async init() {
        const e = await geometryLoader.batched("planets/present/water.drc"), i = e.length, s = e.reduce((o, l) => o + l.attributes.position.count, 0), a = e.reduce((o, l) => o + l.index.count, 0); this.mesh = new BatchedMesh(i, s, a, new ShaderMaterial({
            name: "water", userData: { hotReload: "water" }, uniformsGroups: [global$1.UBO], uniforms: { uColor1: { value: new Color("#4c868c") }, uColor2: { value: new Color("#437a7f") }, uColorWaves1: { value: new Color("#366a6f") }, uColorWaves2: { value: new Color("#6facb2") }, uDepthRange: { value: new Vector2(.001, .013) }, tNoise: { value: textureLoader.load("water-noises-highq.ktx2", "linearfilter-repeat") }, uCameraNear: { value: this.scene.camera.near }, uCameraFar: { value: this.scene.camera.far }, uProjMat: { value: new Matrix4 }, uWorldMat: { value: new Matrix4 }, tScene: { value: null }, tSceneInfo: { value: null }, ...fogUniforms }, vertexShader: `
                varying vec4 vMvPos;
                varying vec2 vHighPrecisionZW;
                varying vec2 vUv;

                void main() {
                    vMvPos = modelViewMatrix * vec4(position, 1.0);
                    vUv = uv;

                    gl_Position = projectionMatrix * vMvPos;
                    vHighPrecisionZW = gl_Position.zw;
                }
            `, fragmentShader: `
                varying vec4 vMvPos;
                varying vec2 vHighPrecisionZW;
                varying vec2 vUv;

                uniform vec3 uColor1;
                uniform vec3 uColor2;
                uniform vec3 uColorWaves1;
                uniform vec3 uColorWaves2;
                uniform vec2 uDepthRange;

                uniform sampler2D tNoise;

                uniform mat4 uProjMat;
                uniform mat4 uWorldMat;

                uniform sampler2D tScene;
                uniform sampler2D tSceneInfo;

                uniform float uCameraNear;
                uniform float uCameraFar;

                ${globalUBO_default}
                ${fit_default}
                ${depth_default}
                ${bicubic_default}
                ${parabolas_default}
                ${sinenoise_default}
                ${eases_default}
                ${fog_default}

                void main() {
                    // calc positions in world space
                    vec2 uv = gl_FragCoord.xy / resolution.xy;

                    vec2 meshUV = vUv * 1.25;

                    // get depths. sample bicubic on scene info to get a more defined depth
                    float sceneDepth = 1.0 - textureBicubic(tSceneInfo, uv).r;
                    float waterSurfaceDepth = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;

                    // calculate height and depth differences
                    vec3 sceneViewPos = getViewPosition(sceneDepth, uv, uCameraNear, uCameraFar, uProjMat);
                    vec3 sceneWorldPos = (uWorldMat * vec4(sceneViewPos, 1.0)).xyz;
                    float sceneDist = length(sceneViewPos);
                    float sceneHeight = length(sceneWorldPos);
                    vec3 waterViewPos = getViewPosition(waterSurfaceDepth, uv, uCameraNear, uCameraFar, uProjMat);
                    vec3 waterWorldPos = (uWorldMat * vec4(waterViewPos, 1.0)).xyz;
                    float waterDist = length(waterViewPos);
                    float waterHeight = length(waterWorldPos);

                    float viewDistDiff = sceneDist - waterDist;
                    float worldHeightDiff = waterHeight - sceneHeight;

                    float depthGradient = fit(viewDistDiff, 0.0, 2.5, 0.0, 1.0);

                    float timeOffset = sinenoise1(vec3(meshUV * 50.0, 0.0)) * 0.5 + 0.5;

                    // calculate foam
                    float foam = 0.0;
                    float foamMargin = fit(worldHeightDiff, 0.0, 0.3, 1.0, 0.0);
                    if (foamMargin > 0.0) {

                        // bands
                        float foamBands = foamMargin * 4.0 - time * 0.35 + timeOffset * 2.0;
                        foam = parabola(fract(foamBands), 5.0);

                        // add shapes
                        float foamNoise = texture2D(tNoise, meshUV * 15.0 - (time + floor(foamBands) * 50.342) * 0.001).r;
                        foam *= foamMargin * foamNoise;

                        // set threshold
                        foam = step(0.42, foam);

                        // limit it to places where the depth is visible
                        float foamVisibility = fit(viewDistDiff, 0.0, 1.0, 0.0, 1.0);
                        foam *= 1.0 - step(0.99, pow(foamVisibility, 2.0));
                    }

                    float seaTime = time + timeOffset * 10.0;

                    // calculate water color
                    vec2 offsetSea1 = vec2(cos(seaTime * 1.0 + 3.432), sin(seaTime * 2.0 + 3.234)) * 0.01;
                    float noiseSea1 = texture2D(tNoise, meshUV * 8.0 - seaTime * 0.01 + offsetSea1).r;
                    vec2 offsetSea2 = vec2(sin(seaTime * 1.5 + 6.54353), cos(seaTime * 0.5 + 43.342)) * 0.0085;
                    float noiseSea2 = texture2D(tNoise, meshUV * 10.0 + 34.54 + seaTime * 0.015 + offsetSea2).r;
                    float noiseSea = noiseSea1 * noiseSea2;

                    float wavesN = step(0.1, pow(noiseSea, 2.0));
                    vec3 seaColor = mix(uColorWaves1, uColor2, wavesN);

                    vec2 offsetSea3 = vec2(sin(seaTime * 2.0 + 12.435), cos(seaTime * 2.75 + 34.3)) * 0.011;
                    float noiseSea3 = texture2D(tNoise, meshUV * 20.0 - seaTime * 0.01 + offsetSea3 - 3.525).r;
                    vec2 offsetSea4 = vec2(cos(seaTime * 1.25 + 3.345), sin(seaTime * 2.5 + 97.798)) * 0.0095;
                    float noiseSea4 = texture2D(tNoise, meshUV * 10.0 + 4.5434 + seaTime * 0.02 + offsetSea4 + 2.34).r;
                    float additionaNoiseSea = noiseSea3 * noiseSea4;

                    float wavesN2 = step(0.45, additionaNoiseSea);
                    seaColor = mix(seaColor, uColorWaves2, wavesN2);

                    // shore water color
                    float colorShore = max(fit(worldHeightDiff, 0.0, 0.15, 0.0, 1.0), depthGradient);
                    vec3 colorWater = mix(uColor1, seaColor, colorShore);

                    // add scene color
                    float gradientScene = 1.0 - max(fit(worldHeightDiff, 0.0, 0.75, 0.0, 1.0), depthGradient);
                    colorWater = mix(colorWater, uColorWaves2, gradientScene * 0.1);

                    // add foam
                    colorWater = mix(colorWater, vec3(1.0), foam);

                    addFog(colorWater, vMvPos.z);

                    gl_FragColor = vec4(colorWater, 1.0 - waterSurfaceDepth);
                }
            `})), this.mesh.name = "water", this.mesh.sortObjects = !1, this.mesh.receiveShadow = !1, this.mesh.castShadow = !1, this.mesh.frustumCulled = !0, this.mesh.perObjectFrustumCulled = !0, e.forEach((o, l) => { this.mesh.addInstance(this.mesh.addGeometry(o)) }), this.scene.beforeRenderCbs.push(this.update.bind(this)), this.isReady()
    } update() { var e; if (this.mesh.material.uniforms.uProjMat.value.copy(this.scene.camera.projectionMatrix), this.mesh.material.uniforms.uWorldMat.value.copy(this.scene.camera.matrixWorld), !!((e = this.scene.characters) != null && e.mesh)) { for (let i = 0; i < this.mesh._instanceInfo.length; i++) { this.mesh.getBoundingSphereAt(i, _s$3); const a = this.scene.characters.mesh._localObject.position; _v0$4.copy(_s$3.center).normalize(), _v1$3.copy(a).normalize(); const o = _v0$4.dot(_v1$3); this.mesh._instanceInfo[i].visible = o > DOT_THRESHOLD } this.mesh._visibilityChanged = !0 } }
} class waterfallvfx {
    constructor(e, i = {}) { this.scene = e, this.options = i, this.ready = new Promise(s => { this.isReady = s }), this.init() } async init() {
        const e = await geometryLoader.load("./planets/present/waterfall_vfx.drc"), i = await geometryLoader.load("./planets/present/waterfallsplash_vfx.drc"), s = await geometryLoader.load("./planets/present/waterfall_inlet_vfx.drc"); this.mesh = new PlanetMesh(e, new ShaderMaterial({
            userData: { hotReload: "waterfallvfx" }, uniformsGroups: [global$1.UBO], uniforms: { uColor1: { value: new Color("#66acb2") }, uColor2: { value: new Color("#216c72") }, uColor3: { value: new Color("#afe7eb") }, tNoise: { value: textureLoader.load("water-noises-highq.ktx2", "linearfilter-repeat") }, tNoise2: { value: textureLoader.load("noise-simplex-layered-blur-highq.ktx2", "linearfilter-repeat") }, tNoise3: { value: textureLoader.load("clouds_noise_512.ktx2", "linearfilter-repeat") }, ...fogUniforms }, vertexShader: `
                ${globalUBO_default}

                attribute float scalefactor;

                varying vec2 vHighPrecisionZW;
                varying vec2 vUv;
                varying vec2 vUv2;
                varying float vScaleFactor;
                varying vec3 vLocalPos;
                varying vec4 vPos;

                uniform sampler2D tNoise;

                void main() {
                    vLocalPos = position;

                    // vec2 displacementUv = uv;
                    // displacementUv.y *= 0.08;
                    // displacementUv * vec2(1.0, 0.5 + displacementUv.y * 0.5);
                    // displacementUv.y += time * 0.085;

                    // float n1 = texture2D(tNoise, displacementUv).r;

                    // float grad = 1.0 - abs(n1 - 0.5) * 2.0;
                    // grad = step(0.95, grad);

                    // vec3 pos = position + normal * grad * 0.03 * (1.0 - scalefactor * 1.75);
                    vec3 pos = position;

                    vPos = modelViewMatrix * vec4(pos, 1.0);

                    gl_Position = projectionMatrix * vPos;
                    vHighPrecisionZW = gl_Position.zw;
                    vUv = uv;
                    vUv2 = uv;
                    vScaleFactor = scalefactor;
                }
            `, fragmentShader: `
                ${globalUBO_default}
                ${aastep_default}
                ${fog_default}

                varying vec2 vHighPrecisionZW;
                varying vec2 vUv;
                varying vec2 vUv2;
                varying float vScaleFactor;
                varying vec3 vLocalPos;
                varying vec4 vPos;

                uniform sampler2D tNoise;
                uniform sampler2D tNoise2;
                uniform sampler2D tNoise3;
                uniform vec3 uColor1;
                uniform vec3 uColor2;
                uniform vec3 uColor3;

                void main() {

                    vec3 off = vLocalPos * 0.025;

                    vec2 uv = vUv;
                    uv.y *= 0.08;

                    uv.y += time * 0.06;

                    float n1 = texture2D(tNoise, vec2(uv.x * (0.5 - vScaleFactor * 0.3) + time * 0.01, uv.y + vScaleFactor * 0.25)).r; // foam
                    float n2 = texture2D(tNoise2, vUv * vec2(0.5, 0.1) + vec2(off.x, time * 0.07)).g;
                    n2 -= texture2D(tNoise2, vUv * vec2(2.0 - vScaleFactor * 2.0, 0.15) + vec2(off.z, time * 0.051)).g;
                    float n3 = texture2D(tNoise2, vUv * vec2(0.5, 0.5 + vUv.y * 0.25) + vec2(-off.x, time * 0.5)).r;

                    float n4 = 1.0 - texture2D(tNoise3, vUv * vec2(0.5, 0.5) - vec2(time * 0.02 - off.z, time * 0.125)).r;
                    n4 = 1.0 - pow(1.0 - n4, 2.0);

                    float edgegrad = 1.0 - abs(vUv.x - 0.5) * 2.0;
                    edgegrad -= n3 * 0.2;

                    float edgemask = 1.0 - aastep(0.125 + vScaleFactor * 0.25, edgegrad);

                    // streaks
                    float streaks = 1.0 - abs(n1 - 0.5) * 2.0;
                    streaks = streaks * streaks * streaks;
                    streaks = aastep(0.8, streaks);

                    // foam near ground
                    float foam = vUv.y - n4 * 0.04;
                    float foammask = 1.0 - step(0.002, foam);

                    if (edgegrad < 0.05) discard;

                    // stylized specular shine
                    float shine1 = 1.0 - clamp(abs(vUv.y - 0.6) * 4.0, 0.0, 1.0);
                    shine1 = 1.0 - pow(1.0 - shine1, 2.0);
                    shine1 -= n2 * 0.06;
                    shine1 = aastep(0.99, shine1);

                    // another specular shine
                    float shine2 = 1.0 - clamp(abs(vUv.y - 0.3) * 4.0, 0.0, 1.0);
                    shine2 = 1.0 - pow(1.0 - shine2, 2.0);
                    shine2 -= n2 * 0.2;
                    shine2 = aastep(0.95, shine2 - 0.05);

                    // darker color near base of waterfall
                    float shadow = vUv.y - n2 * 0.25;
                    shadow = 1.0 - aastep(0.175, shadow);

                    // composite all effects together
                    vec3 color = uColor1;
                    color = mix(color, uColor3, max(shine1, shine2));
                    color = mix(color, uColor2, shadow);
                    color = mix(color, vec3(1.0), max(streaks, edgemask));
                    color = mix(color, vec3(1.0), foammask);

                    addFog(color, vPos.z);

                    gl_FragColor = vec4(color, 1.0 - (0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5));
                }
            `, side: DoubleSide
        }), this.scene, 25), this.mesh.name = "waterfallvfx", this.mesh.updateMatrixWorld(), this.mesh.matrixAutoUpdate = !1, this.mesh.matrixWorldAutoUpdate = !1, this.scene.add(this.mesh), this.mesh2 = new PlanetMesh(i, new ShaderMaterial({
            userData: { hotReload: "waterfallsplashvfx" }, uniformsGroups: [global$1.UBO], uniforms: { uColor1: { value: new Color("#75bdc3") }, uColor2: { value: new Color("#468c92") }, uColor3: { value: new Color("#afe7eb") }, tNoise: { value: textureLoader.load("water-noises-highq.ktx2", "linearfilter-repeat") }, tNoise2: { value: textureLoader.load("noise-simplex-layered-pixellated-highq.ktx2", "linearfilter-repeat") }, tNoise3: { value: textureLoader.load("clouds_noise_512.ktx2", "linearfilter-repeat") }, ...fogUniforms }, vertexShader: `
                ${globalUBO_default}

                varying vec2 vHighPrecisionZW;
                varying vec2 vUv;
                varying vec4 vPos;

                void main() {
                    vPos = modelViewMatrix * vec4(position, 1.0);

                    gl_Position = projectionMatrix * vPos;
                    vHighPrecisionZW = gl_Position.zw;
                    vUv = uv;
                }
            `, fragmentShader: `
                ${globalUBO_default}
                ${aastep_default}
                ${fog_default}

                varying vec2 vHighPrecisionZW;
                varying vec2 vUv;
                varying vec4 vPos;

                uniform sampler2D tNoise;
                uniform sampler2D tNoise2;
                uniform sampler2D tNoise3;
                uniform vec3 uColor1;
                uniform vec3 uColor2;
                uniform vec3 uColor3;

                void main() {

                    vec2 uv = vUv * vec2(1.0, 5.0);
                    uv.x = pow(uv.x, 2.0);

                    // animated texture
                    float mask1 = texture2D(tNoise, uv + vec2(-time * 0.2, 0.0)).r;

                    // concentric rings that animate outwards
                    float concentric = sin(uv.x * 25.0 - time * 5.0) * 0.5 + 0.5;

                    // foam pattern that animates outwards
                    float foam = mask1 * 0.65;
                    foam += 0.3 * (pow(concentric, 20.0));
                    foam += pow(1.0 - vUv.x, 3.0);
                    foam *= 1.0 - pow(smoothstep(0.2, 1.0, vUv.x), 3.0);

                    float alpha = step(0.5, foam);
                    if (alpha < 0.5) discard;

                    vec3 color = vec3(1.0);
                    addFog(color, vPos.z);

                    gl_FragColor = vec4(color, 1.0 - (0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5));
                }
            `}), this.scene, 25), this.mesh2.name = "waterfallsplashvfx", this.mesh2.updateMatrixWorld(), this.mesh2.matrixAutoUpdate = !1, this.mesh2.matrixWorldAutoUpdate = !1, this.scene.add(this.mesh2), this.mesh3 = new PlanetMesh(s, new ShaderMaterial({
                userData: { hotReload: "waterfallinletvfx" }, uniformsGroups: [global$1.UBO], uniforms: { uColor1: { value: new Color("#62acb2") }, uColor2: { value: new Color("#468c92") }, uColor3: { value: new Color("#afe7eb") }, tNoise: { value: textureLoader.load("water-noises-highq.ktx2", "linearfilter-repeat") }, tNoise2: { value: textureLoader.load("noise-simplex-layered-pixellated-highq.ktx2", "linearfilter-repeat") }, tNoise3: { value: textureLoader.load("clouds_noise_512.ktx2", "linearfilter-repeat") }, ...fogUniforms }, vertexShader: `
                ${globalUBO_default}

                attribute vec2 uv2;
                attribute float extrafoam;

                varying vec2 vHighPrecisionZW;
                varying vec2 vUv;
                varying vec2 vUv2;
                varying float vExtraFoam;
                varying vec4 vPos;

                void main() {
                    vPos = modelViewMatrix * vec4(position, 1.0);
                    gl_Position = projectionMatrix * vPos;
                    vHighPrecisionZW = gl_Position.zw;
                    vUv = uv;
                    vUv2 = uv2;
                    vExtraFoam = extrafoam;
                }
            `, fragmentShader: `
                ${globalUBO_default}
                ${aastep_default}
                ${fog_default}

                varying vec2 vHighPrecisionZW;
                varying vec2 vUv;
                varying vec2 vUv2;
                varying float vExtraFoam;
                varying vec4 vPos;

                uniform sampler2D tNoise;
                uniform sampler2D tNoise2;
                uniform sampler2D tNoise3;
                uniform vec3 uColor1;
                uniform vec3 uColor2;
                uniform vec3 uColor3;

                void main() {

                    // vec2 uv = vUv * vec2(1.0, 5.0);
                    // uv.x = pow(uv.x, 2.0);

                    float foam = texture2D(tNoise, vUv * vec2(0.5, 2.0) + vec2(0.5, time * 0.15)).r;
                    float foam2 = texture2D(tNoise, vUv * vec2(0.5, 2.0) * 2.0 + vec2(0.0, time * 0.13)).r;
                    float edges = smoothstep(0.3, 0.0, vUv.x) + smoothstep(0.8, 1.0, vUv.x);

                    // // concentric rings that animate outwards
                    // float concentric = sin(uv.x * 25.0 - time * 5.0) * 0.5 + 0.5;

                    // // foam pattern that animates outwards
                    // float foam = mask1 * 0.65;
                    // foam += 0.3 * (pow(concentric, 20.0));
                    // foam += pow(1.0 - vUv.x, 3.0);
                    // foam *= 1.0 - pow(smoothstep(0.2, 1.0, vUv.x), 3.0);

                    // float alpha = step(0.5, foam);
                    // if (alpha < 0.5) discard;

                    float value = max(foam, edges);
                    value = max(value, smoothstep(0.2, 0.0, vUv.y) - foam2 * 0.1 + vExtraFoam * foam2 * 1.5);
                    value = step(0.7, value);

                    // composite all effects together
                    vec3 color = uColor1;
                    color = mix(uColor1, uColor2, step(0.4, smoothstep(0.425, 0.6, vUv.y) - foam2 * 0.1));
                    color = mix(color, vec3(1.0), value);

                    float n2 = texture2D(tNoise2, vUv * vec2(0.55, 1.0) + vec2(0.0, time * 0.07)).g;
                    float alpha = smoothstep(0.0, 0.05, vUv.y) - foam2 * 0.4;
                    if (alpha < 0.05) discard;

                    addFog(color, vPos.z);

                    gl_FragColor = vec4(color, 1.0 - (0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5));
                }
            `}), this.scene, 25), this.mesh3.name = "waterfallinletvfx", this.mesh3.updateMatrixWorld(), this.mesh3.matrixAutoUpdate = !1, this.mesh3.matrixWorldAutoUpdate = !1, this.scene.add(this.mesh3), this.isReady()
    }
} class beachwavevfx {
    constructor(e, i = {}) { this.scene = e, this.options = i, this.ready = miscutils.deferred(), this.init() } async init() {
        const e = await geometryLoader.load("./planets/present/beachfoam_vfx.drc"); this.mesh = new PlanetMesh(e, new ShaderMaterial({
            userData: { hotReload: "beachfoamvfx" }, uniformsGroups: [global$1.UBO], uniforms: { uColor1: { value: new Color("#376b6f") }, uColor2: { value: new Color("#467d7f") }, uColor3: { value: new Color("#bcb1a4") }, uColorWaves2: { value: new Color("#6facb2") }, tNoise: { value: textureLoader.load("water-noises-highq.ktx2", "linearfilter-repeat") }, tNoise2: { value: textureLoader.load("noise-simplex-layered-blur-highq.ktx2", "linearfilter-repeat") }, tNoise3: { value: textureLoader.load("clouds_noise_512.ktx2", "linearfilter-repeat") }, tScene: { value: null }, tSceneInfo: { value: null }, uDepthRange: { value: new Vector2(.001, .013) }, uCameraNear: { value: this.scene.camera.near }, uCameraFar: { value: this.scene.camera.far }, uProjMat: { value: new Matrix4 }, uWorldMat: { value: new Matrix4 }, ...fogUniforms }, vertexShader: `
                ${globalUBO_default}

                varying vec2 vHighPrecisionZW;
                varying vec2 vUv;
                varying vec4 vPos;

                void main() {
                    vec3 pos = position;

                    // push closer to ground so you can't see under it
                    pos -= normal * 0.0175;

                    vPos =  modelViewMatrix * vec4(pos, 1.0);

                    gl_Position = projectionMatrix * vPos;
                    vHighPrecisionZW = gl_Position.zw;
                    vUv = uv;
                }
            `, fragmentShader: `
                ${globalUBO_default}
                ${fit_default}
                ${depth_default}
                ${bicubic_default}
                ${parabolas_default}
                ${sinenoise_default}
                ${eases_default}
                ${fog_default}

                varying vec2 vHighPrecisionZW;
                varying vec2 vUv;
                varying vec3 vLPos;
                varying vec4 vPos;

                uniform sampler2D tNoise;
                uniform sampler2D tNoise2;
                uniform sampler2D tNoise3;
                uniform vec3 uColor1;
                uniform vec3 uColor2;
                uniform vec3 uColor3;
                uniform vec3 uColorWaves2;

                uniform vec2 uDepthRange;

                uniform mat4 uProjMat;
                uniform mat4 uWorldMat;

                uniform sampler2D tScene;
                uniform sampler2D tSceneInfo;

                uniform float uCameraNear;
                uniform float uCameraFar;

                vec4 getWave(float t) {

                    float w1 = sin(t) * 0.5 + 0.5;
                    float w2 = sin(t + 3.14159) * 0.5 + 0.5;
                    float looptime = fract(t / 6.283 + 3.14159 * 5.0);

                    float n1 = 1.0 - texture2D(tNoise2, vUv * vec2(1.5, 2.5) + vec2(w1 * 1.0, - w1 * 0.1)).r;
                    float n2 = texture2D(tNoise, vUv * vec2(2.0, 4.0) + vec2(w1 * 1.0, -t * 0.24)).r;
                    float n3 = texture2D(tNoise, vUv * vec2(2.0, 2.0) + vec2(w1 * 0.1, -t * 0.065)).r;

                    float og1 = vUv.x + w1;
                    og1 += n1 * 0.2 - 0.1;
                    float base1 = fract(og1);
                    base1 *= 1.0 - step(1.0, og1);

                    float foamfront1 = smoothstep(0.9, 1.0, base1);
                    float foamwide1 = base1 * n2 * smoothstep(0.0, 0.5, base1);
                    float rearfade = smoothstep(0.0, 0.3, vUv.x);
                    foamwide1 *= rearfade;
                    foamfront1 *= rearfade;

                    float value = foamfront1 + foamwide1;
                    value *= smoothstep(1.0, 0.3, looptime);

                    float alpha = base1;

                    value = step(0.45, value);

                    vec4 color = vec4(mix(mix(uColor1, uColor2, step(0.7, n3)), vec3(1.0), value), alpha);

                    return color;
                }

                float getWetSand(float t) {

                    float wetsand_w1 = sin(t) * 0.5 + 0.5;
                    float wetsand_looptime = fract(t / 6.283 + 3.14159 * 5.0 + 0.018);

                    float wetsand_og1 = vUv.x + wetsand_w1;
                    float wetsand_n1 = 1.0 - texture2D(tNoise2, vUv * vec2(1.5, 2.5) + vec2(wetsand_w1 * 1.0, -wetsand_w1 * 0.1)).r;
                    wetsand_og1 += wetsand_n1 * 0.2 - 0.1;
                    float wetsand_base1 = fract(wetsand_og1);
                    wetsand_base1 *= 1.0 - step(0.99, wetsand_og1);
                    wetsand_base1 *= 1.0 - wetsand_looptime;

                    return wetsand_base1;
                }

                void main() {
                    float t = time * 0.66;

                    vec4 wave = getWave(t);
                    float wetsand = getWetSand(t - 0.3);

                    vec4 wave2 = getWave(t + 3.14159);
                    float wetsand2 = getWetSand(t + 3.14159 - 0.3);

                    wave = max(wave, wave2);
                    wetsand = max(wetsand, wetsand2);

                    float wetsandmask = step(0.01, wetsand) - step(0.01, wave.a);
                    wetsandmask = max(0.0, wetsandmask);

                    vec3 color = mix(wave.rgb, uColor3, wetsandmask);

                    if (wave.a + wetsandmask < 0.01) discard;

                    // calc positions in world space
                    vec2 screenUv = gl_FragCoord.xy / resolution.xy;

                    float sceneDepth = 1.0 - texture2D(tSceneInfo, screenUv).r;
                    float waterSurfaceDepth = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;

                    // calculate height and depth differences
                    vec3 sceneViewPos = getViewPosition(sceneDepth, screenUv, uCameraNear, uCameraFar, uProjMat);
                    vec3 sceneWorldPos = (uWorldMat * vec4(sceneViewPos, 1.0)).xyz;
                    float sceneDist = length(sceneViewPos);
                    float sceneHeight = length(sceneWorldPos);
                    vec3 waterViewPos = getViewPosition(waterSurfaceDepth, screenUv, uCameraNear, uCameraFar, uProjMat);
                    vec3 waterWorldPos = (uWorldMat * vec4(waterViewPos, 1.0)).xyz;
                    float waterDist = length(waterViewPos);
                    float waterHeight = length(waterWorldPos);

                    float viewDistDiff = sceneDist - waterDist;
                    float worldHeightDiff = waterHeight - sceneHeight;

                    float depthGradient = fit(viewDistDiff, 0.0, 2.5, 0.0, 1.0);

                    float outlinecontribution = 0.0;

                    // add scene color
                    float gradientScene = 1.0 - max(fit(worldHeightDiff, 0.0, 0.2, 0.0, 1.0), depthGradient);
                    float gradientSceneSmall = 1.0 - max(fit(worldHeightDiff, 0.0, 0.06, 0.0, 1.0), depthGradient);
                    color = mix(color, mix(color + color, color * color, wetsandmask), gradientScene * 0.5);
                    color = mix(color, mix(color + color, color * color, wetsandmask), pow(gradientSceneSmall, 5.0));
                    color = clamp(color, vec3(0.0), vec3(1.0));

                    // add character shadow
                    color = mix(color, color * (step(0.5, texture2D(tScene, screenUv).r) * 0.3 + 0.7), smoothstep(0.3, 0.65, vUv.x));

                    // float timeOffset = sinenoise1(vec3(vUv * 50.0, 0.0)) * 0.5 + 0.5;

                    // // calculate foam
                    // float foam = 0.0;
                    // float foamMargin = fit(worldHeightDiff, 0.0, 0.3, 1.0, 0.0);
                    // if (foamMargin > 0.0) {

                    //     // bands
                    //     float foamBands = foamMargin * 4.0 - time * 0.35 + timeOffset * 2.0;
                    //     foam = parabola(fract(foamBands), 5.0);

                    //     // add shapes
                    //     // float foamNoise = texture2D(tNoise, vUv * 15.0 - (time + floor(foamBands) * 50.342) * 0.001).r;
                    //     // foam *= foamMargin * foamNoise;
                    //     foam *= foamMargin;

                    //     // set threshold
                    //     foam = step(0.42, foam);

                    //     // limit it to places where the depth is visible
                    //     float foamVisibility = fit(viewDistDiff, 0.0, 1.0, 0.0, 1.0);
                    //     foam *= 1.0 - step(0.99, pow(foamVisibility, 2.0));
                    // }
                    // color = max(color, vec3(foam));

                    // add fog
                    addFog(color, vPos.z);


                    gl_FragColor = vec4(color, 1.0 - (0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5));
                }
            `}), this.scene), this.scene.beforeRenderCbs.push(() => { this.mesh.material.uniforms.uProjMat.value.copy(this.scene.camera.projectionMatrix), this.mesh.material.uniforms.uWorldMat.value.copy(this.scene.camera.matrixWorld) }), this.mesh.name = "beachwavevfx", this.scene.add(this.mesh), this.ready.resolve()
    }
} class smokevfx {
    constructor(e, i = {}) { this.scene = e, this.options = i, this.ready = miscutils.deferred(), this.init() } async init() {
        const e = await geometryLoader.load("planets/present/smoke-1.drc"), i = new ShaderMaterial({
            userData: { hotReload: "smoke" }, uniformsGroups: [global$1.UBO], uniforms: { tNoise: { value: textureLoader.load("clouds_noise_512.ktx2", "srgb-repeat") }, tNoise2: { value: textureLoader.load("water-noises-highq.ktx2", "srgb-repeat") }, uColor: { value: new Color("#565c5f") }, uWidth: { value: 1 }, ...fogUniforms }, vertexShader: `
                attribute float randomm;
                attribute float thickness;
                attribute vec3 nextpos;
                attribute vec3 prevpos;
                attribute vec3 curvepos;
                attribute vec2 uv2;

                ${globalUBO_default}
                ${fit_default}

                uniform float uWidth;
                uniform sampler2D tNoise;

                varying vec2 vHighPrecisionZW;
                varying vec2 vUv;
                varying vec2 vUv2;
                varying vec3 vWorldPos;
                varying vec4 vPos;
                varying float vRandom;
                varying float vFresnel;
                varying float vThickness;

                void main() {
                    vUv = uv;
                    vUv2 = uv2;
                    vRandom = randomm;
                    vThickness = thickness;

                    vec4 worldPos = modelMatrix * vec4(curvepos, 1.0);
                    vec4 worldPrevPos = modelMatrix * vec4(prevpos, 1.0);
                    vec4 worldNextPos = modelMatrix * vec4(nextpos, 1.0);

                    // for animation offset in fragment shader
                    vWorldPos = curvepos.xyz;

                    vPos = viewMatrix * worldPos;

                    mat4 projView = projectionMatrix * viewMatrix;
                    vec4 finalPos = projView * worldPos;
                    vec4 finalPrevPos = projView * worldPrevPos;
                    vec4 finalNextPos = projView * worldNextPos;

                    float aspect = resolution.x / resolution.y;
                    vec2 aspectVec = vec2(aspect, 1.0);
                    vec2 posScreen = finalPos.xy / finalPos.w * aspectVec;
                    vec2 prevPosScreen = finalPrevPos.xy / finalPrevPos.w * aspectVec;
                    vec2 nextPosScreen = finalNextPos.xy / finalNextPos.w * aspectVec;

                    // calculate screen space line normal, so we can extrude it to give it thickness
                    vec2 dirA = normalize((posScreen - prevPosScreen));
                    vec2 dirB = normalize((nextPosScreen - posScreen));
                    vec2 tangent = normalize(dirA + dirB);
                    vec2 normal = normalize(vec2(-tangent.y, tangent.x));

                    // choose which direction to extrude
                    if (uv.x > 0.5) {
                        normal = -normal;
                    }
                    normal.x /= aspect;

                    // calculate fresnel so we can fade the smoke at harsh corners
                    // bias it to one side, as broken geometry only appears when
                    // lines are moving away from camera
                    // vFresnel = 1.0 - dot(normalize(finalPrevPos.xyz - finalPos.xyz), vec3(0.0, 0.0, -1.0));
                    // vFresnel = smoothstep(0.15, 1.0, vFresnel);

                    // extrude line in screen space
                    float width = 0.35;
                    width = width * thickness * mix(0.25, 3.0, vUv2.y);
                    // width = width * mix(0.1, 1.0, smoothstep(1.0, 0.2, vUv2.y));
                    normal *= width;
                    vec4 thicknessOffset = vec4(normal.xy, 0.0, 0.0);

                    gl_Position = finalPos + thicknessOffset;

                    vHighPrecisionZW = gl_Position.zw;
                }
            `, fragmentShader: `
                layout(location = 1) out highp vec4 gInfo;

                ${globalUBO_default}
                ${fog_default}

                uniform vec3 uColor;
                uniform sampler2D tNoise;
                uniform sampler2D tNoise2;

                varying float vRandom;
                varying vec2 vUv;
                varying vec2 vUv2;
                varying vec2 vHighPrecisionZW;
                varying vec3 vWorldPos;
                varying vec4 vPos;
                varying float vFresnel;
                varying float vThickness;

                void main() {
                    float n1 = texture2D(tNoise, vUv2 * vec2(0.25, 1.0) - vec2(vRandom, time * 0.05)).r;
                    float n2 = 1.0 - texture2D(tNoise2, vec2(vUv2 * vec2(0.7, 1.5) - vec2(vRandom, time * 0.15))).r;
                    n2 -= n1 * 0.4;
                    n2 = pow(n2, 2.0);
                    // n += (1.0 - abs(vUv.x - 0.5) * 2.0) * 0.25;
                    // if (n < 0.5) discard;

                    float grad = 1.0 - abs(vUv.x - 0.5) * 2.0;
                    float mask = grad * n2;
                    // mask -= vUv.y * 0.15;
                    mask -= (sin(vUv.y * 2.0 - time + vRandom * 10.0) * 0.5 + 0.5) * 0.15;
                    mask *= smoothstep(0.0, 0.15, vUv2.y);
                    mask *= smoothstep(1.0, 0.5, vUv2.y);
                    if (mask < 0.05) discard;
                    vec3 color = vec3(1.0);

                    addFog(color, vPos.z);

                    gl_FragColor.rgb = color;
                    gl_FragColor.a = 0.35;

                    gInfo = vec4(1.0 - (0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5), vec2(0.0), 0.0);
                }
            `, transparent: !0, blending: CustomBlending, blendSrcAlpha: ZeroFactor, blendDstAlpha: OneFactor
        }); this.mesh = new PlanetMesh(e, i, this.scene, 25), this.mesh.name = "smoke", this.mesh.updateMatrixWorld(), this.mesh.matrixAutoUpdate = !1, this.mesh.matrixWorldAutoUpdate = !1, this.scene.add(this.mesh), this.ready.resolve()
    }
} class cables {
    constructor(e, i = {}) { this.scene = e, this.options = i, this.ready = miscutils.deferred(), this.mesh = new Group, this.scene.add(this.mesh), this.mesh.name = "cables", this.mesh.updateMatrixWorld(), this.mesh.matrixAutoUpdate = !1, this.mesh.matrixWorldAutoUpdate = !1, this.init() } async init() {
        const e = ["cables-1", "cables-2"], i = await Promise.all(e.map(a => geometryLoader.load(`planets/present/${a}.drc`))), s = new ShaderMaterial({
            uniformsGroups: [global$1.UBO], uniforms: { tNoise: { value: textureLoader.load("clouds_noise_512.ktx2", "srgb-repeat") }, uColor: { value: new Color("#565c5f") }, uWidth: { value: 1 }, ...fogUniforms }, vertexShader: `
                attribute float randomm;
                attribute vec3 nextpos;
                attribute vec3 prevpos;
                attribute vec3 curvepos;

                ${globalUBO_default}
                ${fit_default}

                uniform float uWidth;
                uniform sampler2D tNoise;

                varying vec2 vHighPrecisionZW;
                varying vec2 vUv;
                varying vec4 vPos;
                varying float vRandom;

                void main() {
                    vUv = uv;
                    vRandom = randomm;

                    vec4 worldPos = modelMatrix * vec4(curvepos, 1.0);
                    vec4 worldPrevPos = modelMatrix * vec4(prevpos, 1.0);
                    vec4 worldNextPos = modelMatrix * vec4(nextpos, 1.0);

                    vec4 viewPos = viewMatrix * worldPos;
                    vPos = viewPos;

                    mat4 projView = projectionMatrix * viewMatrix;
                    vec4 finalPos = projView * worldPos;
                    vec4 finalPrevPos = projView * worldPrevPos;
                    vec4 finalNextPos = projView * worldNextPos;

                    float aspect = resolution.x / resolution.y;
                    vec2 aspectVec = vec2(aspect, 1.0);
                    vec2 posScreen = finalPos.xy / finalPos.w * aspectVec;
                    vec2 prevPosScreen = finalPrevPos.xy / finalPrevPos.w * aspectVec;
                    vec2 nextPosScreen = finalNextPos.xy / finalNextPos.w * aspectVec;

                    // calculate screen space line normal, so we can extrude it to give it thickness
                    vec2 dirA = normalize((posScreen - prevPosScreen));
                    vec2 dirB = normalize((nextPosScreen - posScreen));
                    vec2 tangent = normalize(dirA + dirB);
                    vec2 normal = normalize(vec2(-tangent.y, tangent.x));

                    // choose which direction to extrude
                    if (uv.x > 0.5) {
                        normal = -normal;
                    }
                    normal.x /= aspect;

                    // extrude line in screen space
                    // set thickness based on camera distance, so that far away lines don't appear too thin
                    float width = viewPos.z * 0.0009 * aspect;
                    normal *= width;
                    vec4 thicknessOffset = vec4(normal.xy, 0.0, 0.0);

                    gl_Position = finalPos + thicknessOffset;

                    vHighPrecisionZW = gl_Position.zw;
                }
            `, fragmentShader: `
                layout(location = 1) out highp vec4 gInfo;

                ${globalUBO_default}
                ${fog_default}

                uniform vec3 uColor;
                uniform sampler2D tNoise;

                varying float vRandom;
                varying vec2 vUv;
                varying vec4 vPos;
                varying vec2 vHighPrecisionZW;

                void main() {

                    float n = texture2D(tNoise, vec2(0.5 + vRandom, vUv.y * 0.2)).r;
                    if (n < 0.25) discard;

                    vec3 color = uColor;
                    addFog(color, vPos.z);

                    gl_FragColor = vec4(color, 1.0);
                    gInfo = vec4(1.0 - (0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5), vec2(0.0), 0.0);
                }
            `, side: DoubleSide
        }); i.forEach((a, o) => { const l = new PlanetMesh(a, s, this.scene, 25); this.mesh.add(l), l.updateMatrixWorld(), l.matrixAutoUpdate = !1, l.matrixWorldAutoUpdate = !1 }), this.ready.resolve()
    }
} const _v0$3 = new Vector3, _v1$2 = new Vector3, _s$2 = new Sphere, VISIBILITY_THRESHOLD$2 = 25; function createGrassMaterial() {
    const r = { ...UniformsUtils.clone(uniforms), charPos: { value: new Vector3 }, charSpeed: { value: 0 }, tGrass: { value: textureLoader.load("grass-blades-highq.ktx2", "linearfilter") }, tColors: { value: textureLoader.load("atlas.png", "srgb-nearest") }, tNoiseTerrain: { value: textureLoader.load("noises-terrain.ktx2", "linearfilter-repeat") }, ...fogUniforms }; return new ShaderMaterial({
        name: "grass", lights: !0, uniformsGroups: [global$1.UBO], uniforms: r, vertexShader: `
            ${globalUBO_default}
            ${fit_default}
            ${sinenoise_default}

            attribute vec3 up;
            attribute vec4 randomm;
            uniform vec3 charPos;
            uniform float charSpeed;

            varying vec2 vUv;
            varying vec4 vRand;
            varying vec2 vHighPrecisionZW;

            varying vec3 wNormal;
            varying vec3 wPos;
            varying vec4 vPos;
            varying vec3 vNormal;

            // for shadows
            #include <shadowmap_pars_vertex>
            vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
                return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
            }

            void main() {
                vRand = randomm;
                vUv = uv;

                // get world position
                vec4 instancePos = instanceMatrix * vec4(position, 1.0);
                vec4 worldPosition = modelMatrix * instancePos;

                vec3 grassBottomPos = vec3(instanceMatrix[3]);
                vec3 grassDir = grassBottomPos - charPos;
                float grassDist = length(grassDir);

                // move up when looking in the up direction to prevent bottom outlines
                vec3 grassUp = normalize(up);
                vec3 grassCamDir = normalize(cameraPosition - grassBottomPos);
                float grassUpDisplacement = fit(max(0.0, dot(grassUp, grassCamDir)), 0.05, 0.3, 0.0, 1.0);

                vec3 grassOffset = grassBottomPos + grassUp * grassUpDisplacement * 0.02;
                vec3 camToGrass = normalize(grassOffset - cameraPosition);
                vec3 grassRight = cross(grassUp, camToGrass);
                vec3 grassForward = cross(grassRight, grassUp);
                mat3 grassTBN = mat3(grassRight, grassForward, grassUp);
                float grassScale = fit(fract(randomm.x + randomm.w * 2.0), 0.0, 1.0, 0.8, 1.3);

                vec3 grassPosition = position.xyz * grassScale;
                worldPosition = vec4(grassTBN * grassPosition + grassOffset, 1.0);

                // add noise
                float upMult = step(0.5, uv.y);
                float grassdisp = 0.1 + 0.2 * randomm.x;
                float grassspeed = 0.25 + 0.3 * randomm.y;
                worldPosition.xyz += grassRight * sinenoise1(vec3(grassBottomPos.x, 0.0, grassBottomPos.z) * vec3(0.05) + time * grassspeed) * grassdisp * upMult;
                worldPosition.xyz += grassRight * sinenoise1(vec3(grassBottomPos.x, 0.0, grassBottomPos.z) * vec3(0.1) + vec3(313.123) + time * grassspeed) * grassdisp * upMult;

                // repel by player movement
                vec3 grassDisp = normalize(grassDir) * fit(grassDist, 0.0, fit(charSpeed, 0.0, 0.01, 0.0, 1.25), 1.0, 0.0) * upMult * fit(charSpeed, 0.0, 0.15, 0.0, 0.3);
                if (length(grassDisp) > 0.001) {
                    grassDisp *= 1.0 - abs(dot(normalize(grassDisp), grassUp)); // displace mostly horizontally
                    worldPosition.xyz += grassDisp;
                }

                wNormal = grassUp;
                wPos = worldPosition.xyz;
                vNormal = normalize((viewMatrix * vec4(grassUp, 0.0)).xyz);

                // this requires worldPosition and transformedNormal
                vec3 transformedNormal = normalize(normalMatrix * normal);
                #include <shadowmap_vertex>

                vPos = viewMatrix * worldPosition;

                gl_Position = projectionMatrix * vPos;
                vHighPrecisionZW = gl_Position.zw;
            }
        `, fragmentShader: `
            layout(location = 1) out highp vec4 gInfo;

            ${globalUBO_default}
            ${fit_default}
            ${encoding_default}
            ${linearstep_default}
            ${colorutils_default}
            ${sinenoise_default}
            ${fog_default}

            varying vec3 wPos;
            varying vec3 wNormal;
            varying vec3 vNormal;
            varying vec4 vPos;

            uniform sampler2D tColors;
            uniform sampler2D tNoiseTerrain;
            uniform sampler2D tGrass;

            ${getTerrainNoise()}

            varying vec2 vUv;
            varying vec4 vRand;
            varying vec2 vHighPrecisionZW;

            // for shadows
            #include <packing>
            #include <shadowmap_pars_fragment>

            void main() {
                float shadowContribution = 1.0;
                float outlineContribution = 1.0;

                vec3 color = vec3(0.0);

                #if NUM_DIR_LIGHTS > 0
                    float grassUVAmount = 10.0;
                    float grassUVX = mix(vUv.x, 1.0 - vUv.x, step(0.5, vRand.w));
                    vec2 grassUV = vec2(fract(grassUVX / grassUVAmount + 1.0 / grassUVAmount * floor(vRand.y * grassUVAmount)), vUv.y * 0.5 + 0.5 * floor(mod(vRand.z * 2.0 + vRand.x * 3.32, 2.0)));
                    float shape = texture2D(tGrass, grassUV).r;
                    if (shape > 0.1) discard;

                    // get color and add noise
                    vec3 wNorm = normalize(wNormal);
                    vec3 baseColor = applyTerrainColor(wNorm, wPos, texture2D(tColors, vec2(0.15, 0.95)).rgb);
                    vec3 colorhsv = rgb2hsv(baseColor);

                    vec3 baseColor2 = hsv2rgb(colorhsv - vec3(0.0, 0.0, 0.075));
                    vec3 baseColor3 = hsv2rgb(colorhsv + vec3(0.0, 0.0, 0.075));

                    // decide which color to use
                    vec3 grassColor = mix(baseColor, baseColor2, step(0.5, fract(vRand.x * 34.324 + vRand.y * 21.231)));
                    grassColor = mix(grassColor, baseColor3, step(0.5, fract(vRand.z * 5.53 + vRand.w * 4.423)));

                    // add noise to the outline, if the grass color is different than the baseColor, add a chance to remove the outline
                    outlineContribution *= step(0.4, sinenoise1(vec3((vUv + vec2(vRand.x * 3.34, vRand.y * 3.1)) * 7.0, vRand.z * 12.312312)) * 0.5 + 0.5);

                    // color shadow
                    vec3 colorShadow = rgb2hsv(grassColor);
                    colorShadow.r -= 0.02;
                    colorShadow.b *= 0.5;
                    colorShadow = hsv2rgb(colorShadow);

                    // shadow
                    float shadow = 0.0;
                    #if defined(USE_SHADOWMAP) && NUM_DIR_LIGHT_SHADOWS > 0
                        DirectionalLightShadow directionalLightShadow;
                        directionalLightShadow = directionalLightShadows[0];
                        shadow = getShadow(
                            directionalShadowMap[0],
                            directionalLightShadow.shadowMapSize,
                            directionalLightShadow.shadowIntensity,
                            directionalLightShadow.shadowBias,
                            directionalLightShadow.shadowRadius,
                            vDirectionalShadowCoord[0]
                        );
                    #endif

                    // set color
                    float shadowCut = smoothstep(0.2, 0.4, shadow);
                    color = mix(colorShadow, grassColor, shadowCut);
                #endif

                // remove outline from the bottom
                outlineContribution *= step(0.015, vUv.y) /* step(0.5, vRand.y)*/;

                float surfaceId = vRand.x;

                // fog
                // addFog(color, vPos.z);

                gl_FragColor = vec4(color, surfaceId);
                gInfo = vec4(1.0 - (0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5), encodeNormalSpheremap(normalize(vNormal)), outlineContribution);
            }
        `})
} let grass$1 = class { constructor(e, i) { this.scene = e, this.options = i, this.meshes = [], this.ready = miscutils.deferred(), this.init() } async init() { const e = new PlaneGeometry; e.rotateZ(Math.PI), e.translate(0, -.5, 0), e.rotateX(Math.PI * -.5), e.scale(.7, .7, .7); const i = await geometryLoader.load(`planets/${this.scene.terrainOptions.terrain}/grass.drc`); (await createInstancedGeometryPatches(e, i)).forEach((a, o) => { const l = new InstancedMesh(a, createGrassMaterial(), a.instanceCount); l.instanceMatrix.array = a._matrixArray, a._colors && (l.instanceColor = a._colors), l.name = "grass", l.frustumCulled = !0, l.computeBoundingSphere(), l.boundingSphere.radius += 1, l.updateMatrixWorld(!0), l.matrixAutoUpdate = !1, l.matrixWorldAutoUpdate = !1, l.receiveShadow = !0, l.castShadow = !1, l.ignore = o !== 0, this.meshes.push(l), this.scene.add(l) }), this.scene.beforeRenderCbs.push(this.update.bind(this)), this.ready.resolve() } update() { var i; if (!((i = this.scene.characters) != null && i.mesh)) return; const e = this.scene.characters.mesh._localObject; this.meshes.forEach(s => { s.material.uniforms.charPos.value.copy(e.position), s.material.uniforms.charSpeed.value = e.velocityHorizontal, _s$2.copy(s.boundingSphere), _v0$3.copy(e.position).sub(_s$2.center).normalize(); const a = _s$2.center.distanceTo(e.position), o = Math.min(a, _s$2.radius); _v1$2.copy(_s$2.center).addScaledVector(_v0$3, o), s.visible = e.position.distanceTo(_v1$2) < VISIBILITY_THRESHOLD$2 }) } }; const _v0$2 = new Vector3, _v1$1 = new Vector3, _s$1 = new Sphere, VISIBILITY_THRESHOLD$1 = 25; function createButterflyMaterial() {
    const r = { ...UniformsUtils.clone(uniforms), charPos: { value: new Vector3 }, charSpeed: { value: 0 }, tButterfly: { value: textureLoader.load("butterfly-highq.ktx2", "linearfilter") }, tButterflyFront: { value: textureLoader.load("butterfly-front-highq.ktx2", "linearfilter") }, uColor1: { value: new Color("#ffffff") }, uColor2: { value: new Color("#f5ba53") }, uColor3: { value: new Color("#ffd998") }, uColor4: { value: new Color("#9dbfe6") }, uColor5: { value: new Color("#ade3d0") }, ...fogUniforms }; return new ShaderMaterial({
        name: "butterflies", lights: !0, uniformsGroups: [global$1.UBO], uniforms: r, vertexShader: `
            ${globalUBO_default}
            ${fit_default}
            ${sinenoise_default}

            attribute vec3 up;
            attribute vec4 randomm;
            uniform vec3 charPos;
            uniform float charSpeed;

            varying vec2 vUv;
            varying vec4 vRand;
            varying vec2 vHighPrecisionZW;

            varying vec3 wNormal;
            varying vec3 wPos;
            varying vec4 vPos;
            varying vec3 vNormal;
            varying vec3 vAnimationOffset;

            // for shadows
            #include <shadowmap_pars_vertex>
            vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
                return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
            }

            mat2 rotate2d(float a) {
                float s = sin(a);
                float c = cos(a);
                return mat2(c, s, -s, c);
            }

            void main() {
                vRand = randomm;
                vUv = uv;

                // get world position
                vec4 instancePos = instanceMatrix * vec4(position, 1.0);
                vec4 worldPosition = modelMatrix * instancePos;

                vec3 butterflyBottomPos = vec3(instanceMatrix[3]);

                // flap animation
                float flapTimeline = fract(time * mix(1.0, 1.5, randomm.w) + randomm.x);
                float flapDisplacement = smoothstep(0.0, 0.4, flapTimeline) * 0.15;
                flapDisplacement *= smoothstep(1.0, 0.4, flapTimeline);
                flapDisplacement *= sin(time * mix(1.0, 4.0, randomm.x)) * 0.5 + 0.5;
                vAnimationOffset = vec3(sin(time * 2.21312 + randomm.y * 5.0 + randomm.z * 6.0) , sin(time * 1.421 + 0.314159 + randomm.y * 10.0), sin(time * 1.79 + 0.27143 + randomm.z * 10.0));
                vAnimationOffset += vec3(sin(time * 1.31412 + randomm.x * 5.0 + randomm.w * 4.0) , sin(time * 2.421 + 0.314159 + randomm.w * 10.0), sin(time *2.69 + 1.32143 + randomm.y * 10.0));
                vAnimationOffset *= 0.5;
                vec3 posAnimation = vec3(0.0);
                posAnimation += normalize(instancePos.xyz) * flapDisplacement;
                posAnimation += 0.5 * vAnimationOffset;

                // billboard
                vec3 butterflyUp = normalize(up);
                vec3 butterflyOffset = butterflyBottomPos + posAnimation;
                vec3 camToButterfly = normalize(butterflyOffset - cameraPosition);
                vec3 butterflyRight = cross(butterflyUp, camToButterfly);
                vec3 butterflyForward = cross(butterflyRight, butterflyUp);
                mat3 butterflyTBN = mat3(butterflyRight, butterflyForward, butterflyUp);
                float butterflyScale = fit(fract(randomm.x + randomm.w * 2.0), 0.0, 1.0, 0.8, 1.3);

                vec3 butterflyPosition = position.xyz * butterflyScale;
                worldPosition = vec4(butterflyTBN * butterflyPosition + butterflyOffset, 1.0);

                wNormal = butterflyUp;
                wPos = worldPosition.xyz;
                vNormal = normalize((viewMatrix * vec4(butterflyUp, 0.0)).xyz);

                // this requires worldPosition and transformedNormal
                vec3 transformedNormal = normalize(normalMatrix * normal);
                #include <shadowmap_vertex>

                vPos = viewMatrix * worldPosition;

                gl_Position = projectionMatrix * vPos;

                vHighPrecisionZW = gl_Position.zw;
            }
        `, fragmentShader: `
            layout(location = 1) out highp vec4 gInfo;

            ${globalUBO_default}
            ${fit_default}
            ${encoding_default}
            ${linearstep_default}
            ${colorutils_default}
            ${sinenoise_default}
            ${fog_default}

            varying vec3 wPos;
            varying vec4 vPos;
            varying vec3 wNormal;
            varying vec3 vNormal;
            varying vec3 vAnimationOffset;

            varying vec2 vUv;
            varying vec4 vRand;
            varying vec2 vHighPrecisionZW;

            uniform sampler2D tButterfly;
            uniform sampler2D tButterflyFront;
            uniform vec3 uColor1;
            uniform vec3 uColor2;
            uniform vec3 uColor3;
            uniform vec3 uColor4;
            uniform vec3 uColor5;

            // for shadows
            #include <packing>
            #include <shadowmap_pars_fragment>

            mat2 rotate2d(float a) {
                float s = sin(a);
                float c = cos(a);
                return mat2(c, s, -s, c);
            }

            void main() {
                float shadowContribution = 1.0;
                float outlineContribution = 1.0;

                // butterfly 'front' view
                vec2 flapUvFront = vUv;
                flapUvFront -= 0.5;

                // butterfly 'top' view
                vec2 flapUvTop = flapUvFront;

                // flap value to drive animation
                float flapTimeline = fract(time * mix(4.0, 5.5, vRand.w) + vRand.x - 0.4 - abs(flapUvFront.x) * 0.25 + vUv.y * 0.5);
                float flapDisplacement = smoothstep(0.0, 0.4, flapTimeline);
                flapDisplacement *= smoothstep(1.0, 0.4, flapTimeline);

                // front animation
                flapUvFront.y += flapDisplacement * abs(flapUvFront.x) * 1.4;
                flapUvFront = rotate2d((vAnimationOffset.x + vAnimationOffset.y + vAnimationOffset.z) * 0.4) * flapUvFront;
                flapUvFront += 0.5;
                float front = texture2D(tButterflyFront, flapUvFront).r;

                // top animation
                flapUvTop.x *= mix(0.5, 2.0, flapDisplacement);
                flapUvTop = rotate2d((vAnimationOffset.x + vAnimationOffset.y + vAnimationOffset.z) * 0.4) * flapUvTop;
                flapUvTop.y *= 1.25;
                flapUvTop += 0.5;
                float top = texture2D(tButterfly, flapUvTop).r;

                // blend between front texture and top texture for different shapes
                float mask = mix(front * 2.0, top * 2.0, sin(time * mix(0.5, 2.0, vRand.z) + vRand.x * 10.0) * 0.5 + 0.5);
                if (mask < 0.5) discard;

                // decide which color to use
                vec3 baseColor = uColor1;
                vec3 baseColor2 = uColor2;
                vec3 baseColor3 = uColor3;
                vec3 baseColor4 = uColor4;
                vec3 baseColor5 = uColor5;

                // vec3 color = mix(baseColor, baseColor2, step(0.5, fract(vRand.x * 34.324 + vRand.y * 21.231)));
                // color = mix(color, baseColor3, step(0.5, fract(vRand.z * 5.53 + vRand.w * 4.423)));
                // color = mix(color, baseColor4, step(0.5, fract(vRand.y * 3.14 + vRand.z * 14.117)));
                // color = mix(color, baseColor5, step(0.5, fract(vRand.x * 22.14 + vRand.z * 107.98)));
                float seed = fract(vRand.x * 34.327 + vRand.y * 21.231);
                vec3 color = mix(baseColor, baseColor2, step(0.2, seed));
                color = mix(color, baseColor3, step(0.4, seed));
                color = mix(color, baseColor4, step(0.6, seed));
                color = mix(color, baseColor5, step(0.8, seed));

                // shadow
                float shadow = 0.0;
                #if defined(USE_SHADOWMAP) && NUM_DIR_LIGHT_SHADOWS > 0
                    DirectionalLightShadow directionalLightShadow;
                    directionalLightShadow = directionalLightShadows[0];
                    shadow = getShadow(
                        directionalShadowMap[0],
                        directionalLightShadow.shadowMapSize,
                        directionalLightShadow.shadowIntensity,
                        directionalLightShadow.shadowBias,
                        directionalLightShadow.shadowRadius,
                        vDirectionalShadowCoord[0]
                    );
                #endif

                // set color
                float shadowCut = smoothstep(0.2, 0.4, shadow);
                color = mix(color * 0.5, color, shadowCut);

                addFog(color, vPos.z);

                float surfaceId = vRand.x;

                gl_FragColor = vec4(color, surfaceId);
                gInfo = vec4(1.0 - (0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5), encodeNormalSpheremap(normalize(vNormal)), outlineContribution);
            }
        `})
} class butterflies { constructor(e, i) { this.scene = e, this.options = i, this.meshes = [], this.ready = miscutils.deferred(), this.init() } async init() { const e = new PlaneGeometry; e.rotateZ(Math.PI), e.translate(0, -.5, 0), e.rotateX(Math.PI * -.5), e.scale(.1, .125, .125), e.scale(.8, .8, .8); const i = await geometryLoader.load(`planets/${this.scene.terrainOptions.terrain}/butterflies.drc`); (await createInstancedGeometryPatches(e, i)).forEach((a, o) => { const l = new InstancedMesh(a, createButterflyMaterial(), a.instanceCount); l.instanceMatrix.array = a._matrixArray, a._colors && (l.instanceColor = a._colors), l.name = "butterflies", l.updateMatrixWorld(), l.matrixAutoUpdate = !1, l.matrixWorldAutoUpdate = !1, l.frustumCulled = !0, l.computeBoundingSphere(), l.boundingSphere.radius += 1, l.updateMatrixWorld(!0), l.matrixAutoUpdate = !1, l.matrixWorldAutoUpdate = !1, l.receiveShadow = !0, l.castShadow = !1, l.ignore = o !== 0, this.meshes.push(l), this.scene.add(l) }), this.scene.beforeRenderCbs.push(this.update.bind(this)), this.ready.resolve() } update() { var i; if (!((i = this.scene.characters) != null && i.mesh)) return; const e = this.scene.characters.mesh._localObject; this.meshes.forEach(s => { s.material.uniforms.charPos.value.copy(e.position), s.material.uniforms.charSpeed.value = e.velocityHorizontal, _s$1.copy(s.boundingSphere), _v0$2.copy(e.position).sub(_s$1.center).normalize(); const a = _s$1.center.distanceTo(e.position), o = Math.min(a, _s$1.radius); _v1$1.copy(_s$1.center).addScaledVector(_v0$2, o), s.visible = e.position.distanceTo(_v1$1) < VISIBILITY_THRESHOLD$1 }) } } const _v0$1 = new Vector3, _v1 = new Vector3, _s = new Sphere, VISIBILITY_THRESHOLD = 35; function createLeavesMaterial(r) {
    const e = { ...UniformsUtils.clone(uniforms), uScale: { value: .28 }, uLeavesShake: { value: .25 }, uShakeSpeed: { value: .75 }, uNearFar: { value: new Vector2(r.near, r.far) }, tTrees: { value: textureLoader.load("tree-leaves.ktx2") }, tTreeDetail: { value: textureLoader.load("tree-leaves-detail.ktx2") }, uColor1: { value: new Color("#5b9f7b") }, uColor2: { value: new Color("#649c75") }, uColor3: { value: new Color("#4e8c6d") }, charPos: { value: new Vector3 }, charSpeed: { value: 0 }, ...fogUniforms }; return new ShaderMaterial({
        userData: { hotReload: "trees-leaves" }, name: "trees-leaves", lights: !0, uniformsGroups: [global$1.UBO], uniforms: e, shadowSide: FrontSide, vertexShader: `
            #define PI2 6.283185307179586

            // for light direction
            struct DirectionalLight {
                vec3 direction;
                vec3 color;
            };
            uniform DirectionalLight directionalLights[ 1 ];

            // for shadows
            #include <shadowmap_pars_vertex>
            vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
                return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
            }

            ${globalUBO_default}
            ${matrixutils_default}
            ${fit_default}
            ${rotate_default}
            ${sinenoise_default}

            attribute vec3 centr;
            attribute vec3 centr_tree;
            attribute vec4 rand;
            attribute int detail;
            attribute int leavescolor;

            varying vec2 vUv;
            varying vec4 vRand;
            varying vec4 vPos;
            varying vec2 vHighPrecisionZW;
            flat varying vec3 vCentrTree;

            flat varying vec3 vNormal;
            flat varying vec3 vLightDir;
            flat varying int vDetail;
            flat varying float vColor;

            uniform float uLeavesShake;
            uniform float uShakeSpeed;
            uniform float uScale;

            uniform vec3 charPos;
            uniform float charSpeed;

            void main() {
                vUv = mix(uv, vec2(1.0 - uv.x, uv.y), step(0.5, rand.x));
                vRand = rand;
                vDetail = detail;
                vCentrTree = centr_tree;
                vLightDir = vec3(0.0);
                vColor = float(leavescolor);

                #if NUM_DIR_LIGHTS > 0
                    vLightDir = normalize(directionalLights[0].direction);
                #endif

                float scale = mix(0.5, 1.0, vRand.w) * uScale;
                float shake = sinenoise1(vec3(centr * 2.0) + vec3(-time * 0.1 * uShakeSpeed, 0.0, time * 0.15 * uShakeSpeed)) * PI2 * uLeavesShake * mix(0.25, 1.0, vRand.y);

                mat3 rot = mat3(1.0);

                if (detail == 1) {
                    vec2 aspectVec = vec2(resolution.x / resolution.y, 1.0);

                    // get screen position of the quad and the center of the bush
                    vec4 quadPos = projectionMatrix * modelViewMatrix * vec4(centr, 1.0);
                    vec4 bushPos = projectionMatrix * modelViewMatrix * vec4(centr_tree, 1.0);
                    vec2 quad2D = quadPos.xy / quadPos.w * aspectVec;
                    vec2 bush2D = bushPos.xy / bushPos.w * aspectVec;

                    // rotate towards the center of the bush
                    vec2 dir = normalize(quad2D - bush2D);
                    float angle = atan(dir.y, dir.x);
                    rot = rotateZ(angle - PI2 * 0.25);

                } else {
                    rot = rotateZ(fit(vRand.z, 0.0, 1.0, -PI2, PI2) + shake);
                }

                // shake with player movement
                float distToPlayer = length(charPos - centr);
                float disp = fit(distToPlayer, 0.0, fit(charSpeed, 0.0, 0.001, 0.0, 0.85), 1.0, 0.0) * fit(charSpeed, 0.0, 0.15, 0.0, 10.0);
                if (length(disp) > 0.001) rot = rotateZ(sin(disp) * 0.15 * sign(rand.w - 0.5)) * rot;

                vec3 posLeaf = rot * vec3(uv * 2.0 - 1.0, 0.0) * scale;

                vec3 pos = centr;
                vec3 right = getViewRight();
                vec3 up = getViewUp();
                vec3 back = getViewBack();
                pos += right * posLeaf.x;
                pos += up * posLeaf.y;
                pos += back * posLeaf.z;

                // shake a bit
                float shakePosMult = 2.0;
                float shakeDisp = 0.025;
                float shakeSpeed = 1.1;
                vec3 shakeX = right * sin((centr.x + centr.y) * shakePosMult + 534.35 + time * shakeSpeed) * shakeDisp;
                vec3 shakeZ = back * sin((centr.z + centr.y) * shakePosMult + 543.55 + time * shakeSpeed * 0.5) * shakeDisp;
                pos -= centr;
                pos += shakeX + shakeZ;
                pos += centr;

                vNormal = normalize(normalMatrix * normal);

                // for shadows
                vec3 transformedNormal = vNormal;
                vec4 worldPosition = modelMatrix * vec4(pos, 1.0);
                #include <shadowmap_vertex>

                vPos = viewMatrix * worldPosition;

                gl_Position = projectionMatrix * vPos;

                // save same depth for all leaves
                vec4 centrPos = projectionMatrix * modelViewMatrix * vec4(centr_tree, 1.0);
                vHighPrecisionZW = centrPos.zw;
            }
        `, fragmentShader: `
            layout(location = 1) out highp vec4 gInfo;

            // for shadows
            #include <packing>
            #include <shadowmap_pars_fragment>

            ${globalUBO_default}
            ${encoding_default}
            ${sinenoise_default}
            ${colorutils_default}
            ${fog_default}

            varying vec2 vUv;
            varying vec4 vPos;
            varying vec4 vRand;
            varying vec2 vHighPrecisionZW;
            flat varying vec3 vCentrTree;
            flat varying int vDetail;
            flat varying vec3 vNormal;
            flat varying vec3 vLightDir;
            flat varying float vColor;

            uniform sampler2D tTrees;
            uniform sampler2D tTreeDetail;
            uniform vec3 uColor1;
            uniform vec3 uColor2;
            uniform vec3 uColor3;
            uniform vec2 uNearFar;

            void main() {
                float surfaceId = fract((vCentrTree.x + vCentrTree.y + vCentrTree.z) * 3.424);
                float negativeDistance = perspectiveDepthToViewZ(gl_FragCoord.z, uNearFar.x, uNearFar.y);

                if (vDetail == 1) {
                    float shapes = 5.0;
                    float shapesStep = 1.0 / shapes;
                    float offset = floor(mod((vRand.z * 4.35 + vRand.w * 43.5) * shapes, shapes));
                    vec2 uv = vec2(vUv.x * shapesStep + offset * shapesStep, vUv.y);
                    float shape = texture2D(tTreeDetail, uv).r;
                    if (shape > 0.9) discard;

                    surfaceId = fract(vRand.x * 32.234);

                    // move details nearest to the camera
                    gl_FragDepth = viewZToPerspectiveDepth(negativeDistance + 0.2, uNearFar.x, uNearFar.y);
                } else {
                    float shape = texture2D(tTrees, vUv).r;
                    if (shape > 0.9) discard;

                    float noise = sinenoise1(vec3(vUv * mix(0.8, 1.0, vRand.z) * 5.0, time * 0.1));
                    gl_FragDepth = viewZToPerspectiveDepth(negativeDistance + noise * 0.1, uNearFar.x, uNearFar.y);
                }

                float outlineContribution = step(sinenoise1(vec3(vUv * 2.0, vRand.x + vRand.w * 34.32)), 0.35);

                // light
                vec3 geometryNormal = normalize(vNormal);
                float light = dot(geometryNormal, normalize(vLightDir));

                // shadow
                float shadow = 0.0;
                #if defined(USE_SHADOWMAP) && NUM_DIR_LIGHTS > 0 && NUM_DIR_LIGHT_SHADOWS > 0
                    DirectionalLightShadow directionalLightShadow;
                    directionalLightShadow = directionalLightShadows[0];
                    shadow = getShadow(
                        directionalShadowMap[0],
                        directionalLightShadow.shadowMapSize,
                        directionalLightShadow.shadowIntensity,
                        directionalLightShadow.shadowBias,
                        directionalLightShadow.shadowRadius,
                        vDirectionalShadowCoord[0]
                    );
                #endif

                light = min(light, shadow);

                vec3 grassColor = mix(uColor1, uColor2, clamp(vColor, 0.0, 1.0));
                grassColor = mix(grassColor, uColor3, clamp(vColor - 1.0, 0.0, 1.0));

                vec3 colorhsv = rgb2hsv(grassColor);
                vec3 colorShadow = colorhsv;
                colorShadow.r -= 0.02;
                colorShadow.b *= 0.5;
                colorShadow = hsv2rgb(colorShadow);

                vec3 color = mix(colorShadow, grassColor, smoothstep(0.0, 0.1, light));

                addFog(color, vPos.z);

                gl_FragColor = vec4(color, surfaceId);
                gInfo = vec4(1.0 - (0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5), vec2(0.0), outlineContribution);
            }
        `})
} class grass { constructor(e, i) { this.scene = e, this.options = i, this.ready = miscutils.deferred(), this.lowMemory = !!client$1.lowMemoryDevice, this.init() } async init() { const i = Array.from({ length: 5 }, (h, d) => d), a = (await Promise.all(i.map(h => geometryLoader.batched(`planets/present/${this.lowMemory ? "low/" : ""}tree-leaves_${h}.drc`)))).flat(), o = a.length, l = a.reduce((h, d) => h + d.attributes.position.count, 0), c = a.reduce((h, d) => h + d.index.count, 0); this.mesh = new BatchedMesh(o, l, c, createLeavesMaterial(this.scene.camera)), this.mesh.name = "tree-leaves", this.mesh.sortObjects = !1, this.mesh.receiveShadow = !0, this.mesh.castShadow = !0, a.forEach((h, d) => { this.mesh.addInstance(this.mesh.addGeometry(h)) }), this.mesh.updateMatrixWorld(!0), this.mesh.matrixAutoUpdate = !1, this.mesh.matrixWorldAutoUpdate = !1, this.scene.beforeRenderCbs.push(this.update.bind(this)), this.scene.add(this.mesh), this.ready.resolve() } update() { var i; if (!((i = this.scene.characters) != null && i.mesh)) return; const e = this.scene.characters.mesh._localObject; this.mesh.material.uniforms.charPos.value.copy(e.position).add(_v0$1.copy(e.position).normalize()), this.mesh.material.uniforms.charSpeed.value = e.velocity.length(); for (let s = 0; s < this.mesh._instanceInfo.length; s++) { this.mesh.getBoundingSphereAt(s, _s), _v0$1.copy(e.position).sub(_s.center).normalize(); const a = _s.center.distanceTo(e.position), o = Math.min(a, _s.radius); _v1.copy(_s.center).addScaledVector(_v0$1, o), this.mesh._instanceInfo[s].visible = e.position.distanceTo(_v1) < VISIBILITY_THRESHOLD } this.mesh._visibilityChanged = !0 } } class presentScene extends planet { constructor(e) { const i = [[5.81095, 5.80205, 25.7794], [13.9316, 19.3062, 8.38147]], s = [Math.PI * .625, Math.PI * .55], a = [1.15, 1.15], o = Math.floor(Math.random() * i.length); super(e, { terrain: "present", charPosition: i[o], charRotation: s[o], charRadius: a[o], roomPrefix: "planet-present", hemisphereOptions: ["#25577c", "#2f2f2f", .7], cmsOptions: ["#ffffff", 3] }) } async init() { client$1.devScene && (this._devAudioController = new audioController(this.mainController), this._devAudioController.camera = this.camera), await Promise.all([...[{ objClass: water, name: "water" }, { objClass: waterfallvfx, name: "waterfallvfx" }, { objClass: beachwavevfx, name: "beachwavevfx" }, { objClass: cables, name: "cables" }, { objClass: smokevfx, name: "smokevfx" }, { objClass: sky, name: "sky" }, { objClass: grass$1, name: "grass" }, { objClass: butterflies, name: "butterflies" }, { objClass: grass, name: "treeleaves" }, { objClass: birds, name: "birds", options: { count: 15, groups: 5, curve: "birds/curve-1.drc", bird: "birds/1.drc" } }, { objClass: birds, name: "birds2", options: { count: 20, groups: 5, curve: "birds/curve-2.drc", bird: "birds/2.drc", multiplier: 1.25, speed: .7, direction: -1 } }].map(({ objClass: e, name: i, options: s = {} }) => (this[i] = new e(this, s), this[i].ready)), this.createNPCS()]), client$1.devScene ? (console.warn("ignore webgl errors on dev, they come from the water being added to the GUI."), this.add(this.water.mesh), this.add(this.beachwavevfx.mesh), this.ready.then(() => this.addWateryElements())) : (this.addWateryElements(), this.anyStepInitiated = anyStepInitiated) } addWateryElements() { this.waterScene.add(this.water.mesh), this.waterScene.add(this.waterfallvfx.mesh), this.waterScene.add(this.waterfallvfx.mesh2), this.waterScene.add(this.waterfallvfx.mesh3), this.waterScene.add(this.beachwavevfx.mesh) } async createNPCS() { this.npcs = [], this.npcs.push(new npc(this, { id: "office-worker", modelURL: "npcs/present/office-worker/office-worker-alt.drc", bonesURL: "npcs/present/office-worker/office-worker-bones.drc", animations: ["npcs/present/office-worker/office-worker-idle.drc", "npcs/present/office-worker/office-worker-talk.drc", "npcs/present/office-worker/office-worker-idle.drc", "npcs/present/office-worker/office-worker-walk-alt.drc"], animationsOptions: [{ speed: 1 }, { speed: 1 }, { speed: 1 }, { speed: 1 }], curve: "npcs/present/tall-man-curve.drc", curveSpeed: .52, curveProgress: 0, curveSpeedAnimationWeight: 1, texts: ["Izvini, ya na obede."], alwaysFaceCharacter: !1, talkFacingPlayer: !1, position: [27.9744, 1.40907, .538691], rotation: [0, 0, math.radians(-88.6297)], textsBubblesOffset: [0, .6, .05], visibilityThreshold: 20, extraData: { name: "Prokhozhiy", color: "#66BDE6" } })), this.npcs.push(new npc(this, { id: "office-worker-2", modelURL: "npcs/present/office-worker/office-worker.drc", bonesURL: "npcs/present/office-worker/office-worker-bones.drc", animations: ["npcs/present/office-worker/office-worker-idle.drc", "npcs/present/office-worker/office-worker-talk.drc", "npcs/present/office-worker/office-worker-idle-talk.drc", "npcs/present/office-worker/office-worker-walk.drc"], animationsOptions: [{ speed: 1 }, { speed: 1 }, { speed: 1 }, { speed: 1 }], texts: ["Starshiy pomoschnik mladshego zamestitelya po yantaryu...", "Zvuchit neplokho, pravda zhe?"], alwaysFaceCharacter: !1, talkFacingPlayer: !0, position: [26.2539, 9.70977, 1.39919], rotation: [math.radians(3.52382), math.radians(-.260877), math.radians(-69.5392)], textsBubblesOffset: [0, .65, .1], visibilityThreshold: 20, icon: !0, iconOffset: [0, .1, .1], extraData: { name: "Ofisnyy klerk iz Klovera", color: "#c25959", voice: "male3" } })), this.npcs.push(new npc(this, { id: "chef", modelURL: "npcs/present/chef/chef.drc", bonesURL: "npcs/present/chef/chef-bones.drc", animations: ["npcs/present/chef/chef-idle.drc", "npcs/present/chef/chef-idle.drc", "npcs/present/chef/chef-idle.drc", "npcs/present/chef/chef-idle.drc"], animationsOptions: [{ speed: 1 }, { speed: 1 }, { speed: 1 }, { speed: 1 }], texts: ["Ne videl moyu doch? Dumala, ona uzhe doma..."], alwaysFaceCharacter: !1, talkFacingPlayer: !1, position: [20.3565, 19.1747, 2.20046], rotation: [math.radians(63.916), math.radians(41.5698), math.radians(-67.6105)], textsBubblesOffset: [.2, .25, .3], lookatOffset: [0, -.2, 0], visibilityThreshold: 20, extraData: { name: "Vladelets suvenirnoy lavki", color: "#66BDE6", voice: "male2" } })), this.npcs.push(new npc(this, { id: "caveman", modelURL: "npcs/present/caveman/caveman.drc", bonesURL: "npcs/present/caveman/caveman-bones.drc", animations: ["npcs/present/caveman/caveman-idle.drc", "npcs/present/caveman/caveman-idle.drc", "npcs/present/caveman/caveman-idle.drc", "npcs/present/caveman/caveman-idle.drc"], animationsOptions: [{ speed: 1 }, { speed: 1 }, { speed: 1 }, { speed: 1 }], texts: ["Mozhet, prosto vzyat bolnichnyy..."], alwaysFaceCharacter: !1, talkFacingPlayer: !1, position: [-22.9825, -3.72729, 4.71889], rotation: [math.radians(44.1775), math.radians(26.6551), math.radians(93.4536)], textsBubblesOffset: [0, .25, 0], lookatOffset: [0, -.3, 0], visibilityThreshold: 20, icon: !0, iconOffset: [0, -.35, 0], extraData: { name: "Yantarschik", color: "#f3c258", voice: "male3" } })), this.npcs.push(new npc(this, { id: "boss", modelURL: "npcs/present/boss/boss.drc", bonesURL: "npcs/present/boss/boss-bones.drc", animations: ["npcs/present/boss/boss-idle.drc", "npcs/present/boss/boss-idle.drc", "npcs/present/boss/boss-idle.drc", "npcs/present/boss/boss-idle.drc"], animationsOptions: [{ speed: .9 }, { speed: .9 }, { speed: .9 }, { speed: .9 }], texts: ["Yo-moyo..."], alwaysFaceCharacter: !1, talkFacingPlayer: !1, position: [-4.04907, 1.05824, 25.4517], rotation: [math.radians(223.52), math.radians(-619.507), math.radians(-132.333)], textsBubblesOffset: [0, .5, 0], lookatOffset: [0, -.1, 0], visibilityThreshold: 30, talkDistance: 2.2, icon: !0, iconOffset: [0, 0, 0], extraData: { name: "Nachalnik", color: "#c25959", voice: "male1" } })), this.npcs.push(new npc(this, { id: "flower-lady", modelURL: "npcs/present/young-lady/young-lady.drc", bonesURL: "npcs/present/young-lady/young-lady-bones.drc", animations: ["npcs/present/young-lady/young-lady-idle.drc", "npcs/present/young-lady/young-lady-talk.drc", "npcs/present/young-lady/young-lady-talk-idle.drc", "npcs/present/young-lady/young-lady-idle.drc"], animationsOptions: [{ speed: .75 }, { speed: 1.1 }, { speed: 1 }, { speed: 1 }], texts: ["Na poberezhe tsvety raspuskayutsya dolgo."], alwaysFaceCharacter: !1, talkFacingPlayer: !1, position: [27.4269, 4.65974, 3.58217], rotation: [math.radians(283.815), math.radians(-192.997), math.radians(-266.012)], textsBubblesOffset: [0, 0, -.2], lookatOffset: [0, -.5, 0], visibilityThreshold: 20, icon: !0, iconOffset: [.1, -.6, .1], extraData: { name: "Tsvetochnitsa", color: "#f3c258", voice: "female2" } })), this.npcs.push(new npc(this, { id: "scout", modelURL: "npcs/present/scout/scout.drc", bonesURL: "npcs/present/scout/scout-bones.drc", animations: ["npcs/present/scout/scout-idle.drc", "npcs/present/scout/scout-idle.drc", "npcs/present/scout/scout-idle.drc", "npcs/present/scout/scout-idle.drc"], animationsOptions: [{ speed: 1 }, { speed: 1 }, { speed: 1 }, { speed: 1 }], texts: ["Kazhetsya, batya zovyot..."], alwaysFaceCharacter: !1, talkFacingPlayer: !1, position: [-8.91062, -21.1061, .906382], rotation: [math.radians(62.3308), math.radians(62.6945), math.radians(119.524)], textsBubblesOffset: [-.15, .5, 0], visibilityThreshold: 20, extraData: { name: "Shpana s Baltrayona", color: "#66BDE6", voice: "female3" } })), this.npcs.push(new npc(this, { id: "threekid", modelURL: "npcs/present/threekid/threekid.drc", bonesURL: "npcs/present/threekid/threekid-bones.drc", animations: ["npcs/present/threekid/threekid-idle.drc", "npcs/present/threekid/threekid-idle.drc", "npcs/present/threekid/threekid-idle.drc", "npcs/present/threekid/threekid-idle.drc"], animationsOptions: [{ speed: .9 }, { speed: .9 }, { speed: .9 }, { speed: .9 }], texts: ["Zdravstvuyte.", "Slyshali o takoy veschi, kak three.js?", "Nu... bolshinstvo lyudey ne znaet o 3D-opyte.", "Eto vid iskusstva, obedinyayuschiy tvorchestvo i tekhnologii.", "Eto kak risovanie, tolko kodom!"], alwaysFaceCharacter: !1, talkFacingPlayer: !1, position: [30.0128, 18.6118, -4.71063], rotation: [math.radians(-194.873), math.radians(-5.41632), math.radians(241.095)], textsBubblesOffset: [0, .4, 0], visibilityThreshold: 20, extraData: { name: "Studentka BFU", color: "#66BDE6", voice: "female3" } })), this.npcs.push(new npc(this, { id: "factory-worker-a", modelURL: "npcs/present/factory-worker-a/factory-worker-a.drc", bonesURL: "npcs/present/factory-worker-a/factory-worker-a-bones.drc", animations: ["npcs/present/factory-worker-a/factory-worker-a-idle.drc", "npcs/present/factory-worker-a/factory-worker-a-idle.drc", "npcs/present/factory-worker-a/factory-worker-a-idle.drc", "npcs/present/factory-worker-a/factory-worker-a-idle.drc"], animationsOptions: [{ speed: 1 }, { speed: 1 }, { speed: 1 }, { speed: 1 }], texts: ["Gruzy prikhodyat... sanktsionka ukhodit..."], alwaysFaceCharacter: !1, talkFacingPlayer: !0, position: [4.16546, 4.2699, -23.5919], rotation: [math.radians(-108.186), math.radians(-253.3), math.radians(27.7728)], textsBubblesOffset: [0, .6, 0], visibilityThreshold: 20, icon: !0, iconOffset: [0, .1, 0], extraData: { name: "Rabochiy vagonozavoda", color: "#66BDE6", voice: "male1" } })), this.npcs.push(new npc(this, { id: "factory-worker-b", modelURL: "npcs/present/factory-worker-b/factory-worker-b.drc", bonesURL: "npcs/present/factory-worker-b/factory-worker-b-bones.drc", animations: ["npcs/present/factory-worker-b/factory-worker-b-walk.drc", "npcs/present/factory-worker-b/factory-worker-b-talk.drc", "npcs/present/factory-worker-b/factory-worker-b-walk.drc", "npcs/present/factory-worker-b/factory-worker-b-walk.drc"], animationsOptions: [{ speed: 1 }, { speed: 1 }, { speed: 1 }, { speed: 1 }], curve: "npcs/present/factory-worker-b/curve-1.drc", curveSpeed: .52, curveProgress: 0, curveSpeedAnimationWeight: 1, texts: ["Novenkiy opyat opozdal iz-za probki na dvukhyarusnom."], alwaysFaceCharacter: !1, talkFacingPlayer: !1, position: [27.9744, 1.40907, .538691], rotation: [0, 0, math.radians(-88.6297)], textsBubblesOffset: [0, .6, .1], visibilityThreshold: 20, extraData: { name: "Tengo", color: "#66BDE6", voice: "male1" } })), this.npcs.push(new npc(this, { id: "female-scientist", modelURL: "npcs/present/female-scientist/female-scientist.drc", bonesURL: "npcs/present/female-scientist/female-scientist-bones.drc", animations: ["npcs/present/female-scientist/female-scientist-idle.drc", "npcs/present/female-scientist/female-scientist-idle.drc", "npcs/present/female-scientist/female-scientist-idle.drc", "npcs/present/female-scientist/female-scientist-idle.drc"], animationsOptions: [{ speed: 1 }, { speed: 1 }, { speed: 1 }, { speed: 1 }], texts: ["We'ut nado postroit torgovyy tsentr... i zdes tozhe..."], alwaysFaceCharacter: !1, talkFacingPlayer: !1, position: [-7.46008, -7.60516, -19.6894], rotation: [math.radians(-181.522), math.radians(-289.583), math.radians(72.0513)], textsBubblesOffset: [0, .6, 0], visibilityThreshold: 20, icon: !0, iconOffset: [0, .1, 0], extraData: { name: "Doktor Frebi (ili Kant?)", color: "#66BDE6", voice: "female1" } })), this.npcs.push(new npc(this, { id: "factory-worker-c", modelURL: "npcs/present/factory-worker-c/factory-worker-c.drc", bonesURL: "npcs/present/factory-worker-c/factory-worker-c-bones.drc", animations: ["npcs/present/factory-worker-c/factory-worker-c-idle.drc", "npcs/present/factory-worker-c/factory-worker-c-idle.drc", "npcs/present/factory-worker-c/factory-worker-c-idle.drc", "npcs/present/factory-worker-c/factory-worker-c-idle.drc"], animationsOptions: [{ speed: 1 }, { speed: 1 }, { speed: 1 }, { speed: 1 }], talkEnabled: !1, texts: [""], alwaysFaceCharacter: !1, talkFacingPlayer: !1, position: [-7.33081, -8.43986, -19.3465], rotation: [math.radians(-214.607), math.radians(-292.8), math.radians(99.0508)], textsBubblesOffset: [0, .6, 0], visibilityThreshold: 20, extraData: { name: "Getave", color: "#66BDE6", voice: "male1" } })), this.npcs.push(new npc(this, { id: "alien", modelURL: "npcs/present/alien/alien.drc", bonesURL: "npcs/present/alien/alien-bones.drc", animations: ["npcs/present/alien/alien-idle.drc", "npcs/present/alien/alien-idle.drc", "npcs/present/alien/alien-idle.drc", "npcs/present/alien/alien-idle.drc"], animationsOptions: [{ speed: 1 }, { speed: 1 }, { speed: 1 }, { speed: 1 }], texts: ["Kazhetsya, ya gde-to tebya videl..."], alwaysFaceCharacter: !1, talkFacingPlayer: !1, position: [-12.6363, 17.6926, -5.86315], rotation: [math.radians(-240.935), math.radians(-412.19), math.radians(125.999)], textsBubblesOffset: [0, -.35, -.7], visibilityThreshold: 15, extraData: { name: "Turist iz Moskvy", color: "#66BDE6", voice: "wtf" } })), this.npcs.push(new npc(this, { id: "male-scientist", modelURL: "npcs/present/male-scientist/male-scientist.drc", bonesURL: "npcs/present/male-scientist/male-scientist-bones.drc", animations: ["npcs/present/male-scientist/male-scientist-idle.drc", "npcs/present/male-scientist/male-scientist-idle.drc", "npcs/present/male-scientist/male-scientist-idle.drc", "npcs/present/male-scientist/male-scientist-idle.drc"], animationsOptions: [{ speed: 1 }, { speed: 1 }, { speed: 1 }, { speed: 1 }], texts: ["Posmotrim... Snachala mne nuzhno vychislit radius velosipednogo kolesa..."], alwaysFaceCharacter: !1, talkFacingPlayer: !1, position: [10.8494, 23.3367, -7.73384], rotation: [math.radians(-26.3333), math.radians(-568.175), math.radians(25.2803)], textsBubblesOffset: [0, .65, .2], visibilityThreshold: 20, icon: !0, iconOffset: [0, .05, .1], extraData: { name: "Professor Immanuil", color: "#66BDE6", voice: "male3" } })), this.npcs.push(new npc(this, { id: "diver", modelURL: "npcs/present/diver/diver.drc", bonesURL: "npcs/present/diver/diver-bones.drc", animations: ["npcs/present/diver/diver-idle.drc", "npcs/present/diver/diver-talk.drc", "npcs/present/diver/diver-talk-idle.drc", "npcs/present/diver/diver-idle.drc"], animationsOptions: [{ speed: 1 }, { speed: 1 }, { speed: 1 }, { speed: 1 }], texts: ["Nu zhe... otkryvaysya..."], alwaysFaceCharacter: !1, talkFacingPlayer: !1, position: [15.8793, 16.9006, 11.2543], rotation: [math.radians(27.0449), math.radians(-548.584), math.radians(36.7925)], textsBubblesOffset: [0, -.2, .4], lookatOffset: [0, -.5, 0], visibilityThreshold: 20, icon: !0, iconOffset: [0, -.65, .3], talkDistance: 2.2, extraData: { name: "Kapitan Stepan", color: "#de794e", voice: "male3" } })), this.npcs.push(new npc(this, { id: "mountainman", modelURL: "npcs/present/mountainman/mountainman.drc", bonesURL: "npcs/present/mountainman/mountainman-bones.drc", animations: ["npcs/present/mountainman/mountainman-idle.drc", "npcs/present/mountainman/mountainman-idle.drc", "npcs/present/mountainman/mountainman-idle.drc", "npcs/present/mountainman/mountainman-idle.drc"], animationsOptions: [{ speed: 1 }, { speed: 1 }, { speed: 1 }, { speed: 1 }], texts: ["Slyshish etot zvuk? Tishina...", "Nu, eschyo kolokolchiki na vetru, no v osnovnom tishina..."], alwaysFaceCharacter: !1, talkFacingPlayer: !1, position: [-8.17226, 32.3472, -1.76941], rotation: [math.radians(22.0663), math.radians(-603.63), math.radians(-31.9016)], textsBubblesOffset: [0, -.2, 0], lookatOffset: [0, -.5, 0], visibilityThreshold: 20, icon: !0, iconOffset: [0, -.8, 0], extraData: { name: "Paren s Kurshskoy", color: "#8cc48c", voice: "male3" } })), this.npcs.push(new npc(this, { id: "oldwoman", modelURL: "npcs/present/oldwoman/oldwoman.drc", bonesURL: "npcs/present/oldwoman/oldwoman-bones.drc", animations: ["npcs/present/oldwoman/oldwoman-idle.drc", "npcs/present/oldwoman/oldwoman-idle.drc", "npcs/present/oldwoman/oldwoman-idle.drc", "npcs/present/oldwoman/oldwoman-idle.drc"], animationsOptions: [{ speed: 1 }, { speed: 1 }, { speed: 1 }, { speed: 1 }], texts: ["Spasibo za dostavku podnosheniya Khomlinam."], alwaysFaceCharacter: !1, talkFacingPlayer: !1, position: [23.3711, -16.514, 12.462], rotation: [math.radians(100.498), math.radians(-564.362), math.radians(62.4696)], textsBubblesOffset: [0, .3, 0], lookatOffset: [0, 0, 0], visibilityThreshold: 20, icon: !0, iconOffset: [0, .2, 0], extraData: { name: "Babulya", color: "#8cc48c", voice: "female1" } })), this.npcs.push(new npc(this, { id: "musician", modelURL: "npcs/present/musician/musician.drc", bonesURL: "npcs/present/musician/musician-bones.drc", animations: ["npcs/present/musician/musician-idle.drc", "npcs/present/musician/musician-talk.drc", "npcs/present/musician/musician-idle.drc", "npcs/present/musician/musician-idle.drc"], animationsOptions: [{ speed: 1 }, { speed: 1 }, { speed: 1 }, { speed: 1 }], texts: ["Have you heard this one before?"], alwaysFaceCharacter: !1, talkFacingPlayer: !1, position: [15.0288, -14.7864, -7.09569], rotation: [math.radians(-194.842), math.radians(-580.277), math.radians(55.2642)], textsBubblesOffset: [0, .4, 0], lookatOffset: [0, -.5, 0], visibilityThreshold: 20, icon: !0, iconOffset: [0, -.1, 0], extraData: { name: "Denis Labukh", color: "#de794e", voice: "male2" } })), this.npcs.push(new npc(this, { id: "fox", modelURL: "npcs/present/fox/fox.drc", bonesURL: "npcs/present/fox/fox-bones.drc", animations: ["npcs/present/fox/fox-idle.drc", "npcs/present/fox/fox-idle.drc", "npcs/present/fox/fox-idle.drc", "npcs/present/fox/fox-idle.drc"], animationsOptions: [{ speed: 1 }, { speed: 1 }, { speed: 1 }, { speed: 1 }], talkEnabled: !1, texts: [""], alwaysFaceCharacter: !1, talkFacingPlayer: !1, position: [-8.36976, -20.368, 10.0339], rotation: [math.radians(224.014), math.radians(-796.511), math.radians(56.1696)], textsBubblesOffset: [0, .6, 0], visibilityThreshold: 20, extraData: { name: "Lis", color: "#66BDE6", voice: "male1" } })), this.npcs.push(new npc(this, { id: "owl", modelURL: "npcs/present/owl/owl.drc", bonesURL: "npcs/present/owl/owl-bones.drc", animations: ["npcs/present/owl/owl-idle.drc", "npcs/present/owl/owl-idle.drc", "npcs/present/owl/owl-idle.drc", "npcs/present/owl/owl-idle.drc"], animationsOptions: [{ speed: 1 }, { speed: 1 }, { speed: 1 }, { speed: 1 }], talkEnabled: !1, texts: [""], alwaysFaceCharacter: !1, talkFacingPlayer: !1, position: [-12.6002, -22.7506, -2.19052], rotation: [math.radians(544.177), math.radians(-551.047), math.radians(-23.0782)], textsBubblesOffset: [0, .6, 0], visibilityThreshold: 20, extraData: { name: "Sova", color: "#66BDE6", voice: "male1" } })), await Promise.all(this.npcs.map(e => e.ready)) } initQuests() { this.questsController = new questsController(this) } playInAnimation() { const e = this.npcs.find(i => { var s; return ((s = i.mesh) == null ? void 0 : s._id) === "musician" }); return e && events.emit("webgl_play_positional", "dialogue-music-dave", e.mesh, .1, 0, !1), events.on("npc_talk_update", ({ id: i, object: s, talking: a }) => { i === "musician" && (a ? events.emit("webgl_stop_positional", "dialogue-music-dave") : events.emit("webgl_play_positional", "dialogue-music-dave", s, .1, 0, !1)) }), super.playInAnimation() } } const _obj$1 = new Object3D, _obj2 = new Object3D, mapping = [{ accessory: "shoes", action: -1 }, { accessory: "shoes", action: 1 }, { accessory: "bottom", action: -1 }, { accessory: "bottom", action: 1 }, { accessory: "top", action: -1 }, { accessory: "top", action: 1 }, { accessory: "hair", action: -1 }, { accessory: "hair", action: 1 }], size = .175, baseGeo1 = new PlaneGeometry(size, size), baseGeo2 = new PlaneGeometry(size, size), baseGeo = mergeGeometries([baseGeo1, baseGeo2]); baseGeo.setAttribute("side", new BufferAttribute(new Int32Array([1, 1, 1, 1, 0, 0, 0, 0]), 1)); baseGeo.setAttribute("vertid", new BufferAttribute(new Int32Array([1, 2, 3, 4, 1, 2, 3, 4]), 1)); class traitarrows {
    constructor(e) { this.scene = e, this.shown = !1, this.lastTouched = 0, this.offsetX = .5, this.offsetXArrow = .5075, this.baseY = .1, this.offsetY = .46, this.closeY = 1.9, this.ready = miscutils.deferred(), this.init() } async init() {
        const e = new InstancedBufferGeometry; e.instanceCount = 9; for (const _ in baseGeo.attributes) e.setAttribute(_, baseGeo.attributes[_]); e.setIndex(baseGeo.index), e.setAttribute("hover", new InstancedBufferAttribute(new Float32Array(e.instanceCount).fill(0), 1)), e.setAttribute("scaleHover", new InstancedBufferAttribute(new Float32Array(e.instanceCount).fill(1), 1)), e._animObjs = []; for (let _ = 0; _ < e.instanceCount; _++)e._animObjs.push({ hover: 0, scaleHover: 1 }); const i = new ShaderMaterial({
            uniformsGroups: [global$1.UBO], uniforms: { uColor: { value: new Color("#F8F8F8") }, uColorShadow: { value: new Color("#647A87") }, uSeed: { value: Math.random() }, uShow: { value: 0 }, uShadowOffset: { value: .01175 } }, vertexShader: `
                attribute float hover;
                attribute float scaleHover;
                attribute int side;
                attribute int vertid;

                ${globalUBO_default}
                ${matrixutils_default}
                ${falloff_default}

                uniform float uSeed;
                uniform float uShow;
                uniform float uShadowOffset;
                uniform vec3 uColor;
                uniform vec3 uColorShadow;

                varying vec2 vUv;
                flat varying vec3 vColor;

                void main() {
                    vUv = uv;
                    vColor = uColor;

                    vec3 localPos = position;

                    float insID = float(gl_InstanceID);
                    float instanceSeed = fract((uSeed + hover) * 54.32 + insID * 45.54352 + float(vertid) * 31.2344);
                    float offset = (instanceSeed * 2.0 - 1.0) * 0.0125;
                    vec3 dir = normalize(vec3(position.xy, 0.0));
                    localPos += dir * offset;

                    float scaleShow = falloff(insID, 0.0, ${e.instanceCount.toFixed(1)}, 5.0, uShow);
                    float steps = floor(2.0 + fract(uSeed * 4.35452 + insID * 23.546) * 3.0);
                    float scaleShowStepped = floor(scaleShow * steps) / steps;

                    localPos.xy *= scaleHover * scaleShowStepped;

                    if (side == 1) {
                        float offsetScale = scaleHover == 1.0 ? 1.0 : 0.4;
                        localPos.xy += uShadowOffset * vec2(1.0, -1.0) * offsetScale;
                        vColor = uColorShadow;
                    }

                    vec4 pos = instanceMatrix * vec4(localPos, 1.0);
                    gl_Position = projectionMatrix * modelViewMatrix * pos;
                }
            `, fragmentShader: `
                varying vec2 vUv;
                flat varying vec3 vColor;

                void main() {
                    gl_FragColor = vec4(vColor, 1.0);
                }
            `, depthWrite: !1, depthTest: !1
        }); this.geo = e, this.mesh = new InstancedMesh(e, i, e.instanceCount), this.mesh.name = "trait squares", this.mesh.frustumCulled = !1, this.mesh.visible = !1, this.mesh.renderOrder = -10; const [s, a, o, l, c, h] = await Promise.all([glyphLoader.loadTexture("ui/cross.icon", "band"), glyphLoader.loadTexture("ui/cross.icon", "curve"), glyphLoader.loadTexture("ui/arrow.icon", "band"), glyphLoader.loadTexture("ui/arrow.icon", "curve"), glyphLoader.loadGeometry("ui/cross.icon", { size: .115 }), glyphLoader.loadGeometry("ui/arrow.icon", { size: .115 })]), d = new ShaderMaterial({
            uniformsGroups: [global$1.UBO], uniforms: { tCurve: { value: a }, tBand: { value: s }, uPosY: { value: this.closeY }, uScale: { value: 1 }, uHover: { value: 1 }, uShow: { value: 0 } }, vertexShader: `
                uniform float uHover;
                uniform float uPosY;
                uniform float uShow;
                uniform float uScale;

                ${globalUBO_default}
                ${falloff_default}
                ${slugvs_default}

                varying vec2 vUv;

                void main() {
                    vUv = uv;

                    float last = ${e.instanceCount.toFixed(1)};
                    float scaleShow = falloff(last, 0.0, last, 5.0, uShow);
                    float scaleShowStepped = floor(scaleShow * 3.0) / 3.0;

                    vec3 pos = SlugVS() * 0.95 * uScale * vec3(vec2(uHover), 1.0) * scaleShowStepped + vec3(0.0, uPosY, 0.0);

                    // apply scale and
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);;
                }
            `, fragmentShader: `
                varying vec2 vUv;

                ${slugfs_default}

                uniform sampler2D tCurve;
                uniform usampler2D tBand;

                void main() {
                    vec4 color = RenderSlug(tCurve, tBand, vTexCoord, vColor, vBanding, vGlyph);

                    if (color.w * vColor.w < 0.001) discard;
                    gl_FragColor = vec4(color.xyz, 1.0);
                }
            `, depthWrite: !1, depthTest: !1
        }); this.meshClose = new Mesh(c, d), this.meshClose.name = "trait close", this.meshClose.frustumCulled = !1, this.meshClose.visible = !1, this.meshClose.renderOrder = -5; const p = new InstancedBufferGeometry; p.instanceCount = 8; for (const _ in h.attributes) p.setAttribute(_, h.attributes[_]); p.setIndex(h.index), p.setAttribute("hover", new InstancedBufferAttribute(new Float32Array(e.instanceCount).fill(1), 1)), this.arrowGeo = p; const f = new ShaderMaterial({
            uniformsGroups: [global$1.UBO], uniforms: { tCurve: { value: l }, tBand: { value: o }, uSeed: { value: Math.random() }, uShow: { value: 0 } }, vertexShader: `
                attribute float hover;

                uniform float uSeed;
                uniform float uShow;

                ${globalUBO_default}
                ${rotate_default}
                ${falloff_default}
                ${slugvs_default}

                varying vec2 vUv;

                void main() {
                    vUv = uv;

                    mat4 imvpMatrix = projectionMatrix * modelViewMatrix * instanceMatrix;
                    vec3 pos = SlugVS(imvpMatrix) * vec3(vec2(hover), 1.0);
                    if (gl_InstanceID % 2 == 0) pos *= rotateZ(3.1416);

                    float insID = float(gl_InstanceID);
                    float scaleShow = falloff(insID, 0.0, ${e.instanceCount.toFixed(1)}, 5.0, uShow);
                    float steps = floor(2.0 + fract(uSeed * 45.35452 + insID * 2.546) * 3.0);
                    float scaleShowStepped = floor(scaleShow * steps) / steps;
                    pos *= scaleShowStepped;

                    gl_Position = imvpMatrix * vec4(pos, 1.0);;
                }
            `, fragmentShader: `
                varying vec2 vUv;

                ${slugfs_default}

                uniform sampler2D tCurve;
                uniform usampler2D tBand;

                void main() {
                    vec4 color = RenderSlug(tCurve, tBand, vTexCoord, vColor, vBanding, vGlyph);

                    if (color.w * vColor.w < 0.001) discard;
                    gl_FragColor = vec4(color.xyz, 1.0);
                }
            `, depthWrite: !1, depthTest: !1
        }); this.meshArrow = new InstancedMesh(p, f, p.instanceCount), this.meshArrow.name = "trait arrows", this.meshArrow.frustumCulled = !1, this.meshArrow.visible = !1, this.meshArrow.renderOrder = -5, this.resize(), this.scene.beforeRenderCbs.push(() => { var x, b, T; const _ = (T = (b = (x = this.scene.controller) == null ? void 0 : x.planetScene) == null ? void 0 : b.characters) == null ? void 0 : T.mesh; _ && (this.mesh.position.copy(_._localObject.position), this.mesh.quaternion.copy(this.scene.camera.quaternion), this.meshArrow.position.copy(_._localObject.position), this.meshArrow.quaternion.copy(this.scene.camera.quaternion), this.meshClose.position.copy(_._localObject.position), this.meshClose.quaternion.copy(this.scene.camera.quaternion)) }), this.interaction = new meshInteraction({ camera: this.scene.camera, meshes: [this.mesh], hoverCursor: !0, onHover: this.hover.bind(this), onTouch: this.touch.bind(this), onClick: this.click.bind(this) }), events.on("character_change_traits_show", this.show, this), events.on("character_change_traits_hide", this.hide, this), events.on("end_screen_show", () => { this.hide(!1) }), events.on("keydown", this.onKey, this), this.scene.add(this.mesh), this.scene.add(this.meshClose), this.scene.add(this.meshArrow), this.ready.resolve()
    } show() { var e, i, s; this.shown || !((s = (i = (e = this.scene.controller) == null ? void 0 : e.planetScene) == null ? void 0 : i.characters) != null && s.mesh) || this.scene.controller.planetScene.characters.isCameraLockingInteractingElement() || this.scene.controller.planetScene.characters.mesh._collisionPhysics._isOnFloor === !1 || this.scene.controller.planetScene.camera.overwriteAmount > 0 || (this.shown = !0, this.scene.controller.planetScene.characters.mesh.interactingElement = "self", this.mesh.material.uniforms.uSeed.value = Math.random(), createTween(this.mesh.material.uniforms.uShow, { to: { value: 1 }, duration: .55, delay: .25, ease: "none", onStart: () => { this.mesh.visible = !0, this.meshClose.visible = !0, this.meshArrow.visible = !0 }, onUpdate: () => { this.meshClose.material.uniforms.uShow.value = this.mesh.material.uniforms.uShow.value, this.meshArrow.material.uniforms.uShow.value = this.mesh.material.uniforms.uShow.value } }), this.interaction.enable(), events.emit("webgl_play_audio", "nastroit"), events.emit("character_change_traits_shown")) } hide(e = !0) { this.shown && (this.shown = !1, this.scene.controller.planetScene.characters.mesh.interactingElement = null, createTween(this.mesh.material.uniforms.uShow, { to: { value: 0 }, duration: .5, delay: 0, ease: "none", onUpdate: () => { this.meshClose.material.uniforms.uShow.value = this.mesh.material.uniforms.uShow.value, this.meshArrow.material.uniforms.uShow.value = this.mesh.material.uniforms.uShow.value }, onComplete: () => { this.mesh.visible = !1, this.meshClose.visible = !1, this.meshArrow.visible = !1 } }), this.interaction.disable(), events.emit("webgl_stop_audio", "nastroit"), e && events.emit("character_change_traits_hiddden")) } hover(e) { if (e.action !== "hover_in") return; const i = e.interactions[0].instanceId, s = this.mesh.geometry._animObjs[i], a = Math.random() * 22.34, o = Math.random() * 3.34; createTween(s, { from: { hover: 0 }, to: { hover: 1 }, duration: .07, ease: "none", onStart: () => { this.mesh.geometry.attributes.hover.setX(i, a), this.mesh.geometry.attributes.hover.needsUpdate = !0, i === this.geo.instanceCount - 1 ? this.meshClose.material.uniforms.uHover.value = .935 : (this.meshArrow.geometry.attributes.hover.setX(i, .935), this.meshArrow.geometry.attributes.hover.needsUpdate = !0) }, onComplete: () => { this.mesh.geometry.attributes.hover.setX(i, o), this.mesh.geometry.attributes.hover.needsUpdate = !0, i === this.geo.instanceCount - 1 ? this.meshClose.material.uniforms.uHover.value = 1 : (this.meshArrow.geometry.attributes.hover.setX(i, 1), this.meshArrow.geometry.attributes.hover.needsUpdate = !0) } }), createTween(s, { from: { scaleHover: 0 }, to: { scaleHover: 1 }, duration: .07, ease: "none", onStart: () => { this.mesh.geometry.attributes.scaleHover.setX(i, 1.1), this.mesh.geometry.attributes.scaleHover.needsUpdate = !0 }, onComplete: () => { this.mesh.geometry.attributes.scaleHover.setX(i, 1), this.mesh.geometry.attributes.scaleHover.needsUpdate = !0 } }), events.emit("webgl_play_audio", "hover2") } touch(e) { var a; (a = e.interactions) != null && a.length && (this.lastTouched = e.interactions[0].instanceId); const i = e.action === "touch_start", s = this.mesh.geometry._animObjs[this.lastTouched]; createTween(s, { to: { scaleHover: 1 }, duration: 0, ease: "none", onComplete: () => { this.mesh.geometry.attributes.scaleHover.setX(this.lastTouched, i ? .925 : 1), this.mesh.geometry.attributes.scaleHover.needsUpdate = !0, this.lastTouched === this.geo.instanceCount - 1 ? this.meshClose.material.uniforms.uHover.value = i ? .9 : 1 : (this.meshArrow.geometry.attributes.hover.setX(this.lastTouched, i ? .9 : 1), this.meshArrow.geometry.attributes.hover.needsUpdate = !0) } }), createTween(s, { to: { hover: 1 }, duration: 0, ease: "none", onComplete: () => { this.mesh.geometry.attributes.hover.setX(this.lastTouched, Math.random() * 43.23), this.mesh.geometry.attributes.hover.needsUpdate = !0 } }), events.emit("webgl_play_audio", `click${i ? 2 : 3}`) } click(e) { const i = e.interactions[0].instanceId; if (i === this.geo.instanceCount - 1) return this.hide(); const { accessory: s, action: a } = mapping[i], o = Object.keys(ACCESSORIES), l = [...client$1.localStorage.modelFiles], c = o.indexOf(s), h = l[c], d = ACCESSORIES[s].indexOf(h); if (d === -1) return; let p = d + a; p < 0 ? p = ACCESSORIES[s].length - 1 : p = p % ACCESSORIES[s].length, l[c] = ACCESSORIES[s][p], this.scene.controller.planetScene.characters.setAccessories(l.filter(f => f !== "base")) } onKey(e) { e.code === "KeyL" ? this[this.shown ? "hide" : "show"]() : e.code === "Escape" && this.hide() } resize() { const e = this.scene.aspect > 1, i = e ? this.offsetX : this.offsetX * .875, s = e ? this.offsetXArrow : this.offsetXArrow * .875, a = math.lerp(1, 1300 / client$1.screen.h, .3), o = 9; for (let l = 0; l < o; l++)l === o - 1 ? (_obj$1.position.set(0, this.closeY, 0), _obj$1.scale.setScalar(1.15 * a)) : (_obj$1.position.set(i * (l % 2 === 0 ? -1 : 1), this.baseY + Math.floor(l / 2) * this.offsetY, 0), _obj$1.scale.setScalar(1 * a), _obj2.position.set(s * (l % 2 === 0 ? -1 : 1), this.baseY + Math.floor(l / 2) * this.offsetY, 0), _obj2.scale.setScalar(1 * a)), _obj$1.updateMatrix(), _obj2.updateMatrix(), this.mesh.setMatrixAt(l, _obj$1.matrix), l < o - 1 && this.meshArrow.setMatrixAt(l, _obj2.matrix); this.meshClose.material.uniforms.uScale.value = a, this.mesh.material.uniforms.uShadowOffset.value = .01175 * a, this.mesh.computeBoundingBox(), this.mesh.computeBoundingSphere(), this.mesh.instanceMatrix.needsUpdate = !0, this.meshArrow.instanceMatrix.needsUpdate = !0 }
} class scene3D extends scene { constructor(e = {}) { super(), this.controller = e.mainController, this.globalUI = e.globalUI, this.aspect = 1, this.controller ? this.init() : this.isReady() } async init() { this.cameraOptions(), await Promise.all([this.createTraitArrows()]), this.resize(), events.on("resize", this.resize, this), client$1.devScene && this.debug(), this.isReady() } cameraOptions() { this.camera.lerpPosition = 0, this.camera.lerpTarget = 0, this.camera.lerpRotation = 0, this.beforeRenderCbs.push(() => { var e; (e = this.controller) != null && e.planetScene && (this.camera.copy(this.controller.planetScene.camera, !1), this.camera.updateMatrixWorld(), this.camera.updateProjectionMatrix()) }) } async createTraitArrows() { this.traitArrows = new traitarrows(this), await this.traitArrows.ready } resize() { this.aspect = client$1.screen.w / client$1.screen.h, [this.traitArrows].forEach(e => { e.resize() }) } } const _obj = new Object3D; class sideButtons {
    constructor(e) { this.scene = e, this.ready = miscutils.deferred(), this.lastSize = 2, this.sizeIcons = [.475, .675, .675, .525, .65], this.shown = !1, this.init() } async init() {
        const e = this.scene.squareGeo2.clone(), i = new InstancedBufferGeometry; i.instanceCount = 4; for (const T in e.attributes) i.setAttribute(T, e.attributes[T]); i.setIndex(e.index), i.setAttribute("hover", new InstancedBufferAttribute(new Float32Array(i.instanceCount).fill(0), 1)), i.setAttribute("scaleHover", new InstancedBufferAttribute(new Float32Array(i.instanceCount).fill(1), 1)), i._animObjs = []; for (let T = 0; T < i.instanceCount; T++)i._animObjs.push({ hover: 0, scaleHover: 1 }); const s = new DataTexture(new Float32Array(4 * 4), 4, 1, RGBAFormat, FloatType); s.needsUpdate = !0; const a = new ShaderMaterial({
            uniformsGroups: [global$1.UBO], uniforms: { uColor: { value: new Color("#F8F8F8") }, uColorShadow: { value: new Color("#647A87") }, tBatchedInfo: { value: s }, uSeed: { value: Math.random() }, uShow: { value: client$1.devScene ? 1 : 0 }, uShadowOffset: { value: 5.5 } }, vertexShader: `
                attribute float hover;
                attribute float scaleHover;
                attribute int side;
                attribute int vertid;

                ${globalUBO_default}
                ${matrixutils_default}
                ${falloff_default}

                uniform float uSeed;
                uniform float uShow;
                uniform float uShadowOffset;
                uniform vec3 uColor;
                uniform vec3 uColorShadow;

                varying vec2 vUv;
                flat varying vec3 vColor;

                void main() {
                    vUv = uv;
                    vColor = uColor;

                    vec3 localPos = position;

                    float insID = float(gl_InstanceID);
                    float instanceSeed = fract((uSeed + hover) * 54.32 + insID * 45.54352 + float(vertid) * 31.2344);
                    float offset = (instanceSeed * 2.0 - 1.0) * 0.065;
                    vec3 dir = normalize(vec3(position.xy, 0.0));
                    localPos += dir * offset;

                    float scaleShow = falloff(insID, 0.0, ${i.instanceCount.toFixed(1)}, 1.0, uShow);
                    float steps = floor(2.0 + fract(uSeed * 4.35452 + insID * 23.546) * 3.0);
                    float scaleShowStepped = floor(scaleShow * steps) / steps;

                    localPos.xy *= scaleHover * scaleShowStepped;

                    if (side == 1) {
                        vec3 scale = getMatrixScale(instanceMatrix);
                        float offsetScale = scaleHover == 1.0 ? 1.0 : 0.4;
                        localPos.xy += (uShadowOffset / scale.x) * vec2(1.0, -1.0) * offsetScale;
                        vColor = uColorShadow;
                    }

                    vec4 pos = instanceMatrix * vec4(localPos, 1.0);
                    gl_Position = projectionMatrix * modelViewMatrix * pos;
                }
            `, fragmentShader: `
                varying vec2 vUv;
                flat varying vec3 vColor;

                void main() {
                    gl_FragColor = vec4(vColor, 1.0);
                }
            `, depthWrite: !1, depthTest: !1
        }); this.geo = i, this.mesh = new InstancedMesh(i, a, i.instanceCount), this.mesh.name = "sidebutton squares", this.mesh.frustumCulled = !1, this.mesh.visible = !!client$1.devScene, this.mesh.renderOrder = 0, this.mesh.matrixAutoUpdate = !1; const o = [];["list", "sound", "sound-muted", "t-shirt", "poo"].forEach((T, M) => { o.push(Promise.all([glyphLoader.loadTexture(`ui/sidebuttons/${T}.icon`, "band"), glyphLoader.loadTexture(`ui/sidebuttons/${T}.icon`, "curve"), glyphLoader.loadGeometry(`ui/sidebuttons/${T}.icon`, { size: 1 })])) }); const [c, h, d, p, f] = await Promise.all(o), _ = [c[2], h[2], d[2], p[2], f[2]], x = _.reduce((T, M) => T + M.attributes.position.count, 0), b = _.reduce((T, M) => T + M.index.count, 0); this.meshIcons = new BatchedMesh(_.length, x, b, new ShaderMaterial({
            name: "side-icons", userData: { hotReload: "side-icons" }, uniformsGroups: [global$1.UBO], uniforms: { uShow: { value: client$1.devScene ? 1 : 0 }, uSeed: { value: Math.random() }, tBands1: { value: c[0] }, tCurves1: { value: c[1] }, tBands2: { value: h[0] }, tCurves2: { value: h[1] }, tBands3: { value: d[0] }, tCurves3: { value: d[1] }, tBands4: { value: p[0] }, tCurves4: { value: p[1] }, tBands5: { value: f[0] }, tCurves5: { value: f[1] } }, vertexShader: `
                /* BATCHING */
                #if ! defined(GL_ANGLE_multi_draw)
                    #define gl_DrawID _gl_DrawID
                    uniform int _gl_DrawID;
                #endif
                uniform highp sampler2D batchingTexture;
                uniform highp usampler2D batchingIdTexture;

                mat4 getBatchingMatrix(const in int i) {
                    int size = textureSize(batchingTexture, 0).x;
                    int j = i * 4;
                    int x = j % size;
                    int y = j / size;
                    vec4 v1 = texelFetch(batchingTexture, ivec2(x, y), 0);
                    vec4 v2 = texelFetch(batchingTexture, ivec2(x + 1, y), 0);
                    vec4 v3 = texelFetch(batchingTexture, ivec2(x + 2, y), 0);
                    vec4 v4 = texelFetch(batchingTexture, ivec2(x + 3, y), 0);
                    return mat4(v1, v2, v3, v4);
                }

                float getIndirectIndex(const in int i) {
                    int size = textureSize(batchingIdTexture, 0).x;
                    int x = i % size;
                    int y = i / size;
                    return float(texelFetch(batchingIdTexture, ivec2(x, y), 0).r);
                }

                uniform float uShow;
                uniform float uSeed;

                varying vec2 vUv;
                flat varying int vBatchID;

                ${globalUBO_default}
                ${slugvs_default}
                ${falloff_default}

                void main() {
                    vUv = uv;

                    float batchID = getIndirectIndex(gl_DrawID);
                    vBatchID = int(batchID);
                    mat4 batchingMatrix = getBatchingMatrix(vBatchID);

                    mat4 bmvpMatrix = projectionMatrix * modelViewMatrix * batchingMatrix;
                    vec3 pos = SlugVS(bmvpMatrix);

                    float scaleShow = falloff(batchID, 0.0, ${_.length.toFixed(1)}, 5.0, uShow);
                    float steps = floor(2.0 + fract(uSeed * 45.35452 + batchID * 2.546) * 3.0);
                    float scaleShowStepped = floor(scaleShow * steps) / steps;
                    pos *= scaleShowStepped;

                    gl_Position = bmvpMatrix * vec4(pos, 1.0);
                }
            `, fragmentShader: `

                // thanks android
                uniform sampler2D tCurves1;
                uniform usampler2D tBands1;
                uniform sampler2D tCurves2;
                uniform usampler2D tBands2;
                uniform sampler2D tCurves3;
                uniform usampler2D tBands3;
                uniform sampler2D tCurves4;
                uniform usampler2D tBands4;
                uniform sampler2D tCurves5;
                uniform usampler2D tBands5;

                ${slugfs_default}

                varying vec2 vUv;
                flat varying int vBatchID;

                void main() {
                    vec4 color;

                    if (vBatchID == 0) {
                        color = RenderSlug(tCurves1, tBands1, vTexCoord, vColor, vBanding, vGlyph);
                    } else if (vBatchID == 1) {
                        color = RenderSlug(tCurves2, tBands2, vTexCoord, vColor, vBanding, vGlyph);
                    } else if (vBatchID == 2) {
                        color = RenderSlug(tCurves3, tBands3, vTexCoord, vColor, vBanding, vGlyph);
                    } else if (vBatchID == 3) {
                        color = RenderSlug(tCurves4, tBands4, vTexCoord, vColor, vBanding, vGlyph);
                    } else if (vBatchID == 4) {
                        color = RenderSlug(tCurves5, tBands5, vTexCoord, vColor, vBanding, vGlyph);
                    }

                    if (color.w * vColor.w < 0.001) discard;

                    gl_FragColor = vec4(color.rgb, 1.0);
                }
            `})), this.meshIcons.name = "sidebutton icons", this.meshIcons.sortObjects = !1, this.meshIcons.receiveShadow = !1, this.meshIcons.castShadow = !1, this.meshIcons.frustumCulled = !1, this.meshIcons.perObjectFrustumCulled = !1, this.meshIcons.visible = !!client$1.devScene, this.meshIcons.renderOrder = 1, this.meshIcons.matrixAutoUpdate = !1, this.meshIcons.__objs = [], _.forEach((T, M) => { this.meshIcons.addInstance(this.meshIcons.addGeometry(T)), this.meshIcons.__objs.push(new Object3D) }), this.domEls = [document.createElement("div"), document.createElement("div"), document.createElement("div"), document.createElement("div")], this.domEls.forEach((T, M) => { T.className = "side-button", T.style.cssText = "position: absolute;user-select: none;touch-action: none;", this.scene.globalUI.domContainer.appendChild(T) }), this.scene.add(this.mesh), this.scene.add(this.meshIcons), this.resize(), this.interaction = new domInteraction({ nodes: [...this.domEls], onHover: this.hover, onTouch: this.touch, onClick: this.click, ctx: this, hoverCursor: !0 }), events.on("ui_show_sideicons", this.show, this), events.on("ui_hide_sideicons", this.hide, this), events.on("character_change_traits_shown", this.hide, this), events.on("character_change_traits_hiddden", () => { this.show(.2) }), events.on("npc_dialog_shown", () => { this.hide() }, this), events.on("npc_dialog_hidden", () => { this.show(.2) }), events.on("end_screen_show", this.hide, this), events.on("end_screen_hide", () => { this.show(.2) }), events.on("audio_update_mute", this.setMuteState, this), this.setMuteState(), this.ready.resolve()
    } setMuteState(e) { (typeof e == "boolean" ? e : this.scene.controller.audioController.muted) ? (this.meshIcons.setVisibleAt(1, !1), this.meshIcons.setVisibleAt(2, !0)) : (this.meshIcons.setVisibleAt(1, !0), this.meshIcons.setVisibleAt(2, !1)) } show(e = 0) { if (this.shown) return; this.shown = !0, this.mesh.material.uniforms.uSeed.value = Math.random(), this.meshIcons.material.uniforms.uSeed.value = Math.random(); let i = !1; createTween(this.mesh.material.uniforms.uShow, { to: { value: 1 }, duration: .5, delay: e, ease: "none", onStart: () => { this.mesh.visible = !0 }, onUpdate: () => { !i && this.mesh.material.uniforms.uShow.value > .2 && (i = !0, events.emit("webgl_play_audio", "buttons")) }, onComplete: () => { this.interaction.enable() } }), createTween(this.meshIcons.material.uniforms.uShow, { to: { value: 1 }, duration: .55, delay: e, ease: "none", onStart: () => { this.meshIcons.visible = !0 } }), events.emit("ui_sideicons_shown") } hide(e = 0) { this.shown && (this.shown = !1, this.interaction.disable(), createTween(this.meshIcons.material.uniforms.uShow, { to: { value: 0 }, duration: .3, delay: e, ease: "none", onComplete: () => { this.meshIcons.visible = !1 } }), createTween(this.mesh.material.uniforms.uShow, { to: { value: 0 }, duration: .35, delay: e, ease: "none", onComplete: () => { this.mesh.visible = !1 } }), events.emit("ui_sideicons_hidden")) } hover(e) { if (e.action === "hover_out") return; const i = e.nodeIndex, s = this.mesh.geometry._animObjs[i], a = Math.random() * 22.34, o = Math.random() * 3.34, l = []; i === 0 ? l.push(0) : i === 1 ? l.push(1, 2) : l.push(i + 1), createTween(s, { from: { hover: 0 }, to: { hover: 1 }, duration: .07, ease: "none", onStart: () => { this.mesh.geometry.attributes.hover.setX(i, a), this.mesh.geometry.attributes.hover.needsUpdate = !0, l.forEach(c => { this.meshIcons.__objs[c].scale.set(this.lastSize, this.lastSize, 1).multiplyScalar(this.sizeIcons[c]).multiplyScalar(.935), this.meshIcons.__objs[c].updateMatrix(), this.meshIcons.setMatrixAt(c, this.meshIcons.__objs[c].matrix) }) }, onComplete: () => { this.mesh.geometry.attributes.hover.setX(i, o), this.mesh.geometry.attributes.hover.needsUpdate = !0, l.forEach(c => { this.meshIcons.__objs[c].scale.set(this.lastSize, this.lastSize, 1).multiplyScalar(this.sizeIcons[c]), this.meshIcons.__objs[c].updateMatrix(), this.meshIcons.setMatrixAt(c, this.meshIcons.__objs[c].matrix) }) } }), createTween(s, { from: { scaleHover: 0 }, to: { scaleHover: 1 }, duration: .07, ease: "none", onStart: () => { this.mesh.geometry.attributes.scaleHover.setX(i, 1.1), this.mesh.geometry.attributes.scaleHover.needsUpdate = !0 }, onComplete: () => { this.mesh.geometry.attributes.scaleHover.setX(i, 1), this.mesh.geometry.attributes.scaleHover.needsUpdate = !0 } }), events.emit("webgl_play_audio", "hover2") } touch(e) { const i = e.nodeIndex, s = e.action === "touch_start", a = []; i === 0 ? a.push(0) : i === 1 ? a.push(1, 2) : a.push(i + 1); const o = this.mesh.geometry._animObjs[i]; createTween(o, { to: { scaleHover: 1 }, duration: 0, ease: "none", onComplete: () => { const l = s; this.mesh.geometry.attributes.scaleHover.setX(i, l ? .925 : 1), this.mesh.geometry.attributes.scaleHover.needsUpdate = !0, a.forEach(c => { this.meshIcons.__objs[c].scale.set(this.lastSize, this.lastSize, 1).multiplyScalar(this.sizeIcons[c]).multiplyScalar(l ? .9 : 1), this.meshIcons.__objs[c].updateMatrix(), this.meshIcons.setMatrixAt(c, this.meshIcons.__objs[c].matrix) }) } }), createTween(o, { to: { hover: 1 }, duration: 0, ease: "none", onComplete: () => { this.mesh.geometry.attributes.hover.setX(i, Math.random() * 43.23), this.mesh.geometry.attributes.hover.needsUpdate = !0 } }), events.emit("webgl_play_audio", `click${s ? 2 : 3}`) } click(e) { const i = e.nodeIndex; i === 0 ? events.emit("ui_quest_log_toggle") : i === 1 ? events.emit("audio_mute_toggle") : i === 2 ? events.emit("character_change_traits_show") : i === 3 && events.emit("ui_emojis_toggle") } resize() { const e = this.scene.mobile ? 45 : this.scene.small ? 65 : 70, i = client$1.screen.w - this.scene.marginLeft - .5 * e, s = this.scene.mobile ? 40 : this.scene.small ? 50 : 60; this.lastSize = e, _obj.position.set(i, -this.scene.marginTop - e * .5, 0), _obj.scale.set(e, e, 1), _obj.updateMatrix(), this.mesh.setMatrixAt(0, _obj.matrix); let a = this.domEls[0].style; a.width = `${_obj.scale.x}px`, a.height = `${_obj.scale.y}px`, a.left = `${_obj.position.x - .5 * _obj.scale.x}px`, a.top = `${Math.abs(_obj.position.y) - .5 * _obj.scale.y}px`, this.meshIcons.__objs[0].position.copy(_obj.position), this.meshIcons.__objs[0].scale.copy(_obj.scale).multiplyScalar(this.sizeIcons[0]), this.meshIcons.__objs[0].updateMatrix(), this.meshIcons.setMatrixAt(0, this.meshIcons.__objs[0].matrix); const o = -client$1.screen.h + this.scene.marginTop; for (let l = 1; l < this.geo.instanceCount; l++) { const c = 3 - l; _obj.position.set(i, o + e * .5 + (e * .5 + s) * c, 0), _obj.scale.set(e, e, 1), _obj.updateMatrix(), this.mesh.setMatrixAt(l, _obj.matrix), a = this.domEls[l].style, a.left = `${_obj.position.x - .5 * _obj.scale.x}px`, a.top = `${Math.abs(_obj.position.y) - .5 * _obj.scale.y}px`, a.width = `${_obj.scale.x}px`, a.height = `${_obj.scale.y}px` } for (let l = 1; l < this.meshIcons._instanceInfo.length; l++) { const c = Math.min(2, 4 - l); this.meshIcons.__objs[l].position.set(i, o + e * .5 + (e * .5 + s) * c, 0), this.meshIcons.__objs[l].scale.set(e, e, 1).multiplyScalar(this.sizeIcons[l]), this.meshIcons.__objs[l].updateMatrix(), this.meshIcons.setMatrixAt(l, this.meshIcons.__objs[l].matrix) } this.mesh.instanceMatrix.needsUpdate = !0, this.meshIcons._matricesTexture.needsUpdate = !0, this.mesh.updateMatrix(), this.mesh.computeBoundingBox(), this.mesh.computeBoundingSphere(), this.meshIcons.updateMatrix() }
} class title {
    constructor(e, i) { this.titles = e, this.scene = e.scene, this.globalUI = e.globalUI, this.data = i, this.font = "planet.font", this.ready = miscutils.deferred(), this.shown = !1, this.init() } async init() {
        const [e, i] = await Promise.all([glyphLoader.loadTexture(this.font, "band"), glyphLoader.loadTexture(this.font, "curve")]); this.mesh = new meshText({ font: this.font, small: !1, text: this.data.text.toUpperCase(), size: 1, width: 5, letterSpacing: -.05, lineHeight: .8, color: "#F8F8F8", align: "left", shadow: !0, shadowX: .04, shadowY: .04, shadowColor: "#647A87" }, new ShaderMaterial({
            name: "zone", defines: {}, userData: { hotReload: "titles" }, uniformsGroups: [global$1.UBO], uniforms: { tCurve: { value: i }, tBand: { value: e }, uSeed: { value: Math.random() }, tNoise: { value: textureLoader.load("noise-simplex-layered-pixellated-highq.ktx2", "linearfilter-repeat") }, uShow: { value: client$1.devScene ? 1 : 0 }, uHide: { value: 0 } }, vertexShader: `
                attribute vec3 centr;
                attribute vec2 textWeights;

                uniform float uShow;
                uniform float uHide;

                flat varying vec3 vCentr;

                ${globalUBO_default}
                ${falloff_default}
                ${rotate_default}
                ${slugvs_default}

                float hash11(float p) {
                    p = fract(p * .1031);
                    p *= p + 33.33;
                    p *= p + p;
                    return fract(p);
                }

                float hash13(vec3 p3) {
                    p3  = fract(p3 * .1031);
                    p3 += dot(p3, p3.zyx + 31.32);
                    return fract((p3.x + p3.y) * p3.z);
                }

                void main() {
                    vCentr = centr;
                    vec3 pos = SlugVS();

                    pos -= centr;
                    float rotSeed = hash11(centr.x + centr.y);
                    pos = rotateZ((rotSeed * 2.0 - 1.0) * 0.075) * pos;
                    pos += centr;

                    // animation
                    if (uShow < 1.0 || uHide > 0.0) {
                        float seed = fract(hash13(centr));
                        float steps = floor(2.0 + seed * 2.0);
                        pos -= centr;

                        // scale
                        float trShow = floor(pow(falloff(textWeights.x, 0.0, 1.0, 0.5, uShow), 2.0) * steps) / steps;
                        float trHide = 1.0 - floor(uHide * (steps + 1.0)) / (steps + 1.0);
                        pos *= trShow;
                        pos *= trHide;

                        // rotate doesn't fit very well the style

                        pos += centr;
                    }

                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `, fragmentShader: `
                uniform sampler2D tCurve;
                uniform usampler2D tBand;
                uniform sampler2D tNoise;
                uniform float uSeed;

                flat varying vec3 vCentr;

                ${globalUBO_default}
                ${slugfs_default}
                ${transformUV_default}

                void main() {
                    // animation
                    float seed = uSeed + vCentr.x;

                    vec2 uv = vTexCoord;

                    float steppedTime = floor(time * 7.0 * 0.45 * mix(fract(seed), 0.8, 1.0) + seed * 15.3423) / 7.0;
                    vec2 noiseUv = rotateUV(uv * 0.15, steppedTime);
                    vec2 n0 = texture(tNoise, noiseUv).rg * 2.0 - 1.0;
                    uv += n0 * 0.02;

                    vec4 color = RenderSlug(tCurve, tBand, uv, vColor, vBanding, vGlyph);

                    if (color.w * vColor.w < 0.0001) discard;

                    gl_FragColor = vec4(color.xyz, 1.0);
                }
            `, depthWrite: !1
        })), this.mesh.name = `Title: ${this.data.text}`, this.mesh.frustumCulled = !1, this.mesh.visible = !1, this.mesh.renderOrder = -50, this.mesh.matrixAutoUpdate = !1, this.mesh.rotation.z = .05, await this.mesh.ready, this.titles.titlesCnt.add(this.mesh), this.ready.resolve()
    } show(e = 0) { this.shown = !0, createTween(this.mesh.material.uniforms.uHide, { to: { value: 0 } }), createTween(this.mesh.material.uniforms.uShow, { from: { value: 0 }, to: { value: 1 }, duration: 1.5, ease: "none", delay: e, onStart: () => { events.emit("webgl_play_audio", "title"), this.mesh.visible = !0 }, onComplete: () => { this.hide(4) } }) } hide(e = 0) { this.shown && (createTween(this.mesh.material.uniforms.uShow, { to: { value: 1 } }), createTween(this.mesh.material.uniforms.uHide, { to: { value: 1 }, duration: .35, ease: "none", delay: e, onStart: () => { }, onComplete: () => { this.shown = !1, this.mesh.visible = !1 } })) } async resize() { const e = this.scene.mobile ? 55 : this.scene.small ? 85 : 110, i = this.scene.mobile ? 45 : this.scene.small ? 65 : 70, s = this.scene.mobile ? 20 : 40, a = this.scene.mobile ? 375 : this.scene.small ? 600 : 750, o = Math.min(client$1.screen.w, a) - this.scene.marginLeft * 2 - i - s; await this.mesh.update({ size: e, width: o }), this.mesh.position.set(this.scene.marginLeft, -client$1.screen.height + this.mesh.size.y + this.scene.marginTop * 1.5, 0), this.mesh.updateMatrix() }
} const _v0 = new Vector3; class zoneTitles { constructor(e) { this.scene = e, this.globalUI = e.globalUI, this.ready = miscutils.deferred(), this.titles = [], this.titlesData = { square: { text: "Ostrov Kanta", sphere: new Sphere(new Vector3(25.1548, 11.1266, 2.25704), 8.75) }, factory: { text: "Dom Sovetov", sphere: new Sphere(new Vector3(-7.82486, 4.19171, -29.304), 18.45) }, falls: { text: "Pregolya", sphere: new Sphere(new Vector3(8.09011, -13.7658, -12.4145), 10) }, redhouse: { text: "Domik rybaka", sphere: new Sphere(new Vector3(-14.4395, -6.11889, 27.0498), 9) }, forest: { text: "Tantsuyuschiy les", sphere: new Sphere(new Vector3(-8.84153, -19.1808, 2.54687), 13) }, graveyard: { text: "Kladbische starykh korabley", sphere: new Sphere(new Vector3(27.7006, -14.1946, 13.4392), 8) }, cave: { text: "Man's Cave", sphere: new Sphere(new Vector3(-21.7063, -6.80204, 6.28998), 5) }, temple: { text: "Ruiny zamka Balga", sphere: new Sphere(new Vector3(-10.1549, 34.7748, -3.82302), 8) }, beach: { text: "Scully's Beach", sphere: new Sphere(new Vector3(-13.1445, 15.572, -1.75282), 8) } }, this.prevZone = null, this.currentZone = null, this.init() } async init() { this.titlesCnt = new Group, this.titlesCnt.name = "zone titles", this.titlesCnt.matrixAutoUpdate = !1, this.scene.add(this.titlesCnt); const e = []; Object.keys(this.titlesData).forEach(i => { const s = new title(this, { name: i, ...this.titlesData[i] }); this.titles.push(s), e.push(s.ready) }), await Promise.all(e), this.resize(), events.on("character_broadcast_position", this.checkPlayerPosition, this), events.on("character_change_traits_shown", this.hideAll, this), events.on("npc_dialog_shown", this.hideAll, this), events.on("ui_emojis_toggle", this.hideAll, this), events.on("end_screen_show", this.hideAll, this), this.ready.resolve() } checkPlayerPosition(e) { _v0.fromArray(e); let i = null, s = -1; const a = Object.keys(this.titlesData); for (let o = 0; o < a.length; o++) { const l = a[o], c = this.titlesData[l].sphere; if (c.center.distanceTo(_v0) < c.radius) { i = l, s = o; break } } if (i !== this.currentZone) { const o = i !== this.prevZone; if (this.prevZone = this.currentZone, this.currentZone = i, o) { const l = this.hideAll() ? .25 : 0; events.emit("ui_zone_title_show"), this.titles[s].show(l) } } } hideAll() { let e = !1; return this.titles.forEach(i => { i.shown && (i.hide(), e = !0) }), e } resize() { this.titles.forEach(e => e.resize()) } } class textbox$1 {
    constructor(e) { this.dialog = e, this.ready = miscutils.deferred(), this.lastVoice = "male1", this.questVolume = { value: 0 }, this.font = "UglyDave-Alternates-optimized.font", this.init() } async init() {
        const e = this.dialog.scene.squareGeo3; this.bg = new Mesh(e, new ShaderMaterial({
            userData: { hotReload: "textbox-bg" }, uniformsGroups: [global$1.UBO], uniforms: { uColor: { value: new Color("#F8F8F8") }, uColorShadow: { value: new Color("#647A87") }, uSeed: { value: Math.random() }, uShow: { value: client$1.devScene ? 1 : 0 }, uShadowOffset: { value: 5.5 } }, vertexShader: `
                attribute int side;
                attribute int vertid;

                ${globalUBO_default}
                ${matrixutils_default}
                ${falloff_default}

                uniform float uSeed;
                uniform float uShow;
                uniform float uShadowOffset;
                uniform vec3 uColor;
                uniform vec3 uColorShadow;

                varying vec2 vUv;
                flat varying vec3 vColor;

                void main() {
                    vec3 localPos = position;

                    float steps = 4.0;
                    float scaleShowStepped = floor(uShow * steps) / steps;

                    float vertSeed = fract(uSeed * 533.32 + float(vertid) * 210.67644 + scaleShowStepped * 34.5435);
                    float offset = (vertSeed * 2.0 - 1.0) * 0.02;
                    vec3 dir = normalize(vec3(position.xy, 0.0));
                    localPos += dir * offset;

                    vec4 pos = vec4(localPos * scaleShowStepped, 1.0);
                    vec4 wPos = modelMatrix * pos;

                    vUv = uv;
                    vColor = uColor;

                    if (scaleShowStepped > 0.0) {
                        if (side == 1) { // backdrop shadow
                            wPos.xy += uShadowOffset * vec2(1.0, -1.0);
                            vColor = uColorShadow;
                        } else if (side == 2) { // inside to prevent outlines due to color changes
                            wPos.xy -= (uv * 2.0 - 1.0) * step(0.01, uShow) * vec2(9.0, 20.0) + vec2(0.0, 5.0); // px inward
                            vColor = -uColor;
                            // vColor = uColor * 0.3; // debug
                        }
                    }

                    gl_Position = projectionMatrix * viewMatrix * wPos;
                }
            `, fragmentShader: `
                varying vec2 vUv;
                flat varying vec3 vColor;

                void main() {
                    gl_FragColor = vec4(vColor, 1.0);
                }
            `, depthWrite: !1, depthTest: !1
        })), this.bg.name = "text bg", this.bg.frustumCulled = !1, this.bg.renderOrder = -10, this.bg.visible = !1, this.bg.matrixAutoUpdate = !1; const [i, s] = await Promise.all([glyphLoader.loadTexture(this.font, "band"), glyphLoader.loadTexture(this.font, "curve")]); this.text = new meshText({ font: this.font, small: !1, text: "hi, how are you doing? i was wondering if you would mind delivering this letter to my brother.".toUpperCase(), size: 1, width: 27, letterSpacing: -.05, lineHeight: 1.1, color: "#0f0f0f", align: "left" }, new ShaderMaterial({
            name: "textbox text", defines: { SLUG_WEIGHT: 1 }, userData: { hotReload: "texbox text" }, uniformsGroups: [global$1.UBO], uniforms: { tCurve: { value: s }, tBand: { value: i }, uSeed: { value: Math.random() }, uShow: { value: 1 }, uHide: { value: 0 } }, vertexShader: `
                attribute vec3 centr;
                attribute vec2 textWeights;

                uniform float uShow;
                uniform float uHide;

                flat varying vec3 vCentr;

                ${globalUBO_default}
                ${falloff_default}
                ${slugvs_default}
                ${eases_default}

                float hash13(vec3 p3) {
                    p3  = fract(p3 * .1031);
                    p3 += dot(p3, p3.zyx + 31.32);
                    return fract((p3.x + p3.y) * p3.z);
                }

                vec2 hash23(vec3 p3) {
                    p3 = fract(p3 * vec3(.1031, .1030, .0973));
                    p3 += dot(p3, p3.yzx+33.33);
                    return fract((p3.xx+p3.yz)*p3.zy);
                }

                void main() {
                    vCentr = centr;
                    vec3 pos = SlugVS();

                    float seed = fract(hash13(centr));

                    // animation
                    if (uShow < 1.0 || uHide > 0.0) {
                        // show
                        float stepsShow = floor(3.0 + seed * 2.0);
                        float trShow = floor(falloff(textWeights.y, 0.0, 1.0, 0.1, uShow) * stepsShow) / stepsShow;
                        vTexCoord += vec2(0.0, 1.0) * (1.0 - trShow);

                        // hide
                        float stepsHide = floor(2.0 + seed * 2.0);
                        float trHide = 1.0 - floor(uHide * (stepsHide + 1.0)) / (stepsHide + 1.0);
                        pos -= centr;
                        pos *= trHide;
                        pos += centr;
                    }

                    // wiggle
                    float steppedTime = floor(time * 1.6 * mix(fract(seed), 0.8, 1.0) + seed * 15.3423) / 7.0;
                    vec2 offset = (hash23(centr + vec3(steppedTime, 0.0, 0.0)) * 2.0 - 1.0) * 0.5;
                    pos.xy += offset;

                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `, fragmentShader: `
                uniform sampler2D tCurve;
                uniform usampler2D tBand;

                flat varying vec3 vCentr;

                ${globalUBO_default}
                ${slugfs_default}
                ${transformUV_default}

                void main() {

                    vec2 uv = vTexCoord;
                    vec4 color = RenderSlug(tCurve, tBand, uv, vColor, vBanding, vGlyph);

                    // skip outline
                    gl_FragColor = vec4(-color.xyz, color.w * vColor.w);
                }
            `, transparent: !0, depthWrite: !1
        })), this.text.name = "Textbox Text", this.text.frustumCulled = !1, this.text.rederOrder = -5, this.text.visible = !1, this.text.matrixAutoUpdate = !1, await this.text.ready, this.dialog.dialogCnt.add(this.bg), this.dialog.dialogCnt.add(this.text), this.ready.resolve()
    } show(e = 0, i = "#ffffff", s, a = "male1") { this.lastVoice = a, this.bg.visible = !1, this.text.visible = !1, this.bg.material.uniforms.uSeed.value = Math.random(), createTween(this.bg.material.uniforms.uShow, { from: { value: 0 }, to: { value: 1 }, duration: .35, ease: "none", delay: e, onStart: () => { this.bg.visible = !0 } }); const o = meshText.getTextWithoutTags(s).length * (1 / 35); createTween(this.text.material.uniforms.uHide, { to: { value: 0 } }), createTween(this.text.material.uniforms.uShow, { from: { value: 0 }, to: { value: 1 }, duration: o, ease: "none", delay: e + .35, onStart: () => { this.text.visible = !0, this.playDialogue(!0) }, onComplete: () => { this.playDialogue(!1) } }) } hide(e = 0) { createTween(this.text.material.uniforms.uHide, { to: { value: 1 }, duration: .05, ease: "none", delay: e, onComplete: () => { this.text.visible = !1 } }), createTween(this.bg.material.uniforms.uShow, { from: { value: 1 }, to: { value: 0 }, duration: .15, ease: "none", delay: e + .05, onComplete: () => { this.bg.visible = !1 } }), this.playDialogue(!1) } playDialogue(e = !0) { var i, s; if (this.lastVoice === "quest") createTween(this.questVolume, { to: { value: e ? 1 : 0 }, duration: .25, onUpdate: () => { events.emit("webgl_set_audio_volume", "dialogue-quest", this.questVolume.value * .075) } }); else { const a = `dialogue-${this.lastVoice}`, o = (i = this.dialog.globalUI.controller) == null ? void 0 : i.planetScene; if (!o || !o.npcs) return; const l = this.dialog.npcIDShowing; if (!l) return; const c = o.npcs.find(h => h.mesh._id === l); if (!c || !((s = c.mesh) != null && s.isWorldNPC)) return; e ? events.emit("webgl_play_positional", a, c.mesh) : events.emit("webgl_stop_positional", a, c.mesh) } } async update(e = "placeholder text") { this.text.setText(e.toUpperCase(), !1), await this.resize() } async resize() { const e = this.dialog.scene, i = e.marginTop * 1.35, s = e.mobile ? 50 : 60, a = e.mobile ? 20 : 45, o = e.mobile ? 46 : 60, l = e.mobile ? 30 : 40, c = e.mobile ? 18 : e.small ? 24 : 26, h = Math.min(client$1.screen.w, 820) - a * 2 - s * 2, d = e.mobile ? -.02 : -.05; await this.text.update({ size: c, width: h, letterSpacing: d }); const p = this.text.size.x, f = this.text.size.y, _ = h + a * 2, x = f + o + l, b = -client$1.screen.height + i, T = e.mobile ? 30 : e.small ? 25 : 20; this.bg.scale.set(_, x, 1), this.bg.position.set(client$1.screen.width * .5, b + x * .5 + T, 0), this.text.position.set(client$1.screen.width * .5 - p * .5, b + f + l + T, 0), this.bg.updateMatrix(), this.text.updateMatrix() }
} const _c0$2 = new Color; class titlebox$1 {
    constructor(e) { this.dialog = e, this.ready = miscutils.deferred(), this.defaultColor = new Color("#66BDE6"), this.color = this.defaultColor.clone(), this.font = "heading.font", this.init() } async init() {
        const e = this.dialog.scene.squareGeo3; this.bg = new Mesh(e, new ShaderMaterial({
            userData: { hotReload: "titlebox-bg" }, uniformsGroups: [global$1.UBO], uniforms: { uColor: { value: new Color("#66BDE6") }, uColorShadow: { value: new Color("#488BAA") }, uSeed: { value: Math.random() }, uShow: { value: client$1.devScene ? 1 : 0 }, uShadowOffset: { value: 5.5 } }, vertexShader: `
                attribute int side;
                attribute int vertid;

                ${globalUBO_default}
                ${matrixutils_default}
                ${falloff_default}

                uniform float uSeed;
                uniform float uShow;
                uniform float uShadowOffset;
                uniform vec3 uColor;
                uniform vec3 uColorShadow;

                varying vec2 vUv;
                flat varying vec3 vColor;

                void main() {
                    vec3 localPos = position;

                    float steps = 4.0;
                    float scaleShowStepped = floor(uShow * steps) / steps;

                    float vertSeed = fract(uSeed * 72.32 + float(vertid) * 36.223 + scaleShowStepped * 62.543);
                    float offset = (vertSeed * 2.0 - 1.0) * 0.02;
                    vec3 dir = normalize(vec3(position.xy, 0.0));
                    localPos += dir * offset;

                    vec4 pos = vec4(localPos * scaleShowStepped, 1.0);
                    vec4 wPos = modelMatrix * pos;

                    vUv = uv;
                    vColor = uColor;

                    if (scaleShowStepped > 0.0) {
                        if (side == 1) { // backdrop shadow
                            wPos.xy += uShadowOffset * vec2(1.0, -1.0);
                            vColor = uColorShadow;
                        } else if (side == 2) { // inside to prevent outlines due to color changes
                            wPos.xy -= (uv * 2.0 - 1.0) * step(0.01, uShow) * 5.0; // px inward
                            vColor = -uColor;
                            //vColor = uColor * 0.3; // debug
                        }
                    }

                    gl_Position = projectionMatrix * viewMatrix * wPos;
                }
            `, fragmentShader: `
                varying vec2 vUv;
                flat varying vec3 vColor;

                void main() {
                    gl_FragColor = vec4(vColor, 1.0);
                }
            `, depthWrite: !1, depthTest: !1
        })), this.bg.name = "title bg", this.bg.frustumCulled = !1, this.bg.renderOrder = -2, this.bg.visible = !1, this.bg.matrixAutoUpdate = !1; const [i, s] = await Promise.all([glyphLoader.loadTexture(this.font, "band"), glyphLoader.loadTexture(this.font, "curve")]); this.text = new meshText({ font: this.font, small: !1, text: "office worker".toUpperCase(), size: 1, width: 20, letterSpacing: 0, lineHeight: 1.1, color: "#ffffff", align: "left", shadow: !0, shadowX: .08, shadowY: .08, shadowColor: "#0f0f0f" }, new ShaderMaterial({
            name: "title text", defines: {}, userData: { hotReload: "title text" }, uniformsGroups: [global$1.UBO], uniforms: { tCurve: { value: s }, tBand: { value: i }, uSeed: { value: Math.random() }, uShow: { value: 1 }, uHide: { value: 0 } }, vertexShader: `
                attribute vec3 centr;
                attribute vec2 textWeights;

                uniform float uShow;
                uniform float uHide;

                flat varying vec3 vCentr;

                ${globalUBO_default}
                ${falloff_default}
                ${slugvs_default}
                ${eases_default}

                float hash13(vec3 p3) {
                    p3  = fract(p3 * .1031);
                    p3 += dot(p3, p3.zyx + 31.32);
                    return fract((p3.x + p3.y) * p3.z);
                }

                vec2 hash23(vec3 p3) {
                    p3 = fract(p3 * vec3(.1031, .1030, .0973));
                    p3 += dot(p3, p3.yzx+33.33);
                    return fract((p3.xx+p3.yz)*p3.zy);
                }

                void main() {
                    vCentr = centr;
                    vec3 pos = SlugVS();

                    float seed = fract(hash13(centr));

                    // animation
                    if (uShow < 1.0 || uHide > 0.0) {
                        // show
                        float stepsShow = floor(3.0 + seed * 2.0);
                        float trShow = floor(falloff(textWeights.y, 0.0, 1.0, 1.5, uShow) * stepsShow) / stepsShow;
                        vTexCoord += vec2(0.0, 1.0) * (1.0 - trShow);

                        // hide
                        float stepsHide = floor(2.0 + seed * 2.0);
                        float trHide = 1.0 - floor(uHide * (stepsHide + 1.0)) / (stepsHide + 1.0);
                        pos -= centr;
                        pos *= trShow;
                        pos *= trHide;
                        pos += centr;
                    }

                    // wiggle
                    float steppedTime = floor(time * 1.6 * mix(fract(seed), 0.8, 1.0) + seed * 15.3423) / 7.0;
                    vec2 offset = (hash23(centr + vec3(steppedTime, 0.0, 0.0)) * 2.0 - 1.0) * 0.5;
                    pos.xy += offset;

                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `, fragmentShader: `
                uniform sampler2D tCurve;
                uniform usampler2D tBand;

                flat varying vec3 vCentr;

                ${globalUBO_default}
                ${slugfs_default}
                ${transformUV_default}

                void main() {
                    // animation

                    vec2 uv = vTexCoord;
                    vec4 color = RenderSlug(tCurve, tBand, uv, vColor, vBanding, vGlyph);

                    // skip outline
                    gl_FragColor = vec4(-color.xyz, color.w * vColor.w);
                }
            `, transparent: !0, depthWrite: !1
        })), this.text.name = "title text", this.text.frustumCulled = !1, this.text.rederOrder = -1, this.text.visible = !1, this.text.matrixAutoUpdate = !1, await this.text.ready, this.dialog.dialogCnt.add(this.bg), this.dialog.dialogCnt.add(this.text), this.updateColors(), this.ready.resolve()
    } updateColors(e = null) { e ? this.color.setStyle(e) : this.color.copy(this.defaultColor), _c0$2.copy(this.color).offsetHSL(0, -.3, -.2), this.bg.material.uniforms.uColor.value.copy(this.color), this.bg.material.uniforms.uColorShadow.value.copy(_c0$2) } show(e = 0, i = null, s) { this.bg.visible = !1, this.text.visible = !1, this.updateColors(i), this.bg.material.uniforms.uSeed.value = Math.random(), createTween(this.bg.material.uniforms.uShow, { from: { value: 0 }, to: { value: 1 }, duration: .35, ease: "none", delay: e, onStart: () => { this.bg.visible = !0 } }), createTween(this.text.material.uniforms.uHide, { to: { value: 0 } }), createTween(this.text.material.uniforms.uShow, { from: { value: 0 }, to: { value: 1 }, duration: .35, ease: "none", delay: e + .25, onStart: () => { this.text.visible = !0 } }) } hide(e = 0) { createTween(this.text.material.uniforms.uHide, { to: { value: 1 }, duration: .05, ease: "none", delay: e, onComplete: () => { this.text.visible = !1 } }), createTween(this.bg.material.uniforms.uShow, { from: { value: 1 }, to: { value: 0 }, duration: .1, ease: "none", delay: e + .05, onComplete: () => { this.bg.visible = !1 } }) } async update(e = "placeholder title") { this.text.setText(e.toUpperCase(), !1), await this.resize() } async resize() { const e = this.dialog.scene, i = this.dialog.textBox, s = e.mobile ? 15 : 25, a = e.mobile ? 20 : 30, o = e.mobile ? 18 : 22, l = e.mobile ? 20 : 25, c = e.mobile ? 25 : e.small ? 30 : 35, h = i.bg.scale.x - a * 2 + s, d = e.mobile ? -.005 : -.01; await this.text.update({ size: c, width: h, letterSpacing: d }); const p = this.text.size.x + a * 2, f = this.text.size.y + this.text.topAlign + o + l; this.bg.scale.set(p, f, 1), this.bg.position.set(i.bg.position.x - i.bg.scale.x * .5 + p * .5 - s, i.bg.position.y + i.bg.scale.y * .5 + f * .5 - 10, 0), this.text.position.set(this.bg.position.x - this.bg.scale.x * .5 + a, this.bg.position.y - this.bg.scale.y * .5 + this.text.size.y + l, 0), this.bg.updateMatrix(), this.text.updateMatrix() }
} const _c0$1 = new Color; class arrowbox {
    constructor(e) { this.dialog = e, this.ready = miscutils.deferred(), this.defaultColor = new Color("#66BDE6"), this.color = this.defaultColor.clone(), this.anims = { hover: 0, scaleHover: 0 }, this.font = "UglyDave-Alternates-optimized.font", this.init() } async init() {
        const e = this.dialog.scene.squareGeo2; this.bg = new Mesh(e, new ShaderMaterial({
            userData: { hotReload: "arrowbox-bg" }, uniformsGroups: [global$1.UBO], uniforms: { uColor: { value: new Color("#F8F8F8") }, uColorShadow: { value: new Color("#647A87") }, uSeed: { value: Math.random() }, uShow: { value: client$1.devScene ? 1 : 0 }, uShadowOffset: { value: 5.5 }, uScaleHover: { value: 1 } }, vertexShader: `
                attribute int side;
                attribute int vertid;

                ${globalUBO_default}
                ${matrixutils_default}
                ${falloff_default}

                uniform float uSeed;
                uniform float uShow;
                uniform float uShadowOffset;
                uniform vec3 uColor;
                uniform vec3 uColorShadow;
                uniform float uScaleHover;

                varying vec2 vUv;
                flat varying vec3 vColor;

                void main() {
                    vUv = uv;
                    vColor = uColor;

                    vec3 localPos = position;

                    float steps = 4.0;
                    float scaleShowStepped = floor(uShow * steps) / steps;

                    float vertSeed = fract(uSeed * 533.32 + float(vertid) * 210.67644 + scaleShowStepped * 34.5435);
                    float offset = (vertSeed * 2.0 - 1.0) * 0.065;
                    vec3 dir = normalize(vec3(position.xy, 0.0));
                    localPos += dir * offset;

                    localPos.xy *= uScaleHover * scaleShowStepped;
                    localPos = (modelMatrix * vec4(localPos, 1.0)).xyz;

                    if (scaleShowStepped > 0.0) {
                        if (side == 1) { // backdrop shadow
                            float offsetScale = uScaleHover == 1.0 ? 1.0 : 0.4;
                            localPos.xy += uShadowOffset * vec2(1.0, -1.0) * offsetScale;
                            vColor = uColorShadow;
                        }
                    }

                    gl_Position = projectionMatrix * viewMatrix * vec4(localPos, 1.0);
                }
            `, fragmentShader: `
                varying vec2 vUv;
                flat varying vec3 vColor;

                void main() {
                    gl_FragColor = vec4(vColor, 2.0);
                }
            `, depthWrite: !1, depthTest: !1
        })), this.bg.name = "arrow bg", this.bg.frustumCulled = !1, this.bg.renderOrder = -10, this.bg.visible = !1, this.bg.matrixAutoUpdate = !1; const [i, s, a] = await Promise.all([glyphLoader.loadTexture("ui/arrow.icon", "band"), glyphLoader.loadTexture("ui/arrow.icon", "curve"), glyphLoader.loadGeometry("ui/arrow.icon", { size: 1 })]); this.arrow = new Mesh(a, new ShaderMaterial({
            uniformsGroups: [global$1.UBO], uniforms: { tCurve: { value: s }, tBand: { value: i }, uHover: { value: 1 }, uShow: { value: client$1.devScene ? 1 : 0 }, uColor: { value: this.defaultColor.clone() } }, vertexShader: `
                uniform float uHover;
                uniform float uShow;

                ${globalUBO_default}
                ${falloff_default}
                ${slugvs_default}

                varying vec2 vUv;

                void main() {
                    vUv = uv;

                    float showStepped = floor(uShow * 2.0) / 2.0;
                    vec3 pos = SlugVS() * vec3(vec2(uHover), 1.0) * showStepped;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `, fragmentShader: `
                varying vec2 vUv;

                ${slugfs_default}

                uniform sampler2D tCurve;
                uniform usampler2D tBand;
                uniform vec3 uColor;

                void main() {
                    vec4 color = RenderSlug(tCurve, tBand, vTexCoord, vColor, vBanding, vGlyph);

                    if (color.w * vColor.w < 0.001) discard;

                    gl_FragColor = vec4(uColor, 1.0);
                }
            `, depthWrite: !1, depthTest: !1, transparent: !1
        })), this.arrow.name = "arrow icon", this.arrow.frustumCulled = !1, this.arrow.renderOrder = -5, this.arrow.visible = !1, this.arrow.matrixAutoUpdate = !1, this.domEl = document.createElement("div"), this.domEl.className = "dialog-button", this.domEl.style.cssText = "position: absolute;user-select: none;touch-action: none;", this.dialog.scene.globalUI.domContainer.appendChild(this.domEl), this.interaction = new domInteraction({ nodes: [this.domEl], hoverCursor: !0, onHover: this.hover.bind(this), onTouch: this.touch.bind(this), onClick: this.click.bind(this) }), this.dialog.dialogCnt.add(this.bg), this.dialog.dialogCnt.add(this.arrow), this.updateColors(), this.ready.resolve()
    } updateColors(e = null) { e ? this.color.setStyle(e) : this.color.copy(this.defaultColor), _c0$1.copy(this.color).offsetHSL(0, -.3, -.2), this.arrow.material.uniforms.uColor.value.copy(this.color) } hover(e) { if (e.action !== "hover_in") return; const i = Math.random() * 22.34, s = Math.random() * 3.34; createTween(this.anims, { from: { hover: 0 }, to: { hover: 1 }, duration: .07, ease: "none", onStart: () => { this.bg.material.uniforms.uSeed.value = i, this.arrow.material.uniforms.uHover.value = .935 }, onComplete: () => { this.bg.material.uniforms.uSeed.value = s, this.arrow.material.uniforms.uHover.value = 1 } }), createTween(this.anims, { from: { scaleHover: 0 }, to: { scaleHover: 1 }, duration: .07, ease: "none", onStart: () => { this.bg.material.uniforms.uScaleHover.value = 1.1 }, onComplete: () => { this.bg.material.uniforms.uScaleHover.value = 1 } }), events.emit("webgl_play_audio", "hover2") } touch(e) { const i = e.action === "touch_start"; createTween(this.anims, { to: { scaleHover: 1 }, duration: 0, ease: "none", onComplete: () => { this.bg.material.uniforms.uScaleHover.value = i ? .925 : 1, this.arrow.material.uniforms.uHover.value = i ? .9 : 1 } }), createTween(this.anims, { to: { hover: 1 }, duration: 0, ease: "none", onComplete: () => { this.bg.material.uniforms.uSeed.value = Math.random() * 43.23 } }), events.emit("webgl_play_audio", `click${i ? 2 : 3}`) } click() { this.dialog.npcIDShowing !== null && this.dialog.clickArrow() } show(e = 0, i = null) { this.bg.visible = !1, this.arrow.visible = !1, this.updateColors(i), this.bg.material.uniforms.uScaleHover.value = 1, this.arrow.material.uniforms.uHover.value = 1, this.bg.material.uniforms.uSeed.value = Math.random(), createTween(this.bg.material.uniforms.uShow, { from: { value: 0 }, to: { value: 1 }, duration: .3, ease: "none", delay: e, onStart: () => { this.bg.visible = !0 }, onComplete: () => { this.interaction.enable() } }), createTween(this.arrow.material.uniforms.uShow, { from: { value: 0 }, to: { value: 1 }, duration: .2, ease: "none", delay: e + .05, onStart: () => { this.arrow.visible = !0 } }) } hide(e = 0) { this.interaction.disable(), createTween(this.arrow.material.uniforms.uShow, { to: { value: 0 }, duration: .05, ease: "none", delay: e, onComplete: () => { this.arrow.visible = !1 } }), createTween(this.bg.material.uniforms.uShow, { from: { value: 1 }, to: { value: 0 }, duration: .1, ease: "none", delay: e, onComplete: () => { this.bg.visible = !1 } }) } update() { this.resize() } resize() { const e = this.dialog.scene, i = this.dialog.textBox, s = e.mobile ? 25 : e.small ? 20 : 30, a = e.mobile ? 30 : e.small ? 40 : 50, o = e.mobile ? 50 : e.small ? 65 : 80; this.bg.scale.set(o, o, 1), this.bg.position.set(i.bg.position.x + i.bg.scale.x * .5 - o * .5 + s, i.bg.position.y - i.bg.scale.y * .5 + o * .5 - a, 0); const l = this.domEl.style; l.width = `${this.bg.scale.x}px`, l.height = `${this.bg.scale.y}px`, l.left = `${this.bg.position.x - .5 * this.bg.scale.x}px`, l.top = `${Math.abs(this.bg.position.y) - .5 * this.bg.scale.y}px`, this.arrow.scale.set(o * .6, o * .6, 1), this.arrow.position.copy(this.bg.position), this.arrow.position.x += this.arrow.scale.x * .075, this.bg.updateMatrix(), this.arrow.updateMatrix() }
} class dialogBox { constructor(e) { this.scene = e, this.globalUI = e.globalUI, this.ready = miscutils.deferred(), this.shown = !1, this.displayed = !1, this.npcIDShowing = null, this.npcIDLast = null, this.isKeyTouching = !1, this.init() } async init() { this.dialogCnt = new Group, this.dialogCnt.name = "dialog box", this.dialogCnt.matrixAutoUpdate = !1, this.scene.add(this.dialogCnt), this.textBox = new textbox$1(this), this.titleBox = new titlebox$1(this), this.arrowBox = new arrowbox(this), await Promise.all([this.textBox.ready, this.titleBox.ready, this.arrowBox.ready]), this.generateTexts(), events.on("npc_dialog_open", this.show, this), events.on("npc_dialog_close", this.hide, this), events.on("keydown", this.onKey, this), events.on("keyup", this.onKey, this), events.on("npc_dialog_finished", this.hideFinal, this), events.on("npc_dialog_interrupted", this.hideFinal, this), this.ready.resolve() } show(e, i, s, a) { if (a.bubblesEnabled) return; this.shown = !0, this.npcIDShowing = e, this.npcIDLast = e; const o = `${(s == null ? void 0 : s.name) || "Neznakomets"}`, l = i || "No dialog text provided", c = (s == null ? void 0 : s.color) || "#ffffff", h = (s == null ? void 0 : s.voice) || "male1"; this.generateTexts(o, l).then(() => { this.shown && (this.displayed = !0, this.titleBox.show(0, c, o), this.textBox.show(.1, c, l, h), this.arrowBox.show(.3, c, l), this.globalUI.playBoxAudio(.3)) }), events.emit("npc_dialog_shown", e) } hide(e) { !this.shown || this.npcIDShowing !== e || (this.arrowBox.hide(0), this.textBox.hide(0), this.titleBox.hide(0), this.globalUI.playBoxAudio(.1), this.shown = !1, this.displayed = !1, this.npcIDShowing = null, this.isKeyTouching = !1) } hideFinal(e) { this.npcIDLast === e && (this.npcIDLast = null, events.emit("npc_dialog_hidden", e)) } async generateTexts(e = "placeholder title", i = "hi, how are you doing? i was wondering if you would mind delivering this letter to my brother.") { await this.textBox.update(i), await Promise.all([this.titleBox.update(e), this.arrowBox.update()]) } onKey(e) { if (!this.displayed || !this.shown || this.npcIDShowing === null) return; const i = e.code === "Escape", s = e.code === "Space" || e.code === "KeyE"; if (!(!i && !s)) if (e.type === "keydown") { if (i) events.emit("npc_force_close_dialog", this.npcIDShowing); else if (s) { if (this.textBox.bg.material.uniforms.uShow.value < .8 || !this.textBox.text.visible || this.textBox.text.material.uniforms.uHide.value > 0) return; this.textBox.text.material.uniforms.uShow.value < 1 ? this.forceEndText() : this.isKeyTouching || (this.isKeyTouching = !0, this.arrowBox.touch({ action: "touch_start" })) } } else s && this.isKeyTouching && (this.arrowBox.touch({ action: "touch_end" }), this.arrowBox.click()) } forceEndText() { createTween(this.textBox.text.material.uniforms.uShow, { to: { value: 1 }, duration: 0, onStart: () => { this.textBox.text.visible = !0 }, onComplete: () => { this.textBox.playDialogue(!1) } }) } clickArrow() { this.textBox.text.material.uniforms.uShow.value < 1 ? this.forceEndText() : events.emit("npc_force_next_dialog", this.npcIDShowing) } resize() { this.textBox.resize().then(() => { this.titleBox.resize(), this.arrowBox.resize() }) } } class textbox {
    constructor(e) { this.dialog = e, this.ready = miscutils.deferred(), this.volumes = { dialogue: 0 }, this.font = "UglyDave-Alternates-optimized.font", this.icon = "ui/cross.icon", this.iconAspect = 1, this.init() } async init() {
        const e = this.dialog.scene.squareGeo3; this.bg = new Mesh(e, new ShaderMaterial({
            userData: { hotReload: "questbox-bg" }, uniformsGroups: [global$1.UBO], uniforms: { uColor: { value: new Color("#F8F8F8") }, uColorShadow: { value: new Color("#647A87") }, uSeed: { value: Math.random() }, uShow: { value: client$1.devScene ? 1 : 0 }, uShadowOffset: { value: 5.5 }, uTextAdjust: { value: new Vector4 } }, vertexShader: `
                attribute int side;
                attribute int vertid;

                ${globalUBO_default}
                ${matrixutils_default}
                ${falloff_default}

                uniform float uSeed;
                uniform float uShow;
                uniform float uShadowOffset;
                uniform vec3 uColor;
                uniform vec3 uColorShadow;
                uniform vec4 uTextAdjust;

                varying vec2 vUv;
                flat varying vec3 vColor;

                void main() {
                    vec3 localPos = position;

                    float steps = 4.0;
                    float scaleShowStepped = floor(uShow * steps) / steps;

                    float vertSeed = fract(uSeed * 533.32 + float(vertid) * 210.67644 + scaleShowStepped * 34.5435);
                    float offset = (vertSeed * 2.0 - 1.0) * 0.02;
                    vec3 dir = normalize(vec3(position.xy, 0.0));
                    localPos += dir * offset;

                    vec4 pos = vec4(localPos * scaleShowStepped, 1.0);
                    vec4 wPos = modelMatrix * pos;

                    vUv = uv;
                    vColor = uColor;

                    if (scaleShowStepped > 0.0) {
                        if (side == 1) { // backdrop shadow
                            wPos.xy += uShadowOffset * vec2(1.0, -1.0);
                            vColor = uColorShadow;
                        } else if (side == 2) { // inside to prevent outlines due to color changes
                            vec4 uAdjust = uTextAdjust * uShow;

                            if (uv.x < 0.5) wPos.x += uAdjust.x;
                            else wPos.x -= uAdjust.y;
                            if (uv.y < 0.5) wPos.y += uAdjust.z;
                            else wPos.y -= uAdjust.w;
                            wPos.y -= 6.0;

                            vColor = -uColor;
                            // vColor = uColor * 0.3; // debug
                        }
                    }

                    gl_Position = projectionMatrix * viewMatrix * wPos;
                }
            `, fragmentShader: `
                varying vec2 vUv;
                flat varying vec3 vColor;

                void main() {
                    gl_FragColor = vec4(vColor, 1.0);
                }
            `, depthWrite: !1, depthTest: !1
        })), this.bg.name = "text bg", this.bg.frustumCulled = !1, this.bg.renderOrder = -10, this.bg.visible = !!client$1.devScene, this.bg.matrixAutoUpdate = !1; const [i, s, a, o, l] = await Promise.all([glyphLoader.loadTexture(this.font, "band"), glyphLoader.loadTexture(this.font, "curve"), glyphLoader.loadTexture(this.icon, "band"), glyphLoader.loadTexture(this.icon, "curve"), glyphLoader.loadGeometry(this.icon, { size: 1 })]); this.text = new meshText({ font: this.font, small: !1, text: "VERNIS K YaNTARSchIKU V PESchERU I OTDAY EMU ODEZhDU".toUpperCase(), size: 1, width: 27, letterSpacing: -.05, lineHeight: 1.1, color: "#0f0f0f", align: "left" }, new ShaderMaterial({
            name: "textbox text", defines: { SLUG_WEIGHT: 1 }, userData: { hotReload: "texbox text" }, uniformsGroups: [global$1.UBO], uniforms: { tCurve: { value: s }, tBand: { value: i }, uSeed: { value: Math.random() }, uShow: { value: 1 }, uHide: { value: 0 } }, vertexShader: `
                attribute vec3 centr;
                attribute vec2 textWeights;

                uniform float uShow;
                uniform float uHide;

                flat varying vec3 vCentr;

                ${globalUBO_default}
                ${falloff_default}
                ${slugvs_default}
                ${eases_default}

                float hash13(vec3 p3) {
                    p3  = fract(p3 * .1031);
                    p3 += dot(p3, p3.zyx + 31.32);
                    return fract((p3.x + p3.y) * p3.z);
                }

                vec2 hash23(vec3 p3) {
                    p3 = fract(p3 * vec3(.1031, .1030, .0973));
                    p3 += dot(p3, p3.yzx+33.33);
                    return fract((p3.xx+p3.yz)*p3.zy);
                }

                void main() {
                    vCentr = centr;
                    vec3 pos = SlugVS();

                    float seed = fract(hash13(centr));

                    // animation
                    if (uShow < 1.0 || uHide > 0.0) {
                        // show
                        float stepsShow = floor(3.0 + seed * 2.0);
                        float trShow = floor(falloff(textWeights.y, 0.0, 1.0, 0.1, uShow) * stepsShow) / stepsShow;
                        vTexCoord += vec2(0.0, 1.0) * (1.0 - trShow);

                        // hide
                        float stepsHide = floor(2.0 + seed * 2.0);
                        float trHide = 1.0 - floor(uHide * (stepsHide + 1.0)) / (stepsHide + 1.0);
                        pos -= centr;
                        pos *= trHide;
                        pos += centr;
                    }

                    // wiggle
                    float steppedTime = floor(time * 1.6 * mix(fract(seed), 0.8, 1.0) + seed * 15.3423) / 7.0;
                    vec2 offset = (hash23(centr + vec3(steppedTime, 0.0, 0.0)) * 2.0 - 1.0) * 0.5;
                    pos.xy += offset;

                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `, fragmentShader: `
                uniform sampler2D tCurve;
                uniform usampler2D tBand;

                flat varying vec3 vCentr;

                ${globalUBO_default}
                ${slugfs_default}
                ${transformUV_default}

                void main() {

                    vec2 uv = vTexCoord;
                    vec4 color = RenderSlug(tCurve, tBand, uv, vColor, vBanding, vGlyph);

                    // skip outline
                    gl_FragColor = vec4(-color.xyz, color.w * vColor.w);
                }
            `, transparent: !0, depthWrite: !1
        })), this.text.name = "Textbox Text", this.text.frustumCulled = !1, this.text.rederOrder = -5, this.text.visible = !!client$1.devScene, this.text.matrixAutoUpdate = !1, await this.text.ready, this.iconMesh = new Mesh(l, new ShaderMaterial({
            name: "quest-icon", uniformsGroups: [global$1.UBO], uniforms: { uShow: { value: client$1.devScene ? 1 : 0 }, uSeed: { value: Math.random() }, uColor: { value: new Color("#FFFFFF") }, uOverwriteColor: { value: !1 }, tBand: { value: a }, tCurve: { value: o } }, vertexShader: `
                uniform float uShow;
                uniform float uSeed;
                uniform vec3 uColor;
                uniform bool uOverwriteColor;

                varying vec2 vUv;

                ${globalUBO_default}
                ${slugvs_default}
                ${falloff_default}
                ${rotate_default}

                float hash11(float p) {
                    p = fract(p * .1031);
                    p *= p + 33.33;
                    p *= p + p;
                    return fract(p);
                }

                void main() {
                    vUv = uv;
                    vec3 pos = SlugVS();

                    float rot = floor((time * 0.5 + uSeed * 34.23) * 7.0) / 7.0;
                    float angle = 0.03;
                    pos *= rotateZ(mix(-angle, angle, hash11(rot)));

                    float scaleShow = uShow;
                    float steps = floor(2.0 + fract(uSeed * 54.35452) * 3.0);
                    float scaleShowStepped = floor(scaleShow * steps) / steps;
                    pos *= scaleShowStepped;

                    if (uOverwriteColor) vColor.rgb = uColor;

                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `, fragmentShader: `
                uniform sampler2D tCurve;
                uniform usampler2D tBand;

                ${slugfs_default}

                varying vec2 vUv;

                void main() {
                    vec4 color = RenderSlug(tCurve, tBand, vTexCoord, vColor, vBanding, vGlyph);

                    if (color.w * vColor.w < 0.001) discard;

                    gl_FragColor = vec4(color.rgb, 1.0);
                }
            `})), this.iconMesh.name = "quest icon", this.iconMesh.frustumCulled = !1, this.iconMesh.visible = !!client$1.devScene, this.iconMesh.renderOrder = -4, this.iconMesh.matrixAutoUpdate = !1, this.dialog.questCnt.add(this.bg), this.dialog.questCnt.add(this.text), this.dialog.questCnt.add(this.iconMesh), this.ready.resolve()
    } async update(e = "placeholder text", i = "ui/cross.icon") { this.text.setText(e.toUpperCase(), !1), this.icon = i; const [s, a, o] = await Promise.all([glyphLoader.loadTexture(this.icon, "band"), glyphLoader.loadTexture(this.icon, "curve"), glyphLoader.loadGeometry(this.icon, { size: 1 })]); this.iconMesh.geometry.dispose(), this.iconMesh.geometry = o, this.iconAspect = Math.abs(o.boundingBox.max.x - o.boundingBox.min.x) / Math.abs(o.boundingBox.max.y - o.boundingBox.min.y), this.iconMesh.material.uniforms.tBand.value = s, this.iconMesh.material.uniforms.tCurve.value = a, await this.resize() } show(e = 0, i = !1, s) { this.bg.visible = !1, this.text.visible = !1, this.iconMesh.visible = !1; const a = typeof i == "string"; this.iconMesh.material.uniforms.uOverwriteColor.value = a, a && this.iconMesh.material.uniforms.uColor.value.setStyle(i), this.bg.material.uniforms.uSeed.value = Math.random(), createTween(this.bg.material.uniforms.uShow, { from: { value: 0 }, to: { value: 1 }, duration: .35, ease: "none", delay: e, onStart: () => { this.bg.visible = !0 } }); const o = meshText.getTextWithoutTags(s).length * (1 / 45); createTween(this.text.material.uniforms.uHide, { to: { value: 0 } }), createTween(this.text.material.uniforms.uShow, { from: { value: 0 }, to: { value: 1 }, duration: o, ease: "none", delay: e + .35, onStart: () => { this.text.visible = !0, this.playDialogue(!0) }, onComplete: () => { this.playDialogue(!1) } }), this.iconMesh.material.uniforms.uSeed.value = Math.random(), createTween(this.iconMesh.material.uniforms.uShow, { from: { value: 0 }, to: { value: 1 }, duration: .2, ease: "none", delay: e + .35, onStart: () => { this.iconMesh.visible = !0 } }) } hide() { createTween(this.text.material.uniforms.uHide, { to: { value: 1 }, duration: .05, ease: "none", delay: 0, onComplete: () => { this.text.visible = !1 } }), createTween(this.iconMesh.material.uniforms.uShow, { to: { value: 0 }, duration: .05, ease: "none", delay: 0, onStart: () => { this.iconMesh.visible = !1 } }), createTween(this.bg.material.uniforms.uShow, { to: { value: 0 }, duration: .15, ease: "none", delay: .05, onComplete: () => { this.bg.visible = !1 } }), this.playDialogue(!1) } playDialogue(e = !0) { createTween(this.volumes, { to: { dialogue: e ? 1 : 0 }, duration: .25, onUpdate: () => { events.emit("webgl_set_audio_volume", "dialogue-quest", this.volumes.dialogue * .075) } }) } async resize() { const e = this.dialog.scene, i = e.marginTop * 1.25, s = e.mobile ? 25 : 30, a = e.mobile ? 20 : 25, o = (e.mobile, 40), l = e.mobile ? 20 : 25, c = e.mobile ? 45 : e.small ? 65 : 70, d = Math.min(450, client$1.screen.width - s * 2 - e.marginLeft - c), p = e.mobile ? 15 : 25, f = d - a * 2 - p, _ = f * .25, x = f - _, b = e.mobile ? 17 : e.small ? 23 : 25, T = e.mobile ? -.02 : -.05; await this.text.update({ size: b, width: x, letterSpacing: T }); const M = client$1.screen.width * .5 - e.marginLeft - c - s, w = Math.max(0, d * .5 - M), D = Math.max(this.text.size.y, _), R = D + o + l, P = -client$1.screen.height + i; this.bg.scale.set(d, R, 1), this.bg.position.set(client$1.screen.width * .5 - w, P + R * .5, 0); const U = this.iconAspect > 1 ? _ / this.iconAspect : _; this.iconMesh.scale.set(U, U, 1), this.iconMesh.position.set(this.bg.position.x - d * .5 + a + _ * .5, this.bg.position.y, 0), this.text.position.set(this.iconMesh.position.x + _ * .5 + p, P + R - o - (D - this.text.size.y) * .5, 0), this.bg.material.uniforms.uTextAdjust.value.set(a + _ + p * .5, a, l, o - this.text.topAlign), this.bg.updateMatrix(), this.text.updateMatrix(), this.iconMesh.updateMatrix() }
} const _c0 = new Color; class titlebox {
    constructor(e) { this.dialog = e, this.ready = miscutils.deferred(), this.defaultColor = new Color("#66BDE6"), this.color = this.defaultColor.clone(), this.font = "heading.font", this.init() } async init() {
        const e = this.dialog.scene.squareGeo3; this.bg = new Mesh(e, new ShaderMaterial({
            userData: { hotReload: "titlebox-bg" }, uniformsGroups: [global$1.UBO], uniforms: { uColor: { value: new Color("#66BDE6") }, uColorShadow: { value: new Color("#488BAA") }, uSeed: { value: Math.random() }, uShow: { value: client$1.devScene ? 1 : 0 }, uShadowOffset: { value: 5.5 } }, vertexShader: `
                attribute int side;
                attribute int vertid;

                ${globalUBO_default}
                ${matrixutils_default}
                ${falloff_default}

                uniform float uSeed;
                uniform float uShow;
                uniform float uShadowOffset;
                uniform vec3 uColor;
                uniform vec3 uColorShadow;

                varying vec2 vUv;
                flat varying vec3 vColor;

                void main() {
                    vec3 localPos = position;

                    float steps = 4.0;
                    float scaleShowStepped = floor(uShow * steps) / steps;

                    float vertSeed = fract(uSeed * 72.32 + float(vertid) * 36.223 + scaleShowStepped * 62.543);
                    float offset = (vertSeed * 2.0 - 1.0) * 0.02;
                    vec3 dir = normalize(vec3(position.xy, 0.0));
                    localPos += dir * offset;

                    vec4 pos = vec4(localPos * scaleShowStepped, 1.0);
                    vec4 wPos = modelMatrix * pos;

                    vUv = uv;
                    vColor = uColor;

                    if (scaleShowStepped > 0.0) {
                        if (side == 1) { // backdrop shadow
                            wPos.xy += uShadowOffset * vec2(1.0, -1.0);
                            vColor = uColorShadow;
                        } else if (side == 2) { // inside to prevent outlines due to color changes
                            wPos.xy -= (uv * 2.0 - 1.0) * step(0.01, uShow) * 5.0; // px inward
                            vColor = -uColor;
                            //vColor = uColor * 0.3; // debug
                        }
                    }

                    gl_Position = projectionMatrix * viewMatrix * wPos;
                }
            `, fragmentShader: `
                varying vec2 vUv;
                flat varying vec3 vColor;

                void main() {
                    gl_FragColor = vec4(vColor, 1.0);
                }
            `, depthWrite: !1, depthTest: !1
        })), this.bg.name = "quest title bg", this.bg.frustumCulled = !1, this.bg.renderOrder = -2, this.bg.visible = !!client$1.devScene, this.bg.matrixAutoUpdate = !1; const [i, s] = await Promise.all([glyphLoader.loadTexture(this.font, "band"), glyphLoader.loadTexture(this.font, "curve")]); this.text = new meshText({ font: this.font, small: !1, text: "office worker".toUpperCase(), size: 1, width: 20, letterSpacing: 0, lineHeight: 1.1, color: "#ffffff", align: "left", shadow: !0, shadowX: .08, shadowY: .08, shadowColor: "#0f0f0f" }, new ShaderMaterial({
            name: "quest title text", defines: {}, userData: { hotReload: "quest title text" }, uniformsGroups: [global$1.UBO], uniforms: { tCurve: { value: s }, tBand: { value: i }, uSeed: { value: Math.random() }, uShow: { value: 1 }, uHide: { value: 0 } }, vertexShader: `
                attribute vec3 centr;
                attribute vec2 textWeights;

                uniform float uShow;
                uniform float uHide;

                flat varying vec3 vCentr;

                ${globalUBO_default}
                ${falloff_default}
                ${slugvs_default}
                ${eases_default}

                float hash13(vec3 p3) {
                    p3  = fract(p3 * .1031);
                    p3 += dot(p3, p3.zyx + 31.32);
                    return fract((p3.x + p3.y) * p3.z);
                }

                vec2 hash23(vec3 p3) {
                    p3 = fract(p3 * vec3(.1031, .1030, .0973));
                    p3 += dot(p3, p3.yzx+33.33);
                    return fract((p3.xx+p3.yz)*p3.zy);
                }

                void main() {
                    vCentr = centr;
                    vec3 pos = SlugVS();

                    float seed = fract(hash13(centr));

                    // animation
                    if (uShow < 1.0 || uHide > 0.0) {
                        // show
                        float stepsShow = floor(3.0 + seed * 2.0);
                        float trShow = floor(falloff(textWeights.y, 0.0, 1.0, 1.5, uShow) * stepsShow) / stepsShow;
                        vTexCoord += vec2(0.0, 1.0) * (1.0 - trShow);

                        // hide
                        float stepsHide = floor(2.0 + seed * 2.0);
                        float trHide = 1.0 - floor(uHide * (stepsHide + 1.0)) / (stepsHide + 1.0);
                        pos -= centr;
                        pos *= trShow;
                        pos *= trHide;
                        pos += centr;
                    }

                    // wiggle
                    float steppedTime = floor(time * 1.6 * mix(fract(seed), 0.8, 1.0) + seed * 15.3423) / 7.0;
                    vec2 offset = (hash23(centr + vec3(steppedTime, 0.0, 0.0)) * 2.0 - 1.0) * 0.5;
                    pos.xy += offset;

                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `, fragmentShader: `
                uniform sampler2D tCurve;
                uniform usampler2D tBand;

                flat varying vec3 vCentr;

                ${globalUBO_default}
                ${slugfs_default}
                ${transformUV_default}

                void main() {
                    // animation

                    vec2 uv = vTexCoord;
                    vec4 color = RenderSlug(tCurve, tBand, uv, vColor, vBanding, vGlyph);

                    // skip outline
                    gl_FragColor = vec4(-color.xyz, color.w * vColor.w);
                }
            `, transparent: !0, depthWrite: !1
        })), this.text.name = "quest title text", this.text.frustumCulled = !1, this.text.rederOrder = -1, this.text.visible = !!client$1.devScene, this.text.matrixAutoUpdate = !1, await this.text.ready, this.dialog.questCnt.add(this.bg), this.dialog.questCnt.add(this.text), this.updateColors(), this.ready.resolve()
    } updateColors(e = null) { e ? this.color.setStyle(e) : this.color.copy(this.defaultColor), _c0.copy(this.color).offsetHSL(0, -.3, -.2), this.bg.material.uniforms.uColor.value.copy(this.color), this.bg.material.uniforms.uColorShadow.value.copy(_c0) } show(e = 0, i = null, s) { this.bg.visible = !1, this.text.visible = !1, this.updateColors(i), this.bg.material.uniforms.uSeed.value = Math.random(), createTween(this.bg.material.uniforms.uShow, { from: { value: 0 }, to: { value: 1 }, duration: .35, ease: "none", delay: e, onStart: () => { this.bg.visible = !0 } }), createTween(this.text.material.uniforms.uHide, { to: { value: 0 } }), createTween(this.text.material.uniforms.uShow, { from: { value: 0 }, to: { value: 1 }, duration: .35, ease: "none", delay: e + .25, onStart: () => { this.text.visible = !0 } }) } hide(e = 0) { createTween(this.text.material.uniforms.uHide, { to: { value: 1 }, duration: .05, ease: "none", delay: e, onComplete: () => { this.text.visible = !1 } }), createTween(this.bg.material.uniforms.uShow, { from: { value: 1 }, to: { value: 0 }, duration: .1, ease: "none", delay: e + .05, onComplete: () => { this.bg.visible = !1 } }) } async update(e = "next up") { this.text.setText(e.toUpperCase(), !1), await this.resize() } async resize() { const e = this.dialog.scene, i = this.dialog.textBox, s = e.mobile ? 15 : 25, a = e.mobile ? 20 : 30, o = e.mobile ? 11 : 15, l = e.mobile ? 15 : 22, c = e.mobile ? 25 : 30, h = i.bg.scale.x - a * 2 + s, d = e.mobile ? -.005 : -.01; await this.text.update({ size: c, width: h, letterSpacing: d }); const p = this.text.size.x + a * 2, f = this.text.size.y + this.text.topAlign + o + l; this.bg.scale.set(p, f, 1), this.bg.position.set(i.bg.position.x - i.bg.scale.x * .5 + p * .5 - s, i.bg.position.y + i.bg.scale.y * .5 + f * .5 - 10, 0), this.text.position.set(this.bg.position.x - this.bg.scale.x * .5 + a, this.bg.position.y - this.bg.scale.y * .5 + this.text.size.y + l, 0), this.bg.updateMatrix(), this.text.updateMatrix() }
} class questBox { constructor(e) { this.scene = e, this.globalUI = e.globalUI, this.ready = miscutils.deferred(), this.shown = !1, this.displayed = !1, this.timeout = null, this.init() } async init() { this.questCnt = new Group, this.questCnt.name = "quest box", this.questCnt.matrixAutoUpdate = !1, this.scene.add(this.questCnt), this.textBox = new textbox(this), this.titleBox = new titlebox(this), await Promise.all([this.textBox.ready, this.titleBox.ready]), this.generateTexts(), events.on("character_change_traits_shown", this.hide, this), events.on("npc_dialog_shown", this.hide, this), events.on("ui_emojis_toggle", this.hide, this), events.on("end_screen_show", this.hide, this), events.on("quest_box_display_after_step", this.display, this), this.ready.resolve() } display(e, i, s, a, o = !1) { this.shown && this.hide(), clearTimeout(this.timeout), this.timeout = setTimeout(() => { this.show(e, i, s, a, o) }, 500) } show(e, i, s, a, o) { this.shown = !0; const l = `${e || "next up"}`, c = s || "No quest text provided", h = i || "ui/sidebuttons/poo.icon", d = a || "#f5fdff"; this.generateTexts(l, h, c).then(() => { if (!this.shown) return; this.displayed = !0; const p = o ? d : !1; this.titleBox.show(0, d, l), this.textBox.show(.1, p, c), this.globalUI.playBoxAudio(.5), clearTimeout(this.timeout), this.timeout = setTimeout(() => { this.hide() }, 6 * 1e3) }) } hide(e) { this.shown && (clearTimeout(this.timeout), this.shown = !1, this.displayed = !1, this.textBox.hide(0), this.titleBox.hide(0), this.globalUI.playBoxAudio(.1)) } async generateTexts(e = "next up", i = "ui/sidebuttons/poo.icon", s = "VERNIS K YaNTARSchIKU V PESchERU I OTDAY EMU ODEZhDU") { await this.textBox.update(s, i), await Promise.all([this.titleBox.update(e)]) } resize() { this.textBox.resize().then(() => { this.titleBox.resize() }) } } class dot {
    constructor(e) { this.scene = e, this.shown = !1, this.init() } init() {
        this.mesh = new Mesh(new PlaneGeometry(1, 1), new ShaderMaterial({
            uniforms: { uColor: { value: new Color("#d85656") }, uShow: { value: client$1.devScene ? 1 : 0 }, uSideShow: { value: client$1.devScene ? 1 : 0 } }, vertexShader: `
                varying vec2 vUv;

                uniform float uShow;
                uniform float uSideShow;

                void main() {
                    vUv = uv;

                    float show = uShow * uSideShow;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position * vec3(vec2(show), 1.0), 1.0);
                }
            `, fragmentShader: `
                varying vec2 vUv;

                uniform vec3 uColor;

                void main() {
                    if (length(vUv - 0.5) > 0.5) discard;

                    gl_FragColor = vec4(uColor, 1.0);
                }
            `, depthWrite: !1, depthTest: !1
        })), this.mesh.frustumCulled = !1, this.mesh.name = "Checklist Red Dot", this.mesh.renderOrder = 100, this.mesh.visible = !!client$1.devScene, this.mesh.matrixAutoUpdate = !1, this.scene.add(this.mesh), this.shown = this.mesh.visible, events.on("ui_sideicons_hidden", this.sideHide, this), events.on("ui_sideicons_shown", this.sideShow, this)
    } sideShow() { createTween(this.mesh.material.uniforms.uSideShow, { to: { value: 1 }, duration: .1, delay: .4 }) } sideHide() { createTween(this.mesh.material.uniforms.uSideShow, { to: { value: 0 }, duration: .1, delay: .2 }) } show() { this.shown || (this.shown = !0, createTween(this.mesh.material.uniforms.uShow, { to: { value: 1 }, duration: .3, delay: 1, onStart: () => { this.mesh.visible = !0 } })) } hide() { this.shown && (this.shown = !1, createTween(this.mesh.material.uniforms.uShow, { to: { value: 0 }, duration: .2, onComplete: () => { this.mesh.visible = !1 } })) }
} class checkList {
    constructor(e) { this.scene = e, this.ready = miscutils.deferred(), this.font = "UglyDave-Alternates-optimized.font", this.currentSize = 1, this.shown = !1, this.enabledColor = new Color("#0f0f0f"), this.disabledColor = new Color("#6D6D6D"), this.init() } async init() {
        this.dot = new dot(this.scene); const e = this.scene.squareGeo3; this.bg = new Mesh(e, new ShaderMaterial({
            userData: { hotReload: "checklist-bg" }, uniformsGroups: [global$1.UBO], uniforms: { uColor: { value: new Color("#F8F8F8") }, uColorShadow: { value: new Color("#647A87") }, uSeed: { value: Math.random() }, uShow: { value: client$1.devScene ? 1 : 0 }, uShadowOffset: { value: 5.5 } }, vertexShader: `
                attribute int side;
                attribute int vertid;

                ${globalUBO_default}
                ${matrixutils_default}
                ${falloff_default}

                uniform float uSeed;
                uniform float uShow;
                uniform float uShadowOffset;
                uniform vec3 uColor;
                uniform vec3 uColorShadow;

                varying vec2 vUv;
                flat varying vec3 vColor;

                void main() {
                    vec3 localPos = position;

                    float steps = 4.0;
                    float scaleShowStepped = floor(uShow * steps) / steps;

                    float vertSeed = fract(uSeed * 54.32 + float(vertid) * 12.645 + scaleShowStepped * 34.5435);
                    float offset = (vertSeed * 2.0 - 1.0) * 0.02;
                    vec3 dir = normalize(vec3(position.xy, 0.0));
                    localPos += dir * offset;
                    localPos.xy -= 0.5;

                    vec4 pos = vec4(localPos * scaleShowStepped, 1.0);
                    vec4 wPos = modelMatrix * pos;

                    vUv = uv;
                    vColor = uColor;

                    if (scaleShowStepped > 0.0) {
                        if (side == 1) { // backdrop shadow
                            wPos.xy += uShadowOffset * vec2(1.0, -1.0);
                            vColor = uColorShadow;
                        } else if (side == 2) { // inside to prevent outlines due to color changes
                            wPos.xy -= (uv * 2.0 - 1.0) * step(0.01, uShow) * vec2(10.0, 10.0); // px inward
                            vColor = -uColor;
                            // vColor = uColor * 0.3; // debug
                        }
                    }

                    gl_Position = projectionMatrix * viewMatrix * wPos;
                }
            `, fragmentShader: `
                varying vec2 vUv;
                flat varying vec3 vColor;

                void main() {
                    gl_FragColor = vec4(vColor, 1.0);
                }
            `, depthWrite: !1, depthTest: !1
        })), this.bg.name = "checklist bg", this.bg.frustumCulled = !1, this.bg.renderOrder = -10, this.bg.visible = !1, this.bg.matrixAutoUpdate = !1; const [i, s] = await Promise.all([glyphLoader.loadTexture(this.font, "band"), glyphLoader.loadTexture(this.font, "curve")]); this.text = new meshText({ font: this.font, small: !1, text: "placeholder".toUpperCase(), size: 1, width: 27, letterSpacing: -.05, lineHeight: 1.1, color: `#${this.enabledColor.getHexString()}`, align: "left" }, new ShaderMaterial({
            name: "checklist-text", defines: { SLUG_WEIGHT: 1 }, userData: { hotReload: "texbox text" }, uniformsGroups: [global$1.UBO], uniforms: { tCurve: { value: s }, tBand: { value: i }, uSeed: { value: Math.random() }, uShow: { value: 1 }, uHide: { value: 0 } }, vertexShader: `
                attribute vec3 centr;
                attribute vec2 textWeights;

                uniform float uShow;
                uniform float uHide;

                flat varying vec3 vCentr;

                ${globalUBO_default}
                ${falloff_default}
                ${slugvs_default}
                ${eases_default}

                float hash13(vec3 p3) {
                    p3  = fract(p3 * .1031);
                    p3 += dot(p3, p3.zyx + 31.32);
                    return fract((p3.x + p3.y) * p3.z);
                }

                vec2 hash23(vec3 p3) {
                    p3 = fract(p3 * vec3(.1031, .1030, .0973));
                    p3 += dot(p3, p3.yzx+33.33);
                    return fract((p3.xx+p3.yz)*p3.zy);
                }

                void main() {
                    vCentr = centr;
                    vec3 pos = SlugVS();

                    float seed = fract(hash13(centr));

                    // animation
                    if (uShow < 1.0 || uHide > 0.0) {
                        // show
                        float stepsShow = floor(3.0 + seed * 2.0);
                        float trShow = floor(falloff(textWeights.y, 0.0, 1.0, 0.1, uShow) * stepsShow) / stepsShow;
                        vTexCoord += vec2(0.0, 1.0) * (1.0 - trShow);

                        // hide
                        float stepsHide = floor(2.0 + seed * 2.0);
                        float trHide = 1.0 - floor(uHide * (stepsHide + 1.0)) / (stepsHide + 1.0);
                        pos -= centr;
                        pos *= trHide;
                        pos += centr;
                    }

                    // wiggle
                    float steppedTime = floor(time * 1.6 * mix(fract(seed), 0.8, 1.0) + seed * 15.3423) / 7.0;
                    vec2 offset = (hash23(centr + vec3(steppedTime, 0.0, 0.0)) * 2.0 - 1.0) * 0.5;
                    pos.xy += offset;

                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `, fragmentShader: `
                uniform sampler2D tCurve;
                uniform usampler2D tBand;

                flat varying vec3 vCentr;

                ${globalUBO_default}
                ${slugfs_default}
                ${transformUV_default}

                void main() {
                    vec2 uv = vTexCoord;
                    vec4 color = RenderSlug(tCurve, tBand, uv, vColor, vBanding, vGlyph);

                    // skip outline
                    gl_FragColor = vec4(-color.xyz, color.w * vColor.w);
                }
            `, transparent: !0, depthWrite: !1
        })), this.text.name = "Checklist Text", this.text.frustumCulled = !1, this.text.rederOrder = -5, this.text.visible = !1, this.text.matrixAutoUpdate = !1, await this.text.ready, this.buildText(), this.domBg = document.createElement("div"), this.domBg.className = "checklist-bg", this.domBg.style.cssText = "position: absolute;user-select: none;touch-action: none;pointer-events: none;", this.scene.globalUI.domContainer.appendChild(this.domBg), this.scene.add(this.bg), this.scene.add(this.text), events.on("ui_quest_log_toggle", this.toggle, this), events.on("character_change_traits_shown", this.hide, this), events.on("npc_dialog_shown", this.hide, this), events.on("ui_emojis_toggle", this.hide, this), events.on("touch_click", this.hide, this), events.on("end_screen_show", this.hide, this), events.on("quest_info_checklist_update", this.update, this), this.ready.resolve()
    } toggle() { this.shown ? this.hide() : (this.show(), this.dot.hide()) } show(e = 0) { this.shown || (this.shown = !0, this.bg.visible = !1, this.text.visible = !1, this.bg.material.uniforms.uSeed.value = Math.random(), createTween(this.bg.material.uniforms.uShow, { from: { value: 0 }, to: { value: 1 }, duration: .2, ease: "none", delay: e, onStart: () => { this.bg.visible = !0, this.domBg.style.pointerEvents = "" } }), createTween(this.text.material.uniforms.uHide, { to: { value: 0 } }), createTween(this.text.material.uniforms.uShow, { from: { value: 0 }, to: { value: 1 }, duration: .2, ease: "none", delay: e + .2, onStart: () => { this.text.visible = !0 } }), events.emit("webgl_play_audio", "open-box2"), events.emit("webgl_play_audio", "open-box-checklist")) } hide() { this.shown && (this.shown = !1, createTween(this.text.material.uniforms.uHide, { to: { value: 1 }, duration: .05, ease: "none", delay: 0, onComplete: () => { this.text.visible = !1 } }), createTween(this.bg.material.uniforms.uShow, { from: { value: 1 }, to: { value: 0 }, duration: .15, ease: "none", delay: .05, onComplete: () => { this.bg.visible = !1, this.domBg.style.pointerEvents = "none" } }), events.emit("webgl_play_audio", "open-box1")) } update(e = !1, i = !1) { i ? this.dot.hide() : e && this.dot.show(), this.buildText(), this.resize() } buildText() {
        const e = Object.keys(QUESTINFO).every(s => QUESTINFO[s].steps.every(o => o === !1)); let i = `CHECKLIST:

`; Object.keys(QUESTINFO).forEach((s, a) => {
            const o = QUESTINFO[s], l = o.steps.reduce((f, _) => f + (_ === !0 ? 1 : 0), 0), c = l > 0, h = l === o.steps.length; let d = "", p = ""; !e && (!c || h) && (d += "{#", p += "{#", c || (d += `colorf(${this.disabledColor.r},${this.disabledColor.g},${this.disabledColor.b},1);`, p += `colorf(${this.enabledColor.r},${this.enabledColor.g},${this.enabledColor.b},1);`), h && (d += "strike(true);", p += "strike(false);"), d += "}", p += "}"), i += `${d}${a + 1}. ${o.text} (${l}/${o.steps.length})${p}`, a < Object.keys(QUESTINFO).length - 1 && (i += `{#size(${(this.currentSize * .75).toFixed(2)})}

{#size(${this.currentSize.toFixed(2)})}`)
        }), this.text.setText(i)
    } async resize() { const e = this.scene, i = e.marginTop, s = e.marginLeft, a = this.scene.mobile ? 45 : this.scene.small ? 65 : 70, o = this.scene.mobile ? 15 : 20, l = e.mobile ? 30 : 40, c = e.mobile ? 12 : 20, h = e.mobile ? 35 : 50, d = e.mobile ? 10 : 20, p = e.mobile ? 20 : e.small ? 24 : 26, f = Math.min(client$1.screen.w, 550) - c * 2 - s - a - o - l, _ = -.01; this.currentSize = p, this.buildText(), await this.text.update({ size: p, width: f, letterSpacing: _ }); const x = f + c * 2, b = this.text.bboxSize.y + h + d, T = -i, M = client$1.screen.width - s - a - o; this.bg.scale.set(x, b, 1), this.bg.position.set(M, T, 0); const w = this.domBg.style; w.width = `${this.bg.scale.x}px`, w.height = `${this.bg.scale.y}px`, w.left = `${this.bg.position.x - this.bg.scale.x}px`, w.top = `${Math.abs(this.bg.position.y)}px`, this.text.position.set(M - x + c, T - h, 0), this.dot.mesh.scale.setScalar(this.scene.mobile ? 15 : 20), this.dot.mesh.position.set(client$1.screen.width - s, T, 0), this.bg.updateMatrix(), this.text.updateMatrix(), this.dot.mesh.updateMatrix() }
} function getBatchedIcons(r, e, i) {
    const s = new BatchedMesh(r, e, i, new ShaderMaterial({
        uniformsGroups: [global$1.UBO], uniforms: { uShow: { value: client$1.devScene ? 1 : 0 }, uSeed: { value: Math.random() }, tBands1: { value: null }, tCurves1: { value: null }, tBands2: { value: null }, tCurves2: { value: null }, tBands3: { value: null }, tCurves3: { value: null }, tBands4: { value: null }, tCurves4: { value: null }, tBands5: { value: null }, tCurves5: { value: null }, tNoise: { value: textureLoader.load("noise-simplex-layered-blur-highq.ktx2", "repeat-linearfilter") } }, vertexShader: `
            /* BATCHING */
            #if ! defined(GL_ANGLE_multi_draw)
                #define gl_DrawID _gl_DrawID
                uniform int _gl_DrawID;
            #endif
            uniform highp sampler2D batchingTexture;
            uniform highp usampler2D batchingIdTexture;

            mat4 getBatchingMatrix(const in int i) {
                int size = textureSize(batchingTexture, 0).x;
                int j = i * 4;
                int x = j % size;
                int y = j / size;
                vec4 v1 = texelFetch(batchingTexture, ivec2(x, y), 0);
                vec4 v2 = texelFetch(batchingTexture, ivec2(x + 1, y), 0);
                vec4 v3 = texelFetch(batchingTexture, ivec2(x + 2, y), 0);
                vec4 v4 = texelFetch(batchingTexture, ivec2(x + 3, y), 0);
                return mat4(v1, v2, v3, v4);
            }

            float getIndirectIndex(const in int i) {
                int size = textureSize(batchingIdTexture, 0).x;
                int x = i % size;
                int y = i / size;
                return float(texelFetch(batchingIdTexture, ivec2(x, y), 0).r);
            }

            uniform float uShow;
            uniform float uSeed;

            varying vec2 vUv;
            flat varying int vBatchID;

            ${globalUBO_default}
            ${slugvs_default}
            ${falloff_default}
            ${rotate_default}

            float hash11(float p) {
                p = fract(p * .1031);
                p *= p + 33.33;
                p *= p + p;
                return fract(p);
            }

            void main() {
                vUv = uv;

                float batchID = getIndirectIndex(gl_DrawID);
                vBatchID = int(batchID);
                mat4 batchingMatrix = getBatchingMatrix(vBatchID);

                mat4 bmvpMatrix = projectionMatrix * modelViewMatrix * batchingMatrix;
                vec3 pos = SlugVS(bmvpMatrix);

                float scaleShow = falloff(batchID, 0.0, 5.0, 5.0, uShow);
                float steps = floor(2.0 + fract(uSeed * 45.35452 + batchID * 2.546) * 2.0);
                float scaleShowStepped = floor(scaleShow * steps) / steps;
                pos *= scaleShowStepped;

                float rot = floor((time * 0.5 + batchID * 221.5435 + uSeed * 34.23) * 7.0) / 7.0;
                float angle = 0.05;
                pos *= rotateZ(mix(-angle, angle, hash11(rot)));

                gl_Position = bmvpMatrix * vec4(pos, 1.0);
            }
        `, fragmentShader: `

            // thanks android
            uniform sampler2D tCurves1;
            uniform usampler2D tBands1;
            uniform sampler2D tCurves2;
            uniform usampler2D tBands2;
            uniform sampler2D tCurves3;
            uniform usampler2D tBands3;
            uniform sampler2D tCurves4;
            uniform usampler2D tBands4;
            uniform sampler2D tCurves5;
            uniform usampler2D tBands5;

            uniform sampler2D tNoise;

            ${slugfs_default}

            varying vec2 vUv;
            flat varying int vBatchID;

            void main() {
                vec4 color;

                // can be optimized to use a single texture, but anyway
                if (vBatchID == 0) {
                    color = RenderSlug(tCurves1, tBands1, vTexCoord, vColor, vBanding, vGlyph);
                } else if (vBatchID == 1) {
                    color = RenderSlug(tCurves2, tBands2, vTexCoord, vColor, vBanding, vGlyph);
                } else if (vBatchID == 2) {
                    color = RenderSlug(tCurves3, tBands3, vTexCoord, vColor, vBanding, vGlyph);
                } else if (vBatchID == 3) {
                    color = RenderSlug(tCurves4, tBands4, vTexCoord, vColor, vBanding, vGlyph);
                } else if (vBatchID == 4) {
                    color = RenderSlug(tCurves5, tBands5, vTexCoord, vColor, vBanding, vGlyph);
                }

                if (color.w * vColor.w < 0.001) discard;

                gl_FragColor = vec4(color.rgb, 1.0);
            }
        `, transparent: !1
    })); return s.name = "emojis icons Top", s.sortObjects = !1, s.receiveShadow = !1, s.castShadow = !1, s.frustumCulled = !1, s.perObjectFrustumCulled = !1, s.visible = !1, s.renderOrder = 1, s.matrixAutoUpdate = !1, s
} class emojiList {
    constructor(e) { this.scene = e, this.ready = miscutils.deferred(), this.shown = !1, this.lastSize = 1, this.init() } async init() {
        const e = this.scene.squareGeo2.clone(); e.translate(-.5, .5, 0), this.bg = new Mesh(e, new ShaderMaterial({
            userData: { hotReload: "emojilist-bg" }, uniformsGroups: [global$1.UBO], uniforms: { uColor: { value: new Color("#F8F8F8") }, uColorShadow: { value: new Color("#647A87") }, uSeed: { value: Math.random() }, uShow: { value: client$1.devScene ? 1 : 0 }, uShadowOffset: { value: 5.5 } }, vertexShader: `
                    attribute int side;
                    attribute int vertid;

                    ${globalUBO_default}
                    ${matrixutils_default}
                    ${rotate_default}
                    ${falloff_default}

                    uniform float uSeed;
                    uniform float uShow;
                    uniform float uShadowOffset;
                    uniform vec3 uColor;
                    uniform vec3 uColorShadow;

                    varying vec2 vUv;
                    flat varying vec3 vColor;

                    void main() {
                        vec3 localPos = position;

                        float steps = 4.0;
                        float scaleShowStepped = floor(uShow * steps) / steps;

                        float vertSeed = fract(uSeed * 54.32 + float(vertid) * 12.645 + scaleShowStepped * 34.5435);
                        float offset = (vertSeed * 2.0 - 1.0) * 0.02;

                        localPos.xy += vec2(0.5, -0.5);
                        vec3 dir = normalize(vec3(localPos.xy, 0.0));
                        localPos += dir * offset;
                        localPos.xy -= vec2(0.5, -0.5);

                        vec4 pos = vec4(localPos * scaleShowStepped, 1.0);
                        vec4 wPos = modelMatrix * pos;

                        vUv = uv;
                        vColor = uColor;

                        if (scaleShowStepped > 0.0) {
                            if (side == 1) { // backdrop shadow
                                wPos.xy += uShadowOffset * vec2(1.0, -1.0);
                                vColor = uColorShadow;
                            }
                        }

                        gl_Position = projectionMatrix * viewMatrix * wPos;
                    }
                `, fragmentShader: `
                    varying vec2 vUv;
                    flat varying vec3 vColor;

                    void main() {
                        gl_FragColor = vec4(vColor, 1.0);
                    }
                `, depthWrite: !1, depthTest: !1
        })), this.bg.name = "emojilist bg", this.bg.frustumCulled = !1, this.bg.renderOrder = -10, this.bg.visible = !1, this.bg.matrixAutoUpdate = !1; const i = []; for (let c = 0; c < 10; c++)i.push(Promise.all([glyphLoader.loadTexture(`ui/emojis/${c}.icon`, "band"), glyphLoader.loadTexture(`ui/emojis/${c}.icon`, "curve"), glyphLoader.loadGeometry(`ui/emojis/${c}.icon`, { size: 1 })])); const s = await Promise.all(i), a = s.map(c => c[2]), o = a.slice(0, 5), l = a.slice(5, 10); this.meshIconsBottom = getBatchedIcons(o.length, o.reduce((c, h) => c + h.attributes.position.count, 0), o.reduce((c, h) => c + h.index.count, 0)), this.meshIconsBottom.name = "emojis icons Bottom", this.meshIconsTop = getBatchedIcons(o.length, l.reduce((c, h) => c + h.attributes.position.count, 0), l.reduce((c, h) => c + h.index.count, 0)), this.meshIconsTop.name = "emojis icons Top"; for (let c = 0; c < 10; c++)c < 5 ? (this.meshIconsBottom.material.uniforms[`tBands${c + 1}`].value = s[c][0], this.meshIconsBottom.material.uniforms[`tCurves${c + 1}`].value = s[c][1]) : (this.meshIconsTop.material.uniforms[`tBands${c - 4}`].value = s[c][0], this.meshIconsTop.material.uniforms[`tCurves${c - 4}`].value = s[c][1]); this._animObjs = []; for (let c = 0; c < 10; c++)this._animObjs.push({ hover: 0, scaleHover: 1 }); this.meshIconsBottom.__objs = [], this.meshIconsTop.__objs = [], a.forEach((c, h) => { h < 5 ? (this.meshIconsBottom.addInstance(this.meshIconsBottom.addGeometry(c)), this.meshIconsBottom.__objs.push(new Object3D)) : (this.meshIconsTop.addInstance(this.meshIconsTop.addGeometry(c)), this.meshIconsTop.__objs.push(new Object3D)) }), this.domBg = document.createElement("div"), this.domBg.className = "emoji-bg", this.domEmojis = []; for (let c = 0; c < 10; c++)this.domEmojis.push(document.createElement("div"));[this.domBg, ...this.domEmojis].forEach((c, h) => { c.style.cssText = "position: absolute;user-select: none;touch-action: none;pointer-events: none;", (h === 0 ? this.scene.globalUI.domContainer : this.domBg).appendChild(c) }), this.scene.add(this.bg), this.scene.add(this.meshIconsBottom), this.scene.add(this.meshIconsTop), this.resize(), this.interaction = new domInteraction({ nodes: [...this.domEmojis], onHover: this.hover, onTouch: this.touch, onClick: this.click, ctx: this, hoverCursor: !0 }), events.on("ui_emojis_toggle", this.toggle, this), events.on("character_change_traits_shown", this.hide, this), events.on("npc_dialog_shown", this.hide, this), events.on("ui_quest_log_toggle", this.hide, this), events.on("touch_click", this.hide, this), events.on("end_screen_show", this.hide, this), this.ready.resolve()
    } toggle() { this.shown ? this.hide() : this.show() } hover(e) { if (e.action === "hover_out") return; const i = e.nodeIndex, s = this._animObjs[i], a = i < 5 ? this.meshIconsBottom : this.meshIconsTop, o = a.__objs; createTween(s, { from: { hover: 0 }, to: { hover: 1 }, duration: .07, ease: "none", onStart: () => { const l = i % 5; o[l].scale.set(this.lastSize, this.lastSize, 1).multiplyScalar(.95), o[l].updateMatrix(), a.setMatrixAt(l, o[l].matrix) }, onComplete: () => { const l = i % 5; o[l].scale.set(this.lastSize, this.lastSize, 1), o[l].updateMatrix(), a.setMatrixAt(l, o[l].matrix) } }) } touch(e) { const i = e.nodeIndex, s = this._animObjs[i], a = i < 5 ? this.meshIconsBottom : this.meshIconsTop, o = a.__objs, l = e.action === "touch_start"; this.bg.material.uniforms.uSeed.value = Math.random(), [this.meshIconsBottom, this.meshIconsTop].forEach(c => { c.material.uniforms.uSeed.value = Math.random() }), createTween(s, { to: { scaleHover: 1 }, duration: 0, ease: "none", onComplete: () => { const c = i % 5; o[c].scale.set(this.lastSize, this.lastSize, 1).multiplyScalar(l ? .875 : 1), o[c].updateMatrix(), a.setMatrixAt(c, o[c].matrix) } }) } click(e) { typeof EMOJI_MAP[e.nodeIndex] == "number" && events.emit("character_emoji_display", EMOJI_MAP[(e.nodeIndex + 1) % 10]) } show(e = 0) { this.shown || (this.shown = !0, this.bg.visible = !1, this.meshIconsBottom.visible = !1, this.meshIconsTop.visible = !1, this.bg.material.uniforms.uSeed.value = Math.random(), createTween(this.bg.material.uniforms.uShow, { from: { value: 0 }, to: { value: 1 }, duration: .15, ease: "none", delay: e, onStart: () => { this.bg.visible = !0, this.domBg.style.pointerEvents = "" }, onComplete: () => { this.interaction.enable() } }), [this.meshIconsBottom, this.meshIconsTop].forEach((i, s) => { createTween(i.material.uniforms.uShow, { from: { value: 0 }, to: { value: 1 }, duration: .15, ease: "none", delay: e + .15 + s * .075, onStart: () => { i.visible = !0 } }) }), events.emit("webgl_play_audio", "open-box2"), events.emit("webgl_play_audio", "open-box-emote")) } hide() { this.shown && (this.shown = !1, this.interaction.disable(), [this.meshIconsTop, this.meshIconsBottom].forEach((e, i) => { createTween(e.material.uniforms.uShow, { from: { value: 1 }, to: { value: 0 }, duration: .05, ease: "none", delay: 0, onComplete: () => { e.visible = !1 } }) }), createTween(this.bg.material.uniforms.uShow, { from: { value: 1 }, to: { value: 0 }, duration: .15, ease: "none", delay: .05, onComplete: () => { this.bg.visible = !1, this.domBg.style.pointerEvents = "none" } }), events.emit("webgl_play_audio", "open-box1")) } resize() { const e = this.scene, i = e.marginTop, s = e.marginLeft, a = this.scene.mobile ? 45 : this.scene.small ? 65 : 70, o = this.scene.mobile ? 15 : 20, l = e.mobile ? 30 : 40, c = e.mobile ? 12 : this.scene.small ? 15 : 20, h = e.mobile || this.scene.small ? 15 : 20, d = h, p = this.scene.mobile ? 375 : this.scene.small ? 475 : 550, f = Math.min(client$1.screen.w, p) - c * 2 - s - a - o - l, _ = this.scene.mobile ? 13 : this.scene.small ? 17 : 20, x = this.scene.mobile ? 10 : this.scene.small ? 15 : 20, b = (f - _ * 4) / 5, T = b * 2 + x, M = f + c * 2, w = T + h + d, D = -client$1.screen.height + i, R = client$1.screen.width - s - a - o; this.lastSize = b, this.bg.scale.set(M, w, 1), this.bg.position.set(R, D, 0); const P = this.domBg.style; P.width = `${this.bg.scale.x}px`, P.height = `${this.bg.scale.y}px`, P.left = `${this.bg.position.x - this.bg.scale.x}px`, P.top = `${Math.abs(this.bg.position.y) - this.bg.scale.y}px`, this.domEmojis.forEach((O, N) => { O.style.width = `${b}px`, O.style.height = `${b}px`; const H = this.bg.scale.x - c - b - (_ + b) * (N % 5); O.style.left = `${H}px`; const F = this.bg.scale.y - d - b - (N < 5 ? 0 : x + b); O.style.top = `${F}px` }); let U = [1, 1, 1, 1, 1]; for (let O = 0; O < 5; O++) { const N = O, H = R - c - b * .5 - (_ + b) * N, F = D + d + b * .5; this.meshIconsBottom.__objs[N].position.set(H, F, 0), this.meshIconsBottom.__objs[N].scale.set(b, b, 1).multiplyScalar(U[N]), this.meshIconsBottom.__objs[N].updateMatrix(), this.meshIconsBottom.setMatrixAt(N, this.meshIconsBottom.__objs[N].matrix) } U = [1, 1, 1, 1, 1]; for (let O = 5; O < 10; O++) { const N = O - 5, H = R - c - b * .5 - (_ + b) * N, F = D + d + b + x + b * .5; this.meshIconsTop.__objs[N].position.set(H, F, 0), this.meshIconsTop.__objs[N].scale.set(b, b, 1).multiplyScalar(U[N]), this.meshIconsTop.__objs[N].updateMatrix(), this.meshIconsTop.setMatrixAt(N, this.meshIconsTop.__objs[N].matrix) } this.bg.updateMatrix(), this.meshIconsBottom.updateMatrix(), this.meshIconsTop.updateMatrix() }
} function createMaterial(r, e) {
    return new ShaderMaterial({
        defines: {}, uniformsGroups: [global$1.UBO], uniforms: { tCurve: { value: r }, tBand: { value: e }, uSeed: { value: Math.random() }, uShow: { value: client$1.devScene ? 1 : 0 }, uHide: { value: 0 }, uScale: { value: 1 } }, vertexShader: `
            attribute vec3 centr;
            attribute vec2 textWeights;

            uniform float uShow;
            uniform float uHide;
            uniform float uScale;

            flat varying vec3 vCentr;

            ${globalUBO_default}
            ${falloff_default}
            ${slugvs_default}
            ${eases_default}

            float hash13(vec3 p3) {
                p3  = fract(p3 * .1031);
                p3 += dot(p3, p3.zyx + 31.32);
                return fract((p3.x + p3.y) * p3.z);
            }

            vec2 hash23(vec3 p3) {
                p3 = fract(p3 * vec3(.1031, .1030, .0973));
                p3 += dot(p3, p3.yzx+33.33);
                return fract((p3.xx+p3.yz)*p3.zy);
            }

            void main() {
                vCentr = centr;
                vec3 pos = SlugVS();

                float seed = fract(hash13(centr));

                // animation
                if (uShow < 1.0 || uHide > 0.0) {
                    // show
                    float stepsShow = floor(3.0 + seed * 2.0);
                    float trShow = floor(falloff(textWeights.x, 0.0, 1.0, 0.35, uShow) * stepsShow) / stepsShow;
                    vTexCoord += vec2(0.0, 1.0) * (1.0 - trShow);

                    // hide
                    float stepsHide = floor(2.0 + seed * 2.0);
                    float trHide = 1.0 - floor(uHide * (stepsHide + 1.0)) / (stepsHide + 1.0);
                    pos -= centr;
                    pos *= trHide;
                    pos += centr;
                }

                // wiggle
                float steppedTime = floor(time * 1.6 * mix(fract(seed), 0.8, 1.0) + seed * 15.3423) / 7.0;
                vec2 offset = (hash23(centr + vec3(steppedTime, 0.0, 0.0)) * 2.0 - 1.0) * 0.5;
                pos.xy += offset;

                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos * uScale, 1.0);
            }
        `, fragmentShader: `
            uniform sampler2D tCurve;
            uniform usampler2D tBand;

            flat varying vec3 vCentr;

            ${globalUBO_default}
            ${slugfs_default}
            ${transformUV_default}

            void main() {
                vec2 uv = vTexCoord;
                vec4 color = RenderSlug(tCurve, tBand, uv, vColor, vBanding, vGlyph);

                // skip outline
                gl_FragColor = vec4(-color.xyz, color.w * vColor.w);
            }
        `, transparent: !0, depthWrite: !1
    })
} class endScreen {
    constructor(e) { this.scene = e, this.ready = miscutils.deferred(), this.font = "UglyDave-Alternates-optimized.font", this.color = new Color("#ffffff"), this.shadowColor = new Color("#030303"), this.volumes = { dialogue: 0 }, this.shown = !1, this.init() } async init() {
        const [e, i] = await Promise.all([glyphLoader.loadTexture(this.font, "band"), glyphLoader.loadTexture(this.font, "curve")]); this.text = new meshText({ font: this.font, small: !1, text: "placeholder".toUpperCase(), size: 1, width: 10, letterSpacing: -.05, lineHeight: 1.1, color: `#${this.color.getHexString()}`, align: "center", shadow: !0, shadowColor: `#${this.shadowColor.getHexString()}`, shadowX: .06, shadowY: .06 }, createMaterial(i, e)), this.text.name = "End Screen Text", this.text.frustumCulled = !1, this.text.rederOrder = 20, this.text.visible = !1, this.text.matrixAutoUpdate = !1, this.textContinue = new meshText({ font: this.font, small: !1, text: "prodolzhit".toUpperCase(), size: 1, width: 10, letterSpacing: -.05, lineHeight: 1.1, color: `#${this.color.getHexString()}`, align: "center", shadow: !0, shadowColor: `#${this.shadowColor.getHexString()}`, shadowX: .06, shadowY: .06 }, createMaterial(i, e)), this.textContinue.name = "End Screen Text Continue", this.textContinue.frustumCulled = !1, this.textContinue.rederOrder = 20, this.textContinue.visible = !1, this.textContinue.matrixAutoUpdate = !1, this.underline = new Mesh(this.scene.squareGeo2.clone(), new ShaderMaterial({
            uniforms: { uShow: { value: client$1.devScene ? 1 : 0 }, uHide: { value: 0 }, uHover: { value: 0 }, uColor1: { value: this.color }, uColor2: { value: this.shadowColor } }, vertexShader: `
                uniform float uHover;

                attribute int side;
                flat varying int vSide;
                varying vec2 vUv;

                void main() {
                    vSide = side;
                    vUv = uv;

                    vec4 wPos = modelMatrix * vec4(position, 1.0);
                    if (side == 1) wPos.xy += vec2(2.0, -2.0);
                    wPos.y -= uHover * 3.0;
                    gl_Position = projectionMatrix * viewMatrix * wPos;
                }
            `, fragmentShader: `
                uniform float uShow;
                uniform float uHide;
                uniform vec3 uColor1;
                uniform vec3 uColor2;

                flat varying int vSide;
                varying vec2 vUv;

                ${fit_default}

                void main() {
                    vec3 color = vSide == 0 ? uColor1 : uColor2;

                    float showAmount = step(vUv.x, uShow);
                    float hideAmount = step(uHide, vUv.x);

                    // float hoverOut = step(fit(uHover, 0.0, 0.5, 0.0, 1.0), vUv.x);
                    // float hoverIn = 1.0 - step(fit(uHover, 0.5, 1.0, 0.0, 1.0), vUv.x);

                    float show = showAmount * hideAmount /* * max(hoverIn, hoverOut) */;
                    if (show < 0.0001) discard;

                    gl_FragColor = vec4(-color, 1.0);
                }
            `})), this.underline.name = "End Screen Underline", this.underline.frustumCulled = !1, this.underline.renderOrder = 20, this.underline.visible = !1, this.underline.matrixAutoUpdate = !1, await Promise.all([this.text.ready, this.textContinue.ready]), this.domButton = document.createElement("div"), this.domButton.className = "continue-button", this.domButton.style.cssText = "position: absolute;user-select: none;touch-action: none;pointer-events: none;", this.scene.globalUI.domContainer.appendChild(this.domButton), this.interaction = new domInteraction({ nodes: [this.domButton], onHover: this.hoverButton, onClick: this.clickButton, ctx: this, hoverCursor: !0 }), this.scene.add(this.text), this.scene.add(this.textContinue), this.scene.add(this.underline), events.on("end_screen_show", this.show, this), events.on("end_screen_hide", this.hide, this), this.ready.resolve()
    } show(e = 0) { var s, a; if (this.shown) return; this.shown = !0, this.interaction.enable(), [this.text, this.textContinue, this.underline].forEach((o, l) => { o.visible = !1, o.visible = !1, o.visible = !1; const c = l === 0 ? 1.5 : .65, h = (l === 0 ? 0 : 1.5) + (l === 2 ? .1 : 0) + .1; createTween(o.material.uniforms.uHide, { to: { value: 0 } }), createTween(o.material.uniforms.uShow, { from: { value: 0 }, to: { value: 1 }, duration: c, ease: "none", delay: e + h, onStart: () => { o.visible = !0, l === 0 ? this.playDialogue(!0) : l === 1 && events.emit("webgl_play_audio", "nastroit") }, onComplete: () => { l === 0 && this.playDialogue(!1) } }) }), events.emit("overlay", !0); const i = (a = (s = this.scene.globalUI.controller) == null ? void 0 : s.planetScene) == null ? void 0 : a.characters; i && (i.mesh.interactingElement = null, i.unlockCamera(), i.disable()) } playDialogue(e = !0) { createTween(this.volumes, { to: { dialogue: e ? 1 : 0 }, duration: .25, onUpdate: () => { events.emit("webgl_set_audio_volume", "dialogue-quest", this.volumes.dialogue * .075) } }) } hide(e = 0) { var s, a; if (!this.shown) return; this.shown = !1, this.playDialogue(!1), events.emit("webgl_play_audio", "zoom-off"), this.interaction.disable(), [this.text, this.textContinue, this.underline].forEach((o, l) => { createTween(o.material.uniforms.uHide, { to: { value: 1 }, duration: .1, ease: "none", delay: 0, onComplete: () => { o.visible = !1 } }) }), events.emit("overlay", !1); const i = (a = (s = this.scene.globalUI.controller) == null ? void 0 : s.planetScene) == null ? void 0 : a.characters; i && i.enable() } hoverButton(e) { e.action !== "hover_out" && (createTween(this.underline.material.uniforms.uHover, { to: { value: 1 }, duration: 0, ease: "none", onComplete: () => { createTween(this.underline.material.uniforms.uHover, { to: { value: 0 }, duration: 0, delay: .1, ease: "none" }) } }), createTween(this.textContinue.material.uniforms.uScale, { to: { value: 1.05 }, duration: 0, ease: "none", onComplete: () => { createTween(this.textContinue.material.uniforms.uScale, { to: { value: 1 }, duration: 0, delay: .1, ease: "none" }) } }), events.emit("webgl_play_audio", "hover2")) } clickButton(e) { events.emit("end_screen_hide") } buildText(e = 20) {
        let i = ""; i += `{#size(${(e * 2).toFixed(2)})} YOU MADE IT! {#size(${e.toFixed(2)})}


`, i += `YOU FINISHED ALL THE DELIVERIES!
`, i += `STAY AND EXPLORE THE WORLD, OR REFRESH YOUR BROWSER TO START AGAIN.

`, i += `CREATED IN 2025 BY VICENTE LUCENDO AND MICHAEL SUNGAILA. MUSIC BY KEVIN COLOMBIN.

`, i += "HI@ABETO.CO", this.text.setText(i), this.textContinue.setText(">CONTINUE")
    } async resize() { const e = this.scene, i = e.mobile ? 20 : e.small ? 24 : 30; this.buildText(i); const s = e.mobile ? 30 : 40, a = Math.min(client$1.screen.w, 850) - s * 2, o = -.01; await Promise.all([this.text.update({ size: i, width: a, letterSpacing: o }), this.textContinue.update({ size: i * 1.1, width: a, letterSpacing: o })]); const l = this.text.bboxSize.y, c = i * 2, h = this.textContinue.bboxSize.y, d = 10, p = 3, f = l + c + h + d + p; this.text.position.set(client$1.screen.width * .5, -client$1.screen.height * .5 - this.text.topAlign + f * .5 * .95, 0), this.textContinue.position.set(this.text.position.x, this.text.position.y - l + this.text.topAlign - c, 0), this.underline.scale.set(this.textContinue.bboxSize.x, p, 1), this.underline.position.set(this.textContinue.position.x, this.textContinue.position.y - d, 0); const _ = this.domButton.style, x = this.textContinue.bboxSize.x + 40, b = this.textContinue.bboxSize.y + 40; _.width = `${x}px`, _.height = `${b}px`, _.left = `${this.textContinue.position.x - x * .5}px`, _.top = `${Math.abs(this.textContinue.position.y) - b * .6}px`, this.text.updateMatrix(), this.textContinue.updateMatrix(), this.underline.updateMatrix() }
} const squareGeo2 = mergeGeometries([new PlaneGeometry(1, 1), new PlaneGeometry(1, 1)]); squareGeo2.setAttribute("side", new BufferAttribute(new Int32Array([1, 1, 1, 1, 0, 0, 0, 0]), 1)); squareGeo2.setAttribute("vertid", new BufferAttribute(new Int32Array([1, 2, 3, 4, 1, 2, 3, 4]), 1)); const squareGeo3 = mergeGeometries([new PlaneGeometry(1, 1), new PlaneGeometry(1, 1), new PlaneGeometry(1, 1)]); squareGeo3.setAttribute("side", new BufferAttribute(new Int32Array([1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2]), 1)); squareGeo3.setAttribute("vertid", new BufferAttribute(new Int32Array([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]), 1)); class scene2D extends scene { constructor(e = {}) { super({ cameraType: "orthographic" }), this.controller = e.mainController, this.globalUI = e.globalUI, this.squareGeo2 = squareGeo2, this.squareGeo3 = squareGeo3, this.gridSize = 50, this.gridSizeLow = 30, this.gridSizeMobile = 20, this.topMargin = 80, this.topMarginLow = 50, this.topMarginMobile = 30, this.breakpointW = 1600, this.breakpointH = 800, this.breakPointMobile = 640, this.small = !1, this.mobile = !1, this.marginLeft = 0, this.marginTop = 0, this.init() } async init() { this.cameraOptions(), await Promise.all([this.createSideButtons(), this.createZoneTitles(), this.createDialogBox(), this.createQuestBox(), this.createCheckList(), this.createEmojiList(), this.createEndScreen()]), this.resize(), events.on("resize", this.resize, this), this.beforeRenderCbs.push(this.update.bind(this)), client$1.devScene && this.debug(), this.isReady() } cameraOptions() { this.camera.lerpPosition = 0, this.camera.lerpTarget = 0, this.camera.lerpRotation = 0 } async createSideButtons() { this.sideButtons = new sideButtons(this), await this.sideButtons.ready } async createZoneTitles() { this.zoneTitles = new zoneTitles(this), await this.zoneTitles.ready } async createDialogBox() { this.dialogBox = new dialogBox(this), await this.dialogBox.ready } async createQuestBox() { this.questBox = new questBox(this), await this.questBox.ready } async createCheckList() { this.checkList = new checkList(this), await this.checkList.ready } async createEmojiList() { this.emojiList = new emojiList(this), await this.emojiList.ready } async createEndScreen() { this.endScreen = new endScreen(this), await this.endScreen.ready } update() { } resize() { this.camera.basePosition.set(client$1.screen.w * .5, -client$1.screen.h * .5, this.camera.basePosition.z), this.camera.baseTarget.set(this.camera.basePosition.x, this.camera.basePosition.y, 0), this.camera.updateProjectionMatrix(), this.small = client$1.screen.width < this.breakpointW || client$1.screen.height < this.breakpointH, this.mobile = client$1.screen.width < this.breakPointMobile || client$1.screen.height < this.breakPointMobile, this.marginLeft = this.mobile ? this.gridSizeMobile : this.small ? this.gridSizeLow : this.gridSize, this.marginTop = this.mobile ? this.topMarginMobile : this.small ? this.topMarginLow : this.topMargin, [this.sideButtons, this.zoneTitles, this.dialogBox, this.questBox, this.checkList, this.emojiList, this.endScreen].forEach(e => { e.resize() }) } } class uiScene extends scene {
    constructor(e = {}) { super({ cameraType: "orthographic" }), this.controller = e.mainController, this.outlineColor = "#455762", this.boxVolume = { value: 0 }, this.init() } async init() { this.cameraOptions(), this.domContainer = document.createElement("div"), this.domContainer.id = "global-ui", this.domContainer.style.cssText = "position: absolute; top: 0; left: 0; width: 0; height: 0;", document.querySelector("#webgl").appendChild(this.domContainer), this.scene2D = new scene2D({ mainController: this.controller, globalUI: this }), this.scene3D = new scene3D({ mainController: this.controller, globalUI: this }), await Promise.all([this.scene2D.uploaded, this.scene3D.uploaded]), this.createProcessing(), this.beforeRenderCbs.push(this.update.bind(this)), client$1.devScene && this.debug(), this.isReady() } cameraOptions() { this.camera.lerpPosition = 0, this.camera.lerpTarget = 0, this.camera.lerpRotation = 0 } createProcessing() {
        this.composer = new effectComposerExtended({ scene: this.scene3D }), this.pass2D = new RenderPass$1(this.scene2D, this.scene2D.camera, void 0, !1, !1), this.pass2D.clear = !1, this.composer.addPass(this.pass2D), this.blendMesh = new Mesh(utils.triangle, new ShaderMaterial({
            uniformsGroups: [global$1.UBO], name: "globalUI", uniforms: { tMap: { value: null }, uOutlineColor: { value: new Color(this.outlineColor) }, uSmoothMargin: { value: .05 }, uThreshold: { value: .01 } }, vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = vec4(position, 1.0);
                }
            `, fragmentShader: `
                ${globalUBO_default}
                ${fit_default}

                uniform sampler2D tMap;
                uniform float uSmoothMargin;
                uniform vec3 uOutlineColor;
                uniform float uThreshold;

                varying vec2 vUv;

                const vec2 dirs[5] = vec2[5](vec2(0, 0), vec2(-1, 0), vec2(1, 0), vec2(0, -1), vec2(0, 1)); // center, left, right, bottom, top

                void main() {
                    float scale = 1.0; // important

                    vec2 offset = 1.0 / vec2(textureSize(tMap, 0)) * scale;
                    vec4 colors[5];

                    // keep track of alphas and minimum color value to skip computations or outlines entirely
                    float maxAlpha = 0.0;
                    float minColorValue = 0.0;
                    vec4 tcolor;

                    #pragma unroll_loop_start
                    for (int i = 0; i < 5; i++) {
                        tcolor = texture(tMap, vUv + offset * dirs[i]);
                        colors[i] = abs(tcolor);
                        maxAlpha = max(maxAlpha, colors[i].a);
                        minColorValue = min(minColorValue, min(tcolor.r, min(tcolor.g, tcolor.b)));
                    }
                    #pragma unroll_loop_end

                    // early out: no alpha changes
                    if (maxAlpha == 0.0) discard;

                    // no outline if color is negative and alpha is equal or lower than 1. pure black is not valid
                    if (minColorValue < 0.0 && maxAlpha <= 1.0) {
                        gl_FragColor = colors[0];
                        return;
                    }

                    vec3 centerColor = colors[0].rgb;
                    vec3 variationLeft = abs(colors[1].rgb - centerColor);
                    vec3 variationRight = abs(colors[2].rgb - centerColor);
                    vec3 variationBottom = abs(colors[3].rgb - centerColor);
                    vec3 variationTop = abs(colors[4].rgb - centerColor);

                    // clamp differences in alpha since values can range from 0 to 2, so the smoothing is normalized
                    float centerAlpha = colors[0].a;
                    float variationLeftAlpha = clamp(abs(colors[1].a - centerAlpha), 0.0, 1.0);
                    float variationRightAlpha = clamp(abs(colors[2].a - centerAlpha), 0.0, 1.0);
                    float variationBottomAlpha = clamp(abs(colors[3].a - centerAlpha), 0.0, 1.0);
                    float variationTopAlpha = clamp(abs(colors[4].a - centerAlpha), 0.0, 1.0);

                    vec4 delta;
                    delta.x = max(max(max(variationLeft.r, variationLeft.g), variationLeft.b), variationLeftAlpha);
                    delta.y = max(max(max(variationTop.r, variationTop.g), variationTop.b), variationTopAlpha);
                    delta.z = max(max(max(variationRight.r, variationRight.g), variationRight.b), variationRightAlpha);
                    delta.w = max(max(max(variationBottom.r, variationBottom.g), variationBottom.b), variationBottomAlpha);

                    vec2 maxDelta = max(delta.xy, delta.zw);
                    float maxDeltaValue = max(maxDelta.x, maxDelta.y);

                    vec3 color = mix(centerColor, uOutlineColor, smoothstep(uThreshold, uThreshold + uSmoothMargin, maxDeltaValue));

                    gl_FragColor = vec4(color, 1.0);
                }
            `, transparent: !0
        })), this.blendMesh.name = "Global UI Blend Mesh", this.blendMesh.frustumCulled = !1, this.blendMesh.matrixAutoUpdate = !1, this.blendMesh.matrixWorldAutoUpdate = !1, this.add(this.blendMesh)
    } update() { this.composer.render(), this.blendMesh.material.uniforms.tMap.value = this.composer.readBuffer.texture } playBoxAudio(e = .5) { createTween(this.boxVolume, { to: { value: 1 }, duration: e * .05, onUpdate: () => { events.emit("webgl_set_audio_volume", "paper4", this.boxVolume.value * .4) } }), createTween(this.boxVolume, { from: { value: 1 }, to: { value: 0 }, overwrite: !1, delay: e * (1 - .05), duration: e * .05 + .2, onUpdate: () => { events.emit("webgl_set_audio_volume", "paper4", this.boxVolume.value * .4) } }) }
} const scenes = { intro: introScene, present: presentScene }; class mainController { constructor(e) { this.options = e, this.ready = miscutils.deferred(), this.state = null, this.sceneComposers = {}, this.currentScene = null, this.planetScene = null, this.init() } async init() { this.initGlobalPlane(), this.audioController = new audioController(this), this.initUI(), await this.initIntro(), events.once("switch_to_present_scene", this.switchToPresent, this), await this.uiScene.uploaded, global$1.renderPass.scene.beforeRenderCbs.push(() => { this.render() }), events.on("overlay", this.overlayAnimation, this), this.sceneComposers[this.state].render(), this.ready.resolve() } initGlobalPlane() { const e = utils.triangle; this.material = new baseShader, this.mainMesh = new Mesh(e, this.material), this.mainMesh.frustumCulled = !1, this.mainMesh.name = "Main triangle mesh", global$1.renderPass.scene.add(this.mainMesh), this.mainMesh.material = this.material, global$1.renderPass.scene._upload(), this.mainMesh.material = this.material } initUI() { this.uiScene = new uiScene({ mainController: this }), this.uiPass = new RenderPass$1(this.uiScene, this.uiScene.camera, void 0, !1, !1), this.uiPass.clear = !1, global$1.composer.addPass(this.uiPass) } async switchToPresent() { if (!this.sceneComposers.intro) { console.warn("No intro scene to switch from"); return } createDelayedCall(1.5, () => { events.emit("toggle_loader", !0) }), createTween(this.material.uniforms.uFlash, { to: { value: 1 }, duration: 1, delay: 1, ease: "power2.inOut" }), await Promise.all([this.currentScene.playOutAnimation(), createTween(this.material.uniforms.uWipe2, { to: { value: 1 }, duration: 1.15, delay: .85, ease: "power2.inOut" })]), this.sceneComposers.intro.dispose(), delete this.sceneComposers.intro, client$1.lowMemoryDevice && await createDelayedCall(.35), this.material.uniforms.uWipe1.value = 1, this.material.uniforms.uWipe2.value = 0, global$1.adaptiveDPR.stop(), await this.initPresent(), global$1.adaptiveDPR.start(), createTween(this.material.uniforms.uFlash, { to: { value: 0 }, duration: 1, ease: "power2.inOut" }), events.emit("toggle_loader", !1), await Promise.all([this.currentScene.playInAnimation(), createTween(this.material.uniforms.uWipe1, { to: { value: 0 }, duration: 2, ease: "inOut1" })]) } async initIntro() { const e = new scenes.intro(this); this.sceneComposers.intro = new effectComposerExtended({ scene: e }), await e.uploaded, this.currentScene = e, this.state = "intro" } async initPresent() { const e = new scenes.present(this); this.sceneComposers.present = new effectComposerExtended({ scene: e }), await e.uploaded, this.planetScene = e, this.audioController.camera = this.planetScene.camera, this.currentScene = e, this.state = "present" } render() { !this.state || !this.sceneComposers[this.state] || (this.sceneComposers[this.state].render(), this.material.uniforms.tScene.value = this.sceneComposers[this.state].readBuffer.texture) } overlayAnimation(e = !1) { createTween(this.material.uniforms.uOverlay, { to: { value: e ? 1 : 0 }, duration: e ? .6 : .3, delay: e ? 0 : .2 }) } resize() { } start() { events.emit("render_active", !0), createTween(this.material.uniforms.uWipe1, { to: { value: 0 }, delay: 0, duration: 2, ease: "inOut1" }), this.currentScene.playInAnimation().then(() => { }) } } var root_1 = from_html('<div id="loader" class="svelte-7zu2uc"><div class="spinner svelte-7zu2uc"><svg xmlns="http://www.w3.org/2000/svg" width="90" height="90" viewBox="0 0 90 90" class="svelte-7zu2uc"><style class="svelte-7zu2uc">path { fill: none; stroke: black; stroke-width: 1.5px; }</style><g id="frame0" class="svelte-7zu2uc"><path d="M 17.4,44.0 L 17.4,44.0 L 16.8,36.0 L 16.4,29.0 L 16.2,21.0 L 16.2,14.0 L 16.5,6.0 " class="svelte-7zu2uc"></path><path d="M 16.5,6.0 L 16.5,6.0 L 25.2,7.0 L 34.0,9.0 L 41.9,11.0 L 50.3,12.0 L 59.2,13.0 L 66.2,12.0 L 73.4,10.0 " class="svelte-7zu2uc"></path><path d="M 73.4,10.0 L 73.4,10.0 L 72.8,18.0 L 72.5,26.0 L 72.6,33.0 L 73.1,40.0 L 73.9,48.0 " class="svelte-7zu2uc"></path><path d="M 17.4,44.0 L 17.4,44.0 L 25.3,45.0 L 33.0,47.0 L 40.3,48.0 L 49.2,50.0 L 58.3,51.0 L 66.3,51.0 L 73.9,48.0 " class="svelte-7zu2uc"></path><path d="M 17.3,7.0 L 17.3,7.0 L 24.5,13.0 L 30.7,18.0 L 37.5,25.0 L 44.6,32.0 " class="svelte-7zu2uc"></path><path d="M 44.6,32.0 L 44.6,32.0 L 51.1,28.0 L 59.3,24.0 L 65.9,18.0 L 72.9,11.0 " class="svelte-7zu2uc"></path><path d="M 14.0,69.0 L 14.0,69.0 L 14.0,72.0 " class="svelte-7zu2uc"></path><path d="M 14.0,72.0 L 14.0,72.0 L 13.2,77.0 " class="svelte-7zu2uc"></path><path d="M 13.2,77.0 L 13.2,77.0 L 14.4,80.0 " class="svelte-7zu2uc"></path><path d="M 14.4,80.0 L 14.4,80.0 L 18.1,79.0 " class="svelte-7zu2uc"></path><path d="M 25.1,71.0 L 25.1,71.0 L 22.5,72.0 " class="svelte-7zu2uc"></path><path d="M 22.5,72.0 L 22.5,72.0 L 22.1,74.0 " class="svelte-7zu2uc"></path><path d="M 22.1,74.0 L 22.1,74.0 L 23.4,78.0 " class="svelte-7zu2uc"></path><path d="M 23.4,78.0 L 23.4,78.0 L 26.0,78.0 " class="svelte-7zu2uc"></path><path d="M 26.0,78.0 L 26.0,78.0 L 28.3,77.0 " class="svelte-7zu2uc"></path><path d="M 28.3,77.0 L 28.3,77.0 L 29.2,74.0 " class="svelte-7zu2uc"></path><path d="M 29.2,74.0 L 29.2,74.0 L 27.8,71.0 " class="svelte-7zu2uc"></path><path d="M 25.1,71.0 L 25.1,71.0 L 27.8,71.0 " class="svelte-7zu2uc"></path><path d="M 32.8,80.0 L 32.8,80.0 L 33.0,77.0 " class="svelte-7zu2uc"></path><path d="M 33.0,77.0 L 33.0,77.0 L 35.5,72.0 " class="svelte-7zu2uc"></path><path d="M 35.5,72.0 L 35.5,72.0 L 36.9,73.0 " class="svelte-7zu2uc"></path><path d="M 36.9,73.0 L 36.9,73.0 L 37.6,76.0 " class="svelte-7zu2uc"></path><path d="M 37.6,76.0 L 37.6,76.0 L 37.9,79.0 " class="svelte-7zu2uc"></path><path d="M 37.9,79.0 L 37.9,79.0 L 37.7,83.0 " class="svelte-7zu2uc"></path><path d="M 33.0,77.0 L 33.0,77.0 L 37.7,78.0 " class="svelte-7zu2uc"></path><path d="M 43.4,74.0 L 43.4,74.0 L 43.7,83.0 " class="svelte-7zu2uc"></path><path d="M 43.7,83.0 L 43.7,83.0 L 46.2,82.0 " class="svelte-7zu2uc"></path><path d="M 46.2,82.0 L 46.2,82.0 L 48.2,81.0 " class="svelte-7zu2uc"></path><path d="M 48.2,81.0 L 48.2,81.0 L 47.8,77.0 " class="svelte-7zu2uc"></path><path d="M 47.8,77.0 L 47.8,77.0 L 45.2,75.0 " class="svelte-7zu2uc"></path><path d="M 43.4,74.0 L 43.4,74.0 L 45.2,75.0 " class="svelte-7zu2uc"></path><path d="M 54.3,75.0 L 54.3,75.0 L 54.4,78.0 " class="svelte-7zu2uc"></path><path d="M 54.4,78.0 L 54.4,78.0 L 54.6,84.0 " class="svelte-7zu2uc"></path><path d="M 58.9,84.0 L 58.9,84.0 L 60.7,77.0 " class="svelte-7zu2uc"></path><path d="M 60.7,77.0 L 60.7,77.0 L 62.2,77.0 " class="svelte-7zu2uc"></path><path d="M 62.2,77.0 L 62.2,77.0 L 65.4,81.0 " class="svelte-7zu2uc"></path><path d="M 65.4,81.0 L 65.4,81.0 L 66.7,81.0 " class="svelte-7zu2uc"></path><path d="M 66.7,81.0 L 66.7,81.0 L 68.3,74.0 " class="svelte-7zu2uc"></path><path d="M 78.2,72.0 L 78.2,72.0 L 75.7,71.0 " class="svelte-7zu2uc"></path><path d="M 75.7,71.0 L 75.7,71.0 L 73.7,72.0 " class="svelte-7zu2uc"></path><path d="M 73.7,72.0 L 73.7,72.0 L 72.3,76.0 " class="svelte-7zu2uc"></path><path d="M 72.3,76.0 L 72.3,76.0 L 72.5,79.0 " class="svelte-7zu2uc"></path><path d="M 72.5,79.0 L 72.5,79.0 L 75.3,80.0 " class="svelte-7zu2uc"></path><path d="M 75.3,80.0 L 75.3,80.0 L 78.3,79.0 " class="svelte-7zu2uc"></path><path d="M 78.3,79.0 L 78.3,79.0 L 78.2,76.0 " class="svelte-7zu2uc"></path><path d="M 78.2,76.0 L 78.2,76.0 L 75.8,77.0 " class="svelte-7zu2uc"></path><path d="M 78.3,79.0 L 78.3,79.0 L 79.1,82.0 " class="svelte-7zu2uc"></path></g><g id="frame1" class="svelte-7zu2uc"><path d="M 17.3,45.0 L 17.3,45.0 L 17.7,37.0 L 17.8,29.0 L 17.4,21.0 L 16.6,13.0 L 15.6,6.0 " class="svelte-7zu2uc"></path><path d="M 15.6,6.0 L 15.6,6.0 L 24.4,8.0 L 32.4,10.0 L 39.5,11.0 L 48.3,12.0 L 56.9,12.0 L 65.2,10.0 L 74.0,8.0 " class="svelte-7zu2uc"></path><path d="M 74.0,8.0 L 74.0,8.0 L 74.0,15.0 L 73.6,23.0 L 73.1,31.0 L 72.5,39.0 L 72.3,46.0 " class="svelte-7zu2uc"></path><path d="M 17.3,45.0 L 17.3,45.0 L 25.4,47.0 L 33.6,49.0 L 40.9,50.0 L 49.2,51.0 L 57.3,50.0 L 64.2,49.0 L 72.3,46.0 " class="svelte-7zu2uc"></path><path d="M 16.6,7.0 L 16.6,7.0 L 24.5,14.0 L 30.8,20.0 L 37.3,26.0 L 44.2,33.0 " class="svelte-7zu2uc"></path><path d="M 44.2,33.0 L 44.2,33.0 L 50.5,27.0 L 58.6,22.0 L 65.8,16.0 L 73.4,8.0 " class="svelte-7zu2uc"></path><path d="M 13.8,69.0 L 13.8,69.0 L 13.7,72.0 " class="svelte-7zu2uc"></path><path d="M 13.7,72.0 L 13.7,72.0 L 13.1,77.0 " class="svelte-7zu2uc"></path><path d="M 13.1,77.0 L 13.1,77.0 L 14.5,79.0 " class="svelte-7zu2uc"></path><path d="M 14.5,79.0 L 14.5,79.0 L 18.1,79.0 " class="svelte-7zu2uc"></path><path d="M 25.1,72.0 L 25.1,72.0 L 22.4,73.0 " class="svelte-7zu2uc"></path><path d="M 22.4,73.0 L 22.4,73.0 L 22.0,75.0 " class="svelte-7zu2uc"></path><path d="M 22.0,75.0 L 22.0,75.0 L 23.4,79.0 " class="svelte-7zu2uc"></path><path d="M 23.4,79.0 L 23.4,79.0 L 26.2,80.0 " class="svelte-7zu2uc"></path><path d="M 26.2,80.0 L 26.2,80.0 L 28.6,79.0 " class="svelte-7zu2uc"></path><path d="M 28.6,79.0 L 28.6,79.0 L 29.6,76.0 " class="svelte-7zu2uc"></path><path d="M 29.6,76.0 L 29.6,76.0 L 28.0,73.0 " class="svelte-7zu2uc"></path><path d="M 25.1,72.0 L 25.1,72.0 L 28.0,73.0 " class="svelte-7zu2uc"></path><path d="M 33.2,82.0 L 33.2,82.0 L 33.5,78.0 " class="svelte-7zu2uc"></path><path d="M 33.5,78.0 L 33.5,78.0 L 36.1,74.0 " class="svelte-7zu2uc"></path><path d="M 36.1,74.0 L 36.1,74.0 L 37.5,74.0 " class="svelte-7zu2uc"></path><path d="M 37.5,74.0 L 37.5,74.0 L 38.2,77.0 " class="svelte-7zu2uc"></path><path d="M 38.2,77.0 L 38.2,77.0 L 38.3,81.0 " class="svelte-7zu2uc"></path><path d="M 38.3,81.0 L 38.3,81.0 L 38.0,84.0 " class="svelte-7zu2uc"></path><path d="M 33.5,78.0 L 33.5,78.0 L 38.2,80.0 " class="svelte-7zu2uc"></path><path d="M 43.6,76.0 L 43.6,76.0 L 44.0,84.0 " class="svelte-7zu2uc"></path><path d="M 44.0,84.0 L 44.0,84.0 L 46.5,83.0 " class="svelte-7zu2uc"></path><path d="M 46.5,83.0 L 46.5,83.0 L 48.4,81.0 " class="svelte-7zu2uc"></path><path d="M 48.4,81.0 L 48.4,81.0 L 47.9,77.0 " class="svelte-7zu2uc"></path><path d="M 47.9,77.0 L 47.9,77.0 L 45.4,76.0 " class="svelte-7zu2uc"></path><path d="M 43.6,76.0 L 43.6,76.0 L 45.4,76.0 " class="svelte-7zu2uc"></path><path d="M 54.0,75.0 L 54.0,75.0 L 54.2,77.0 " class="svelte-7zu2uc"></path><path d="M 54.2,77.0 L 54.2,77.0 L 54.7,83.0 " class="svelte-7zu2uc"></path><path d="M 58.9,82.0 L 58.9,82.0 L 60.5,75.0 " class="svelte-7zu2uc"></path><path d="M 60.5,75.0 L 60.5,75.0 L 62.1,76.0 " class="svelte-7zu2uc"></path><path d="M 62.1,76.0 L 62.1,76.0 L 65.5,79.0 " class="svelte-7zu2uc"></path><path d="M 65.5,79.0 L 65.5,79.0 L 66.7,78.0 " class="svelte-7zu2uc"></path><path d="M 66.7,78.0 L 66.7,78.0 L 68.6,71.0 " class="svelte-7zu2uc"></path><path d="M 78.2,70.0 L 78.2,70.0 L 75.8,70.0 " class="svelte-7zu2uc"></path><path d="M 75.8,70.0 L 75.8,70.0 L 73.9,70.0 " class="svelte-7zu2uc"></path><path d="M 73.9,70.0 L 73.9,70.0 L 72.4,74.0 " class="svelte-7zu2uc"></path><path d="M 72.4,74.0 L 72.4,74.0 L 72.5,77.0 " class="svelte-7zu2uc"></path><path d="M 72.5,77.0 L 72.5,77.0 L 75.1,79.0 " class="svelte-7zu2uc"></path><path d="M 75.1,79.0 L 75.1,79.0 L 78.2,78.0 " class="svelte-7zu2uc"></path><path d="M 78.2,78.0 L 78.2,78.0 L 78.1,75.0 " class="svelte-7zu2uc"></path><path d="M 78.1,75.0 L 78.1,75.0 L 75.7,75.0 " class="svelte-7zu2uc"></path><path d="M 78.2,78.0 L 78.2,78.0 L 78.9,81.0 " class="svelte-7zu2uc"></path></g><g id="frame2" class="svelte-7zu2uc"><path d="M 18.4,49.0 L 18.4,49.0 L 17.4,40.0 L 17.1,32.0 L 17.5,24.0 L 18.4,15.0 L 18.8,8.0 " class="svelte-7zu2uc"></path><path d="M 18.8,8.0 L 18.8,8.0 L 26.2,9.0 L 34.1,11.0 L 40.4,11.0 L 48.3,10.0 L 55.7,9.0 L 63.0,8.0 L 71.7,6.0 " class="svelte-7zu2uc"></path><path d="M 71.7,6.0 L 71.7,6.0 L 71.5,14.0 L 71.7,21.0 L 72.1,29.0 L 72.5,37.0 L 72.8,45.0 " class="svelte-7zu2uc"></path><path d="M 18.4,49.0 L 18.4,49.0 L 26.6,50.0 L 34.8,52.0 L 41.2,51.0 L 48.8,49.0 L 56.5,48.0 L 63.8,46.0 L 72.8,45.0 " class="svelte-7zu2uc"></path><path d="M 19.7,9.0 L 19.7,9.0 L 25.8,15.0 L 31.9,22.0 L 37.7,27.0 L 44.4,33.0 " class="svelte-7zu2uc"></path><path d="M 44.4,33.0 L 44.4,33.0 L 50.3,26.0 L 57.5,20.0 L 63.3,13.0 L 71.1,7.0 " class="svelte-7zu2uc"></path><path d="M 14.0,70.0 L 14.0,70.0 L 13.9,73.0 " class="svelte-7zu2uc"></path><path d="M 13.9,73.0 L 13.9,73.0 L 12.9,78.0 " class="svelte-7zu2uc"></path><path d="M 12.9,78.0 L 12.9,78.0 L 14.2,81.0 " class="svelte-7zu2uc"></path><path d="M 14.2,81.0 L 14.2,81.0 L 18.1,81.0 " class="svelte-7zu2uc"></path><path d="M 25.1,74.0 L 25.1,74.0 L 22.5,75.0 " class="svelte-7zu2uc"></path><path d="M 22.5,75.0 L 22.5,75.0 L 22.1,77.0 " class="svelte-7zu2uc"></path><path d="M 22.1,77.0 L 22.1,77.0 L 23.5,81.0 " class="svelte-7zu2uc"></path><path d="M 23.5,81.0 L 23.5,81.0 L 26.2,82.0 " class="svelte-7zu2uc"></path><path d="M 26.2,82.0 L 26.2,82.0 L 28.6,81.0 " class="svelte-7zu2uc"></path><path d="M 28.6,81.0 L 28.6,81.0 L 29.4,78.0 " class="svelte-7zu2uc"></path><path d="M 29.4,78.0 L 29.4,78.0 L 27.9,75.0 " class="svelte-7zu2uc"></path><path d="M 25.1,74.0 L 25.1,74.0 L 27.9,75.0 " class="svelte-7zu2uc"></path><path d="M 33.2,83.0 L 33.2,83.0 L 33.5,80.0 " class="svelte-7zu2uc"></path><path d="M 33.5,80.0 L 33.5,80.0 L 35.9,75.0 " class="svelte-7zu2uc"></path><path d="M 35.9,75.0 L 35.9,75.0 L 37.4,75.0 " class="svelte-7zu2uc"></path><path d="M 37.4,75.0 L 37.4,75.0 L 38.3,78.0 " class="svelte-7zu2uc"></path><path d="M 38.3,78.0 L 38.3,78.0 L 38.5,81.0 " class="svelte-7zu2uc"></path><path d="M 38.5,81.0 L 38.5,81.0 L 38.2,85.0 " class="svelte-7zu2uc"></path><path d="M 33.5,80.0 L 33.5,80.0 L 38.3,80.0 " class="svelte-7zu2uc"></path><path d="M 44.1,75.0 L 44.1,75.0 L 44.3,83.0 " class="svelte-7zu2uc"></path><path d="M 44.3,83.0 L 44.3,83.0 L 46.9,82.0 " class="svelte-7zu2uc"></path><path d="M 46.9,82.0 L 46.9,82.0 L 48.9,80.0 " class="svelte-7zu2uc"></path><path d="M 48.9,80.0 L 48.9,80.0 L 48.6,76.0 " class="svelte-7zu2uc"></path><path d="M 48.6,76.0 L 48.6,76.0 L 45.9,75.0 " class="svelte-7zu2uc"></path><path d="M 44.1,75.0 L 44.1,75.0 L 45.9,75.0 " class="svelte-7zu2uc"></path><path d="M 54.7,73.0 L 54.7,73.0 L 54.9,75.0 " class="svelte-7zu2uc"></path><path d="M 54.9,75.0 L 54.9,75.0 L 54.9,81.0 " class="svelte-7zu2uc"></path><path d="M 59.0,80.0 L 59.0,80.0 L 60.8,73.0 " class="svelte-7zu2uc"></path><path d="M 60.8,73.0 L 60.8,73.0 L 62.3,73.0 " class="svelte-7zu2uc"></path><path d="M 62.3,73.0 L 62.3,73.0 L 65.5,77.0 " class="svelte-7zu2uc"></path><path d="M 65.5,77.0 L 65.5,77.0 L 66.7,77.0 " class="svelte-7zu2uc"></path><path d="M 66.7,77.0 L 66.7,77.0 L 68.4,70.0 " class="svelte-7zu2uc"></path><path d="M 78.1,70.0 L 78.1,70.0 L 75.6,69.0 " class="svelte-7zu2uc"></path><path d="M 75.6,69.0 L 75.6,69.0 L 73.6,70.0 " class="svelte-7zu2uc"></path><path d="M 73.6,70.0 L 73.6,70.0 L 72.3,73.0 " class="svelte-7zu2uc"></path><path d="M 72.3,73.0 L 72.3,73.0 L 72.5,76.0 " class="svelte-7zu2uc"></path><path d="M 72.5,76.0 L 72.5,76.0 L 75.4,78.0 " class="svelte-7zu2uc"></path><path d="M 75.4,78.0 L 75.4,78.0 L 78.6,77.0 " class="svelte-7zu2uc"></path><path d="M 78.6,77.0 L 78.6,77.0 L 78.4,75.0 " class="svelte-7zu2uc"></path><path d="M 78.4,75.0 L 78.4,75.0 L 75.8,75.0 " class="svelte-7zu2uc"></path><path d="M 78.6,77.0 L 78.6,77.0 L 79.5,81.0 " class="svelte-7zu2uc"></path></g><g id="frame3" class="svelte-7zu2uc"><path d="M 21.6,51.0 L 21.6,51.0 L 21.1,44.0 L 19.7,36.0 L 18.0,28.0 L 16.8,19.0 L 16.0,11.0 " class="svelte-7zu2uc"></path><path d="M 16.0,11.0 L 16.0,11.0 L 24.8,13.0 L 33.6,13.0 L 41.2,10.0 L 49.5,7.0 L 57.6,7.0 L 64.0,6.0 L 71.6,6.0 " class="svelte-7zu2uc"></path><path d="M 71.6,6.0 L 71.6,6.0 L 71.4,14.0 L 71.5,21.0 L 71.3,29.0 L 71.1,37.0 L 71.3,44.0 " class="svelte-7zu2uc"></path><path d="M 21.6,51.0 L 21.6,51.0 L 27.7,51.0 L 35.0,52.0 L 40.8,50.0 L 48.5,47.0 L 55.8,46.0 L 62.8,44.0 L 71.3,44.0 " class="svelte-7zu2uc"></path><path d="M 16.9,12.0 L 16.9,12.0 L 24.8,19.0 L 31.6,24.0 L 38.0,27.0 L 44.8,32.0 " class="svelte-7zu2uc"></path><path d="M 44.8,32.0 L 44.8,32.0 L 50.8,24.0 L 58.6,17.0 L 64.2,12.0 L 71.1,7.0 " class="svelte-7zu2uc"></path><path d="M 14.2,71.0 L 14.2,71.0 L 13.9,75.0 " class="svelte-7zu2uc"></path><path d="M 13.9,75.0 L 13.9,75.0 L 12.8,80.0 " class="svelte-7zu2uc"></path><path d="M 12.8,80.0 L 12.8,80.0 L 14.1,83.0 " class="svelte-7zu2uc"></path><path d="M 14.1,83.0 L 14.1,83.0 L 17.9,83.0 " class="svelte-7zu2uc"></path><path d="M 25.6,75.0 L 25.6,75.0 L 22.8,76.0 " class="svelte-7zu2uc"></path><path d="M 22.8,76.0 L 22.8,76.0 L 22.3,79.0 " class="svelte-7zu2uc"></path><path d="M 22.3,79.0 L 22.3,79.0 L 23.5,83.0 " class="svelte-7zu2uc"></path><path d="M 23.5,83.0 L 23.5,83.0 L 26.2,83.0 " class="svelte-7zu2uc"></path><path d="M 26.2,83.0 L 26.2,83.0 L 28.8,81.0 " class="svelte-7zu2uc"></path><path d="M 28.8,81.0 L 28.8,81.0 L 29.8,78.0 " class="svelte-7zu2uc"></path><path d="M 29.8,78.0 L 29.8,78.0 L 28.4,75.0 " class="svelte-7zu2uc"></path><path d="M 25.6,75.0 L 25.6,75.0 L 28.4,75.0 " class="svelte-7zu2uc"></path><path d="M 33.2,83.0 L 33.2,83.0 L 33.6,80.0 " class="svelte-7zu2uc"></path><path d="M 33.6,80.0 L 33.6,80.0 L 36.3,74.0 " class="svelte-7zu2uc"></path><path d="M 36.3,74.0 L 36.3,74.0 L 37.7,75.0 " class="svelte-7zu2uc"></path><path d="M 37.7,75.0 L 37.7,75.0 L 38.3,77.0 " class="svelte-7zu2uc"></path><path d="M 38.3,77.0 L 38.3,77.0 L 38.4,81.0 " class="svelte-7zu2uc"></path><path d="M 38.4,81.0 L 38.4,81.0 L 38.0,84.0 " class="svelte-7zu2uc"></path><path d="M 33.6,80.0 L 33.6,80.0 L 38.2,80.0 " class="svelte-7zu2uc"></path><path d="M 43.9,73.0 L 43.9,73.0 L 44.0,82.0 " class="svelte-7zu2uc"></path><path d="M 44.0,82.0 L 44.0,82.0 L 46.4,81.0 " class="svelte-7zu2uc"></path><path d="M 46.4,81.0 L 46.4,81.0 L 48.3,78.0 " class="svelte-7zu2uc"></path><path d="M 48.3,78.0 L 48.3,78.0 L 48.0,74.0 " class="svelte-7zu2uc"></path><path d="M 48.0,74.0 L 48.0,74.0 L 45.6,73.0 " class="svelte-7zu2uc"></path><path d="M 43.9,73.0 L 43.9,73.0 L 45.6,73.0 " class="svelte-7zu2uc"></path><path d="M 54.0,71.0 L 54.0,71.0 L 54.1,74.0 " class="svelte-7zu2uc"></path><path d="M 54.1,74.0 L 54.1,74.0 L 54.3,80.0 " class="svelte-7zu2uc"></path><path d="M 58.3,79.0 L 58.3,79.0 L 60.0,72.0 " class="svelte-7zu2uc"></path><path d="M 60.0,72.0 L 60.0,72.0 L 61.5,73.0 " class="svelte-7zu2uc"></path><path d="M 61.5,73.0 L 61.5,73.0 L 64.8,77.0 " class="svelte-7zu2uc"></path><path d="M 64.8,77.0 L 64.8,77.0 L 66.1,77.0 " class="svelte-7zu2uc"></path><path d="M 66.1,77.0 L 66.1,77.0 L 67.7,70.0 " class="svelte-7zu2uc"></path><path d="M 78.1,72.0 L 78.1,72.0 L 75.4,71.0 " class="svelte-7zu2uc"></path><path d="M 75.4,71.0 L 75.4,71.0 L 73.3,71.0 " class="svelte-7zu2uc"></path><path d="M 73.3,71.0 L 73.3,71.0 L 72.0,74.0 " class="svelte-7zu2uc"></path><path d="M 72.0,74.0 L 72.0,74.0 L 72.2,77.0 " class="svelte-7zu2uc"></path><path d="M 72.2,77.0 L 72.2,77.0 L 75.1,79.0 " class="svelte-7zu2uc"></path><path d="M 75.1,79.0 L 75.1,79.0 L 78.5,79.0 " class="svelte-7zu2uc"></path><path d="M 78.5,79.0 L 78.5,79.0 L 78.3,76.0 " class="svelte-7zu2uc"></path><path d="M 78.3,76.0 L 78.3,76.0 L 75.7,76.0 " class="svelte-7zu2uc"></path><path d="M 78.5,79.0 L 78.5,79.0 L 79.3,82.0 " class="svelte-7zu2uc"></path></g><g id="frame4" class="svelte-7zu2uc"><path d="M 18.3,51.0 L 18.3,51.0 L 19.5,43.0 L 21.0,36.0 L 21.7,29.0 L 20.9,21.0 L 19.3,13.0 " class="svelte-7zu2uc"></path><path d="M 19.3,13.0 L 19.3,13.0 L 26.8,13.0 L 34.7,13.0 L 40.8,10.0 L 48.6,8.0 L 56.6,8.0 L 64.5,8.0 L 73.2,8.0 " class="svelte-7zu2uc"></path><path d="M 73.2,8.0 L 73.2,8.0 L 73.0,16.0 L 72.7,23.0 L 72.3,30.0 L 71.8,38.0 L 71.4,45.0 " class="svelte-7zu2uc"></path><path d="M 18.3,51.0 L 18.3,51.0 L 26.1,51.0 L 34.0,50.0 L 40.3,47.0 L 48.2,45.0 L 55.6,45.0 L 62.8,44.0 L 71.4,45.0 " class="svelte-7zu2uc"></path><path d="M 20.5,15.0 L 20.5,15.0 L 27.3,19.0 L 34.5,23.0 L 39.3,26.0 L 45.6,30.0 " class="svelte-7zu2uc"></path><path d="M 45.6,30.0 L 45.6,30.0 L 51.0,23.0 L 58.5,18.0 L 65.1,13.0 L 72.7,9.0 " class="svelte-7zu2uc"></path><path d="M 13.9,73.0 L 13.9,73.0 L 13.8,77.0 " class="svelte-7zu2uc"></path><path d="M 13.8,77.0 L 13.8,77.0 L 13.1,81.0 " class="svelte-7zu2uc"></path><path d="M 13.1,81.0 L 13.1,81.0 L 14.3,84.0 " class="svelte-7zu2uc"></path><path d="M 14.3,84.0 L 14.3,84.0 L 17.8,85.0 " class="svelte-7zu2uc"></path><path d="M 24.8,76.0 L 24.8,76.0 L 22.1,77.0 " class="svelte-7zu2uc"></path><path d="M 22.1,77.0 L 22.1,77.0 L 21.7,80.0 " class="svelte-7zu2uc"></path><path d="M 21.7,80.0 L 21.7,80.0 L 23.0,84.0 " class="svelte-7zu2uc"></path><path d="M 23.0,84.0 L 23.0,84.0 L 25.6,84.0 " class="svelte-7zu2uc"></path><path d="M 25.6,84.0 L 25.6,84.0 L 28.0,82.0 " class="svelte-7zu2uc"></path><path d="M 28.0,82.0 L 28.0,82.0 L 29.0,78.0 " class="svelte-7zu2uc"></path><path d="M 29.0,78.0 L 29.0,78.0 L 27.6,76.0 " class="svelte-7zu2uc"></path><path d="M 24.8,76.0 L 24.8,76.0 L 27.6,76.0 " class="svelte-7zu2uc"></path><path d="M 32.5,83.0 L 32.5,83.0 L 32.8,79.0 " class="svelte-7zu2uc"></path><path d="M 32.8,79.0 L 32.8,79.0 L 35.7,73.0 " class="svelte-7zu2uc"></path><path d="M 35.7,73.0 L 35.7,73.0 L 37.1,73.0 " class="svelte-7zu2uc"></path><path d="M 37.1,73.0 L 37.1,73.0 L 37.6,76.0 " class="svelte-7zu2uc"></path><path d="M 37.6,76.0 L 37.6,76.0 L 37.7,80.0 " class="svelte-7zu2uc"></path><path d="M 37.7,80.0 L 37.7,80.0 L 37.5,83.0 " class="svelte-7zu2uc"></path><path d="M 32.8,79.0 L 32.8,79.0 L 37.5,79.0 " class="svelte-7zu2uc"></path><path d="M 43.5,72.0 L 43.5,72.0 L 43.6,80.0 " class="svelte-7zu2uc"></path><path d="M 43.6,80.0 L 43.6,80.0 L 46.1,79.0 " class="svelte-7zu2uc"></path><path d="M 46.1,79.0 L 46.1,79.0 L 48.0,77.0 " class="svelte-7zu2uc"></path><path d="M 48.0,77.0 L 48.0,77.0 L 47.7,73.0 " class="svelte-7zu2uc"></path><path d="M 47.7,73.0 L 47.7,73.0 L 45.3,72.0 " class="svelte-7zu2uc"></path><path d="M 43.5,72.0 L 43.5,72.0 L 45.3,72.0 " class="svelte-7zu2uc"></path><path d="M 54.0,70.0 L 54.0,70.0 L 54.1,73.0 " class="svelte-7zu2uc"></path><path d="M 54.1,73.0 L 54.1,73.0 L 54.4,79.0 " class="svelte-7zu2uc"></path><path d="M 58.6,79.0 L 58.6,79.0 L 60.3,72.0 " class="svelte-7zu2uc"></path><path d="M 60.3,72.0 L 60.3,72.0 L 61.8,73.0 " class="svelte-7zu2uc"></path><path d="M 61.8,73.0 L 61.8,73.0 L 65.2,77.0 " class="svelte-7zu2uc"></path><path d="M 65.2,77.0 L 65.2,77.0 L 66.4,78.0 " class="svelte-7zu2uc"></path><path d="M 66.4,78.0 L 66.4,78.0 L 68.1,71.0 " class="svelte-7zu2uc"></path><path d="M 78.0,74.0 L 78.0,74.0 L 75.6,73.0 " class="svelte-7zu2uc"></path><path d="M 75.6,73.0 L 75.6,73.0 L 73.6,72.0 " class="svelte-7zu2uc"></path><path d="M 73.6,72.0 L 73.6,72.0 L 72.2,75.0 " class="svelte-7zu2uc"></path><path d="M 72.2,75.0 L 72.2,75.0 L 72.3,79.0 " class="svelte-7zu2uc"></path><path d="M 72.3,79.0 L 72.3,79.0 L 75.0,81.0 " class="svelte-7zu2uc"></path><path d="M 75.0,81.0 L 75.0,81.0 L 78.2,81.0 " class="svelte-7zu2uc"></path><path d="M 78.2,81.0 L 78.2,81.0 L 78.1,79.0 " class="svelte-7zu2uc"></path><path d="M 78.1,79.0 L 78.1,79.0 L 75.6,78.0 " class="svelte-7zu2uc"></path><path d="M 78.2,81.0 L 78.2,81.0 L 78.9,85.0 " class="svelte-7zu2uc"></path></g><g id="frame5" class="svelte-7zu2uc"><path d="M 18.5,51.0 L 18.5,51.0 L 17.9,43.0 L 17.8,35.0 L 18.1,27.0 L 18.4,19.0 L 18.4,12.0 " class="svelte-7zu2uc"></path><path d="M 18.4,12.0 L 18.4,12.0 L 27.2,10.0 L 36.7,9.0 L 44.9,9.0 L 51.1,8.0 L 58.5,10.0 L 64.2,12.0 L 71.7,12.0 " class="svelte-7zu2uc"></path><path d="M 71.7,12.0 L 71.7,12.0 L 71.6,20.0 L 71.8,27.0 L 72.0,34.0 L 72.2,40.0 L 72.3,48.0 " class="svelte-7zu2uc"></path><path d="M 18.5,51.0 L 18.5,51.0 L 25.7,49.0 L 33.3,48.0 L 39.9,45.0 L 48.2,44.0 L 56.0,46.0 L 63.4,47.0 L 72.3,48.0 " class="svelte-7zu2uc"></path><path d="M 19.5,13.0 L 19.5,13.0 L 26.7,16.0 L 34.6,21.0 L 39.9,24.0 L 46.5,29.0 " class="svelte-7zu2uc"></path><path d="M 46.5,29.0 L 46.5,29.0 L 52.6,24.0 L 59.6,20.0 L 64.6,17.0 L 71.2,13.0 " class="svelte-7zu2uc"></path><path d="M 13.7,74.0 L 13.7,74.0 L 13.8,77.0 " class="svelte-7zu2uc"></path><path d="M 13.8,77.0 L 13.8,77.0 L 13.1,82.0 " class="svelte-7zu2uc"></path><path d="M 13.1,82.0 L 13.1,82.0 L 14.5,84.0 " class="svelte-7zu2uc"></path><path d="M 14.5,84.0 L 14.5,84.0 L 18.0,84.0 " class="svelte-7zu2uc"></path><path d="M 24.8,74.0 L 24.8,74.0 L 22.2,76.0 " class="svelte-7zu2uc"></path><path d="M 22.2,76.0 L 22.2,76.0 L 21.9,79.0 " class="svelte-7zu2uc"></path><path d="M 21.9,79.0 L 21.9,79.0 L 23.2,82.0 " class="svelte-7zu2uc"></path><path d="M 23.2,82.0 L 23.2,82.0 L 25.9,82.0 " class="svelte-7zu2uc"></path><path d="M 25.9,82.0 L 25.9,82.0 L 28.3,79.0 " class="svelte-7zu2uc"></path><path d="M 28.3,79.0 L 28.3,79.0 L 29.2,76.0 " class="svelte-7zu2uc"></path><path d="M 29.2,76.0 L 29.2,76.0 L 27.7,74.0 " class="svelte-7zu2uc"></path><path d="M 24.8,74.0 L 24.8,74.0 L 27.7,74.0 " class="svelte-7zu2uc"></path><path d="M 32.9,80.0 L 32.9,80.0 L 33.2,77.0 " class="svelte-7zu2uc"></path><path d="M 33.2,77.0 L 33.2,77.0 L 35.8,71.0 " class="svelte-7zu2uc"></path><path d="M 35.8,71.0 L 35.8,71.0 L 37.3,71.0 " class="svelte-7zu2uc"></path><path d="M 37.3,71.0 L 37.3,71.0 L 37.9,74.0 " class="svelte-7zu2uc"></path><path d="M 37.9,74.0 L 37.9,74.0 L 38.1,77.0 " class="svelte-7zu2uc"></path><path d="M 38.1,77.0 L 38.1,77.0 L 37.8,81.0 " class="svelte-7zu2uc"></path><path d="M 33.2,77.0 L 33.2,77.0 L 37.9,76.0 " class="svelte-7zu2uc"></path><path d="M 43.8,70.0 L 43.8,70.0 L 44.0,79.0 " class="svelte-7zu2uc"></path><path d="M 44.0,79.0 L 44.0,79.0 L 46.5,78.0 " class="svelte-7zu2uc"></path><path d="M 46.5,78.0 L 46.5,78.0 L 48.4,76.0 " class="svelte-7zu2uc"></path><path d="M 48.4,76.0 L 48.4,76.0 L 48.1,72.0 " class="svelte-7zu2uc"></path><path d="M 48.1,72.0 L 48.1,72.0 L 45.6,70.0 " class="svelte-7zu2uc"></path><path d="M 43.8,70.0 L 43.8,70.0 L 45.6,70.0 " class="svelte-7zu2uc"></path><path d="M 54.3,71.0 L 54.3,71.0 L 54.5,73.0 " class="svelte-7zu2uc"></path><path d="M 54.5,73.0 L 54.5,73.0 L 54.5,79.0 " class="svelte-7zu2uc"></path><path d="M 58.6,80.0 L 58.6,80.0 L 60.5,73.0 " class="svelte-7zu2uc"></path><path d="M 60.5,73.0 L 60.5,73.0 L 62.0,74.0 " class="svelte-7zu2uc"></path><path d="M 62.0,74.0 L 62.0,74.0 L 65.3,79.0 " class="svelte-7zu2uc"></path><path d="M 65.3,79.0 L 65.3,79.0 L 66.6,80.0 " class="svelte-7zu2uc"></path><path d="M 66.6,80.0 L 66.6,80.0 L 68.4,73.0 " class="svelte-7zu2uc"></path><path d="M 78.4,75.0 L 78.4,75.0 L 75.9,74.0 " class="svelte-7zu2uc"></path><path d="M 75.9,74.0 L 75.9,74.0 L 73.9,74.0 " class="svelte-7zu2uc"></path><path d="M 73.9,74.0 L 73.9,74.0 L 72.5,77.0 " class="svelte-7zu2uc"></path><path d="M 72.5,77.0 L 72.5,77.0 L 72.5,81.0 " class="svelte-7zu2uc"></path><path d="M 72.5,81.0 L 72.5,81.0 L 75.3,83.0 " class="svelte-7zu2uc"></path><path d="M 75.3,83.0 L 75.3,83.0 L 78.5,82.0 " class="svelte-7zu2uc"></path><path d="M 78.5,82.0 L 78.5,82.0 L 78.4,80.0 " class="svelte-7zu2uc"></path><path d="M 78.4,80.0 L 78.4,80.0 L 75.9,80.0 " class="svelte-7zu2uc"></path><path d="M 78.5,82.0 L 78.5,82.0 L 79.1,86.0 " class="svelte-7zu2uc"></path></g><g id="frame6" class="svelte-7zu2uc"><path d="M 17.6,48.0 L 17.6,48.0 L 18.3,41.0 L 18.9,33.0 L 18.9,26.0 L 18.6,18.0 L 18.3,10.0 " class="svelte-7zu2uc"></path><path d="M 18.3,10.0 L 18.3,10.0 L 25.8,9.0 L 34.1,8.0 L 41.8,8.0 L 50.5,9.0 L 59.9,11.0 L 67.7,13.0 L 73.9,13.0 " class="svelte-7zu2uc"></path><path d="M 73.9,13.0 L 73.9,13.0 L 74.3,21.0 L 73.9,29.0 L 73.1,36.0 L 72.3,43.0 L 71.8,50.0 " class="svelte-7zu2uc"></path><path d="M 17.6,48.0 L 17.6,48.0 L 25.1,47.0 L 32.6,45.0 L 39.8,44.0 L 48.4,46.0 L 56.5,48.0 L 63.6,50.0 L 71.8,50.0 " class="svelte-7zu2uc"></path><path d="M 19.2,11.0 L 19.2,11.0 L 25.6,15.0 L 32.2,19.0 L 38.6,23.0 L 46.1,30.0 " class="svelte-7zu2uc"></path><path d="M 46.1,30.0 L 46.1,30.0 L 53.4,26.0 L 61.4,23.0 L 68.8,19.0 L 73.6,14.0 " class="svelte-7zu2uc"></path><path d="M 13.9,73.0 L 13.9,73.0 L 13.8,76.0 " class="svelte-7zu2uc"></path><path d="M 13.8,76.0 L 13.8,76.0 L 12.7,81.0 " class="svelte-7zu2uc"></path><path d="M 12.7,81.0 L 12.7,81.0 L 13.9,84.0 " class="svelte-7zu2uc"></path><path d="M 13.9,84.0 L 13.9,84.0 L 17.6,83.0 " class="svelte-7zu2uc"></path><path d="M 25.1,72.0 L 25.1,72.0 L 22.4,74.0 " class="svelte-7zu2uc"></path><path d="M 22.4,74.0 L 22.4,74.0 L 21.9,77.0 " class="svelte-7zu2uc"></path><path d="M 21.9,77.0 L 21.9,77.0 L 23.1,81.0 " class="svelte-7zu2uc"></path><path d="M 23.1,81.0 L 23.1,81.0 L 25.8,80.0 " class="svelte-7zu2uc"></path><path d="M 25.8,80.0 L 25.8,80.0 L 28.4,77.0 " class="svelte-7zu2uc"></path><path d="M 28.4,77.0 L 28.4,77.0 L 29.4,74.0 " class="svelte-7zu2uc"></path><path d="M 29.4,74.0 L 29.4,74.0 L 28.0,72.0 " class="svelte-7zu2uc"></path><path d="M 25.1,72.0 L 25.1,72.0 L 28.0,72.0 " class="svelte-7zu2uc"></path><path d="M 33.1,79.0 L 33.1,79.0 L 33.4,75.0 " class="svelte-7zu2uc"></path><path d="M 33.4,75.0 L 33.4,75.0 L 36.0,70.0 " class="svelte-7zu2uc"></path><path d="M 36.0,70.0 L 36.0,70.0 L 37.4,70.0 " class="svelte-7zu2uc"></path><path d="M 37.4,70.0 L 37.4,70.0 L 38.1,73.0 " class="svelte-7zu2uc"></path><path d="M 38.1,73.0 L 38.1,73.0 L 38.3,76.0 " class="svelte-7zu2uc"></path><path d="M 38.3,76.0 L 38.3,76.0 L 38.1,80.0 " class="svelte-7zu2uc"></path><path d="M 33.4,75.0 L 33.4,75.0 L 38.2,75.0 " class="svelte-7zu2uc"></path><path d="M 43.8,70.0 L 43.8,70.0 L 44.2,79.0 " class="svelte-7zu2uc"></path><path d="M 44.2,79.0 L 44.2,79.0 L 46.7,78.0 " class="svelte-7zu2uc"></path><path d="M 46.7,78.0 L 46.7,78.0 L 48.6,77.0 " class="svelte-7zu2uc"></path><path d="M 48.6,77.0 L 48.6,77.0 L 48.2,73.0 " class="svelte-7zu2uc"></path><path d="M 48.2,73.0 L 48.2,73.0 L 45.6,71.0 " class="svelte-7zu2uc"></path><path d="M 43.8,70.0 L 43.8,70.0 L 45.6,71.0 " class="svelte-7zu2uc"></path><path d="M 54.4,72.0 L 54.4,72.0 L 54.6,75.0 " class="svelte-7zu2uc"></path><path d="M 54.6,75.0 L 54.6,75.0 L 54.7,81.0 " class="svelte-7zu2uc"></path><path d="M 58.7,82.0 L 58.7,82.0 L 60.6,75.0 " class="svelte-7zu2uc"></path><path d="M 60.6,75.0 L 60.6,75.0 L 62.1,76.0 " class="svelte-7zu2uc"></path><path d="M 62.1,76.0 L 62.1,76.0 L 65.1,81.0 " class="svelte-7zu2uc"></path><path d="M 65.1,81.0 L 65.1,81.0 L 66.3,81.0 " class="svelte-7zu2uc"></path><path d="M 66.3,81.0 L 66.3,81.0 L 68.3,75.0 " class="svelte-7zu2uc"></path><path d="M 78.3,75.0 L 78.3,75.0 L 75.7,75.0 " class="svelte-7zu2uc"></path><path d="M 75.7,75.0 L 75.7,75.0 L 73.7,75.0 " class="svelte-7zu2uc"></path><path d="M 73.7,75.0 L 73.7,75.0 L 72.2,78.0 " class="svelte-7zu2uc"></path><path d="M 72.2,78.0 L 72.2,78.0 L 72.2,82.0 " class="svelte-7zu2uc"></path><path d="M 72.2,82.0 L 72.2,82.0 L 75.0,84.0 " class="svelte-7zu2uc"></path><path d="M 75.0,84.0 L 75.0,84.0 L 78.3,82.0 " class="svelte-7zu2uc"></path><path d="M 78.3,82.0 L 78.3,82.0 L 78.2,80.0 " class="svelte-7zu2uc"></path><path d="M 78.2,80.0 L 78.2,80.0 L 75.7,80.0 " class="svelte-7zu2uc"></path><path d="M 78.3,82.0 L 78.3,82.0 L 79.1,86.0 " class="svelte-7zu2uc"></path></g><g id="frame7" class="svelte-7zu2uc"><path d="M 16.1,46.0 L 16.1,46.0 L 16.2,38.0 L 16.8,30.0 L 18.0,23.0 L 19.5,15.0 L 20.6,8.0 " class="svelte-7zu2uc"></path><path d="M 20.6,8.0 L 20.6,8.0 L 27.6,7.0 L 35.6,8.0 L 41.9,9.0 L 49.3,11.0 L 57.4,13.0 L 64.6,13.0 L 72.8,12.0 " class="svelte-7zu2uc"></path><path d="M 72.8,12.0 L 72.8,12.0 L 73.3,19.0 L 74.2,27.0 L 75.0,35.0 L 74.8,43.0 L 73.9,51.0 " class="svelte-7zu2uc"></path><path d="M 16.1,46.0 L 16.1,46.0 L 24.7,45.0 L 32.6,45.0 L 39.9,46.0 L 48.8,48.0 L 57.7,51.0 L 65.8,52.0 L 73.9,51.0 " class="svelte-7zu2uc"></path><path d="M 21.5,9.0 L 21.5,9.0 L 26.6,13.0 L 32.6,19.0 L 38.1,24.0 L 45.2,31.0 " class="svelte-7zu2uc"></path><path d="M 45.2,31.0 L 45.2,31.0 L 51.7,28.0 L 59.5,23.0 L 65.5,19.0 L 72.3,13.0 " class="svelte-7zu2uc"></path><path d="M 14.2,70.0 L 14.2,70.0 L 14.1,74.0 " class="svelte-7zu2uc"></path><path d="M 14.1,74.0 L 14.1,74.0 L 13.2,79.0 " class="svelte-7zu2uc"></path><path d="M 13.2,79.0 L 13.2,79.0 L 14.4,81.0 " class="svelte-7zu2uc"></path><path d="M 14.4,81.0 L 14.4,81.0 L 18.0,80.0 " class="svelte-7zu2uc"></path><path d="M 25.3,70.0 L 25.3,70.0 L 22.6,72.0 " class="svelte-7zu2uc"></path><path d="M 22.6,72.0 L 22.6,72.0 L 22.1,75.0 " class="svelte-7zu2uc"></path><path d="M 22.1,75.0 L 22.1,75.0 L 23.2,79.0 " class="svelte-7zu2uc"></path><path d="M 23.2,79.0 L 23.2,79.0 L 25.9,78.0 " class="svelte-7zu2uc"></path><path d="M 25.9,78.0 L 25.9,78.0 L 28.4,76.0 " class="svelte-7zu2uc"></path><path d="M 28.4,76.0 L 28.4,76.0 L 29.6,73.0 " class="svelte-7zu2uc"></path><path d="M 29.6,73.0 L 29.6,73.0 L 28.1,70.0 " class="svelte-7zu2uc"></path><path d="M 25.3,70.0 L 25.3,70.0 L 28.1,70.0 " class="svelte-7zu2uc"></path><path d="M 32.9,78.0 L 32.9,78.0 L 33.4,75.0 " class="svelte-7zu2uc"></path><path d="M 33.4,75.0 L 33.4,75.0 L 36.1,70.0 " class="svelte-7zu2uc"></path><path d="M 36.1,70.0 L 36.1,70.0 L 37.6,71.0 " class="svelte-7zu2uc"></path><path d="M 37.6,71.0 L 37.6,71.0 L 38.2,73.0 " class="svelte-7zu2uc"></path><path d="M 38.2,73.0 L 38.2,73.0 L 38.2,77.0 " class="svelte-7zu2uc"></path><path d="M 38.2,77.0 L 38.2,77.0 L 37.8,81.0 " class="svelte-7zu2uc"></path><path d="M 33.4,75.0 L 33.4,75.0 L 38.1,76.0 " class="svelte-7zu2uc"></path><path d="M 43.8,72.0 L 43.8,72.0 L 44.1,80.0 " class="svelte-7zu2uc"></path><path d="M 44.1,80.0 L 44.1,80.0 L 46.6,80.0 " class="svelte-7zu2uc"></path><path d="M 46.6,80.0 L 46.6,80.0 L 48.5,79.0 " class="svelte-7zu2uc"></path><path d="M 48.5,79.0 L 48.5,79.0 L 48.1,75.0 " class="svelte-7zu2uc"></path><path d="M 48.1,75.0 L 48.1,75.0 L 45.6,73.0 " class="svelte-7zu2uc"></path><path d="M 43.8,72.0 L 43.8,72.0 L 45.6,73.0 " class="svelte-7zu2uc"></path><path d="M 54.0,75.0 L 54.0,75.0 L 54.2,77.0 " class="svelte-7zu2uc"></path><path d="M 54.2,77.0 L 54.2,77.0 L 54.7,83.0 " class="svelte-7zu2uc"></path><path d="M 58.7,83.0 L 58.7,83.0 L 60.1,77.0 " class="svelte-7zu2uc"></path><path d="M 60.1,77.0 L 60.1,77.0 L 61.7,78.0 " class="svelte-7zu2uc"></path><path d="M 61.7,78.0 L 61.7,78.0 L 65.0,82.0 " class="svelte-7zu2uc"></path><path d="M 65.0,82.0 L 65.0,82.0 L 66.3,82.0 " class="svelte-7zu2uc"></path><path d="M 66.3,82.0 L 66.3,82.0 L 67.9,75.0 " class="svelte-7zu2uc"></path><path d="M 78.0,74.0 L 78.0,74.0 L 75.4,74.0 " class="svelte-7zu2uc"></path><path d="M 75.4,74.0 L 75.4,74.0 L 73.4,75.0 " class="svelte-7zu2uc"></path><path d="M 73.4,75.0 L 73.4,75.0 L 72.0,78.0 " class="svelte-7zu2uc"></path><path d="M 72.0,78.0 L 72.0,78.0 L 72.1,81.0 " class="svelte-7zu2uc"></path><path d="M 72.1,81.0 L 72.1,81.0 L 74.9,83.0 " class="svelte-7zu2uc"></path><path d="M 74.9,83.0 L 74.9,83.0 L 78.2,81.0 " class="svelte-7zu2uc"></path><path d="M 78.2,81.0 L 78.2,81.0 L 78.1,79.0 " class="svelte-7zu2uc"></path><path d="M 78.1,79.0 L 78.1,79.0 L 75.5,79.0 " class="svelte-7zu2uc"></path><path d="M 78.2,81.0 L 78.2,81.0 L 79.0,84.0 " class="svelte-7zu2uc"></path></g></svg></div></div>'); function Loader(r, e) { push(e, !0); let i = state(null), s = state(!client$1.devScene); const a = { opacity: 0 }, o = () => { set(s, !0) }, l = () => { !get(s) || !get(i) || createTween(a, { to: { opacity: 0 }, ease: "power2.inOut", duration: .5, onUpdate: () => { get(i).style.opacity = a.opacity }, onComplete: () => { set(s, !1) } }) }; user_effect(() => { get(s) && createTween(a, { to: { opacity: 1 }, ease: "power2.inOut", duration: .5, onUpdate: () => { get(i).style.opacity = a.opacity } }) }); var c = comment(), h = first_child(c); { var d = p => { var f = root_1(), _ = child(f); bind_this(_, x => set(i, x), () => get(i)), append(p, f) }; if_block(h, p => { get(s) && p(d) }) } return append(r, c), pop({ show: o, hide: l }) } enable_legacy_mode_flag(); var root$1 = from_html("<div>Seems like WebGL2 is not supported by your browser  Please update it to access the experience.</div>"); function Unsupported(r) { var e = root$1(); append(r, e) } var root_3 = from_html(`<div id="webgl"></div> <style>/* js */
        div#webgl {
            display: block;
            position: absolute;
            width: 100%;
            height: 100%;
        }</style>`, 1), root = from_html("<!> <!>", 1); function App3D(r, e) { push(e, !0); const i = prop(e, "interactionNode", 3, null), s = prop(e, "relativePath", 3, ""), a = miscutils.deferred(); let o = null, l = !1, c = state(null), h = state(null); user_effect(async () => { if (!get(h) || l) return; l = !0, events.on("toggle_loader", M => { M ? o.show() : o.hide() }), customEase("tweaked", "M0,0 C0.388,0 0.441,0.356 0.496,0.496 0.553,0.641 0.647,1 1,1"); const T = window.devicePixelRatio <= 2 ? Math.min(window.devicePixelRatio, 1.15) : Math.min(window.devicePixelRatio, 1.5); await global$1.init({ canvasCnt: get(h), interactionNode: i(), relativePath: s(), fingers: 2, audioContext: !0, contextMenu: !1, DPR: T || 1, adaptiveDPR: !0, shadowMap: !0, shadowMapType: PCFSoftShadowMap }); { const M = new mainController; await M.ready, o.hide(), M.start() } a.resolve(!0) }); const d = async () => { }; (async () => { if (!client$1.capabilities.webgl2) { a.resolve(!1), set(c, !1); return } await d(), set(c, !0) })(); var p = root(), f = first_child(p); { var _ = T => { Unsupported(T) }, x = T => { var M = comment(), w = first_child(M); { var D = R => { var P = root_3(), U = first_child(P); bind_this(U, O => set(h, O), () => get(h)), append(R, P) }; if_block(w, R => { get(c) === !0 && R(D) }, !0) } append(T, M) }; if_block(f, T => { get(c) === !1 ? T(_) : T(x, !1) }) } var b = sibling(f, 2); return bind_this(Loader(b, {}), T => o = T, () => o), append(r, p), pop({ ready: a }) } export { App3D as default };
